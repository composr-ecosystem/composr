<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    nusearch
 */

// TODO: Not needed in v11
/*EXTRA FUNCTIONS: hex2bin*/

/*
Reference implementation, coded for English.

We only expose limited methods because not all languages have words or phrases - other languages will implement the decomposition and ngram functionality very differently.

Particularly / for example...

These common languages do not have words:
 - Chinese
 - Japanese
 - Thai
 - Khmer
 - Lao
 - Burmese
 - Korean

Vietnamese has spaces but they dilineate syllables, not words.
*/

class LangTokeniser_EN
{
    /* Querying */

    /**
     * Turn a search query into a set of tokens to search against.
     *
     * @param  string $query Search query
     * @param  boolean $support_boolean Whether to support boolean syntax
     * @return array A complex structure of search tokens
     */
    public function query_to_search_tokens($query, $support_boolean = true)
    {
        $fuzzy_and = array();
        $and = array();
        $not = array();

        $in_quotes = false;
        $operator = null;
        $current_search_token = '';

        $len = cms_mb_strlen($query);
        for ($i = 0; $i < $len; $i++) {
            $c = cms_mb_substr($query, $i, 1);

            if (($operator === null) && (!$in_quotes) && ($current_search_token == '')) {
                switch ($c) {
                    case '"':
                        $in_quotes = true;
                        break;

                    case '+':
                    case '-':
                        if ($support_boolean) {
                            $operator = $c;
                            break;
                        }
                        // no break

                    default:
                        if (preg_match('#\w#' . ((get_charset() == 'utf-8') ? 'u' : ''), $c) != 0) {
                            $current_search_token = $c;
                        }
                        break;
                }
            } else {
                switch ($c) {
                    case '"':
                        if ($in_quotes) {
                            $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token);
                            break;
                        }
                        $in_quotes = true;
                        break;

                    default:
                        if (preg_match('#\w#' . ((get_charset() == 'utf-8') ? 'u' : ''), $c) != 0) {
                            $current_search_token .= $c;
                        } elseif (!$in_quotes) {
                            $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token);
                        } else {
                            $current_search_token .= ' ';
                        }
                        break;
                }
            }
        }

        $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token);

        return array($fuzzy_and, $and, $not);
    }

    /**
     * Finish off parsing of a search token.
     *
     * @param  array $fuzzy_and Current fuzzy and tokens
     * @param  array $and Current and tokens
     * @param  array $not Current not tokens
     * @param  boolean $in_quotes Whether we are currently parsing a quoted portion of the query
     * @param  ?string $operator The special boolean operator for this token (null: none)
     * @param  string $current_search_token The current token
     */
    protected function finish_search_token(&$fuzzy_and, &$and, &$not, &$in_quotes, &$operator, &$current_search_token)
    {
        if ($current_search_token != '') {
            $current_search_token = cms_mb_strtolower($current_search_token);

            // We map from search token to whether is is a $is_singular_ngram.
            //  In practice this means stemming and considering if it is a stop word
            //  For reference implementation this checks for spaces, which is consistent with how we delineate words in ngrams in this implementation
            //  Spaces will only be possible to be there if the term was surrounded in quotes
            $is_singular_ngram = (strpos($current_search_token, ' ') === false);
            if ($operator === null) {
                $fuzzy_and[$current_search_token] = $is_singular_ngram;
            } elseif ($operator == '+') {
                $and[$current_search_token] = $is_singular_ngram;
            } elseif ($operator == '-') {
                $not[$current_search_token] = $is_singular_ngram;
            } else {
                fatal_exit('Unknown operator');
            }
        }

        $in_quotes = false;
        $operator = null;
        $current_search_token = '';
    }

    /* Indexing */

    /**
     * Convert some text into some ngrams (basically words or word sequences) to be indexed.
     *
     * @param  string $text Text to be indexed
     * @param  integer $max_ngram_size The maximum number of ngrams (typically words) to sequence together
     * @param  ?integer $total_singular_ngram_tokens Write into a count of singular ngrams (typically, words) in here (null: do not count)
     * @return array A list of ngrams (along with a boolean to indicate whether they are a boolean ngram)
     */
    public function text_to_ngrams($text, $max_ngram_size, &$total_singular_ngram_tokens = null)
    {
        $word_ngrams = array();

        $phrases = $this->text_to_phrases($text);
        foreach ($phrases as $phrase) {
            $word_list = $this->phrase_to_word_list($phrase, $total_singular_ngram_tokens);
            $this->word_list_to_word_ngrams($word_ngrams, $word_list, $max_ngram_size);
        }

        return $word_ngrams;
    }

    /**
     * Convert text to phrases (a phrase is a sequence of words that go together, that can be used for ngram sequences).
     *
     * @param  string $text The text
     * @return array List of phrases
     */
    protected function text_to_phrases($text)
    {
        $phrases = array();
        $len = cms_mb_strlen($text);
        $current_phrase = '';
        $phrase_separation_characters = array('.', ';', ':', '"', '!', '?', '(', ')', '[', ']', '{', '}', '<', '>');
        if (get_charset() == 'utf-8') {
            // Smart quote characters
            $phrase_separation_characters[] = hex2bin('e2809c');
            $phrase_separation_characters[] = hex2bin('e2809d');
            $phrase_separation_characters[] = hex2bin('e28098');
            $phrase_separation_characters[] = hex2bin('e28099');
        }
        $phrase_separation_characters = array_flip($phrase_separation_characters);
        for ($i = 0; $i < $len; $i++) {
            $c = cms_mb_substr($text, $i, 1);
            if (isset($phrase_separation_characters[$c])) {
                $phrases[] = $current_phrase;
                $current_phrase = '';
            } else {
                $current_phrase .= $c;
            }
        }
        if ($current_phrase != '') {
            $phrases[] = $current_phrase;
        }
        return $phrases;
    }

    /**
     * Convert a phrase to a list of words.
     *
     * @param  string $phrase A phrase
     * @param  TODO $total_word_tokens Maintain a count of singular ngrams (word tokens in our case) in here
     * @return array List of words
     */
    protected function phrase_to_word_list($phrase, &$total_word_tokens)
    {
        $matches = array();
        $_total_word_tokens = preg_match_all('#\w+#' . ((get_charset() == 'utf-8') ? 'u' : ''), $phrase, $matches);
        if ($total_word_tokens !== null) {
            $total_word_tokens += $_total_word_tokens;
        }
        $words = array();
        for ($i = 0; $i < $_total_word_tokens; $i++) {
            $words[] = cms_mb_strtolower($matches[0][$i]);
        }
        return $words;
    }

    /**
     * Convert a simple word list into a list of ngrams, taking into account we want to do sequencing.
     *
     * @param  array $word_ngrams Write word ngrams into here (along with a boolean to indicate whether they are a boolean ngram)
     * @param  array $word_list List of words
     * @param  integer $max_ngram_size The maximum number of ngrams (typically words) to sequence together
     */
    protected function word_list_to_word_ngrams(&$word_ngrams, $word_list, $max_ngram_size)
    {
        $count = count($word_list);

        for ($i = 0; $i < $count; $i++) {
            $current_ngram = '';

            for ($j = 0; $j < $max_ngram_size; $j++) {
                if (!array_key_exists($i + $j, $word_list)) {
                    break;
                }

                $word = $word_list[$i + $j];

                if ($j != 0) {
                    $current_ngram .= ' ';
                }
                $current_ngram .= $word;

                $is_singular_ngram = ($j == 0);
                $word_ngrams[$current_ngram] = $is_singular_ngram;
            }
        }
    }
}
