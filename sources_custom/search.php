<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    nusearch
 */

function init__search()
{
    define('APPEARANCE_CONTEXT_title', 1);
    define('APPEARANCE_CONTEXT_meta', 2);
    define('APPEARANCE_CONTEXT_body', 3); // Nothing will be indexed in here that is indexed in one of the above, to avoid duplicated content records when doing non-appearance-filtered searches
}

// This implements an alternative to MySQL full-text search, the Composr fast custom index.
//  It is much faster as all content indexing happens through a single table, and we control how deep we search.
//   Except quoted strings are an issue due to necessary index size, so we may revert to MySQL search for these cases, depending on configuration.
//    Other algorithms store word sequencing information which goes completely against our strategy.
//  We also have full control over stemming, maximum ngram sizes, and stop word lists.
//  We also can index in multiple-languages.
//  We also don't have problems de-duplicating searches run across different fields.
//  We do not need word size limits.
// This does not 100% replace MySQL full-text search. The capability remains in the system for those who prefer it, or for non-search-engine uses of it.

class Composr_fulltext_helper
{
    // Querying...

    /**
     * Get some rows, queried from the database according to the search parameters, using the Composr fast custom index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  string $content_table The content table to query (may contain JOIN components)
     * @param  array $key_transfer_map A map to show how keys relate between the index table and the content table, used to construct a JOIN
     * @param  string $where_clause Special WHERE clause querying things from content table (i.e. stuff not covered in our index)
     * @param  string $extra_join_clause Extra SQL to insert into the JOIN clauses of each keyword, used to enforce query constraints handled within our indexing
     * @param  string $content Search string
     * @param  boolean $boolean_search Whether to do a boolean search
     * @param  boolean $only_search_meta Whether to only do a META (tags) search
     * @param  boolean $only_titles Whether to only search titles (as opposed to both titles and content)
     * @param  integer $max Start position in total results
     * @param  integer $start Maximum results to return in total
     * @param  ID_TEXT $order What to order by
     * @param  ID_TEXT $direction Order direction
     * @param  ?string $permissions_module The permission module to check category access for (null: none)
     * @param  ?string $permissions_field The field that specifies the permissions ID to check category access for (null: none)
     * @param  boolean $permissions_field_is_string Whether the permissions field is a string
     * @return array The rows found
     */
    public function get_search_rows($db, $index_table, $content_table, $key_transfer_map, $where_clause, $extra_join_clause, $content, $boolean_search, $only_search_meta, $only_titles, $max, $start, $order, $direction, $permissions_module = null, $index_permissions_field = null, $permissions_field_is_string = false)
    {
        if ($only_search_meta) {
            $appearance_context = APPEARANCE_CONTEXT_meta;
        } elseif ($only_titles) {
            $appearance_context = APPEARANCE_CONTEXT_title;
        } else {
            $appearance_context = null;
        }

        if (preg_match('#_fulltext_index$#', $index_table) == 0) {
            fatal_exit('By convention any Composr full-text index table must end with _fulltext_index');
        }

        $lang = user_lang();

        $tokeniser = $this->get_tokeniser($lang);
        $stemmer = $this->get_stemmer($lang);

        // We start with the content table, which is needed for things like validation checks, or other stuff that basically won't be a dominant index culling factor
        $join = $content_table;

        if ($order == '') {
            $order = 'contextual_relevance';
        }

        // Work out our search terms
        list($fuzzy_and, $and, $not) = $tokeniser->query_to_search_tokens($content, $boolean_search);
        if (($order != 'contextual_relevance') || ($direction == 'ASC') || (get_value('fulltext_allow_fuzzy_search', '1', true) === '0')) {
            // We only allow fuzzy search when returning results in relevance order, with most relevant first
            //  - this is because it makes no sense for any other orders
            // We also allow it to be disabled as it could have major performance slow-down for large datasets, it's a lot to pull out from the index, join, and sort.
            $and = $and + $fuzzy_and;
            $fuzzy_and = array();
        }
        $search_token_sets = array(
            'fuzzy_and' => $fuzzy_and,
            'and' => $and,
            'not' => $not,
        );

        // Load commonalities so we can scale by them
        if ((!empty($fuzzy_and)) && (!empty($and)) && (!empty($not)) && (get_value('fulltext_scale_by_commonality', '1', true) == '1')) {
            $commonality_query = 'SELECT * FROM ' . get_table_prefix() . 'ft_index_commonality WHERE ';
            foreach (array_keys($fuzzy_and + $and + $not) as $i => $ngram) {
                if ($i != 0) {
                    $commonality_query .= ' OR ';
                }
                $commonality_query .= db_string_equal_to('c_ngram', $ngram);
            }
            $commonalities = collapse_2d_complexity('c_ngram', 'c_commonality', $db->query($commonality_query));
        } else {
            $commonalities = null;
        }

        // Code for querying against each ngram
        $order_by_total_ngrams_matched = '';
        $order_by_occurrence_rates = '';
        $i = 0;
        foreach ($search_token_sets as $set_type => $search_tokens) {
            foreach ($search_tokens as $ngram => $is_singular_ngram) {
                if ($is_singular_ngram) {
                    if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                        continue;
                    }

                    $ngram = $stemmer->stem($ngram);
                }

                if ($set_type == 'and') {
                    $join_type = 'JOIN'; // Will enforce the AND implicitly
                } else {
                    $join_type = 'LEFT JOIN';
                }

                $join .= ' ' . $join_type . ' ' . $db->get_table_prefix() . $index_table . ' i' . strval($i) . ' ON ';
                $key_i = 0;
                foreach ($key_transfer_map as $content_table_field => $index_table_field) {
                    if ($key_i != 0) {
                        $join .= ' AND ';
                    }
                    if ($i == 0) {
                        $join .= 'i' . strval($i) . '.' . $index_table_field . '=r.' . $content_table_field;
                    } else {
                        $join .= 'i' . strval($i) . '.' . $index_table_field . '=i' . strval($i - 1) . '.' . $index_table_field;
                    }
                    $key_i++;
                }
                $join .= ' AND i' . strval($i) . '.i_ngram=' . strval($this->crc($ngram));
                $join .= str_replace('ixxx.', 'i' . strval($i) . '.', $extra_join_clause);
                $join .= ' AND ' . db_string_equal_to('i' . strval($i) . '.i_lang', $lang);
                if ($appearance_context !== null) {
                    $join .= ' AND i_ac=' . strval($appearance_context);
                }

                if ($set_type == 'not') {
                    $where_clause .= ' AND i' . strval($i) . '.i_ngram IS NULL';
                }

                if (($set_type != 'not') && ($order_by_total_ngrams_matched != '')) {
                    $order_by_total_ngrams_matched .= '+';

                    $order_by_occurrence_rates .= '+';
                }

                if ($set_type != 'not') {
                    $order_by_total_ngrams_matched .= db_function('IFF', array('i' . strval($i) . '.i_ngram IS NULL', '0', '1'));

                    $scaler = (isset($commonalities[$ngram]) ? float_to_raw_string($commonalities[$ngram], 10) : '1');
                    $order_by_occurrence_rates .= db_function('COALESCE', array('i' . strval($i) . '.i_occurrence_rate', '0')) . '*' . $scaler;
                }

                $i++;
            }
        }

        if ($i == 0) {
            // This is important - if there are no words to index against, then security will not have run either
            return array();
        }

        $where_clause .= ' AND ' . $order_by_total_ngrams_matched . '>0';

        // Code for considering permissions
        if (($permissions_module !== null) && (!$GLOBALS['FORUM_DRIVER']->is_super_admin(get_member()))) {
            $g_or = _get_where_clause_groups(get_member());

            // this destroys mysqls query optimiser by forcing complexed OR's into the join, so we'll do this in PHP code
            /*$table .= ' LEFT JOIN ' . $db->get_table_prefix() . 'group_category_access z ON (' . db_string_equal_to('z.module_the_name', $permissions_module) . ' AND z.category_name=' . $permissions_field . (($g_or != '') ? (' AND ' . str_replace('group_id', 'z.group_id', $g_or)) : '') . ')';
            $where_clause .= ' AND ';
            $where_clause .= 'z.category_name IS NOT NULL';*/

            $cat_sql = '';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'group_category_access WHERE (' . $g_or . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_sql .= ' UNION ALL ';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'member_category_access WHERE (member_id=' . strval((integer)get_member()) . ' AND active_until>' . strval(time()) . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_access = array_keys(list_to_map('category_name', $db->query($cat_sql, null, null, false, true)));

            if (empty($cat_access)) {
                return array();
            }

            $where_clause .= ' AND ' . $index_permissions_field . ' IN (';
            foreach ($cat_access as $i => $cat) {
                if ($i != 0) {
                    $where_clause .= ',';
                }
                if ($permissions_field_is_string) {
                    $where_clause .= '\'' . db_escape_string($cat) . '\'';
                } else {
                    if (is_numeric($cat)) {
                        $where_clause .= $cat;
                    } // else should not be possible
                }
            }
            $where_clause .= ')';
        }

        // Do querying...

        $contextual_relevance_sql = $order_by_total_ngrams_matched . ((($order_by_total_ngrams_matched == '') || ($order_by_occurrence_rates == '')) ? '' : '+') . $order_by_occurrence_rates; // $order_by_total_ngrams_matched will be the dominent factor (intended!) as it is an integer while $order_by_occurrence_rates cannot add to more than 1
        if ($contextual_relevance_sql == '') {
            $contextual_relevance_sql = '1';
        }
        $select = 'r.*,' . $contextual_relevance_sql . ' AS contextual_relevance';

        // Rating ordering, via special encoding
        if (strpos($order, 'compound_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT SUM(rating-1) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS compound_rating';
            $order = 'compound_rating';
        }
        if (strpos($order, 'average_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT AVG(rating) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS average_rating';
            $order = 'average_rating';
        }

        $t_rows_sql = 'SELECT ' . $select . ' FROM ' . $join . ' WHERE 1=1' . $where_clause . ' ORDER BY ' . $order . ' ' . $direction;

        if (get_param_integer('keep_show_query', 0) == 1) {
            attach_message($t_rows_sql, 'inform');
        }
        if (get_param_integer('keep_just_show_query', 0) == 1) {
            safe_ini_set('ocproducts.xss_detect', '0');
            header('Content-type: text/plain; charset=' . get_charset());
            exit($t_rows_sql);
        }

        $t_rows = $db->query($t_rows_sql, $max, $start);

        $t_count_sql = 'SELECT COUNT(*) FROM ' . $join . ' WHERE 1=1' . $where_clause;
        $t_count = $db->query_value_if_there($t_count_sql);
        $GLOBALS['TOTAL_SEARCH_RESULTS'] += $t_count;

        if ((get_param_integer('keep_show_query', 0) == 1) && (($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())) || ($GLOBALS['IS_ACTUALLY_ADMIN']))) {
            if ((array_key_exists(0, $t_rows)) && (array_key_exists('id', $t_rows[0]))) {
                $results = var_export(array_unique(collapse_1d_complexity('id', $t_rows)), true);
            } else {
                $results = var_export($t_rows, true);
            }
            attach_message(do_lang('COUNT_RESULTS') . ': ' . $results, 'inform');
        }

        return $t_rows;
    }

    /**
     * Find if we have to join in custom fields due to filtering.
     *
     * @return boolean Whether we have special filtering
     */
    public function active_search_has_special_filtering()
    {
        foreach ($_GET as $key => $val) {
            if ((substr($key, 0, 7) == 'option_') && ($val != '')) {
                return true;
            }
        }
        return false;
    }

    /**
     * Helper function for hooks, used to get catalogue entry data (useful also for custom fields).
     *
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  string $c_name Catalogue codename
     * @param  integer $id Catalogue entry ID
     * @param  ?LANGUAGE_NAME $lang Language codename (null: default)
     * @return array A pair: Fields to index, Content fields
     */
    public function get_content_fields_from_catalogue_entry(&$content_fields, &$fields_to_index, $c_name, $id, $lang = null)
    {
        require_code('catalogues');

        $map = get_catalogue_entry_field_values($c_name, $id, null, null, false, 'PAGE', $lang);
        $i = 0;
        foreach ($map as $field) {
            if (is_string($field['effective_value_pure'])) {
                $fields_to_index['field_' . strval($i)] = ($i == 0) ? APPEARANCE_CONTEXT_title : APPEARANCE_CONTEXT_body;
                $content_fields['field_' . strval($i)] = $field['effective_value_pure'];
            }
            $i++;
        }
    }

    /**
     * Helper function for hooks, used to generate SQL for filtering rows by timestamp.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $since_index_fields List of fields which contain timestamps that we use for recency checks
     * @param  ?TIME $since Filter to records with recency since this timestamp (null: no limit)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return string Extra SQL
     */
    public function generate_since_where_clause($db, $index_table, $since_index_fields, $since, &$statistics_map = null)
    {
        $where_clauses = array();

        if ($since !== null) {
            $test = $db->query_select_value_if_there($index_table, '1 AS test');
            if ($test !== null) {
                foreach ($since_index_fields as $field => $may_be_null) {
                    if ($may_be_null) {
                        $where_clause = $field . ' IS NOT NULL AND ' . $field . '>' . strval($since);
                    } else {
                        $where_clause = $field . '>' . strval($since);
                    }
                    $where_clauses[] = $where_clause;
                }

                // We nullify $statistics_map as it's useless if we're not doing a full indexing
                $statistics_map = null;
            } // Else: If the table has been truncated we treat that as a signal to do a full regeneration
        }

        if (empty($where_clauses)) {
            return '';
        }

        return ' AND (' . implode(' OR ', $where_clauses) . ')';
    }

    // Indexing...

    /**
     * Index a content resource.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_transfer_map A map between content field keys to index field keys, so we can clear out old indexing for the content resource
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @param  ?LANGUAGE_NAME $lang Passed content is for this specific language only (null: lookup for all installed languages)
     * @param  boolean $clean_scan If we are doing a clean scan and hence do not need to clean up old records
     */
    public function index_for_search($db, $index_table, $content_fields, $fields_to_index, $key_transfer_map, $filter_field_transfer_map, &$total_singular_ngram_tokens = null, &$statistics_map = null, $lang = null, $clean_scan = false)
    {
        if (!$GLOBALS['SITE_DB']->table_exists('ft_index_commonality')) {
            $GLOBALS['SITE_DB']->create_table('ft_index_commonality', array(
                'id' => '*AUTO',
                'c_ngram' => 'SHORT_TEXT',
                'c_commonality' => 'REAL',
            ));
        }

        // Clear out any previous indexing for this content resource
        $key_map = array();
        foreach ($key_transfer_map as $content_table_field => $index_table_field) {
            $key_map[$index_table_field] = $content_fields[$content_table_field];
        }
        if (!$clean_scan) {
            if ($lang === null) {
                $db->query_delete($index_table, $key_map);
            } else {
                $db->query_delete($index_table, $key_map + array('i_lang' => $lang)); // We're calling this method language-by-language
            }
        }

        if ($lang === null) {
            $langs = multi_lang_content() ? array_keys(find_all_langs()) : array(get_site_default_lang());
        } else {
            $langs = array($lang);
        }

        foreach ($langs as $lang) {
            if ($statistics_map !== null) {
                if (!array_key_exists($lang, $statistics_map)) {
                    $statistics_map[$lang] = array();
                }
            }

            $ngrams_for = array();
            foreach (array(APPEARANCE_CONTEXT_title, APPEARANCE_CONTEXT_meta, APPEARANCE_CONTEXT_body) as $appearance_context) {
                $_fields_to_index = array();
                foreach ($fields_to_index as $field => $_appearance_context) {
                    if ($_appearance_context == $appearance_context) {
                        $_fields_to_index[] = $field;
                    }
                }

                if ($appearance_context == APPEARANCE_CONTEXT_body) {
                    $ngrams_exclude = $ngrams_for[APPEARANCE_CONTEXT_title] + $ngrams_for[APPEARANCE_CONTEXT_meta];
                } else {
                    $ngrams_exclude = array();
                }

                $ngrams_for[$appearance_context] = $this->index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $_fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);
            }
        }
    }

    /**
     * Index a content resource, specifically for a particular language and appearance context.
     *
     * @param  object $db Database connection
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  integer $appearance_context An APPEARANCE_CONTEXT_* constant
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_map A map of keys for the index
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        $combined_text = '';
        foreach ($fields_to_index as $field) {
            $text = is_integer($content_fields[$field]) ? get_translated_text($content_fields[$field], $db, $lang) : $content_fields[$field];
            $combined_text .= ' ' . $text;
        }

        $ngrams = $this->tokenise_text($combined_text, $lang, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);

        $fields = $key_map;

        // Add indexing row for each ngram
        foreach ($filter_field_transfer_map as $content_table_field => $index_table_field) {
            $fields[$index_table_field] = $content_fields[$content_table_field];
        }
        $insert_arr = array();
        foreach ($ngrams as $ngram => $count) {
            $fields_for_ngram = array(
                'i_lang' => $lang,
                'i_ngram' => $this->crc($ngram),
                'i_ac' => $appearance_context,
                'i_occurrence_rate' => floatval($count) / floatval($total_singular_ngram_tokens),
            ) + $fields;
            if (empty($insert_arr)) {
                foreach ($fields_for_ngram as $key => $val) {
                    $insert_arr[$key] = array();
                }
            }
            foreach ($fields_for_ngram as $key => $val) {
                $insert_arr[$key][] = $val;
            }
        }

        if (!empty($insert_arr)) {
            $db->query_insert($index_table, $insert_arr);
        }

        return $ngrams;
    }

    /**
     * Clear out a content resource from the index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $index_key_map Map of index keys, defining what to delete
     */
    public function delete_from_index($db, $index_table, $index_key_map)
    {
        $db->query_delete($index_table, $index_key_map);
    }

    /**
     * Tokenise some text, so it can be indexed by token.
     *
     * @param  string $text The text
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function tokenise_text($text, $lang, $ngrams_exclude = null, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        if (strpos($text, '&') !== false) {
            $text = html_entity_decode($text, ENT_QUOTES, get_charset());
        }

        static $max_ngram_size = null;
        if ($max_ngram_size === null) {
            $max_ngram_size = intval(get_value('fulltext_max_ngram_size', '1', true));
        }

        $tokeniser = $this->get_tokeniser($lang);
        $stemmer = $this->get_stemmer($lang);

        $ngrams = array();

        $_ngrams = $tokeniser->text_to_ngrams($text, $max_ngram_size, $total_singular_ngram_tokens);
        foreach ($_ngrams as $ngram => $is_singular_ngram) {
            if ($is_singular_ngram) {
                if ($statistics_map !== null) {
                    if (!isset($statistics_map[$lang][$ngram])) {
                        $statistics_map[$lang][$ngram] = 0;
                    }
                    $statistics_map[$lang][$ngram]++;
                }
            }

            if ($is_singular_ngram) {
                if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                    continue;
                }
            }

            if ($ngrams_exclude !== null) {
                if (isset($ngrams_exclude[$ngram])) {
                    continue;
                }
            }

            if ($is_singular_ngram) {
                if (is_object($stemmer)) {
                    $ngram = $stemmer->stem($ngram);
                }
            }

            if (!isset($ngrams[$ngram])) {
                $ngrams[$ngram] = 0;
            }
            $ngrams[$ngram]++;
        }

        return $ngrams;
    }

    /**
     * Find whether a singular ngram (typically a word) is a stop word (i.e. too banal to be indexed).
     *
     * @param  string $ngram Singular ngram
     * @param  LANGUAGE_NAME $lang Language codename
     * @return boolean Whether it is
     */
    protected function singular_ngram_is_stop_word($ngram, $lang)
    {
        static $stop_list = array();
        if (!array_key_exists($lang, $stop_list)) {
            require_code('textfiles');
            $stop_list[$lang] = array_flip(explode("\n", read_text_file('too_common_words', $lang)));
            unset($stop_list[$lang]['']);
        }
        return isset($stop_list[$lang][$ngram]);
    }

    /**
     * Get a tokeniser for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return object Tokeniser
     */
    protected function get_tokeniser($lang)
    {
        static $tokeniser = array();
        if (!array_key_exists($lang, $tokeniser)) {
            if (((is_file(get_file_base() . '/sources/lang_tokeniser_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/tokeniser_' . $lang . '.php'))) && (!in_safe_mode())) {
                require_code('lang_tokeniser_' . $lang);
                $tokeniser[$lang] = object_factory('LangTokeniser_' . $lang);
            } else {
                require_code('lang_tokeniser_' . fallback_lang());
                $tokeniser[$lang] = object_factory('LangTokeniser_' . fallback_lang());
            }
        }
        return $tokeniser[$lang];
    }

    /**
     * Get a stemmer for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return ?object Stemmer (null: none)
     */
    protected function get_stemmer($lang)
    {
        static $stemmer = array();
        if (!array_key_exists($lang, $stemmer)) {
            $stemmer[$lang] = null;
            if (((is_file(get_file_base() . '/sources/lang_stemmer_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/stemmer_' . $lang . '.php'))) && (!in_safe_mode())) {
                if (get_value('fulltext_do_stemming', '1', true) === '1') {
                    require_code('lang_stemmer_' . $lang);
                    $stemmer[$lang] = object_factory('Stemmer_' . $lang);
                }
            }
        }
        return $stemmer[$lang];
    }

    /**
     * Calculate a CRC, effectively converting a string ngram to an integer hash of it.
     *
     * @param  string $str String
     * @return integer CRC
     */
    protected function crc($str)
    {
        return crc32($str) >> 1; // Makes compatible between 32-bit and 64-bit
    }
}

/*
TODO when integrating into v11...

1)
Grep for:
$_content_bits = explode(' ', str_replace('"', '', cms_preg_replace_safe('#(^|\s)\+#', '', cms_preg_replace_safe('#(^|\s)\-#', '', $content))));
And change to use query_to_search_tokens

2) Move all to bundled

3) Move new table creation code to modules, and add uninstallation code

4) Call 'delete_from_index' throughout any delete actualiser functions

5) Turn hidden options into real ones

6) Fix any "Fix in v11" comments

7) Leave our old get_search_rows implementation as a non-Cron or hidden-value activated fallback

8) Make boolean search support implicit with no boolean tickbox and no conjunctive operator option, with simple support for only [+-"], and generally tidy up the API to just pass through queries to hooks unaltered

9) Alter get_search_rows parameter naming and order to be sane and consistent with Composr_fulltext_helper->get_search_rows

10) Documentation for Composr fast custom index:
 Generally review existing documentation
 Overview of all the config options
 Clearly explain the boolean search syntax supported, including:
  + and -
  ", including how quote grabs phrases which may include stop words, how maximum ngram length affects quoting, and how stemming happens but only for ngrams that are singular (so quoted phrased will not be stemmed but +/- operators do operate on stemmed ngrams)
  How anything else is 'fuzzy' for a relevance search with highest relevance first, unless fuziness is disabled - and otherwise just works like '+'
 Explain how to dump the contents of *_fulltext_index tables to force regeneration
 Explain how translations made through translation queue will not rebuild index, must be through content editing
 Explain advantages over regular full-text: multi-language, much more configurable
 Explain ft_index_commonality
 Document tokeniser customisation in tut_intl

11) Add future ideas to tracker
 Synomym support

*/
