<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2016

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    nusearch
 */

/*
TODO when integrating into v11...

1)
Grep for:
$_content_bits = explode(' ', str_replace('"', '', cms_preg_replace_safe('#(^|\s)\+#', '', cms_preg_replace_safe('#(^|\s)\-#', '', $content))));
And change to use query_to_search_tokens

2) Move all to bundled

3) Move new table creation code to modules, and add uninstallation code

4) Call 'delete_from_index' throughout any delete actualiser functions

5) Turn hidden options into real ones, and also...
 Checkboxes for when to use nusearch
  Particular languages flagged to prefer it
  Heavy filtered queries
  If database driver does not have fulltext search
  Any simple search query
  Queries matching a particular regular expression

6) Fix any "Fix in v11" comments

7) Leave our old get_search_rows implementation as a non-Cron or hidden-value activated fallback

8) Make boolean search support implicit with no boolean tickbox and no conjunctive operator option, with simple support for only [+-"], and generally tidy up the API to just pass through queries to hooks unaltered

9) Alter get_search_rows parameter naming and order to be sane and consistent with Composr_fulltext_engine->get_search_rows

10) Change db_meta_indices primary key:
$GLOBALS['SITE_DB']->change_primary_key('db_meta_indices', array('i_table', 'i_name'));
$GLOBALS['SITE_DB']->alter_table_field('db_meta_indices', 'i_fields', 'LONG_TEXT');
And change create_table code

11) Documentation for Composr fast custom index:
 Generally review existing documentation
 Overview of all the config options
 Clearly explain the boolean search syntax supported, including:
  + and -
  ", including how quote grabs phrases which may include stop words, how maximum ngram length affects quoting, and how stemming happens but only for ngrams that are singular (so quoted phrased will not be stemmed but +/- operators do operate on stemmed ngrams)
  How anything else is 'fuzzy' for a relevance search with highest relevance first, unless fuzziness is disabled - and otherwise just works like '+'

12) Add future ideas to tracker
 Synomym support
 Automatic reindexing of content edited via translation queue

13) Code change: disclude -> exclude

14) Make 'search_do_days_fallback' hidden option official
*/

function init__search()
{
    define('APPEARANCE_CONTEXT_title', 1);
    define('APPEARANCE_CONTEXT_meta', 2);
    define('APPEARANCE_CONTEXT_body', 3); // Nothing will be indexed in here that is indexed in one of the above, to avoid duplicated content records when doing non-appearance-filtered searches
}

/**
 * Find if we can use the Composr fast custom index.
 *
 * @param string $hook The hook it is for (assumption that this hook is at least capable in some situations)
 * @param ?string $query Query to run for (null: no query to check at this point)
 * @param ?boolean $has_heavy_filtering Whether there is heavy filtering (which suggests to use Composr fast custom index) (null: unknown at this point)
 * @return boolean Whether we can
 */
function can_use_composr_fulltext_engine($hook, $query = null, $has_heavy_filtering = null)
{
    if ($query !== null) {
        $only_singular_ngrams = (intval(get_value('fulltext_max_ngram_size', '1', true)) <= 1);

        $_trigger_words = get_value('fulltext_trigger_words', '', true);
        $trigger_words = ($_trigger_words == '') ? array() : array_map('cms_mb_strtolower', array_map('trim', explode(',', $_trigger_words)));

        if (($only_singular_ngrams) || (!empty($trigger_words))) {
            $tokeniser = Composr_fulltext_engine::get_tokeniser(user_lang());
            $ngrams = $tokeniser->query_to_search_tokens($query);
        }
    }

    // Negative, cannot use for these reasons...

    if (($query !== null) && ($query == '')) {
        return false; // Blank queries not supported
    }

    if (($query !== null) && ($only_singular_ngrams)) {
        if (array_unique(array_values($ngrams[0] + $ngrams[1] + $ngrams[2])) !== array(true)) {
            return false; // Quoted text not supported in this configuration
        }
    }

    if (!cron_installed()) {
        return false; // No indexing working
    }

    // Positive, must use for these reasons...

    if (($query !== null) && (!empty($trigger_words))) {
        $test = array_intersect(array_map('cms_mb_strtolower', array_keys($ngrams)), $trigger_words);
        if (!empty($test)) {
            return true; // We will use Composr fast custom index if there's certain stop words
        }
    }

    if ($has_heavy_filtering === true) {
        return true; // We will use Composr fast custom index if there's heavy filtering as there'll be a big speed boost
    }

    // Explicit choice...

    $by_url = get_param_integer('keep_composr_fulltext_engine', null);
    if ($by_url !== null) {
        return ($by_url == 1); // Explicitly specified by URL
    }

    $default_choice = get_value('composr_fulltext_engine__' . $hook, '', true);
    if ($default_choice != '') {
        return ($default_choice == '1'); // Explicitly specified by config
    }

    // -

    return false; // Default to use traditional search
}

class Composr_fulltext_engine
{
    // Querying...

    /**
     * Get some rows, queried from the database according to the search parameters, using the Composr fast custom index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  string $content_table The content table to query (may contain JOIN components)
     * @param  array $key_transfer_map A map to show how keys relate between the index table and the content table, used to construct a JOIN
     * @param  string $where_clause Special WHERE clause querying things from content table (i.e. stuff not covered in our index)
     * @param  string $extra_join_clause Extra SQL to insert into the JOIN clauses of each keyword, used to enforce query constraints handled within our indexing
     * @param  string $content Search string
     * @param  boolean $boolean_search Whether to do a boolean search
     * @param  boolean $only_search_meta Whether to only do a META (tags) search
     * @param  boolean $only_titles Whether to only search titles (as opposed to both titles and content)
     * @param  integer $max Start position in total results
     * @param  integer $start Maximum results to return in total
     * @param  ID_TEXT $order What to order by
     * @param  ID_TEXT $direction Order direction
     * @param  ?string $permissions_module The permission module to check category access for (null: none)
     * @param  ?string $permissions_field The field that specifies the permissions ID to check category access for (null: none)
     * @param  boolean $permissions_field_is_string Whether the permissions field is a string
     * @return array The rows found
     */
    public function get_search_rows($db, $index_table, $content_table, $key_transfer_map, $where_clause, $extra_join_clause, $content, $boolean_search, $only_search_meta, $only_titles, $max, $start, $order, $direction, $permissions_module = null, $index_permissions_field = null, $permissions_field_is_string = false)
    {
        if ($only_search_meta) {
            $appearance_context = APPEARANCE_CONTEXT_meta;
        } elseif ($only_titles) {
            $appearance_context = APPEARANCE_CONTEXT_title;
        } else {
            $appearance_context = null;
        }

        if (preg_match('#_fulltext_index$#', $index_table) == 0) {
            fatal_exit('By convention any Composr full-text index table must end with _fulltext_index');
        }

        // Load configuration
        global $SEARCH_CONFIG_OVERRIDE;
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_allow_fuzzy_search'])) {
            $allow_fuzzy_search = ($SEARCH_CONFIG_OVERRIDE['fulltext_allow_fuzzy_search'] == '1');
        } else {
            $allow_fuzzy_search = (get_value('fulltext_allow_fuzzy_search', '0', true) == '1');
        }
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_scale_by_commonality'])) {
            $scale_by_commonality = ($SEARCH_CONFIG_OVERRIDE['fulltext_scale_by_commonality'] == '1');
        } else {
            $scale_by_commonality = (get_value('fulltext_scale_by_commonality', '1', true) == '1');
        }
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_use_imprecise_ordering'])) {
            $use_imprecise_ordering = ($SEARCH_CONFIG_OVERRIDE['fulltext_use_imprecise_ordering'] == '1');
        } else {
            $use_imprecise_ordering = (get_value('fulltext_use_imprecise_ordering', '1', true) == '1');
        }

        $lang = user_lang();

        $tokeniser = self::get_tokeniser($lang);
        $stemmer = self::get_stemmer($lang);

        // We start with the content table, which is needed for things like validation checks, or other stuff that basically won't be a dominant index culling factor
        $join = $content_table;

        if (($order == '') || ($order == 'relevance')) {
            $order = 'contextual_relevance';
        }

        // Work out our search terms
        list($fuzzy_and, $and, $not) = $tokeniser->query_to_search_tokens($content, $boolean_search);
        if (($order != 'contextual_relevance') || ($direction == 'ASC') || (!$allow_fuzzy_search)) {
            // We only allow fuzzy search when returning results in relevance order, with most relevant first
            //  - this is because it makes no sense for any other orders
            // We also allow it to be disabled as it could have major performance slow-down for large datasets, it's a lot to pull out from the index, join, and sort.
            $and = $and + $fuzzy_and;
            $fuzzy_and = array();
        }
        $search_token_sets = array(
            'fuzzy_and' => $fuzzy_and,
            'and' => $and,
            'not' => $not,
        );

        // Load commonalities so we can scale by them
        if (((!empty($fuzzy_and)) || (!empty($and))) && ($scale_by_commonality)) {
            $commonalities = $this->load_commonalities($db, array_keys($fuzzy_and + $and));

            // Order search terms by commonality
            $_fuzzy_and = array();
            foreach ($commonalities as $ngram => $commonality) {
                if (isset($fuzzy_and[$ngram])) {
                    $_fuzzy_and[$ngram] = $fuzzy_and[$ngram];
                }
            }
            $fuzzy_and = $_fuzzy_and;
            $_and = array();
            foreach ($commonalities as $ngram => $commonality) {
                if (isset($and[$ngram])) {
                    $_and[$ngram] = $and[$ngram];
                }
            }
            $and = $_and;
        } else {
            $commonalities = null;
        }

        // Code for considering permissions
        if (($permissions_module !== null) && (!$GLOBALS['FORUM_DRIVER']->is_super_admin(get_member()))) {
            $g_or = _get_where_clause_groups(get_member());

            // this destroys mysqls query optimiser by forcing complexed OR's into the join, so we'll do this in PHP code
            /*$table .= ' LEFT JOIN ' . $db->get_table_prefix() . 'group_category_access z ON (' . db_string_equal_to('z.module_the_name', $permissions_module) . ' AND z.category_name=' . $permissions_field . (($g_or != '') ? (' AND ' . str_replace('group_id', 'z.group_id', $g_or)) : '') . ')';
            $where_clause .= ' AND ';
            $where_clause .= 'z.category_name IS NOT NULL';*/

            $cat_sql = '';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'group_category_access WHERE (' . $g_or . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_sql .= ' UNION ALL ';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'member_category_access WHERE (member_id=' . strval((integer)get_member()) . ' AND active_until>' . strval(time()) . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_access = array_keys(list_to_map('category_name', $db->query($cat_sql, null, null, false, true)));

            if (empty($cat_access)) {
                return array();
            }

            $extra_join_clause .= ' AND ixxx.' . $index_permissions_field . ' IN (';
            foreach ($cat_access as $i => $cat) {
                if ($i != 0) {
                    $extra_join_clause .= ',';
                }
                if ($permissions_field_is_string) {
                    $extra_join_clause .= '\'' . db_escape_string($cat) . '\'';
                } else {
                    if (is_numeric($cat)) {
                        $extra_join_clause .= $cat;
                    } // else should not be possible
                }
            }
            $extra_join_clause .= ')';
        }

        // Code for querying against each ngram
        $order_by_total_ngrams_matched = '';
        $order_by_occurrence_rates = '';
        $is_all_hard_joins = true;
        $i = 0;
        $open_brackets = 0;
        foreach ($search_token_sets as $set_type => $search_tokens) {
            foreach ($search_tokens as $ngram => $is_singular_ngram) {
                if ($is_singular_ngram) {
                    if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                        continue;
                    }

                    if (is_object($stemmer)) {
                        $ngram = $stemmer->stem($ngram);
                    }
                }

                $join_condition = '';
                $key_i = 0;
                foreach ($key_transfer_map as $content_table_field => $index_table_field) {
                    if ($key_i != 0) {
                        $join_condition .= ' AND ';
                    }
                    if ($i == 0) {
                        $join_condition .= 'i' . strval($i) . '.' . $index_table_field . '=r.' . $content_table_field;
                    } else {
                        $join_condition .= 'i' . strval($i) . '.' . $index_table_field . '=i0.' . $index_table_field;
                    }
                    $key_i++;
                }
                $join_condition .= ' AND i' . strval($i) . '.i_ngram=' . strval($this->crc($ngram));
                if (strpos(get_db_type(), 'mysql') !== false) {
                    $join_condition .= '/*' . str_replace('/', '\\', $ngram) . '*/';
                }
                $join_condition .= str_replace('ixxx.', 'i' . strval($i) . '.', $extra_join_clause);
                $join_condition .= ' AND ' . db_string_equal_to('i' . strval($i) . '.i_lang', $lang);
                if ($appearance_context !== null) {
                    $join_condition .= ' AND i_ac=' . strval($appearance_context);
                }

                if (($i == 0) || (!$use_imprecise_ordering) || ($set_type == 'fuzzy_and')) {
                    if ($set_type == 'and') {
                        $join_type = 'JOIN'; // Will enforce the AND implicitly
                    } else {
                        $join_type = 'LEFT JOIN';
                        $is_all_hard_joins = false;
                    }
                    $join .= ' ' . $join_type . ' ' . $db->get_table_prefix() . $index_table . ' i' . strval($i) . ' ON ' . $join_condition;

                    if ($set_type == 'not') {
                        $where_clause .= ' AND i' . strval($i) . '.i_ngram IS NULL';
                    }
                } else {
                    $where_clause .= ' AND ' . (($set_type == 'and') ? 'EXISTS' : 'NOT EXISTS') . ' (SELECT * FROM ' . $db->get_table_prefix() . $index_table . ' i' . strval($i) . ' WHERE ' . $join_condition;
                    $open_brackets++; // We keep opening up more brackets to stop the MySQL query optimiser doing whacky things, partly executing random subqueries into temporary tables before the first join
                }

                if (($set_type != 'not') && ($order_by_total_ngrams_matched != '')) {
                    $order_by_total_ngrams_matched .= '+';

                    if (!$use_imprecise_ordering) {
                        $order_by_occurrence_rates .= '+';
                    }
                }

                if ($set_type != 'not') {
                    $order_by_total_ngrams_matched .= db_function('IFF', array('i' . strval($i) . '.i_ngram IS NULL', '0', '1'));

                    if (!$use_imprecise_ordering) {
                        $scaler = (isset($commonalities[$ngram]) ? float_to_raw_string($commonalities[$ngram], 10) : '1');
                        $order_by_occurrence_rates .= db_function('COALESCE', array('i' . strval($i) . '.i_occurrence_rate', '0')) . '*' . $scaler;
                    } elseif ($order_by_occurrence_rates == '') {
                        $order_by_occurrence_rates = 'i' . strval($i) . '.i_occurrence_rate';
                    }
                }

                $i++;
            }
        }
        while ($open_brackets > 0) {
            $open_brackets--;
            $where_clause .= ')';
        }

        if ($i == 0) {
            // This is important - if there are no words to index against, then security will not have run either
            return array();
        }

        if (!$is_all_hard_joins) {
            $where_clause .= ' AND ' . $order_by_total_ngrams_matched . '>0';
        }

        // Do querying...

        if ($use_imprecise_ordering) {
            $contextual_relevance_sql = $order_by_occurrence_rates; // Will just be the occurrence rate of the least common term
        } else {
            $contextual_relevance_sql = $order_by_total_ngrams_matched . ((($order_by_total_ngrams_matched == '') || ($order_by_occurrence_rates == '')) ? '' : '+') . $order_by_occurrence_rates; // $order_by_total_ngrams_matched will be the dominent factor (intended!) as it is an integer while $order_by_occurrence_rates cannot add to more than 1
        }
        if ($contextual_relevance_sql == '') {
            $contextual_relevance_sql = '1';
        }
        $select = 'r.*,' . $contextual_relevance_sql . ' AS contextual_relevance';

        // Rating ordering, via special encoding
        if (strpos($order, 'compound_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT SUM(rating-1) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS compound_rating';
            $order = 'compound_rating';
        }
        if (strpos($order, 'average_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT AVG(rating) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS average_rating';
            $order = 'average_rating';
        }

        $t_rows_sql = 'SELECT ' . $select . ' FROM ' . $join . ' WHERE 1=1' . $where_clause . ' ORDER BY ' . $order . ' ' . $direction;

        if (get_param_integer('keep_show_query', 0) == 1) {
            attach_message($t_rows_sql, 'inform');
        }
        if (get_param_integer('keep_just_show_query', 0) == 1) {
            safe_ini_set('ocproducts.xss_detect', '0');
            header('Content-type: text/plain; charset=' . get_charset());
            exit($t_rows_sql);
        }

        // Useful for automated testing
        global $LAST_SEARCH_QUERY, $LAST_COUNT_QUERY;

        $LAST_SEARCH_QUERY = $t_rows_sql;
        $t_rows = $db->query($t_rows_sql, $max, $start);

        $t_count_sql = '(SELECT COUNT(*) FROM (';
        $t_count_sql .= 'SELECT 1 FROM ' . $join . ' WHERE 1=1' . $where_clause;
        $t_count_sql .= ' LIMIT 1000) counter)';
        $LAST_COUNT_QUERY = $t_count_sql;
        $t_count = $db->query_value_if_there($t_count_sql);
        $GLOBALS['TOTAL_SEARCH_RESULTS'] += $t_count;

        if ((get_param_integer('keep_show_query', 0) == 1) && (($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())) || ($GLOBALS['IS_ACTUALLY_ADMIN']))) {
            if ((array_key_exists(0, $t_rows)) && (array_key_exists('id', $t_rows[0]))) {
                $results = var_export(array_unique(collapse_1d_complexity('id', $t_rows)), true);
            } else {
                $results = var_export($t_rows, true);
            }
            attach_message(do_lang('COUNT_RESULTS') . ': ' . $results, 'inform');
        }

        return $t_rows;
    }

    /**
     * Find if we have to join in custom fields due to filtering.
     *
     * @return boolean Whether we have special filtering
     */
    public function active_search_has_special_filtering()
    {
        // TODO: This needs to be able to distinguish between tick boxes supported in index, and fully custom filtering -- and then can_use_composr_fulltext_engine can make use of this to infer which engine to use based on configuration

        foreach ($_GET as $key => $val) {
            if ((substr($key, 0, 7) == 'option_') && ($val != '')) {
                return true;
            }
        }
        return false;
    }

    /**
     * Helper function for hooks, used to get catalogue entry data (useful also for custom fields).
     *
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  string $c_name Catalogue codename
     * @param  integer $id Catalogue entry ID
     * @param  ?LANGUAGE_NAME $lang Language codename (null: default)
     */
    public function get_content_fields_from_catalogue_entry(&$content_fields, &$fields_to_index, $c_name, $id, $lang = null)
    {
        if (!addon_installed('catalogues')) {
            return;
        }

        require_code('catalogues');

        $map = get_catalogue_entry_field_values($c_name, $id, null, null, false, 'PAGE', $lang);
        $i = 0;
        foreach ($map as $field) {
            if (is_string($field['effective_value_pure'])) {
                $fields_to_index['field_' . strval($i)] = ($i == 0) ? APPEARANCE_CONTEXT_title : APPEARANCE_CONTEXT_body;
                $content_fields['field_' . strval($i)] = $field['effective_value_pure'];
            }
            $i++;
        }
    }

    /**
     * Helper function for hooks, used to generate SQL for filtering rows by timestamp.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $since_index_fields List of fields which contain timestamps that we use for recency checks
     * @param  ?TIME $since Filter to records with recency since this timestamp (null: no limit)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return string Extra SQL
     */
    public function generate_since_where_clause($db, $index_table, $since_index_fields, $since, &$statistics_map = null)
    {
        $where_clauses = array();

        if ($since !== null) {
            $test = $db->query_select_value_if_there($index_table, '1 AS test');
            if ($test !== null) {
                foreach ($since_index_fields as $field => $may_be_null) {
                    if ($may_be_null) {
                        $where_clause = $field . ' IS NOT NULL AND ' . $field . '>' . strval($since);
                    } else {
                        $where_clause = $field . '>' . strval($since);
                    }
                    $where_clauses[] = $where_clause;
                }

                // We nullify $statistics_map as it's useless if we're not doing a full indexing
                $statistics_map = null;
            } // Else: If the table has been truncated we treat that as a signal to do a full regeneration
        }

        if (empty($where_clauses)) {
            return '';
        }

        return ' AND (' . implode(' OR ', $where_clauses) . ')';
    }

    // Indexing...

    /**
     * Index a content resource.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_transfer_map A map between content field keys to index field keys, so we can clear out old indexing for the content resource
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @param  ?LANGUAGE_NAME $lang Passed content is for this specific language only (null: lookup for all installed languages)
     * @param  boolean $clean_scan If we are doing a clean scan and hence do not need to clean up old records
     */
    public function index_for_search($db, $index_table, $content_fields, $fields_to_index, $key_transfer_map, $filter_field_transfer_map, &$total_singular_ngram_tokens = null, &$statistics_map = null, $lang = null, $clean_scan = false)
    {
        // Clear out any previous indexing for this content resource
        $key_map = array();
        foreach ($key_transfer_map as $content_table_field => $index_table_field) {
            $key_map[$index_table_field] = $content_fields[$content_table_field];
        }
        if (!$clean_scan) {
            if ($lang === null) {
                $db->query_delete($index_table, $key_map);
            } else {
                $db->query_delete($index_table, $key_map + array('i_lang' => $lang)); // We're calling this method language-by-language
            }
        }

        if ($lang === null) {
            $langs = multi_lang_content() ? array_keys(find_all_langs()) : array(get_site_default_lang());
        } else {
            $langs = array($lang);
        }

        foreach ($langs as $lang) {
            if ($statistics_map !== null) {
                if (!array_key_exists($lang, $statistics_map)) {
                    $statistics_map[$lang] = array();
                }
            }

            $ngrams_for = array();
            foreach (array(APPEARANCE_CONTEXT_title, APPEARANCE_CONTEXT_meta, APPEARANCE_CONTEXT_body) as $appearance_context) {
                $_fields_to_index = array();
                foreach ($fields_to_index as $field => $_appearance_context) {
                    if ($_appearance_context == $appearance_context) {
                        $_fields_to_index[] = $field;
                    }
                }

                if ($appearance_context == APPEARANCE_CONTEXT_body) {
                    $ngrams_exclude = $ngrams_for[APPEARANCE_CONTEXT_title] + $ngrams_for[APPEARANCE_CONTEXT_meta];
                } else {
                    $ngrams_exclude = array();
                }

                $ngrams_for[$appearance_context] = $this->index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $_fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);
            }
        }
    }

    /**
     * Index a content resource, specifically for a particular language and appearance context.
     *
     * @param  object $db Database connection
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  integer $appearance_context An APPEARANCE_CONTEXT_* constant
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_map A map of keys for the index
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        $combined_text = '';
        foreach ($fields_to_index as $field) {
            $text = is_integer($content_fields[$field]) ? get_translated_text($content_fields[$field], $db, $lang) : $content_fields[$field];
            $combined_text .= ' ' . $text;
        }

        $ngrams = $this->tokenise_text($combined_text, $lang, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);

        $fields = $key_map;

        // Add indexing row for each ngram
        foreach ($filter_field_transfer_map as $content_table_field => $index_table_field) {
            $fields[$index_table_field] = $content_fields[$content_table_field];
        }
        $insert_arr = array();
        $ngrams_crc = array();
        foreach ($ngrams as $ngram => $count) {
            $crc = $this->crc($ngram);
            if (isset($ngrams_crc[$crc])) {
                // CRC hash collision. Happens about 1 in 200,000 -- so we can ignore it from a UX perspective but we have to stop key collisions!s
                $ngrams_crc[$crc] += $count;
            } else {
                $ngrams_crc[$crc] = $count;
            }
        }
        foreach ($ngrams_crc as $crc => $count) {
            $fields_for_ngram = array(
                'i_lang' => $lang,
                'i_ngram' => $crc,
                'i_ac' => $appearance_context,
                'i_occurrence_rate' => floatval($count) / floatval($total_singular_ngram_tokens),
            ) + $fields;

            // We are bulk-inserting, for speed
            if (empty($insert_arr)) {
                foreach ($fields_for_ngram as $key => $val) {
                    $insert_arr[$key] = array();
                }
            }
            foreach ($fields_for_ngram as $key => $val) {
                $insert_arr[$key][] = $val;
            }
        }

        if (!empty($insert_arr)) {
            $db->query_insert($index_table, $insert_arr);
        }

        return $ngrams;
    }

    /**
     * Clear out a content resource from the index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $index_key_map Map of index keys, defining what to delete
     */
    public function delete_from_index($db, $index_table, $index_key_map)
    {
        $db->query_delete($index_table, $index_key_map);
    }

    /**
     * Tokenise some text, so it can be indexed by token.
     *
     * @param  string $text The text
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function tokenise_text($text, $lang, $ngrams_exclude = null, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        if (strpos($text, '&') !== false) {
            $text = html_entity_decode($text, ENT_QUOTES, get_charset());
        }

        static $max_ngram_size = null;
        if ($max_ngram_size === null) {
            $max_ngram_size = intval(get_value('fulltext_max_ngram_size', '1', true));
        }

        $tokeniser = self::get_tokeniser($lang);
        $stemmer = self::get_stemmer($lang);

        $ngrams = array();

        $_ngrams = $tokeniser->text_to_ngrams($text, $max_ngram_size, $total_singular_ngram_tokens);
        foreach ($_ngrams as $ngram => $is_singular_ngram) {
            if ($is_singular_ngram) {
                if ($statistics_map !== null) {
                    if (!isset($statistics_map[$lang][$ngram])) {
                        $statistics_map[$lang][$ngram] = 0;
                    }
                    $statistics_map[$lang][$ngram]++;
                }
            }

            if ($is_singular_ngram) {
                if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                    continue;
                }
            }

            if ($ngrams_exclude !== null) {
                if (isset($ngrams_exclude[$ngram])) {
                    continue;
                }
            }

            if ($is_singular_ngram) {
                if (is_object($stemmer)) {
                    $ngram = $stemmer->stem($ngram);
                }
            }

            if (!isset($ngrams[$ngram])) {
                $ngrams[$ngram] = 0;
            }
            $ngrams[$ngram]++;
        }

        return $ngrams;
    }

    /**
     * Find whether a singular ngram (typically a word) is a stop word (i.e. too banal to be indexed).
     *
     * @param  string $ngram Singular ngram
     * @param  LANGUAGE_NAME $lang Language codename
     * @return boolean Whether it is
     */
    protected function singular_ngram_is_stop_word($ngram, $lang)
    {
        static $stop_list = array();
        if (!array_key_exists($lang, $stop_list)) {
            require_code('textfiles');
            $stop_list[$lang] = array_flip(explode("\n", read_text_file('too_common_words', $lang)));
            unset($stop_list[$lang]['']);
        }
        return isset($stop_list[$lang][$ngram]);
    }


    /**
     * Load up the commonalities for some ngrams, with caching.
     *
     * @param  object $db Database connection
     * @param  array $ngrams List of ngrams
     * @return array Map between ngram and commonality
     */
    protected function load_commonalities($db, $ngrams)
    {
        static $cache = array();

        $commonality_query = 'SELECT * FROM ' . get_table_prefix() . 'ft_index_commonality WHERE ';
        $commonalities = array();
        $where = '';
        foreach ($ngrams as $ngram) {
            if (isset($cache[$ngram])) {
                $commonalities[$ngram] = $cache[$ngram];
            } else {
                if ($where != '') {
                    $where .= ' OR ';
                }
                $where .= db_string_equal_to('c_ngram', $ngram);
            }
        }
        if ($where != '') {
            $commonality_query .= $where;
            $results = collapse_2d_complexity('c_ngram', 'c_commonality', $db->query($commonality_query . ' ORDER BY c_commonality'));
            $commonalities += $results;
            $cache += $results;
        }
        return $commonalities;
    }

    /**
     * Get a tokeniser for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return object Tokeniser
     */
    public static function get_tokeniser($lang)
    {
        static $tokeniser = array();
        if (!array_key_exists($lang, $tokeniser)) {
            if (((is_file(get_file_base() . '/sources/lang_tokeniser_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/tokeniser_' . $lang . '.php'))) && (!in_safe_mode())) {
                require_code('lang_tokeniser_' . $lang);
                $tokeniser[$lang] = object_factory('LangTokeniser_' . $lang);
            } else {
                require_code('lang_tokeniser_' . fallback_lang());
                $tokeniser[$lang] = object_factory('LangTokeniser_' . fallback_lang());
            }
        }
        return $tokeniser[$lang];
    }

    /**
     * Get a stemmer for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return ?object Stemmer (null: none)
     */
    public static function get_stemmer($lang)
    {
        static $stemmer = array();
        if (!array_key_exists($lang, $stemmer)) {
            $stemmer[$lang] = null;
            if (((is_file(get_file_base() . '/sources/lang_stemmer_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/lang_stemmer_' . $lang . '.php'))) && (!in_safe_mode())) {
                if (get_value('fulltext_do_stemming', '1', true) === '1') {
                    require_code('lang_stemmer_' . $lang);
                    $stemmer[$lang] = object_factory('Stemmer_' . $lang);
                }
            }
        }
        return $stemmer[$lang];
    }

    /**
     * Calculate a CRC, effectively converting a string ngram to an integer hash of it.
     * CRC-24 algorithm, to avoid compatibility issues with PHP's crc32.
     *
     * @param  string $str String
     * @return integer CRC
     */
    protected function crc($str)
    {
        static $ob = null;
        if ($ob === null) {
            $ob = new CRC24();
        }
        return $ob->calculate($str);
    }
}

// TODO: Put this in another file and credit it properly
/**
 * @author Philip Burggraf <philip@pburggraf.de>
 */
class CRC24
{
    protected $poly = 0x864cfb;
    protected $lookupTable;
    protected $bitLength = 24;

    public function __construct()
    {
        $this->lookupTable = $this->generateTable($this->poly);
    }

    public function calculate($buffer)
    {
        $buffer_length = strlen($buffer);

        $mask = (((1 << ($this->bitLength - 1)) - 1) << 1) | 1;
        $high_bit = 1 << ($this->bitLength - 1);

        $crc = 0xb704ce;

        for ($iterator = 0; $iterator < $buffer_length; ++$iterator) {
            $character = ord($buffer[$iterator]);

            for ($j = 0; $j < 8; $j++) {
                $_j = 0x80 & (1 << $j);

                $bit = $crc & $high_bit;
                $crc = $crc << 1;

                if (($character & $_j) > 0) {
                    $bit = $bit ^ $high_bit;
                }

                if ($bit > 0) {
                    $crc = $crc ^ $this->poly;
                }
            }
        }

        return $crc & $mask;
    }

    protected function generateTable($polynomial)
    {
        $table_size = 256;

        $mask = (((1 << ($this->bitLength - 1)) - 1) << 1) | 1;
        $high_bit = 1 << ($this->bitLength - 1);

        $crctab = array();

        for ($i = 0; $i < $table_size; ++$i) {
            $crc = $i;

            $crc = $crc << $this->bitLength - 8;

            for ($j = 0; $j < 8; ++$j) {
                $bit = $crc & $high_bit;
                $crc = $crc << 1;
                if ($bit > 0) {
                    $crc = $crc ^ $polynomial;
                }
            }

            $crc = $crc & $mask;
            $crctab[] = $crc;
        }

        return $crctab;
    }
}
