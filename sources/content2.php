<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__content2()
{
    if (!defined('METADATA_HEADER_NO')) {
        define('METADATA_HEADER_NO', 0);
        define('METADATA_HEADER_YES', 1);
        define('METADATA_HEADER_FORCE', 2);

        define('ORDER_AUTOMATED_CRITERIA', 2147483647); // lowest order, shared for all who care not about order, so other SQL ordering criterias take precedence // TODO: #3046 in tracker
    }
}

/**
 * Define page metadata.
 * This function is intended for programmers, writing upgrade scripts for a custom site (dev>staging>live).
 *
 * @param  array $page_metadata Page metadata for multiple pages (see function code for an example; description and keywords go to SEO metadata, rest goes to custom fields which will auto-create as needed)
 * @param  string $zone The zone to do this in
 */
function define_page_metadata(array $page_metadata, string $zone = '')
{
    /*
        CALLING SAMPLE:

        $page_metadata = [
            'start' => [
                'Title' => 'Page title goes here',
                'description' => 'Page description goes here.',
                'keywords' => 'page, keywords, go here',
            ],
        );
        define_page_metadata($page_metadata);
    }
    */

    foreach ($page_metadata as $page_name => $metadata) {
        $catalogue_entry_id = null;
        $order = 0;

        foreach ($metadata as $key => $val) {
            if (in_array($key, ['description', 'keywords'])) {
                continue;
            }

            require_code('fields');

            if ($catalogue_entry_id === null) {
                $catalogue_entry_id = get_bound_content_entry_wrap('comcode_page', ':' . $page_name);
            }

            $field_id = define_custom_field($key, '', $order);
            $order++;

            $GLOBALS['SITE_DB']->query_delete('catalogue_efv_short', ['cf_id' => $field_id, 'ce_id' => $catalogue_entry_id]);
            $GLOBALS['SITE_DB']->query_insert('catalogue_efv_short', ['cf_id' => $field_id, 'ce_id' => $catalogue_entry_id, 'cv_value' => $val]);
        }

        seo_meta_set_for_explicit('comcode_page', ':' . $page_name, isset($metadata['keywords']) ? $metadata['keywords'] : '', isset($metadata['description']) ? $metadata['description'] : '');
    }
}

/**
 * Get an order inputter.
 *
 * @param  ID_TEXT $entry_type The type of resource being ordered
 * @param  ?ID_TEXT $category_type The type of resource being ordered within (null: no categories involved)
 * @param  ?integer $current_order The current order (null: new, so add to end)
 * @param  ?integer $max Maximum order field (null: work out from content type metadata)
 * @param  ?integer $total Number of entries, alternative to supplying $max (null: work out from content type metadata)
 * @param  ID_TEXT $order_field The POST field to save under
 * @param  ?Tempcode $description Description for field input (null: {!ORDER})
 * @param  ?integer $num_automated_now The number of records that are currently automated (null: work out)
 * @return Tempcode Ordering field
 */
function get_order_field(string $entry_type, ?string $category_type, ?int $current_order, ?int $max = null, ?int $total = null, string $order_field = 'order', ?object $description = null, ?int $num_automated_now = null) : object
{
    $new = ($current_order === null);

    $min = 0;

    require_code('content');
    $ob = get_content_object($entry_type);
    $info = $ob->info();

    $db_order_field = $info['order_field'];

    if ($max === null) {
        $max = $info['db']->query_value_if_there('SELECT MAX(' . $db_order_field . ') FROM ' . $info['db']->get_table_prefix() . $info['table'] . ' WHERE ' . $db_order_field . '<>' . strval(ORDER_AUTOMATED_CRITERIA));
        if ($max === null) {
            $max = 0;
        }
    }

    if ($total === null) {
        $total = $info['db']->query_select_value($info['table'], 'COUNT(*)');
    }

    if ($total > $max) {
        // Need to make sure there's always enough slots to pick from
        $max = $total - 1;
    }

    if ($new) {
        if ($num_automated_now === null) {
            $test = $info['db']->query_value_if_there('SELECT COUNT(' . $db_order_field . ') FROM ' . $info['db']->get_table_prefix() . $info['table'] . ' WHERE ' . $db_order_field . '=' . strval(ORDER_AUTOMATED_CRITERIA));
        }

        if ($num_automated_now > 0 || $total == 0) {
            $current_order = ORDER_AUTOMATED_CRITERIA; // Ah, we are already in the habit of automated ordering here / starting fresh
        } else {
            $max++; // Space for new one on end
            $current_order = $max;
        }
    }

    if ($description === null) {
        if ($category_type === null) {
            $description = do_lang_tempcode('DESCRIPTION_ORDER_NO_CATS', escape_html($entry_type));
        } else {
            $description = do_lang_tempcode('DESCRIPTION_ORDER', escape_html($entry_type), escape_html($category_type));
        }
    }

    if ($max > 100) {
        // Too much for a list, so do a typed integer input
        return form_input_integer(do_lang_tempcode('ORDER'), $description, $order_field, $current_order, false);
    }

    // List input
    $order_list = new Tempcode();
    for ($i = $min; $i <= $max; $i++) {
        $selected = ($i === $current_order);
        $order_list->attach(form_input_list_entry(strval($i), $selected, integer_format($i + 1)));
    }
    $order_list->attach(form_input_list_entry('', $current_order == ORDER_AUTOMATED_CRITERIA, do_lang_tempcode('ORDER_AUTOMATED_CRITERIA')));
    return form_input_list(do_lang_tempcode('ORDER'), $description, $order_field, $order_list, null, false, false);
}

/**
 * Get submitted order value.
 *
 * @param  ID_TEXT $order_field The POST field
 * @return integer The order value
 */
function post_param_order_field(string $order_field = 'order') : int
{
    $ret = post_param_integer($order_field, null);
    if ($ret === null) {
        $ret = ORDER_AUTOMATED_CRITERIA;
    }
    return $ret;
}

/**
 * Get template fields to insert into a form page, for manipulation of metadata.
 *
 * @param  ID_TEXT $content_type The type of resource (e.g. download)
 * @param  ?ID_TEXT $content_id The ID of the resource (null: adding)
 * @param  boolean $require_owner Whether to require owner to be filled in
 * @param  array $fields_to_skip List of fields to NOT take in
 * @param  integer $show_header Whether to show a header (a METADATA_HEADER_* constant)
 * @return Tempcode Form page Tempcode fragment
 */
function metadata_get_fields(string $content_type, ?string $content_id, bool $require_owner = true, array $fields_to_skip = [], int $show_header = 1) : object
{
    require_lang('metadata');

    $fields = new Tempcode();

    if (has_privilege(get_member(), 'edit_meta_fields')) {
        require_code('content');
        $ob = get_content_object($content_type);
        $info = $ob->info();

        require_code('content');
        $content_row = null;
        if ($content_id !== null) {
            list(, , , $content_row) = content_get_details($content_type, $content_id);
        }

        $views_field = in_array('views', $fields_to_skip) ? null : $info['views_field'];
        if ($views_field !== null) {
            $views = ($content_row === null) ? 0 : $content_row[$views_field];
            $fields->attach(form_input_integer(do_lang_tempcode('COUNT_VIEWS'), do_lang_tempcode('DESCRIPTION_META_VIEWS'), 'meta_views', null, false));
        }

        $submitter_field = in_array('submitter', $fields_to_skip) ? null : $info['submitter_field'];
        if ($submitter_field !== null) {
            $submitter = ($content_row === null) ? get_member() : $content_row[$submitter_field];
            if ($submitter !== null) {
                $username = $GLOBALS['FORUM_DRIVER']->get_username($submitter, false, USERNAME_DEFAULT_NULL);
                if ($username === null) {
                    $username = $GLOBALS['FORUM_DRIVER']->get_username(get_member());
                }
            } else {
                $username = '';
            }
            $fields->attach(form_input_username(do_lang_tempcode('OWNER'), do_lang_tempcode('DESCRIPTION_OWNER'), 'meta_submitter', $username, $require_owner));
        }

        $add_time_field = in_array('add_time', $fields_to_skip) ? null : $info['add_time_field'];
        if ($add_time_field !== null) {
            $add_time = ($content_row === null) ? null : $content_row[$add_time_field];
            $fields->attach(form_input_date(do_lang_tempcode('ADD_TIME'), do_lang_tempcode('DESCRIPTION_META_ADD_TIME'), 'meta_add_time', $content_row !== null, ($content_row === null), true, $add_time, 40, intval(date('Y')) - 20));
        }

        if ($content_id !== null) {
            $edit_time_field = in_array('edit_time', $fields_to_skip) ? null : $info['edit_time_field'];
            if ($edit_time_field !== null) {
                $edit_time = ($content_row === null) ? null : (($content_row[$edit_time_field] === null) ? time() : max(time(), $content_row[$edit_time_field]));
                $fields->attach(form_input_date(do_lang_tempcode('EDIT_TIME'), do_lang_tempcode('DESCRIPTION_META_EDIT_TIME'), 'meta_edit_time', false, ($edit_time === null), true, $edit_time, -10));
            }
        }

        if (($info['support_url_monikers']) && (url_monikers_enabled()) && (!in_array('url_moniker', $fields_to_skip))) {
            $url_moniker = null;
            if ($content_id !== null) {
                if ($content_type == 'comcode_page') {
                    list($zone, $_content_id) = explode(':', $content_id);
                    $attributes = [];
                    $url_moniker = find_id_moniker(['page' => $_content_id] + $attributes, $zone);
                } else {
                    $_content_id = $content_id;
                    list($zone, $attributes,) = page_link_decode($info['view_page_link_pattern']);
                    $url_moniker = find_id_moniker(['id' => $_content_id] + $attributes, $zone);
                }

                if ($url_moniker === null) {
                    $url_moniker = '';
                }

                $moniker_where = [
                    'm_manually_chosen' => 1,
                    'm_resource_page' => ($content_type == 'comcode_page') ? $_content_id : $attributes['page'],
                    'm_resource_type' => ($content_type == 'comcode_page') ? '' : (isset($attributes['type']) ? $attributes['type'] : ''),
                    'm_resource_id' => ($content_type == 'comcode_page') ? $zone : $_content_id,
                ];
                $manually_chosen = ($GLOBALS['SITE_DB']->query_select_value_if_there('url_id_monikers', 'm_moniker', $moniker_where) !== null);
            } else {
                $url_moniker = '';
                $manually_chosen = false;
            }
            if ($url_moniker == '') {
                $url_moniker_to_show = do_lang_tempcode('_UNSET');
            } else {
                $url_moniker_to_show = make_string_tempcode(escape_html($url_moniker));
            }
            $fields->attach(form_input_codename(do_lang_tempcode('URL_MONIKER'), do_lang_tempcode('DESCRIPTION_META_URL_MONIKER', $url_moniker_to_show), 'meta_url_moniker', (($manually_chosen) && (!is_numeric($url_moniker))) ? $url_moniker : '', false, null, null, ['/']));
        }
    } else {
        if ($show_header != METADATA_HEADER_FORCE) {
            return new Tempcode();
        }
    }

    if ((!$fields->is_empty()) && ($show_header != METADATA_HEADER_NO)) {
        $_fields = new Tempcode();
        $_fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', [
            '_GUID' => 'adf2a2cda231619243763ddbd0cc9d4e',
            'SECTION_HIDDEN' => true,
            'TITLE' => do_lang_tempcode('METADATA'),
            'HELP' => do_lang_tempcode('DESCRIPTION_METADATA', ($content_id === null) ? do_lang_tempcode('RESOURCE_NEW') : escape_html($content_id)),
        ]));
        $_fields->attach($fields);
        return $_fields;
    }

    return $fields;
}

/**
 * Get field values for metadata.
 *
 * @param  ID_TEXT $content_type The type of resource (e.g. download)
 * @param  ?ID_TEXT $content_id The old ID of the resource (null: adding)
 * @param  array $fields_to_skip List of fields to NOT take in
 * @param  ?ID_TEXT $new_content_id The new ID of the resource (null: not being renamed)
 * @return array A map of standard metadata fields (name to value). If adding, this map is accurate for adding. If editing, nulls mean do-not-edit or non-editable.
 */
function actual_metadata_get_fields(string $content_type, ?string $content_id, array $fields_to_skip = [], ?string $new_content_id = null) : array
{
    require_lang('metadata');

    if (fractional_edit()) {
        return [
            'views' => INTEGER_MAGIC_NULL,
            'submitter' => INTEGER_MAGIC_NULL,
            'add_time' => INTEGER_MAGIC_NULL,
            'edit_time' => INTEGER_MAGIC_NULL,
            /*'url_moniker' => null, was handled internally*/
        ];
    }

    if (!has_privilege(get_member(), 'edit_meta_fields')) { // Pass through as how an edit would normally function (things left alone except edit time)
        return [
            'views' => ($content_id === null) ? 0 : INTEGER_MAGIC_NULL,
            'submitter' => ($content_id === null) ? get_member() : INTEGER_MAGIC_NULL,
            'add_time' => ($content_id === null) ? time() : INTEGER_MAGIC_NULL,
            'edit_time' => time(),
            /*'url_moniker' => null, was handled internally*/
        ];
    }

    require_code('content');
    $ob = get_content_object($content_type);
    $info = $ob->info();

    $views = null;
    $views_field = in_array('views', $fields_to_skip) ? null : $info['views_field'];
    if ($views_field !== null) {
        $views = post_param_integer('meta_views', null);
        if ($views === null) {
            if ($content_id === null) {
                $views = 0;
            } else {
                $views = INTEGER_MAGIC_NULL;
            }
        }
    }

    $submitter = null;
    $submitter_field = in_array('submitter', $fields_to_skip) ? null : $info['submitter_field'];
    if ($submitter_field !== null) {
        $_submitter = post_param_string('meta_submitter', '');
        if ($_submitter == '') {
            if ($content_id === null) {
                $submitter = get_member();
            } else {
                $submitter = INTEGER_MAGIC_NULL;
            }
        } else {
            $submitter = $GLOBALS['FORUM_DRIVER']->get_member_from_username($_submitter);
            if ($submitter === null) {
                $submitter = null; // Leave alone, we did not recognise the user
                attach_message(do_lang_tempcode('_MEMBER_NO_EXIST', escape_html($_submitter)), 'warn'); // ...but attach an error at least
            }
            if ($submitter === null) {
                if ($content_id === null) {
                    $submitter = get_member();
                }
            }
        }
    }

    $add_time = null;
    $add_time_field = in_array('add_time', $fields_to_skip) ? null : $info['add_time_field'];
    if ($add_time_field !== null) {
        $add_time = post_param_date('meta_add_time');
        if ($add_time === null) {
            if ($content_id === null) {
                $add_time = time();
            } else {
                $add_time = INTEGER_MAGIC_NULL;
            }
        } else {
            $add_time = min($add_time, 4294967295); // TODO #3046
        }
    }

    $edit_time = null;
    $edit_time_field = in_array('edit_time', $fields_to_skip) ? null : $info['edit_time_field'];
    if ($edit_time_field !== null) {
        $edit_time = post_param_date('meta_edit_time');
        if ($edit_time === null) {
            if ($content_id === null) {
                $edit_time = null; // No edit time
            } else {
                $edit_time = null; // Edit time explicitly wiped out
            }
        } else {
            $edit_time = min($edit_time, 4294967295); // TODO #3046
        }
    }

    if ($content_id !== null) {
        set_url_moniker($content_type, $content_id, $fields_to_skip, $new_content_id);
    }

    return [
        'views' => $views,
        'submitter' => $submitter,
        'add_time' => $add_time,
        'edit_time' => $edit_time,
        /*'url_moniker' => $url_moniker, was handled internally*/
    ];
}

/**
 * Set a URL moniker for a resource.
 *
 * @param  ID_TEXT $content_type The type of resource (e.g. download)
 * @param  ID_TEXT $content_id The old ID of the resource
 * @param  array $fields_to_skip List of fields to NOT take in
 * @param  ?ID_TEXT $new_content_id The new ID of the resource (null: not being renamed)
 */
function set_url_moniker(string $content_type, string $content_id, array $fields_to_skip = [], ?string $new_content_id = null)
{
    require_lang('metadata');

    require_code('content');
    $ob = get_content_object($content_type);
    $info = $ob->info();

    $url_moniker = null;
    if (($info['support_url_monikers']) && (!in_array('url_moniker', $fields_to_skip))) {
        $url_moniker = post_param_string('meta_url_moniker', '');
        if ($url_moniker == '') {
            if ($content_type == 'comcode_page') {
                $url_moniker = '';
                $parent = post_param_string('parent_page', '');
                while ($parent != '') {
                    $url_moniker = str_replace('_', '-', $parent) . (($url_moniker != '') ? ('/' . $url_moniker) : '');

                    $parent = $GLOBALS['SITE_DB']->query_select_value_if_there('comcode_pages', 'p_parent_page', ['the_page' => $parent]);
                    if ($parent === null) {
                        $parent = '';
                    }
                }
                if ($url_moniker != '') {
                    $url_moniker .= '/' . preg_replace('#^.*:#', '', str_replace('_', '-', $content_id));
                } else {
                    $url_moniker = null;
                }
            } else {
                $url_moniker = null;
            }
        }

        if ($url_moniker !== null) {
            require_code('type_sanitisation');
            if ((!is_alphanumeric(str_replace('/', '', $url_moniker))) || (is_numeric($url_moniker))) {
                attach_message(do_lang_tempcode('BAD_CODENAME'), 'warn');
                $url_moniker = null;
            }

            if ($url_moniker !== null) {
                if ($content_type == 'comcode_page') {
                    list($zone, $page) = explode(':', $content_id);
                    $type = '';
                    $_content_id = $zone;

                    // Update ID of existing moniker(s)
                    if ($new_content_id !== null) {
                        $GLOBALS['SITE_DB']->query_update('url_id_monikers', [
                            'm_resource_page' => $new_content_id,
                        ], ['m_resource_page' => $page, 'm_resource_type' => '', 'm_resource_id' => $zone]);
                    }
                } else {
                    list($zone, $attributes,) = page_link_decode($info['view_page_link_pattern']);
                    $page = $attributes['page'];
                    $type = $attributes['type'];
                    $_content_id = $content_id;

                    // Update ID of existing moniker(s)
                    if ($new_content_id !== null) {
                        $GLOBALS['SITE_DB']->query_update('url_id_monikers', [
                            'm_resource_id' => $new_content_id,
                        ], ['m_resource_page' => $page, 'm_resource_type' => $type, 'm_resource_id' => $content_id]);
                    }
                }

                $ok = true;

                // Test for conflicts
                $conflict_test_map = [
                    'm_moniker' => $url_moniker,
                ];
                if (substr($url_moniker, 0, 1) != '/') { // Can narrow the conflict-check scope if it's relative to a module rather than a zone ('/' prefix)
                    $conflict_test_map += [
                        'm_resource_page' => $page,
                        'm_resource_type' => $type,
                    ];
                }
                $test = $GLOBALS['SITE_DB']->query_select('url_id_monikers', ['*'], $conflict_test_map);
                if ((array_key_exists(0, $test)) && ($test[0]['m_resource_id'] !== $_content_id)) {
                    if ($test[0]['m_deprecated'] == 0) {
                        $ok = false;

                        if ($content_type == 'comcode_page') {
                            $competing_page_link = $test[0]['m_resource_id'] . ':' . $test[0]['m_resource_page'];
                        } else {
                            $competing_page_link = '_WILD' . ':' . $test[0]['m_resource_page'];
                            if ($test[0]['m_resource_type']) {
                                $competing_page_link .= ':' . $test[0]['m_resource_type'];
                            }
                            if ($test[0]['m_resource_id'] != '') {
                                $competing_page_link .= ':' . $test[0]['m_resource_id'];
                            }
                        }
                        attach_message(do_lang_tempcode('URL_MONIKER_TAKEN', escape_html($competing_page_link), escape_html($url_moniker)), 'warn');
                    } else { // Deprecated, so we can claim it
                        $GLOBALS['SITE_DB']->query_delete('url_id_monikers', $conflict_test_map);
                    }
                }

                if (substr($url_moniker, 0, 1) == '/') { // ah, relative to zones, better run some anti-conflict tests!
                    $parts = explode('/', substr($url_moniker, 1), 3);

                    if ($ok) {
                        // Test there are no zone conflicts
                        if ((file_exists(get_file_base() . '/' . $parts[0])) || (file_exists(get_custom_file_base() . '/' . $parts[0]))) {
                            $ok = false;
                            attach_message(do_lang_tempcode('URL_MONIKER_CONFLICT_ZONE'), 'warn');
                        }
                    }

                    if ($ok) {
                        // Test there are no page conflicts, from perspective of welcome zone
                        require_code('site');
                        $test1 = (count($parts) < 2) ? _request_page($parts[0], '') : false;
                        $test2 = false;
                        if (isset($parts[1])) {
                            $test2 = (count($parts) < 3) ? _request_page($parts[1], $parts[0]) : false;
                        }
                        if (($test1 !== false) || ($test2 !== false)) {
                            $ok = false;
                            attach_message(do_lang_tempcode('URL_MONIKER_CONFLICT_PAGE'), 'warn');
                        }
                    }

                    if ($ok) {
                        // Test there are no page conflicts, from perspective of deep zones
                        require_code('site');
                        $start = 0;
                        $zones = [];
                        do {
                            $zones = find_all_zones(false, false, false, $start, 50);
                            foreach ($zones as $zone_name) {
                                $test1 = (count($parts) < 2) ? _request_page($parts[0], $zone_name) : false;
                                if ($test1 !== false) {
                                    $ok = false;
                                    attach_message(do_lang_tempcode('URL_MONIKER_CONFLICT_PAGE'), 'warn');
                                    break 2;
                                }
                            }
                            $start += 50;
                        } while (!empty($zones));
                    }
                }

                if ($ok) {
                    // Insert
                    require_code('urls2');
                    suggest_new_idmoniker_for($page, $type, $_content_id, ($content_type == 'comcode_page') ? $zone : '', $url_moniker, false, $url_moniker);
                }
            }
        }
    }
}

/**
 * Read in an additional metadata field, specific to a resource type.
 *
 * @param  array $metadata metadata already collected
 * @param  ID_TEXT $key The parameter name
 * @param  mixed $default The default if it was not set
 */
function actual_metadata_get_fields__special(array &$metadata, string $key, $default)
{
    $metadata[$key] = $default;
    if (has_privilege(get_member(), 'edit_meta_fields')) {
        if (is_integer($default)) {
            switch ($default) {
                case 0:
                case INTEGER_MAGIC_NULL:
                    $metadata[$key] = post_param_integer('meta_' . $key, $default);
                    break;
            }
        } else {
            switch ($default) {
                case '':
                case STRING_MAGIC_NULL:
                    $metadata[$key] = post_param_string('meta_' . $key, $default);
                    if ($metadata[$key] == '') {
                        $metadata[$key] = $default;
                    }
                    break;

                case null:
                    $metadata[$key] = post_param_integer('meta_' . $key, null);
                    break;
            }
        }
    }
}

/**
 * Clear caching for a particular seo entry.
 *
 * @param  ID_TEXT $type The type of resource (e.g. download)
 * @param  ID_TEXT $id The ID of the resource
 */
function seo_meta_clear_caching(string $type, string $id)
{
    if (function_exists('delete_cache_entry')) {
        delete_cache_entry('side_tag_cloud');
    }

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete(['seo', $type, $id]);
    }
}

/**
 * Erase a seo entry... as these shouldn't be left hanging around once content is deleted.
 *
 * @param  ID_TEXT $type The type of resource (e.g. download)
 * @param  ID_TEXT $id The ID of the resource
 * @param  boolean $do_decache Whether to clear caching for this too
 */
function seo_meta_erase_storage(string $type, string $id, bool $do_decache = true)
{
    $rows = $GLOBALS['SITE_DB']->query_select('seo_meta', ['meta_description'], ['meta_for_type' => $type, 'meta_for_id' => $id], '', 1);
    if (array_key_exists(0, $rows)) {
        delete_lang($rows[0]['meta_description']);
        $GLOBALS['SITE_DB']->query_delete('seo_meta', ['meta_for_type' => $type, 'meta_for_id' => $id], '', 1);
    }

    $rows = $GLOBALS['SITE_DB']->query_select('seo_meta_keywords', ['meta_keyword'], ['meta_for_type' => $type, 'meta_for_id' => $id]);
    foreach ($rows as $row) {
        delete_lang($row['meta_keyword']);
    }
    $GLOBALS['SITE_DB']->query_delete('seo_meta_keywords', ['meta_for_type' => $type, 'meta_for_id' => $id]);

    if ($do_decache) {
        seo_meta_clear_caching($type, $id);
    }
}

/**
 * Get template fields to insert into a form page, for manipulation of seo fields.
 *
 * @param  ID_TEXT $type The type of resource (e.g. download)
 * @param  ?ID_TEXT $id The ID of the resource (null: adding)
 * @param  boolean $show_header Whether to show a header
 * @return Tempcode Form page Tempcode fragment
 */
function seo_get_fields(string $type, ?string $id = null, bool $show_header = true) : object
{
    require_code('form_templates');
    if ($id === null) {
        list($keywords, $description) = ['', ''];
    } else {
        list($keywords, $description) = seo_meta_get_for($type, $id);
    }

    $fields = new Tempcode();
    if ((get_option('enable_seo_fields') != 'no') && ((get_option('enable_seo_fields') != 'only_on_edit') || ($id !== null))) {
        if ($show_header) {
            $fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', [
                '_GUID' => '545aefd48d73cf01bdec7226dc6d93fb',
                'SECTION_HIDDEN' => $keywords == '' && $description == '',
                'TITLE' => do_lang_tempcode('SEO'),
                'HELP' => (get_option('show_docs') === '0') ? null : do_lang_tempcode('TUTORIAL_ON_THIS', escape_html(get_tutorial_url('tut_seo'))),
            ]));
        }
        $fields->attach(form_input_line_multi(do_lang_tempcode('KEYWORDS'), do_lang_tempcode('DESCRIPTION_META_KEYWORDS'), 'meta_keywords[]', array_map('trim', explode(',', preg_replace('#,+#', ',', $keywords))), 0));
        $fields->attach(form_input_line(do_lang_tempcode('META_DESCRIPTION'), do_lang_tempcode('DESCRIPTION_META_DESCRIPTION'), 'meta_description', $description, false));
    }
    return $fields;
}

/**
 * Explicitly sets the meta information for the specified resource.
 *
 * @param  ID_TEXT $type The type of resource (e.g. download)
 * @param  ID_TEXT $id The ID of the resource
 * @param  SHORT_TEXT $keywords The keywords to use
 * @param  SHORT_TEXT $description The description to use
 */
function seo_meta_set_for_explicit(string $type, string $id, string $keywords, string $description)
{
    if ($description == STRING_MAGIC_NULL) {
        return;
    }
    if ($keywords == STRING_MAGIC_NULL) {
        return;
    }

    $map_general = [
        'meta_for_type' => $type,
        'meta_for_id' => $id,
    ];

    // Description...

    $description = str_replace("\n", ' ', $description);

    $rows = $GLOBALS['SITE_DB']->query_select('seo_meta', ['meta_description'], $map_general, '', 1);
    if (array_key_exists(0, $rows)) {
        $map = [];
        $map += lang_remap('meta_description', $rows[0]['meta_description'], $description);
        $GLOBALS['SITE_DB']->query_update('seo_meta', $map, $map_general, '', 1);
    } else {
        $map = $map_general;
        $map += insert_lang('meta_description', $description, 2);
        $GLOBALS['SITE_DB']->query_insert('seo_meta', $map);
    }

    // Keywords...

    $_keywords = [];
    foreach (array_unique(explode(',', $keywords)) as $keyword) {
        $keyword = trim($keyword, " \t");
        $_keywords[] = $keyword;
    }

    $rows = $GLOBALS['SITE_DB']->query_select('seo_meta_keywords', ['*'], $map_general);
    foreach ($rows as $i => $row) {
        if ($i < count($_keywords)) {
            $map = ['sort_order' => $i];
            $map += lang_remap('meta_keyword', $row['meta_keyword'], $_keywords[$i]);
            $GLOBALS['SITE_DB']->query_update('seo_meta_keywords', $map, ['id' => $row['id']], '', 1);
        } else {
            delete_lang($row['meta_keyword']);
            $GLOBALS['SITE_DB']->query_delete('seo_meta_keywords', ['id' => $row['id']]);
        }
    }

    foreach ($_keywords as $i => $keyword) {
        if ($i >= count($rows)) {
            $map = $map_general;
            $map['sort_order'] = $i;
            $map += insert_lang('meta_keyword', $keyword, 2);
            $GLOBALS['SITE_DB']->query_insert('seo_meta_keywords', $map);
        }
    }

    // Clear caching...
    seo_meta_clear_caching($type, $id);
}

/**
 * Automatically extracts meta information from some source data.
 *
 * @param  array $keyword_sources Array of content strings to summarise from
 * @param  SHORT_TEXT $description The description to use
 * @return array A pair: Keyword string generated, Description generated
 *
 * @ignore
 */
function _seo_meta_find_data(array $keyword_sources, string $description = '') : array
{
    // These characters are considered to be word-characters
    require_code('textfiles');
    $word_chars = explode("\n", read_text_file('word_characters', '')); // We use this, as we have no easy multi-language way of detecting if something is a word character in non-latin alphabets (as they don't usually have upper/lower case which would be our detection technique)
    foreach ($word_chars as $i => $word_char) {
        $_word_char = trim($word_char);
        if ($_word_char != '') {
            $word_chars[$i] = $_word_char;
        }
    }
    $common_words = explode("\n", read_text_file('too_common_words', ''));
    foreach ($common_words as $i => $common_word) {
        $_common_word = trim(cms_mb_strtolower($common_word));
        if ($_common_word != '') {
            $common_words[$i] = $_common_word;
        }
    }

    $word_chars_flip = array_flip($word_chars);
    $common_words_flip = array_flip($common_words);

    $min_word_length = 3;

    $keywords_might_use = []; // This will be filled
    $keywords_must_use = []; // ...and/or this

    $this_word = '';

    $source = null;
    foreach ($keyword_sources as $source) { // Look in all our sources
        // Some sources are marked 'must use', i.e. to put as higher priority
        $must_use = false;
        // Some sources are marked 'codename', i.e. they should be taken literally without being split.
        $codename = false;
        if (is_array($source)) {
            if (count($source) >= 3) {
                list($source, $must_use, $codename) = $source;
            } else {
                list($source, $must_use) = $source;
            }
        }

        // Clean up word pre-processing
        $source = strip_comcode($source, true);
        if (cms_mb_strtoupper($source) == $source) {
            $source = cms_mb_strtolower($source); // Don't leave in all caps, as is ugly, and also would break our Proper Noun detection
        }

        // Do we need to be Unicode-aware? (slower)
        $len_a = strlen($source);
        $len_b = cms_mb_strlen($source);
        $len = $len_a;
        $unicode = false;
        if ($len_b > $len_a) {
            $len = $len_b;
            $unicode = true;
        }

        // Loop through finding words
        $i = 0;
        $word_start = 0;
        $is_in_word = false;
        $word_starts_caps = false;
        while ($i < $len) {
            if ($unicode) { // Slower :(
                $current_char = cms_mb_substr($source, $i, 1);
                $is_word_char = isset($word_chars_flip[$current_char]) || cms_mb_strtolower($current_char) != cms_mb_strtoupper($current_char);

                if ($is_in_word) {
                    // Exiting word?
                    $is_exiting_word = false;
                    if ((!$codename) && (!$is_word_char) && (/*Not space-separated*/($current_char != ' ') || (/*Current word not starting with Caps*/!$word_starts_caps) || (/*Next word not starting with Caps*/cms_mb_strtolower(substr($source, $i + 1, 1)) == substr($source, $i + 1, 1)))) { // End of apparent word and not a space-separated Proper Noun
                        $is_exiting_word = true;
                    } elseif ($i == $len - 1) { // End of string; we don't look for outstanding words at the end of the loop so we have to trigger $is_exiting_word early
                        $is_exiting_word = true;
                        $i++; // This is the last character, so we need to move the cursor past it
                    }
                    if ($is_exiting_word) {
                        $this_word = cms_mb_substr($source, $word_start, $i - $word_start);

                        // Strip off any special characters we may have allowed to be inside words from the end of the word
                        while ((cms_mb_strlen($this_word) != 0) && (cms_mb_substr($this_word, -1) == '\'' || cms_mb_substr($this_word, -1) == '-' || cms_mb_substr($this_word, -1) == '.')) {
                            $this_word = cms_mb_substr($this_word, 0, cms_mb_strlen($this_word) - 1);
                        }

                        // If word is long enough, we might use it
                        if (($i - $word_start) >= $min_word_length) {
                            // If word is not a stop word, we might use it
                            if (!isset($common_words_flip[cms_mb_strtolower($this_word)])) {
                                // We store the word, either as one we might use, or one we must use, and we store how many occurrences it had
                                if (!isset($keywords_might_use[$this_word])) {
                                    $keywords_might_use[$this_word] = 0;
                                }
                                if ($must_use) {
                                    $keywords_must_use[$this_word]++;
                                } else {
                                    $keywords_might_use[$this_word]++;
                                }
                            }
                        }
                        $is_in_word = false;
                    } else {
                        $this_word .= $current_char;
                    }
                } else {
                    // Entering word?
                    if (($is_word_char) && ($current_char != '\'') && ($current_char != '-') && ($current_char != '.')/*Special latin cases, cannot start a word with a symbol*/) {
                        $word_starts_caps = (cms_mb_strtolower($current_char) != $current_char);
                        $word_start = $i;
                        $is_in_word = true;
                        $this_word = $current_char;
                    }
                }
            } else {
                $current_char = $source[$i];
                $is_word_char = isset($word_chars_flip[$current_char]);

                if ($is_in_word) {
                    // Exiting word?
                    $is_exiting_word = false;
                    if ((!$codename) && (!$is_word_char) && (/*Not space-separated*/($current_char != ' ') || (/*Current word not starting with Caps*/!$word_starts_caps) || (/*Next word not starting with Caps*/cms_mb_strtolower(substr($source, $i + 1, 1)) == substr($source, $i + 1, 1)))) { // End of apparent word and not a space-separated Proper Noun
                        $is_exiting_word = true;
                    } elseif ($i == $len - 1) { // End of string; we don't look for outstanding words at the end of the loop so we have to trigger $is_exiting_word early
                        $is_exiting_word = true;
                        $i++; // This is the last character, so we need to move the cursor past it
                    }
                    if ($is_exiting_word) {
                        $this_word = substr($source, $word_start, $i - $word_start);

                        // Strip off any special characters we may have allowed to be inside words from the end of the word
                        while ((strlen($this_word) != 0) && (substr($this_word, -1) == '\'' || substr($this_word, -1) == '-' || substr($this_word, -1) == '.')) {
                            $this_word = substr($this_word, 0, strlen($this_word) - 1);
                        }

                        // If word is long enough, we might use it
                        if (($i - $word_start) >= $min_word_length) {
                            // If word is not a stop word, we might use it
                            if (!isset($common_words_flip[cms_mb_strtolower($this_word)])) {
                                // We store the word, either as one we might use, or one we must use, and we store how many occurrences it had
                                if (!isset($keywords_might_use[$this_word])) {
                                    $keywords_might_use[$this_word] = 0;
                                }
                                if ($must_use) {
                                    $keywords_must_use[$this_word]++;
                                } else {
                                    $keywords_might_use[$this_word]++;
                                }
                            }
                        }
                        $is_in_word = false;
                    }
                } else {
                    // Entering word?
                    if ($is_word_char) {
                        $word_starts_caps = (cms_mb_strtolower($current_char) != $current_char);
                        $word_start = $i;
                        $is_in_word = true;
                    }
                }
            }
            $i++;
        }
    }

    // Put most common ones first
    cms_mb_arsort($keywords_must_use, SORT_NATURAL | SORT_FLAG_CASE);
    cms_mb_arsort($keywords_might_use, SORT_NATURAL | SORT_FLAG_CASE);

    // Put together keywords (in priority and frequency order, not alphabetical)
    $i = 0;
    $_keywords = [];
    foreach (array_keys($keywords_must_use) as $keyword) {
        $_keywords[] = $keyword;
        $i++;
    }
    foreach (array_keys($keywords_might_use) as $keyword) {
        // Too many keywords already
        if ($i == 10) {
            break;
        }

        $keyword_lower = cms_mb_strtolower($keyword);
        if (!isset($_keywords[$keyword_lower])) {
            $_keywords[$keyword_lower] = [];
        }
        $_keywords[$keyword_lower][] = $keyword;

        $i++;
    }
    $keywords = '';
    foreach ($_keywords as $keyword_lower => $variants) {
        if ($keywords != '') {
            $keywords .= ',';
        }
        if (count($variants) == 1) {
            $keywords .= $variants[0];
        } else {
            $keywords .= $keyword_lower; // Different cases, so take lower case
        }
    }

    // Tidy up descriptions...

    require_code('xhtml');
    $description = strip_comcode($description, true);
    $description = trim(preg_replace('#\n(-+|=+)(\n|$)#', ":$2", $description));
    $description = trim(cms_preg_replace_safe('#\s+---+\s+#', ' ', $description));
    $description = preg_replace('#\n+#', ' ', $description);

    if (cms_mb_strlen($description) > 160) {
        if (get_charset() == 'utf-8') {
            $description = cms_mb_substr($description, 0, 159);
            $description .= "\u{2026}";
        } else {
            $description = cms_mb_substr($description, 0, 157);
            $description .= '...';
        }
    }

    // ---

    return [$keywords, $description];
}

/**
 * Sets the meta information for the specified resource, by auto-summarisation from the given parameters.
 *
 * @param  ID_TEXT $type The type of resource (e.g. download)
 * @param  ID_TEXT $id The ID of the resource
 * @param  array $keyword_sources Array of content strings to summarise from
 * @param  SHORT_TEXT $description The description to use
 * @return SHORT_TEXT Keyword string generated (it's also saved in the DB, so usually you won't want to collect this)
 */
function seo_meta_set_for_implicit(string $type, string $id, array $keyword_sources, string $description) : string
{
    if ((post_param_string('meta_keywords', null) !== null) && ((post_param_string('meta_keywords') != '') || (post_param_string('meta_description') != ''))) {
        seo_meta_set_for_explicit($type, $id, post_param_string('meta_keywords'), post_param_string('meta_description'));
        return '';
    }

    if (get_option('automatic_meta_extraction') == '0') {
        return '';
    }

    list($imp, $description) = _seo_meta_find_data($keyword_sources, $description);

    seo_meta_set_for_explicit($type, $id, $imp, $description);

    if (function_exists('delete_cache_entry')) {
        delete_cache_entry('side_tag_cloud');
    }

    return $imp;
}

/**
 * Find if some predefined content is installed.
 *
 * @param  string $addon Addon to do for
 * @param  string $codename Predefined content codename
 * @return boolean Whether it is
 */
function has_predefined_content(string $addon, string $codename) : bool
{
    $enumerated = enumerate_predefined_content($addon);
    return $enumerated[$codename]['installed'];
}

/**
 * Find available predefined content, and what is installed.
 *
 * @param  string $addon Addon to do for
 * @return array A map of available predefined content codenames, and details (if installed, and title)
 */
function enumerate_predefined_content(string $addon) : array
{
    static $ret = [];
    if (!array_key_exists($addon, $ret)) {
        require_code('hooks/systems/addon_registry/' . filter_naughty($addon));
        $ob = object_factory('Hook_addon_registry_' . $addon);
        $ret[$addon] = $ob->enumerate_predefined_content();
    }

    return $ret[$addon];
}

/**
 * Install/uninstall predefined content.
 *
 * @param  string $addon Addon to do for
 * @param  ?array $content A map of predefined content labels to install, codename to installation state (null: install all)
 */
function install_predefined_content(string $addon, ?array $content = null)
{
    require_code('hooks/systems/addon_registry/' . filter_naughty($addon));
    $ob = object_factory('Hook_addon_registry_' . $addon);

    if ($content === null) {
        $ob->install_predefined_content();
    } else {
        $install = [];
        $uninstall = [];
        foreach ($content as $codename => $intended) {
            if ($intended) {
                $install[] = $codename;
            } else {
                $uninstall[] = $codename;
            }
        }

        $ob->install_predefined_content($install);
        $ob->uninstall_predefined_content($uninstall);
    }
}

/**
 * Generate a UI for predefined content installation/uninstallation.
 *
 * @param  string $addon Addon to do for
 * @param  Tempcode $title Screen title
 * @param  Tempcode $url POST URL
 * @param  array $skip List of predefined content codenames to skip
 * @param  ?array $only List of predefined content codenames to limit to (null: no limit)
 * @return Tempcode UI
 */
function predefined_content_changes_ui(string $addon, object $title, object $url, array $skip = [], ?array $only = null) : object
{
    check_privilege('mass_import');

    require_code('content2');
    $enumerated = enumerate_predefined_content($addon);

    require_code('templates_columned_table');
    $header_row = columned_table_header_row([
        do_lang_tempcode('TITLE'),
        do_lang_tempcode('DESCRIPTION'),
        do_lang_tempcode('CHOOSE'),
    ]);

    $rows = new Tempcode();
    foreach ($enumerated as $codename => $details) {
        if (in_array($codename, $skip)) {
            continue;
        }
        if (($only !== null) && (!in_array($codename, $only))) {
            continue;
        }

        $choose_action = do_template('COLUMNED_TABLE_ROW_CELL_TICK', [
            '_GUID' => 'c355b82d286c3f10180b8a0ecddf070g',
            'LABEL' => do_lang_tempcode('CHOOSE'),
            'NAME' => 'select__' . $codename,
            'VALUE' => '1',
            'HIDDEN' => '',
            'TICKED' => $details['installed'],
        ]);

        $rows->attach(columned_table_row([
            $details['title'],
            $details['description'],
            $choose_action,
        ], false));
    }

    $table = do_template('COLUMNED_TABLE', ['_GUID' => 'b5765aca9ffe84242ca2c9d17f5ec0a7', 'HEADER_ROW' => $header_row, 'ROWS' => $rows, 'NONRESPONSIVE' => false]);

    return do_template('COLUMNED_TABLE_SCREEN', [
        '_GUID' => 'ddfa0fb6ea396d3b57cb447bc228a886',
        'TITLE' => $title,
        'TEXT' => do_lang_tempcode('PREDEFINED_CONTENT_DESCRIPTION'),
        'TABLE' => $table,
        'SUBMIT_ICON' => 'buttons/save',
        'SUBMIT_NAME' => do_lang_tempcode('PROCEED'),
        'POST_URL' => $url,
        'JS_FUNCTION_CALLS' => [],
    ]);
}

/**
 * Actualiser for predefined content installation/uninstallation.
 *
 * @param  string $addon Addon to do for
 * @param  Tempcode $title Screen title
 * @param  array $skip List of predefined content codenames to skip
 * @param  ?array $only List of predefined content codenames to limit to (null: no limit)
 * @return Tempcode UI
 */
function predefined_content_changes_actualiser(string $addon, object $title, array $skip = [], ?array $only = null) : object
{
    check_privilege('mass_import');

    $enumerated = enumerate_predefined_content($addon);

    $content = [];
    foreach (array_keys($enumerated) as $codename) {
        if (in_array($codename, $skip)) {
            continue;
        }
        if (($only !== null) && (!in_array($codename, $only))) {
            continue;
        }

        $content[$codename] = (post_param_integer('select__' . $codename, 0) == 1);
    }
    install_predefined_content($addon, $content);

    return inform_screen($title, do_lang_tempcode('SUCCESS'));
}
