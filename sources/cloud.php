<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2021

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */


/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__cloud()
{
    define('CMS_CLOUD__LOCAL', 1); // Unchanging file hosted on each machine (may be changed by Git of course).
    define('CMS_CLOUD__PROPAGATED', 2); // Copied to all machines via a sync queue (the propagation_dirs & propagation_files tables). Fast local access, but a delay propagating and more local disk space use.
    define('CMS_CLOUD__REMOTE', 3); // Hosted on e.g. a NAS, via a NFS share. Slower access, but always in sync and better for large amounts of data.

    // Regexps specifying where normal Composr file paths will be routed to.
    // Should be in precedence order (for performance reasons).
    // Nothing used in early boot (pre-database connection) should use CMS_CLOUD__REMOTE.
    // Override cloud.php and this data to change the configuration. Addons can add to this global themselves if needed.
    global $CMS_CLOUD_BINDINGS;
    $CMS_CLOUD_BINDINGS = [
        '#^data_custom/errorlog\.php$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/[^/]*\.log$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/modules/admin_backup(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/modules/user_export(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/sitemaps(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/spelling(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/xml_config(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^exports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^imports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^lang_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^[^/]*/pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^text_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/css_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/images_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/javascript_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/templates_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^uploads(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^.*$#' => CMS_CLOUD__LOCAL,
    ];

    global $SITE_INFO;
    if (empty($SITE_INFO['nas_directory'])) {
        $SITE_INFO['nas_directory'] = '../shared_storage';
    }
}

/**
 * Enable the cloud file system.
 */
function enable_cloud_fs()
{
    stream_wrapper_register('cloudfs', 'CloudFsStreamWrapper');

    global $FILE_BASE, $FILE_BASE_LOCAL;
    $FILE_BASE_LOCAL = $FILE_BASE;
    $FILE_BASE = 'cmsCloud://';
}

/**
 * A filesystem wrapper that adds some additional restrictions,
 * so that this runs as a common denominator of any file system's limitations.
 * Useful if developing on Mac/Windows with an SSD!
 *
 * @package core
 */
class CloudFsStreamWrapper
{
    public $context = null;

    /**
     * Construct our wrapper.
     */
    public function __construct()
    {
    }

    /**
     * Deconstruct our wrapper.
     */
    public function __destruct()
    {
    }

    /**
     * Resolve a path to the correct local path and find the storage type.
     *
     * @param  string $path Path
     * @return boolean The storage type, a CMS_CLOUD__* constant
     */
    protected function resolve_storage(string &$path) : bool
    {
        global $CMS_CLOUD_BINDINGS, $FILE_BASE_LOCAL, $SITE_INFO;

        //$path = preg_replace('#^.*://#U', $path); The more-correct way, but too slow
        $path = substr($path, 10); // Strips "cloudfs://"

        $root = (($path == '') || ($path == '/'));

        $storage_type = CMS_CLOUD__LOCAL;
        if (!$root) {
            foreach ($CMS_CLOUD_BINDINGS as $regexp => $_storage_type) {
                if (preg_match($regexp, $path) != 0) {
                    $storage_type = $_storage_type;
                    break;
                }
            }
        }

        switch ($storage_type) {
            case CMS_CLOUD__PROPAGATED:
            case CMS_CLOUD__LOCAL:
                if ($root) {
                    $path = $FILE_BASE_LOCAL;
                } else {
                    $path = $FILE_BASE_LOCAL . '/' . $path;
                }
                break;

            case CMS_CLOUD__REMOTE:
                $nas_directory = $SITE_INFO['nas_directory'];
                if (substr($nas_directory, 0, 1) == '/') || ((strpos(PHP_OS, 'WIN') !== false) && (substr($nas_directory, 1, 2) == ':/')) {
                    $path = $nas_directory . '/' . $path;
                } else {
                    $path = $FILE_BASE_LOCAL . '/' . $nas_directory . '/' . $path;
                }
                break;
        }

        return $storage_type;
    }

    /**
     * Detail a file for propagation across all servers.
     *
     * @param  string $op_type Operation type
     * @set create touch move delete
     * @param  PATH $path The path
     * @param  ?integer $perms The Unix file permissions (null: N/A)
     * @param  string $data The property value
     */
    protected function inject_propagation_dir($op_type, $path, $perms = null, $data = '')
    {
        // Clean up any contradictions/prior-bloat first
        if ($op_type != 'move') {
            $GLOBALS['SITE_DB']->query_delete('cloud_propagation_dirs', [
                'op_type' => $op_type,
                'dir_path' => $path,
            ]);
        }

        $GLOBALS['SITE_DB']->query_insert('cloud_propagation_dirs', [
            'op_type' => $op_type,
            'op_timestamp' => time(),
            'dir_path' => $path,
            'dir_perms' => $perms,
            'op_data' => $data,
            'op_originating_host' => gethostname(),
        ]);
    }

    /**
     * Detail a file for propagation across all servers.
     *
     * @param  string $op_type Operation type
     * @set create touch move delete
     * @param  PATH $path The path
     * @param  ?TIME $mtime The modification time (null: N/A)
     * @param  ?integer $perms The Unix file permissions (null: N/A)
     * @param  string $data The base64-encoded file contents / property value
     */
    protected function inject_propagation_file($op_type, $path, $mtime = null, $perms = null, $data = '')
    {
        // Clean up any contradictions/prior-bloat first
        if ($op_type != 'move') {
            $GLOBALS['SITE_DB']->query_delete('cloud_propagation_files', [
                'op_type' => $op_type,
                'dir_path' => $path,
            ]);
        }

        $GLOBALS['SITE_DB']->query_insert('cloud_propagation_files', [
            'op_type' => $op_type,
            'op_timestamp' => time(),
            'file_path' => $path,
            'file_mtime' => $mtime,
            'file_perms' => $perms,
            'op_data' => $data,
            'op_originating_host' => gethostname(),
        ]);
    }

    /* Directory operations */

    protected $directory_handle = false;

    /**
     * Open a directory for analysis.
     *
     * @param  PATH $path The path to the directory to open
     * @param  boolean $options Bitmask options
     * @return boolean Success status
     */
    public function dir_opendir(string $path, bool $options) : bool
    {
        global $FILE_BASE_LOCAL;

        $this->resolve_storage($path);

        $this->directory_handle = opendir($FILE_BASE_LOCAL . '/' . $path, $this->context);
        return ($this->directory_handle !== false);
    }

    /**
     * Read entry from directory handle.
     *
     * @return ~string Next filename (false: error)
     */
    public function dir_readdir()
    {
        if ($this->directory_handle === false) {
            return false;
        }

        return readdir($this->directory_handle);
    }

    /**
     * Rewind directory handle.
     *
     * @return boolean Success status
     */
    public function dir_rewinddir() : bool
    {
        if ($this->directory_handle === false) {
            return false;
        }

        rewinddir($this->directory_handle);
        return true;
    }

    /**
     * Close directory handle.
     *
     * @return boolean Success status
     */
    public function dir_closedir() : bool
    {
        if ($this->directory_handle === false) {
            return false;
        }

        closedir($this->directory_handle);
        $this->directory_handle = false;
        return true;
    }

    /**
     * Makes a directory. {{creates-file}}
     *
     * @param  PATH $path The path to the directory to make
     * @param  integer $mode The mode (e.g. 0777)
     * @param  integer $options Bitmask options
     * @return boolean Success status
     */
    public function mkdir(string $path, int $mode, int $options) : bool
    {
        global $FILE_BASE_LOCAL;

        $storage_type = $this->resolve_storage($path);

        $ret = mkdir($FILE_BASE_LOCAL . '/' . $path, $mode, ($options & STREAM_MKDIR_RECURSIVE) != 0, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            $this->inject_propagation_dir('create', $path, $mode);
        }

        return $ret;
    }

    /**
     * Removes directory.
     *
     * @param  PATH $path Directory path
     * @param  boolean $options Bitmask options
     * @return boolean Success status
     */
    public function rmdir(string $path, bool $options) : bool
    {
        global $FILE_BASE_LOCAL;

        $storage_type = $this->resolve_storage($path);

        $ret = rmdir($FILE_BASE_LOCAL . '/' . $path, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            $this->inject_propagation_dir('delete', $path);
        }

        return $ret;
    }

    /* File operations */

    /**
     * Deletes a file.
     *
     * @param  PATH $path The file path
     * @return boolean Success status
     */
    public function unlink(string $path) : bool
    {
        global $FILE_BASE_LOCAL;

        $storage_type = $this->resolve_storage($path);

        $ret = unlink($FILE_BASE_LOCAL . '/' . $path, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            $this->inject_propagation_file('delete', $path);
        }

        return $ret;
    }

    /**
     * Gets information about a file.
     *
     * @param  PATH $path File path
     * @param  boolean $flags Bitmask options
     * @return ~array Map of status information (false: error)
     */
    public function url_stat(string $path, bool $flags)
    {
        global $FILE_BASE_LOCAL;

        $this->resolve_storage($path);

        return stat($FILE_BASE_LOCAL . '/' . $path);
    }

    protected $file_path = null;
    protected $file_handle = false;
    protected $file_is_new = null;

    /**
     * Opens file or URL. {{creates-file}}
     *
     * @param  PATH $path Filename
     * @param  string $mode Mode (e.g. at)
     * @param  integer $options Bitmask options
     * @param  string $opened_path The real path will be written into here, if requested
     * @return boolean Success status
     */
    public function stream_open(string $path, string $mode, int $options, string &$opened_path) : bool
    {
        global $FILE_BASE_LOCAL;

        $this->resolve_storage($path);

        $this->file_path = $path;
        $this->file_is_new = !is_file($path);
        $this->file_handle = fopen($FILE_BASE_LOCAL . '/' . $path, $mode, false, $this->context);

        return ($this->file_handle !== false);
    }

    /**
     * Binary-safe file read.
     *
     * @param  integer $count Maximum length to read
     * @return ~string The read data (false: error)
     */
    public function stream_read(int $count)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fread($this->file_handle, $count);
    }

    /**
     * Binary-safe file write.
     *
     * @param  string $data The string to write to the file
     * @return ~integer The number of bytes written (false: error)
     */
    public function stream_write(string $data)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fwrite($this->file_handle, $data);
    }

    /**
     * Truncates a file to a given length.
     *
     * @param  integer $new_size Cut off size
     * @return boolean Success status
     */
    public function stream_truncate(int $new_size) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftruncate($this->file_handle, $new_size);
    }

    /**
     * Seeks on a file pointer.
     *
     * @param  integer $offset The offset (meaning depends on whence)
     * @param  integer $whence SEEK_SET, SEEK_CUR or SEEK_END
     * @return boolean Success status
     */
    public function stream_seek(int $offset, int $whence = 0/*SEEK_SET*/) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return (fseek($this->file_handle, $offset, $whence) == 0);
    }

    /**
     * Gets file pointer read/write position.
     *
     * @return ~integer The offset (false: error)
     */
    public function stream_tell()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftell($this->file_handle);
    }

    /**
     * Tests for end-of-file on a file pointer.
     *
     * @return boolean Whether the end of the file has been reached
     */
    public function stream_eof() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return feof($this->file_handle);
    }

    /**
     * Flushes the output to a file.
     *
     * @return boolean Success status
     */
    public function stream_flush() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fflush($this->file_handle);
    }

    /**
     * Portable advisory file locking.
     *
     * @param  integer $operation Operation (LOCK_SH, LOCK_EX, LOCK_UN)
     * @return boolean Success status
     */
    public function stream_lock(int $operation) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return flock($this->file_handle, $operation);
    }

    /**
     * Change stream options.
     *
     * @param  integer $option Option being set
     * @param  integer $arg1 1st argument
     * @param  integer $arg2 2nd argument
     * @return boolean Success status
     */
    public function stream_set_option(int $option, int $arg1, int $arg2) : bool
    {
        return false;
    }

    /**
     * Gets information about a file using an open file pointer.
     *
     * @return ~array Map of status information (false: error)
     */
    public function stream_stat()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fstat($this->file_handle);
    }

    /**
     * Closes an open file pointer.
     *
     * @return boolean Success status
     */
    public function stream_close() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        global $FILE_BASE_LOCAL;

        $ret = fclose($this->file_handle);
        $this->file_handle = false;

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            $this->inject_propagation_file('create', $this->file_path, time(), fileperms($FILE_BASE_LOCAL . '/' . $this->file_path), base64_encode(file_get_contents($FILE_BASE_LOCAL . '/' . $this->file_path)));
        }

        return $ret;
    }

    /* File and Directory operations */

    /**
     * Renames a file.
     *
     * @param  PATH $path_from Old name
     * @param  PATH $path_to New name
     * @return boolean Success status
     */
    public function rename(string $path_from, string $path_to) : bool
    {
        global $FILE_BASE_LOCAL;

        $storage_type_from = $this->resolve_storage($path_from);
        $storage_type_to = $this->resolve_storage($path_to);

        $ret = rename($FILE_BASE_LOCAL . '/' . $path_from, $FILE_BASE_LOCAL . '/' . $path_to);

        if ($ret) {
            if (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    $this->inject_propagation_dir('move', $path_from, null, $path_to);
                } else {
                    $this->inject_propagation_file('move', $path_from, null, $path_to);
                }
            } elseif (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to != CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    $this->inject_propagation_dir('create', $path_to, fileperms($FILE_BASE_LOCAL . '/' . $path_to));
                } else {
                    $this->inject_propagation_file('create', $path_to, filemtime($FILE_BASE_LOCAL . '/' . $path_to), fileperms($FILE_BASE_LOCAL . '/' . $path_to), base64_encode(file_get_contents($FILE_BASE_LOCAL . '/' . $path_to)));
                }
            } elseif (($storage_type_from != CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    $this->inject_propagation_dir('delete', $path_from);
                } else {
                    $this->inject_propagation_file('delete', $path_to);
                }
            }
        }

        return $ret;
    }

    /**
     * Set metadata on a file.
     *
     * @param  PATH $path Path
     * @param  integer $option What to set on
     * @param  mixed $value Value to set
     * @return boolean Success status
     */
    public function stream_metadata(string $path, int $option, $value) : bool
    {
        global $FILE_BASE_LOCAL;

        $storage_type = $this->resolve_storage($path);

        $ret = false;
        switch ($option) {
            case STREAM_META_TOUCH:
                $ret = touch($FILE_BASE_LOCAL . '/' . $path, $value);
                return $ret;

            case STREAM_META_OWNER_NAME:
            case STREAM_META_OWNER:
                if (php_function_allowed('chown')) {
                    $ret = chown($FILE_BASE_LOCAL . '/' . $path, $value);
                }
                break;

            case STREAM_META_GROUP_NAME:
            case STREAM_META_GROUP:
                if (php_function_allowed('chgrp')) {
                    $ret = chgrp($FILE_BASE_LOCAL . '/' . $path, $value);
                }
                break;

            case STREAM_META_ACCESS:
                $ret = chmod($FILE_BASE_LOCAL . '/' . $path, $value);
                break;
        }

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            if (is_dir($FILE_BASE_LOCAL . '/' . $path)) {
                $this->inject_propagation_dir('touch', $path, fileperms($FILE_BASE_LOCAL . '/' . $path));
            } else {
                $this->inject_propagation_file('touch', $path, filemtime($FILE_BASE_LOCAL . '/' . $path), fileperms($FILE_BASE_LOCAL . '/' . $path));
            }
        }

        return $ret;
    }
}
