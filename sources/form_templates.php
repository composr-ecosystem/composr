<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_form_interfaces
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__form_templates()
{
    require_javascript('checking');
    require_javascript('editing');

    global $WYSIWYG_ATTACHED;
    $WYSIWYG_ATTACHED = false;

    global $BLOCK_EXTRA_POSTING_FIELDS;
    $BLOCK_EXTRA_POSTING_FIELDS = false; // Used to signal that there's a main posting form, so we can't allow extra custom posting form fields

    global $TABINDEX;
    $TABINDEX = 50; // Base

    global $NO_DEV_MODE_FULLSTOP_CHECK;
    $NO_DEV_MODE_FULLSTOP_CHECK = false;

    require_code('input_filter');

    global $DOING_ALTERNATE_FIELDS_SET;
    $DOING_ALTERNATE_FIELDS_SET = null;

    // This is a hackerish way to chain raw field inputs together
    global $_FORM_INPUT_PREFIX, $_FORM_INPUT_SUFFIX;
    $_FORM_INPUT_PREFIX = null;
    $_FORM_INPUT_SUFFIX = null;

    global $SKIPPING_LABELS;
    $SKIPPING_LABELS = false;

    require_css('forms');

    if (function_exists('get_member')) {
        if ((has_privilege(get_member(), 'allow_html')) && (get_value('edit_with_my_comcode_perms') === '1') && ((strpos(get_param_string('type', ''), 'edit') !== false) || (strpos(get_param_string('type', ''), 'edit_category') !== false))) {
            attach_message('You have enabled content editing to assume your permissions via a hidden option. Be VERY careful to check whatever Comcode/HTML you edit.', 'warn');
        }
    }

    if (function_exists('set_no_clickjacking_csp')) {
        set_no_clickjacking_csp();
    }
}

/**
 * Read a multi code from a named parameter stub.
 *
 * @param  ID_TEXT $param The parameter stub (stub of a series of POST parameters, made by cns_get_forum_multi_code_field's field or similar)
 * @return SHORT_TEXT The multi code
 */
function read_multi_code($param)
{
    $type = post_param_string($param);
    if ($type == '*') {
        return $type;
    }
    if (!array_key_exists($param . '_list', $_POST)) {
        return '';
    }
    $in = implode(',', $_POST[$param . '_list']);
    return $type . $in;
}

/**
 * Ensure Suhosin is not going to break a request due to number of request form fields. Call this each time a field is added to the output.
 *
 * @param  integer $inc How much to increment the counter by
 * @param  integer $name_length The name length being checked
 */
function check_suhosin_request_quantity($inc = 1, $name_length = 0)
{
    static $count = 0;
    $count += $inc;

    static $failed_already = false;
    if ($failed_already) {
        return;
    }

    static $max_values = null;
    if ($max_values === null) {
        $max_values = array();
        foreach (array('max_input_vars', 'suhosin.post.max_vars', 'suhosin.request.max_vars') as $setting) {
            if (@is_numeric(ini_get($setting))) {
                $max_values[$setting] = intval(ini_get($setting));
            }
        }
    }
    foreach ($max_values as $setting => $max_value) {
        if ($max_value < $count) {
            global $MODSECURITY_WORKAROUND_ENABLED;
            if (!$MODSECURITY_WORKAROUND_ENABLED) {
                attach_message(do_lang_tempcode('SUHOSIN_MAX_VARS_TOO_LOW', escape_html($setting)), 'warn', false, true);
            }
            $failed_already = true;
        }
    }

    static $max_length_values = null;
    if ($max_length_values === null) {
        $max_length_values = array();
        foreach (array('suhosin.post.max_name_length', 'suhosin.request.max_name_length', 'suhosin.post.max_totalname_length', 'suhosin.request.max_totalname_length') as $setting) {
            if (@is_numeric(ini_get($setting))) {
                $max_length_values[$setting] = intval(ini_get($setting));
            }
        }
    }
    foreach ($max_length_values as $setting => $max_length_value) {
        if ($max_length_value < $name_length) {
            attach_message(do_lang_tempcode('SUHOSIN_MAX_VARS_TOO_LOW', escape_html($setting)), 'warn', false, true);
            $failed_already = true;
        }
    }
}

/**
 * Ensure Suhosin is not going to break a request due to request size.
 *
 * @param  integer $size Most determinative size within wider request size (we'll assume we actually need 500 more bytes than this)
 */
function check_suhosin_request_size($size)
{
    foreach (array('suhosin.request.max_value_length', 'suhosin.post.max_value_length') as $setting) {
        if ((@is_numeric(ini_get($setting))) && (intval(ini_get($setting)) - 500 < $size)) {
            attach_message(do_lang_tempcode('SUHOSIN_MAX_VALUE_TOO_SHORT', escape_html($setting)), 'warn', false, true);
        }
    }
}

/**
 * Enable reading in default parameters from the GET environment. This is typically called before 'add' forms.
 */
function url_default_parameters__enable()
{
    global $URL_DEFAULT_PARAMETERS_ENABLED;
    $URL_DEFAULT_PARAMETERS_ENABLED = true;
}

/**
 * Disable reading in default parameters from the GET environment. This is typically called after 'add' forms.
 */
function url_default_parameters__disable()
{
    global $URL_DEFAULT_PARAMETERS_ENABLED;
    $URL_DEFAULT_PARAMETERS_ENABLED = false;
}

/**
 * Find a default property, defaulting to the average of what is there already, or the given default if really necessary.
 *
 * @param  ?integer $setting The current setting (null: we have to work it out); if non-null, the function will immediately return
 * @param  ID_TEXT $db_property The property
 * @param  ID_TEXT $table The table to average within
 * @param  integer $default The last-resort default
 * @return integer The value
 */
function take_param_int_modeavg($setting, $db_property, $table, $default)
{
    if ($setting !== null) {
        return $setting;
    }

    if (running_script('install')) {
        return $default;
    }

    $db = get_db_for($table);
    $val = $db->query_value_if_there('SELECT ' . $db_property . ',count(' . $db_property . ') AS qty FROM ' . $db->get_table_prefix() . $table . ' GROUP BY ' . $db_property . ' ORDER BY qty DESC', false, true); // We need the mode here, not the mean
    if ($val !== null) {
        return $val;
    }

    return $default;
}

/**
 * Attach the WYSIWYG editor.
 */
function attach_wysiwyg()
{
    // Force-disable CSP as CKEditor doesn't yet support CSP
    load_csp(array('csp_enabled' => '0')); // TODO: Remove once CKEditor supports CSP (#651)

    global $WYSIWYG_ATTACHED;
    if (!$WYSIWYG_ATTACHED) {
        require_code('site');
        attach_to_javascript(do_template('WYSIWYG_LOAD'));
    }
    $WYSIWYG_ATTACHED = true;
}

/**
 * Insert hidden data for the maximum file size of form fields.
 *
 * @param  Tempcode $hidden Hidden fields
 * @param  ID_TEXT $regular_max_size_type Code representing the media types we are using limits for
 * @set image file
 */
function handle_max_file_size(&$hidden, $regular_max_size_type = 'file')
{
    require_code('files2');
    switch ($regular_max_size_type) {
        case 'image':
            require_code('images');
            $regular_max_size = get_max_image_size();
            break;
        case 'file':
        default:
            $regular_max_size = get_max_file_size();
            break;
    }
    $hidden->attach(form_input_hidden('MAX_FILE_SIZE', strval($regular_max_size)));
}

/**
 * Get what we need to get attachments in a form-field interface.
 *
 * @param  ID_TEXT $posting_field_name The name of the field attachments are for
 * @param  boolean $true_attachment_ui Include a true attachment UI (as opposed to something say on a contact form)
 * @return array A pair: the attachments UI (Tempcode), the hidden attachment field
 */
function get_attachments($posting_field_name, $true_attachment_ui = true)
{
    $image_types = str_replace(',', ', ', get_option('valid_images'));

    require_lang('comcode');
    require_javascript('plupload');
    require_css('widget_plupload');
    require_javascript('editing');
    require_javascript('checking');
    require_javascript('posting');

    require_code('upload_syndication');
    list($syndication_json, $filter) = get_upload_syndication_json(CMS_UPLOAD_ANYTHING);

    if (get_forum_type() == 'cns') {
        require_code('cns_groups');
        require_lang('cns');
        $max_attachments = cns_get_member_best_group_property(get_member(), 'max_attachments_per_post');
    } else {
        $max_attachments = 100;
    }
    if ($max_attachments == 0) {
        return array(new Tempcode(), new Tempcode());
    }

    require_code('files2');
    $max_attach_size = get_max_file_size(($syndication_json === null) ? get_member() : null, $GLOBALS['SITE_DB']);
    $no_quota = ((get_forum_type() == 'cns') && (cns_get_member_best_group_property(get_member(), 'max_daily_upload_mb') == 0));
    if ($no_quota) {
        if ($syndication_json === null) {
            return array(new Tempcode(), new Tempcode());
        }
    } else {
        $filter = null;
    }
    $attach_size_field = form_input_hidden('MAX_FILE_SIZE', strval($max_attach_size));

    $num_attachments = post_param_integer('num_attachments', 1);

    $attachments = new Tempcode();
    for ($i = 1; $i <= $num_attachments; $i++) {
        $attachments->attach(do_template('ATTACHMENT', array(
            '_GUID' => 'c3b38ca70cbd1c5f9cf91bcae9ed1134',
            'POSTING_FIELD_NAME' => $posting_field_name,
            'I' => strval($i),
            'SYNDICATION_JSON' => $syndication_json,
            'NO_QUOTA' => $no_quota,
            'FILTER' => $filter,
            'TRUE_ATTACHMENT_UI' => $true_attachment_ui,
        )));
    }

    $attachment_template = do_template('ATTACHMENT', array(
        '_GUID' => 'c3b38ca70cbd1c5f9cf91bcae9ed11ds',
        'POSTING_FIELD_NAME' => $posting_field_name,
        'I' => '__num_attachments__',
        'SYNDICATION_JSON' => $syndication_json,
        'NO_QUOTA' => $no_quota,
        'FILTER' => $filter,
        'TRUE_ATTACHMENT_UI' => $true_attachment_ui,
    ));
    $attachments = do_template('ATTACHMENTS', array(
        '_GUID' => '054921e7c09412be479676759accf222',
        'POSTING_FIELD_NAME' => $posting_field_name,
        'ATTACHMENT_TEMPLATE' => $attachment_template,
        'IMAGE_TYPES' => $image_types,
        'ATTACHMENTS' => $attachments,
        'MAX_ATTACHMENTS' => strval($max_attachments),
        'NUM_ATTACHMENTS' => strval($num_attachments),
        'TRUE_ATTACHMENT_UI' => $true_attachment_ui,
        'FILTER' => $filter,
    ));

    return array($attachments, $attach_size_field);
}

/**
 * Creates a posting form, with attachment support.
 *
 * @param  mixed $submit_name The title of the form submission button
 * @param  ID_TEXT $submit_icon The submit icon CSS class
 * @param  LONG_TEXT $post The default post to put in
 * @param  mixed $post_url Where the form is sent (URLPATH or Tempcode)
 * @param  Tempcode $hidden_fields A form_input_hidden buildup of hidden fields (additional parameters sent to the target URL)
 * @param  Tempcode $specialisation A buildup of leading extra fields, in a format compatible with the templates used by this function
 * @param  ?mixed $post_comment The post comment (string or Tempcode). This gives information about how you should post. (null: no post comment)
 * @param  string $extra Extra info to put on the posting form
 * @param  ?Tempcode $specialisation2 A buildup of trailing extra fields, in a format compatible with the templates used by this function. (null: none)
 * @param  ?Tempcode $default_parsed The parsed Comcode. (null: calculate)
 * @param  array $js_function_calls JavaScript functions to execute
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $required Whether this is a required input field
 * @param  boolean $has_preview Whether the form supports previewing
 * @param  boolean $support_wysiwyg Whether to support WYSIWYG mode
 * @param  boolean $support_autosave Whether to support auto-save
 * @param  boolean $specialisation2_hidden Whether to hide trailing extra fields
 * @param  mixed $description A description for this input field
 * @param  ?Tempcode $cancel_url Cancel URL for cancelling auto-save (null: no cancel button)
 * @return Tempcode The posting form
 */
function get_posting_form($submit_name, $submit_icon, $post, $post_url, $hidden_fields, $specialisation, $post_comment = null, $extra = '', $specialisation2 = null, $default_parsed = null, $js_function_calls = array(), $tabindex = null, $required = true, $has_preview = true, $support_wysiwyg = true, $support_autosave = true, $specialisation2_hidden = false, $description = '', $cancel_url = null)
{
    require_javascript('posting');
    require_javascript('plupload');
    require_css('widget_plupload');

    require_lang('comcode');

    handle_default_comcode_text($post);

    $tabindex = get_form_field_tabindex($tabindex);

    $post = filter_form_field_default(is_object($submit_name) ? $submit_name->evaluate() : $submit_name, $post);

    require_code('comcode_cleanup');
    $comcode_page_hints = comcode_page_hints_ui('post', $post);

    $required = filter_form_field_required('post', $required);

    check_suhosin_request_size(strlen($post));

    if ($post_comment === null) {
        $post_comment = do_lang_tempcode('POST_COMMENT');
    }
    if ($specialisation2 === null) {
        $specialisation2 = new Tempcode();
    }

    list($attachments, $attach_size_field) = get_attachments('post');

    $hidden_fields->attach($attach_size_field);

    $continue_url = get_self_url();

    $help_zone = get_comcode_zone('userguide_comcode', false);

    $emoticon_chooser = $GLOBALS['FORUM_DRIVER']->get_emoticon_chooser();

    $comcode_editor = get_comcode_editor('post', false, true);
    $comcode_editor_small = get_comcode_editor('post', true, true);

    $w = ($support_wysiwyg) && (browser_matches('wysiwyg', $post) && (strpos($post, '{$,page hint: no_wysiwyg}') === false));

    $class = '';
    attach_wysiwyg();
    if ($w) {
        $class .= ' wysiwyg';
    }

    push_lax_comcode(true);
    $GLOBALS['COMCODE_PARSE_URLS_CHECKED'] = 100; // FUDGE: Little hack to stop it checking any URLs
    /*Actually we reparse always to ensure it is done in semiparse mode if ($default_parsed === null) */
    $default_parsed = @comcode_to_tempcode($post, null, false, null, null, COMCODE_SEMIPARSE_MODE);
    pop_lax_comcode();

    global $MODSECURITY_WORKAROUND_ENABLED;

    return do_template('POSTING_FORM', array(
        '_GUID' => '41259424ca13c437d5bc523ce18980fe',
        'REQUIRED' => $required,
        'TABINDEX_PF' => strval($tabindex)/*not called TABINDEX due to conflict with FORM_STANDARD_END*/,
        'JS_FUNCTION_CALLS' => $js_function_calls,
        'PREVIEW' => $has_preview,
        'COMCODE_EDITOR' => $comcode_editor,
        'COMCODE_EDITOR_SMALL' => $comcode_editor_small,
        'CLASS' => $class,
        'COMCODE_URL' => ($help_zone === null) ? new Tempcode() : build_url(array('page' => 'userguide_comcode'), $help_zone),
        'EXTRA' => $extra,
        'POST_COMMENT' => $post_comment,
        'EMOTICON_CHOOSER' => $emoticon_chooser,
        'SUBMIT_ICON' => $submit_icon,
        'SUBMIT_NAME' => $submit_name,
        'HIDDEN_FIELDS' => $hidden_fields,
        'URL' => $post_url,
        'POST' => $post,
        'DEFAULT_PARSED' => $default_parsed,
        'CONTINUE_URL' => $continue_url,
        'ATTACHMENTS' => $attachments,
        'SPECIALISATION' => $specialisation,
        'SPECIALISATION2' => $specialisation2,
        'SPECIALISATION2_HIDDEN' => $specialisation2_hidden,
        'SUPPORT_AUTOSAVE' => $support_autosave,
        'CANCEL_URL' => $cancel_url,
        'DESCRIPTION' => $description,
        'MODSECURITY_WORKAROUND' => $MODSECURITY_WORKAROUND_ENABLED,
        'COMCODE_PAGE_HINTS' => $comcode_page_hints,
    ));
}

/**
 * Creates a Comcode editor.
 *
 * @param  string $field_name The name of the field the editor is working for
 * @param  boolean $cut_down Whether to make a cut-down version
 * @param  boolean $is_posting_field Whether this is for a posting field (i.e. has attachment support)
 * @return Tempcode The Comcode editor
 */
function get_comcode_editor($field_name = 'post', $cut_down = false, $is_posting_field = false)
{
    require_lang('comcode');

    $buttons = new Tempcode();
    $_buttons = array();

    // Non-wrappers
    if (!$cut_down) {
        $_buttons[] = (function_exists('imagetypes') ? 'thumb' : 'img');
    }
    if (has_privilege(get_member(), 'comcode_dangerous')) {
        $_buttons[] = 'block';
    }
    $_buttons[] = 'comcode';
    if (!$cut_down) {
        $_buttons[] = 'list'; // NB: list isn't actually a Comcode tag, it's a textcode syntax
    }

    // Links
    if (!$cut_down) {
        $_buttons[] = 'url';
    }
    if (has_zone_access(get_member(), 'adminzone')) {
        $_buttons[] = 'page';
    }
    //if (!$cut_down) $_buttons[]='email';   Not enough space anymore

    // Wrappers
    $_buttons[] = 'quote';
    if ((get_option('simplify_wysiwyg_by_permissions') == '0') || (has_privilege(get_member(), 'allow_html'))) {
        $_buttons[] = 'box';
    }
    $_buttons[] = 'code';
    if (has_privilege(get_member(), 'allow_html')) {
        if (!$cut_down) {
            $_buttons[] = 'html';
        }
    }
    foreach ($_buttons as $i => $button) {
        $divider = false;
        if (($button == 'url') || ($button == 'quote') || ($i == 0)) {
            $divider = true;
        }
        $buttons->attach(do_template('COMCODE_EDITOR_BUTTON', array(
            '_GUID' => 'e4fe3bc16cec070e06532fedc598d075',
            'DIVIDER' => $divider,
            'FIELD_NAME' => $field_name,
            'TITLE' => do_lang_tempcode('INPUT_COMCODE_' . $button),
            'B' => $button,
            'IS_POSTING_FIELD' => $is_posting_field,
        )));
    }

    $micro_buttons = new Tempcode();
    if (!$cut_down) {
        $_micro_buttons = array(
            array('t' => 'b'),
            array('t' => 'i'),
        );
        foreach ($_micro_buttons as $button) {
            $micro_buttons->attach(do_template('COMCODE_EDITOR_MICRO_BUTTON', array(
                '_GUID' => 'dbab001b3fa5480bb590ffed3ca81eaf',
                'FIELD_NAME' => $field_name,
                'TITLE' => do_lang_tempcode('INPUT_COMCODE_' . $button['t']),
                'B' => $button['t'],
                'IS_POSTING_FIELD' => $is_posting_field,
            )));
        }
    }
    return do_template('COMCODE_EDITOR', array(
        '_GUID' => 'ebff3145776a0441d115f2e4e13617d6',
        'POSTING_FIELD' => $field_name,
        'BUTTONS' => $buttons,
        'MICRO_BUTTONS' => $micro_buttons,
        'IS_POSTING_FIELD' => $is_posting_field,
    ));
}

/**
 * Find whether WYSIWYG is currently on.
 *
 * @param  ?string $default Comcode that might be WYSIWYG edited (null: none)
 * @return boolean Whether it is
 */
function wysiwyg_on($default = null)
{
    return ((browser_matches('wysiwyg', $default)) && ((!array_key_exists('use_wysiwyg', $_COOKIE)) || ($_COOKIE['use_wysiwyg'] != '0')));
}

/**
 * Find if a form field is required via fields.xml filters.
 *
 * @param  ID_TEXT $name The codename for this field
 * @param  boolean $required Whether it is required by default
 * @return boolean Whether it is required
 */
function filter_form_field_required($name, $required)
{
    if (!$required) {
        $minlength = get_field_restrict_property('minlength', $name);
        if ((!empty($minlength)) && (intval($minlength) > 0)) {
            $required = true;
        }
    }
    return $required;
}

/**
 * Get the value of a scoped field restriction property. Returns "first-found".
 *
 * @param  string $property The name of the property
 * @param  string $field The name of the field it's scoped for
 * @param  ?string $page The page name scoped for (null: current page)
 * @param  ?string $type The page type scoped for (null: current type)
 * @return ?string The property (null: non-existent)
 */
function get_field_restrict_property($property, $field, $page = null, $type = null)
{
    if ($page === null) {
        $page = get_page_name();
    }
    if ($type === null) {
        $type = get_param_string('type', post_param_string('type', 'browse'));
    }

    $restrictions = load_field_restrictions($page, $type);
    foreach ($restrictions as $_r => $_restrictions) {
        $_r_exp = explode(',', $_r);
        foreach ($_r_exp as $__r) {
            if (simulated_wildcard_match($field, trim($__r), true)) {
                foreach ($_restrictions as $bits) {
                    list($restriction, $attributes) = $bits;
                    if (strtolower($restriction) == strtolower($property)) {
                        return $bits[1]['embed'];
                    }
                }
            }
        }
    }
    return null;
}

/**
 * Get the Tempcode for a codename input line.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?integer $_maxlength The maximum length of the field (null: default 80)
 * @param  array $extra_chars List of extra characters to allow
 * @param  ?string $placeholder The placeholder value for this input field (null: none)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_codename($pretty_name, $description, $name, $default, $required, $tabindex = null, $_maxlength = 40, $extra_chars = array(), $placeholder = null, $autocomplete = null)
{
    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $maxlength = get_field_restrict_property('maxlength', $name);
    if (($maxlength === null) && ($_maxlength !== null)) {
        $maxlength = strval($_maxlength);
    }
    $input = do_template('FORM_SCREEN_INPUT_CODENAME', array(
        '_GUID' => '4b1a3a3ebe6ac85c7c14bcec9d8ab88d',
        'PLACEHOLDER' => $placeholder,
        'MAXLENGTH' => $maxlength,
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'EXTRA_CHARS' => $extra_chars,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a text input line (an <input type="text" ... />).
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?integer $_maxlength The maximum length of the field (null: default 255)
 * @param  string $type The input type
 * @param  ?string $placeholder The placeholder value for this input field (null: none)
 * @param  ?string $pattern Custom regex pattern (null: none)
 * @param  ?string $pattern_error Custom regex pattern validation error (null: none)
 * @param  ?integer $size How much space the list takes up (inline lists only) (null: default 27)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_line($pretty_name, $description, $name, $default, $required, $tabindex = null, $_maxlength = null, $type = 'text', $placeholder = null, $pattern = null, $pattern_error = null, $size = null, $autocomplete = null)
{
    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $maxlength = get_field_restrict_property('maxlength', $name);
    if (($maxlength === null) && ($_maxlength !== null)) {
        $maxlength = strval($_maxlength);
    }

    if ($size === null) {
        $size = 27;
    }

    $input = do_template('FORM_SCREEN_INPUT_LINE', array(
        '_GUID' => '02789c9af25cbc971e86bfcc0ad322d5',
        'PLACEHOLDER' => $placeholder,
        'MAXLENGTH' => $maxlength,
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'TYPE' => $type,
        'PATTERN' => $pattern,
        'SIZE' => strval($size),
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex, false, false, '', (($pattern_error === null) && ($pattern !== null)) ? strip_html($description->evaluate()) : $pattern_error);
}

/**
 * Get the Tempcode for a URL.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_url($pretty_name, $description, $name, $default, $required, $tabindex = null, $autocomplete = null)
{
    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    require_code('urls_simplifier');
    $coder_ob = new HarmlessURLCoder();
    $_default = $coder_ob->decode($default);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_URL', array(
        '_GUID' => '12789c9af25cbc971e86bfcc0ad322d5',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $_default,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a username input line.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  boolean $needs_match Whether it is required than a valid username is given
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_username($pretty_name, $description, $name, $default, $required, $needs_match = true, $tabindex = null, $autocomplete = null)
{
    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    require_javascript('ajax_people_lists');

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_USERNAME', array(
        '_GUID' => '591b5fe23f0cc0a4975a52d52aa5701e',
        'TABINDEX' => strval($tabindex),
        'NEEDS_MATCH' => $needs_match,
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex, $autocomplete);
}

/**
 * Get the Tempcode for a author/username input line.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_author($pretty_name, $description, $name, $default, $required, $tabindex = null, $autocomplete = null)
{
    if (!addon_installed('authors')) {
        return form_input_username($pretty_name, $description, $name, $default, $required, true, $tabindex, $autocomplete);
    }

    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    require_javascript('ajax_people_lists');

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_description = new Tempcode();
    $_description->attach($description);
    if (!$_description->is_empty()) {
        $_description->attach(do_template('FORM_DESCRIP_SEP'));
    }
    $keep = symbol_tempcode('KEEP');
    $extra = do_template('HYPERLINK_POPUP_WINDOW', array(
        '_GUID' => 'fb25dc4777a166c143a1bc32ff0c3239',
        'URL' => find_script('authors') . '?field_name=' . urlencode($name) . $keep->evaluate(),
        'TITLE' => do_lang_tempcode('AUTHOR'),
        'CAPTION' => do_lang_tempcode('BROWSE_SENTENCE'),
    ));
    $_description->attach($extra);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_AUTHOR', array(
        '_GUID' => '2662a51e494120078b4022915593e28a',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $_description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a e-mail-address input line.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_email($pretty_name, $description, $name, $default, $required, $tabindex = null, $autocomplete = null)
{
    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_EMAIL', array(
        '_GUID' => '2ff1d9e21894710b8f09598fd92049c7',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex, $autocomplete);
}

/**
 * Get the Tempcode for a colour input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_colour($pretty_name, $description, $name, $default, $required, $tabindex = null)
{
    if ($default === null) {
        $default = '';
    }

    if ($default == 'inherit') {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    return do_template('FORM_SCREEN_INPUT_COLOUR', array(
        '_GUID' => '9a1a8061cebd717ea98522984d9465af',
        'RAW_FIELD' => false,
        'REQUIRED' => $required,
        'PRETTY_NAME' => $pretty_name,
        'DESCRIPTION' => $description,
        'TABINDEX' => strval($tabindex),
        '_REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
    ));
}

/**
 * Get the Tempcode for a page-link input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?ID_TEXT $page_type Page type to show (null: all)
 * @param  boolean $get_title_too Whether to also get the title for the page
 * @return Tempcode The input field
 */
function form_input_page_link($pretty_name, $description, $name, $default, $required, $tabindex = null, $page_type = null, $get_title_too = false)
{
    require_lang('menus');

    require_javascript('tree_list');

    // Display
    $input = do_template('PAGE_LINK_CHOOSER', array(
        '_GUID' => 'aabbd8e80df919afe08ca70bd24578dc',
        'AS_FIELD' => true,
        'GET_TITLE_TOO' => $get_title_too,
        'NAME' => $name,
        'VALUE' => $default,
        'PAGE_TYPE' => $page_type,
    ));

    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex, false, true);
}

/**
 * Get the Tempcode for a Comcode-enabled text input line.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?string $default The default value for this input field (null: blank)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_line_comcode($pretty_name, $description, $name, $default, $required, $tabindex = null, $autocomplete = null)
{
    require_lang('comcode');

    if ($default === null) {
        $default = '';
    }

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_LINE', array(
        '_GUID' => 'b47034df1d68c1465d045fca822071a1',
        'MAXLENGTH' => get_field_restrict_property('maxlength', $name),
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'SIZE' => '40',
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, true, $tabindex);
}

/**
 * Get the Tempcode for a DHTML input field that takes multiple lines. A new line is added when the prior one isn't blank.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The base parameter name which this input field is for (as this takes multiple parameters, they are named <name><x>). This name must end with '_'.
 * @param  array $default_array An array of lines to use as default (at least this many lines, filled by this array, will be presented by default)
 * @param  integer $num_required The minimum number of inputs allowed
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  string $class CSS class for input
 * @set line email
 * @param  ?string $pattern Custom regex pattern (null: none)
 * @param  ?string $pattern_error Custom regex pattern validation error (null: none)
 * @return Tempcode The input field
 */
function form_input_line_multi($pretty_name, $description, $name, $default_array, $num_required, $tabindex = null, $class = 'line', $pattern = null, $pattern_error = null)
{
    if (substr($name, -1) != '_' && substr($name, -2) != '[]') {
        $name .= '_';
    }

    $tabindex = get_form_field_tabindex($tabindex);

    $default_array[0] = filter_form_field_default($name, array_key_exists(0, $default_array) ? $default_array[0] : '');
    if ($num_required == 0) {
        $required = filter_form_field_required($name, false);
        if ($required) {
            $num_required = 1;
        }
    }

    $input = new Tempcode();
    $i = 0;
    foreach ($default_array as $default) {
        $_required = ($i < $num_required) ? '-required' : '';
        $input->attach(do_template('FORM_SCREEN_INPUT_LINE_MULTI', array(
            '_GUID' => 'e2da34b7564cebfd83da2859e4abd020',
            'CLASS' => $class,
            'MAXLENGTH' => get_field_restrict_property('maxlength', $name),
            'PRETTY_NAME' => $pretty_name,
            'TABINDEX' => strval($tabindex),
            'NAME_STUB' => $name,
            'I' => strval($i),
            'REQUIRED' => $_required,
            'DEFAULT' => $default,
            'PATTERN' => $pattern,
        )));
        $i++;
    }
    $num_to_show_initially = max($num_required, count($default_array) + 1);
    for (; $i < $num_to_show_initially; $i++) {
        $input->attach(do_template('FORM_SCREEN_INPUT_LINE_MULTI', array(
            '_GUID' => '10fcbe72e80ea1be07c3dd1fd9e0719e',
            'CLASS' => $class,
            'MAXLENGTH' => get_field_restrict_property('maxlength', $name),
            'PRETTY_NAME' => $pretty_name,
            'TABINDEX' => strval($tabindex),
            'NAME_STUB' => $name,
            'I' => strval($i),
            'REQUIRED' => ($i >= $num_required) ? '' : '-required',
            'DEFAULT' => '',
            'PATTERN' => $pattern,
        )));
    }
    return _form_input(preg_replace('#\[\]$#', '', $name), $pretty_name, $description, $input, $num_required > 0, false, $tabindex, false, true, '', $pattern_error);
}

/**
 * Get the Tempcode for a DHTML input field that takes multiple textareas. A new textarea is added when the prior one isn't blank.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The base parameter name which this input field is for (as this takes multiple parameters, they are named <name><x>). This name must end with '_'.
 * @param  array $default_array An array of texts to use as default (at least this many textareas, filled by this array, will be presented by default)
 * @param  integer $num_required The minimum number of textareas allowed
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?integer $maxlength The maximum length of the field (null: unlimited)
 * @return Tempcode The input field
 */
function form_input_text_multi($pretty_name, $description, $name, $default_array, $num_required, $tabindex = null, $maxlength = null)
{
    if (substr($name, -1) != '_') {
        $name .= '_';
    }

    $tabindex = get_form_field_tabindex($tabindex);

    $default_array[0] = filter_form_field_default($name, array_key_exists(0, $default_array) ? $default_array[0] : '');
    if ($num_required == 0) {
        $required = filter_form_field_required($name, false);
        if ($required) {
            $num_required = 1;
        }
    }

    $input = new Tempcode();
    $i = 0;
    foreach ($default_array as $default) {
        $_required = ($i < $num_required) ? '-required' : '';
        $input->attach(do_template('FORM_SCREEN_INPUT_TEXT_MULTI', array('_GUID' => '0d9e3c073d09d1ce3725f47813375c28', 'PRETTY_NAME' => $pretty_name, 'TABINDEX' => strval($tabindex), 'NAME_STUB' => $name, 'I' => strval($i), 'REQUIRED' => $_required, 'DEFAULT' => $default, 'MAXLENGTH' => ($maxlength === null) ? null : strval($maxlength))));
        $i++;
    }
    for (; $i < $num_required; $i++) {
        $input->attach(do_template('FORM_SCREEN_INPUT_TEXT_MULTI', array('_GUID' => '2e816a71ef5a9ac9e1aac4bd1c13b5bd', 'PRETTY_NAME' => $pretty_name, 'TABINDEX' => strval($tabindex), 'NAME_STUB' => $name, 'I' => strval($i), 'REQUIRED' => '-required', 'DEFAULT' => '', 'MAXLENGTH' => ($maxlength === null) ? null : strval($maxlength))));
    }
    return _form_input($name, $pretty_name, $description, $input, $num_required > 0, false, $tabindex, false, true);
}

/**
 * Get the Tempcode for a multi-username input widget.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The base parameter name which this input field is for (as this takes multiple parameters, they are named <name><x>). This name must end with '_'.
 * @param  array $default_array An array of lines to use as default (at least this many lines, filled by this array, will be presented by default)
 * @param  integer $num_required The minimum number of inputs allowed
 * @param  boolean $needs_match Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_username_multi($pretty_name, $description, $name, $default_array, $num_required, $needs_match = true, $tabindex = null)
{
    if (substr($name, -1) != '_') {
        $name .= '_';
    }

    require_javascript('ajax_people_lists');

    $tabindex = get_form_field_tabindex($tabindex);

    if ($num_required == 0) {
        $required = filter_form_field_required($name, false);
        if ($required) {
            $num_required = 1;
        }
    }

    $input = new Tempcode();
    $i = 0;
    foreach ($default_array as $default) {
        if ($default === null) {
            $default = '';
        }
        $default = filter_form_field_default($name, $default);

        $_required = ($i < $num_required) ? '-required' : '';
        $input->attach(do_template('FORM_SCREEN_INPUT_USERNAME_MULTI', array('_GUID' => 'f2adcb1464b13e339a0336db6d5228cb', 'PRETTY_NAME' => $pretty_name, 'TABINDEX' => strval($tabindex), 'NEEDS_MATCH' => $needs_match, 'NAME_STUB' => $name, 'I' => strval($i), 'REQUIRED' => $_required, 'DEFAULT' => $default)));
        $i++;
    }
    if ($num_required > $i) {
        $_num_required = $num_required;
    } else {
        $_num_required = $i + 1;
    }
    for (; $i < $_num_required; $i++) {
        $_required = ($i < $num_required) ? '-required' : '';

        $input->attach(do_template('FORM_SCREEN_INPUT_USERNAME_MULTI', array('_GUID' => '4bc8a187ee5fac91275f66f78478a3c6', 'PRETTY_NAME' => $pretty_name, 'TABINDEX' => strval($tabindex), 'NEEDS_MATCH' => $needs_match, 'NAME_STUB' => $name, 'I' => strval($i), 'REQUIRED' => $_required, 'DEFAULT' => '')));
    }

    return _form_input($name, $pretty_name, $description, $input, $num_required > 0, false, $tabindex);
}

/**
 * Get the Tempcode for a text input (textarea).
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  string $default The default value for this input field
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $scrolls Whether the field scrolls
 * @param  ?integer $maxlength The maximum length of the field (null: unlimited)
 * @param  ?integer $rows Number of rows for text input (null: default)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_text($pretty_name, $description, $name, $default, $required, $tabindex = null, $scrolls = false, $maxlength = null, $rows = null, $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    check_suhosin_request_size(strlen($default));

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $_required = ($required) ? '-required' : '';

    $input = do_template('FORM_SCREEN_INPUT_TEXT', array(
        '_GUID' => '01626015c6ae36b1027e35e66a8b5d0b',
        'RAW' => true,
        'SCROLLS' => $scrolls,
        'ROWS' => ($rows === null) ? null : strval($rows),
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'MAXLENGTH' => ($maxlength === null) ? null : strval($maxlength),
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex, true);
}

/**
 * Get the Tempcode for a Comcode-enabled text input (textarea).
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  string $default The default value for this input field
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $force_non_wysiwyg Force non-WYSIWYG and non default-Comcode parsing
 * @param  mixed $description_side A secondary side description for this input field
 * @param  ?Tempcode $default_parsed The parsed Comcode. (null: calculate)
 * @param  boolean $scrolls Whether the field scrolls
 * @param  ?integer $rows Number of rows for text input (null: default)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_text_comcode($pretty_name, $description, $name, $default, $required, $tabindex = null, $force_non_wysiwyg = false, $description_side = '', $default_parsed = null, $scrolls = false, $rows = null, $autocomplete = null)
{
    if ((browser_matches('wysiwyg', $default)) && (!$force_non_wysiwyg) && (strpos($default, '{$,page hint: no_wysiwyg}') === false)) {
        return form_input_huge_comcode($pretty_name, $description, $name, $default, $required, $tabindex, 10, $description_side, $default_parsed, $scrolls);
    }

    require_lang('comcode');

    handle_default_comcode_text($default);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';
    $default_parsed = new Tempcode();

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    check_suhosin_request_size(strlen($default));

    if (!$force_non_wysiwyg) {
        attach_wysiwyg();

        $w = (browser_matches('wysiwyg', $default) && (strpos($default, '{$,page hint: no_wysiwyg}') === false));
        if ($w) {
            $_required .= ' wysiwyg';
        }
        push_lax_comcode(true);
        $GLOBALS['COMCODE_PARSE_URLS_CHECKED'] = 100; // FUDGE: Little hack to stop it checking any URLs
        /*Actually we reparse always to ensure it is done in semiparse mode if ($default_parsed === null) */
        $default_parsed = @comcode_to_tempcode($default, null, false, null, null, COMCODE_SEMIPARSE_MODE);
        pop_lax_comcode();
    } else {
        $w = false;
        $default_parsed = new Tempcode();
    }

    $input = do_template('FORM_SCREEN_INPUT_TEXT', array(
        '_GUID' => 'ff53196e943e7b19bc72fc3bbb3238b5',
        'SCROLLS' => $scrolls,
        'ROWS' => ($rows === null) ? (((is_object($description_side)) || ($description_side != '')) ? '16' : '8') : strval($rows),
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => $default,
        'DEFAULT_PARSED' => $default_parsed,
        'AUTOCOMPLETE' => $autocomplete,
    ));

    return _form_input($name, $pretty_name, $description, $input, $required, true, $tabindex, $w, false, $description_side);
}

/**
 * Get the Tempcode for a huge Comcode-enabled text input (textarea). These need extra space to fit.
 * This function is also used as an automatic replacement for form_input_text_comcode if WYSIWYG is available (as WYSIWYG needs more space too).
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  string $default The default value for this input field
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  integer $rows The number of rows to use
 * @param  mixed $description_side A secondary side description for this input field
 * @param  ?Tempcode $default_parsed The parsed Comcode. (null: calculate)
 * @param  boolean $scrolls Whether the field scrolls
 * @param  boolean $force_non_wysiwyg Force non-WYSIWYG and non default-Comcode parsing
 * @return Tempcode The input field
 */
function form_input_huge_comcode($pretty_name, $description, $name, $default, $required, $tabindex = null, $rows = 20, $description_side = '', $default_parsed = null, $scrolls = false, $force_non_wysiwyg = false)
{
    require_lang('comcode');

    handle_default_comcode_text($default);

    $tabindex = get_form_field_tabindex($tabindex);

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    check_suhosin_request_size(strlen($default));

    $_required = ($required) ? '-required' : '';
    $default_parsed = new Tempcode();

    attach_wysiwyg();

    if (!$force_non_wysiwyg) {
        $w = (browser_matches('wysiwyg', $default) && (strpos($default, '{$,page hint: no_wysiwyg}') === false));
        if ($w) {
            $_required .= ' wysiwyg';
        }
        push_lax_comcode(true);
        $GLOBALS['COMCODE_PARSE_URLS_CHECKED'] = 100; // FUDGE: Little hack to stop it checking any URLs
        /*Actually we reparse always to ensure it is done in semiparse mode if ($default_parsed === null) */
        $default_parsed = @comcode_to_tempcode($default, null, false, null, null, COMCODE_SEMIPARSE_MODE);
        pop_lax_comcode();
    } else {
        $w = false;
        $default_parsed = new Tempcode();
    }

    $help_zone = get_comcode_zone('userguide_comcode', false);
    $_comcode = ($help_zone === null) ? new Tempcode() : do_template('COMCODE_MESSAGE', array('_GUID' => 'fbcf2413f754ca5829b9f4c908746843', 'NAME' => $name, 'W' => $w, 'URL' => build_url(array('page' => 'userguide_comcode'), $help_zone)));

    return do_template('FORM_SCREEN_INPUT_HUGE_COMCODE', array(
        '_GUID' => 'b8231827be2f4a00e12fcd8986119588',
        'SCROLLS' => $scrolls,
        'DESCRIPTION_SIDE' => $description_side,
        'REQUIRED' => $required,
        '_REQUIRED' => $_required,
        'TABINDEX' => strval($tabindex),
        'COMCODE' => $_comcode,
        'PRETTY_NAME' => $pretty_name,
        'DESCRIPTION' => $description,
        'NAME' => $name,
        'DEFAULT' => $default,
        'DEFAULT_PARSED' => $default_parsed,
        'ROWS' => strval($rows),
    ));
}

/**
 * Get the Tempcode for a huge text input (textarea).
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  string $default The default value for this input field
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  integer $rows The number of rows to use
 * @param  mixed $description_side A secondary side description for this input field
 * @param  boolean $scrolls Whether the field scrolls
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_huge($pretty_name, $description, $name, $default, $required, $tabindex = null, $rows = 20, $description_side = '', $scrolls = false, $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $default = filter_form_field_default($name, $default);
    $required = filter_form_field_required($name, $required);

    check_suhosin_request_size(strlen($default));

    $_required = ($required) ? '-required' : '';
    $default_parsed = new Tempcode();

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    return do_template('FORM_SCREEN_INPUT_HUGE', array(
        '_GUID' => '9d51961cd53c3fcadb8f83b905b2bbea',
        'RAW' => true,
        'SCROLLS' => $scrolls,
        'DESCRIPTION_SIDE' => $description_side,
        'REQUIRED' => $required,
        '_REQUIRED' => $_required,
        'TABINDEX' => strval($tabindex),
        'PRETTY_NAME' => $pretty_name,
        'DESCRIPTION' => $description,
        'NAME' => $name,
        'DEFAULT' => $default,
        'ROWS' => strval($rows),
        'AUTOCOMPLETE' => $autocomplete,
    ));
}

/**
 * Get the Tempcode for a password input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  string $default The default value for this input field
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_password($pretty_name, $description, $name, $required, $tabindex = null, $default = '', $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    if ($autocomplete === 'autocomplete-disabled') {
        $autocomplete = 'new-password'; // More reliable for disabling autofill on password fields
    }

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_PASSWORD', array(
        '_GUID' => '12af7290441ebf5459feefaf9daa28c6',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'VALUE' => $default,
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a checkbox input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  boolean $ticked Whether this is ticked (checked) by default
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ID_TEXT $value The value the checkbox passes when ticked (checked)
 * @param  boolean $read_only Whether this box should be disabled
 * @param  boolean $disabled Whether this box should be disabled
 * @return Tempcode The input field
 */
function form_input_tick($pretty_name, $description, $name, $ticked, $tabindex = null, $value = '1', $read_only = false, $disabled = false)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $ticked = (filter_form_field_default($name, $ticked ? '1' : '0') == '1');

    $input = do_template('FORM_SCREEN_INPUT_TICK', array(
        '_GUID' => '340a68c271b838d327f042d101df27eb',
        'VALUE' => $value,
        'CHECKED' => $ticked,
        'TABINDEX' => strval($tabindex),
        'NAME' => $name,
        'READ_ONLY' => $read_only,
        'DISABLED' => $disabled,
    ));
    return _form_input($name, $pretty_name, $description, $input, false, false, $tabindex);
}

/**
 * Get the Tempcode for a bank of tick (check) boxes.
 *
 * @param  array $options A list of tuples: (prettyname, name, value, description)
 * @param  mixed $description A description for this input field
 * @param  ?integer $_tabindex The tab index of the field (null: not specified)
 * @param  mixed $_pretty_name A human intelligible name for this input field (blank: use default)
 * @param  boolean $simple_style Whether to place each tick (check) on a new line
 * @param  ?ID_TEXT $custom_name Name for custom value to be entered to (null: no custom value allowed)
 * @param  ?mixed $custom_value Value for custom value, string (accept single value) or array (accept multiple values) (null: no custom value known)
 * @return Tempcode The input field
 */
function form_input_various_ticks($options, $description, $_tabindex = null, $_pretty_name = '', $simple_style = false, $custom_name = null, $custom_value = null)
{
    if (count($options) == 0) {
        return new Tempcode();
    }

    $options = array_values($options);

    if ($_tabindex === null) {
        $tabindex = get_form_field_tabindex(null);
    } else {
        $_tabindex++;
        $tabindex = $_tabindex;
    }

    if ((is_string($_pretty_name)) && ($_pretty_name == '')) {
        $_pretty_name = do_lang_tempcode('OPTIONS');
    }

    $input = new Tempcode();

    if (count($options[0]) != 3) {
        $options = array(array($options, null, new Tempcode()));
    }
    foreach ($options as $_option) {
        $out = array();
        foreach ($_option[0] as $option) {
            list($pretty_name, $name, $value, $_description) = $option;

            $value = (filter_form_field_default($name, $value ? '1' : '0') == '1');

            $out[] = array('DISABLED' => false, 'CHECKED' => $value, 'TABINDEX' => strval($tabindex), 'NAME' => $name, 'PRETTY_NAME' => $pretty_name, 'DESCRIPTION' => $_description);
        }

        if ($custom_value === array()) {
            $custom_value = array('');
        }

        $input->attach(do_template('FORM_SCREEN_INPUT_VARIOUS_TICKS', array(
            '_GUID' => 'a6212f61304a101fb2754e334a8b4212',
            'CUSTOM_ACCEPT_MULTIPLE' => is_array($custom_value),
            'CUSTOM_NAME' => $custom_name,
            'CUSTOM_VALUE' => ($custom_value === null) ? '' : $custom_value,
            'SECTION_TITLE' => $_option[2],
            'EXPANDED' => $_option[1],
            'SIMPLE_STYLE' => $simple_style,
            'SIBLINGS' => strval(count($out)),
            'OUT' => $out,
        )));
    }
    return _form_input('', $_pretty_name, $description, $input, false, false, $tabindex);
}

/**
 * Get the Tempcode for a multi-set upload, allowing selection from multiple different sources.
 * Mainly for images, used with post_param_image or post_param_multi_source_upload.
 *
 * @param  mixed $set_title A human intelligible name for this input field
 * @param  mixed $set_description A description for this input field
 * @param  Tempcode $hidden A reference to where we're putting hidden fields
 * @param  ID_TEXT $set_name The name which this input field is for (actually, this is a prefix put in front of different input types)
 * @param  ?ID_TEXT $theme_image_type The directory of theme images to provide selection from (null: do not support theme images)
 * @param  boolean $required Whether this is a required input field. Set this to false if you are using this field on an edit form and already have an uploaded file -- therefore you'd know no new file would mean not to replace the existing file
 * @param  ?string $default The default value for the field (null: none) (blank: none). Should only be passed if $required is false, because it creates a delete button for the existing file, implying that leaving it with no file is valid
 * @param  boolean $support_syndication Whether to syndicate the file off
 * @param  ?string $filter File type filter (null: autodetect)
 * @param  boolean $images_only Whether to accept images only
 * @return Tempcode The input field
 */
function form_input_upload_multi_source($set_title, $set_description, &$hidden, $set_name = 'image', $theme_image_type = null, $required = true, $default = null, $support_syndication = false, $filter = null, $images_only = true)
{
    require_code('images');

    // Remap theme image to URL if needed
    if ($images_only) {
        if (($theme_image_type !== null) && (get_option('allow_theme_image_selector') == '1')) {
            require_code('themes2');
            $ids = get_all_image_ids_type($theme_image_type);

            if (in_array($default, $ids)) {
                $default = find_theme_image($default);
            }
        }
    }

    // ---

    // Upload
    // ------

    $field_file = $set_name . '__upload';

    if ($support_syndication) {
        require_code('upload_syndication');
        list($syndication_json,) = get_upload_syndication_json(CMS_UPLOAD_IMAGE);
    } else {
        $syndication_json = null;
    }
    if ($filter === null) {
        if ($images_only) {
            $filter = get_allowed_image_file_types(); // We don't use the filter from get_upload_syndication_json because we're not restricted to what can syndicate
        } else {
            $filter = '';
        }
    }

    if (get_value('disable_multi_homed_upload__' . get_page_name()) === '1') {
        if ($default != '') {
            $required = false; // As we already have it. But we pass $default as '' so it does not offer deletion. The current URL is passed through the URL setting.
        }

        $upload_widget = form_input_upload(do_lang_tempcode('UPLOAD'), do_lang_tempcode('DESCRIPTION_UPLOAD'), $field_file, $required, null, null, true, $filter, $syndication_json);

        $hidden_url_widget = form_input_hidden($set_name . '__url', $default);
        $hidden->attach($hidden_url_widget);

        return $upload_widget;
    }

    $field_set = alternate_fields_set__start($set_name);

    $upload_widget = form_input_upload(do_lang_tempcode('UPLOAD'), do_lang_tempcode('DESCRIPTION_UPLOAD'), $field_file, $required, $default, null, true, $filter, $syndication_json);

    $field_set->attach($upload_widget);

    if ($images_only) {
        handle_max_file_size($hidden, 'image');
    }

    // URL
    // ---

    $field_url = $set_name . '__url';

    $url_widget = form_input_url(do_lang_tempcode('URL'), do_lang_tempcode('DESCRIPTION_ALTERNATE_URL'), $field_url, $default, $required);

    $field_set->attach($url_widget);

    // Filedump
    // --------

    if ((addon_installed('filedump')) && (has_actual_page_access(null, 'filedump'))) {
        require_code('files2');
        $full_path = get_custom_file_base() . '/uploads/filedump';
        $files = get_directory_contents($full_path, '', IGNORE_ACCESS_CONTROLLERS, false);
        $has_image_or_dir = false;
        foreach ($files as $file) {
            if (is_image($file, IMAGE_CRITERIA_WEBSAFE, true) || is_dir($full_path . '/' . $file)) {
                $has_image_or_dir = true;
                break;
            }
        }
        if ($has_image_or_dir) {
            $field_filedump = $set_name . '__filedump';

            require_lang('filedump');

            $filedump_url = build_url(array('page' => 'filedump'), get_module_zone('filedump'));
            if ($images_only) {
                $filedump_options = array('images_only' => '1');
            } else {
                $filedump_options = array();
            }
            if ($default === null) {
                $filedump_default = '';
            } else {
                $filedump_default = (preg_match('#^uploads/filedump/#', $default) != 0) ? $default : '';
            }
            $filedump_field_description = do_lang_tempcode('DESCRIPTION_ALTERNATE_URL_FILEDUMP', escape_html($filedump_url->evaluate()));
            $filedump_widget = form_input_tree_list(do_lang_tempcode('FILEDUMP'), $filedump_field_description, $field_filedump, '', 'choose_filedump_file', $filedump_options, $required, $filedump_default, false);
            $field_set->attach($filedump_widget);
        }
    }

    // Theme image
    // -----------

    if ($images_only) {
        if (($theme_image_type !== null) && (get_option('allow_theme_image_selector') == '1')) {
            if (count($ids) > 0) {
                $field_choose = $set_name . '__theme_image';

                $theme_image_widget = form_input_theme_image(do_lang_tempcode('STOCK'), '', $field_choose, $ids, $default, null, null, $required);

                $field_set->attach($theme_image_widget);
            }
        }
    }

    // ---

    return alternate_fields_set__end($set_name, $set_title, $set_description, $field_set, $required);
}

/**
 * Make a preview URL absolute and return if it is an image.
 *
 * @param  URLPATH $url URL
 * @return array A pair: Modified URL, whether it is an image
 */
function make_previewable_url_absolute($url)
{
    $_url = $url;
    $is_image = false;

    if (($_url !== null) && ($_url != '')) {
        if (url_is_local($_url)) {
            $image_path = get_custom_file_base() . '/' . dirname(rawurldecode($_url));
            if (!is_file($image_path)) {
                $image_path = get_file_base() . '/' . dirname(rawurldecode($_url));
                $custom = false;
            } else {
                $custom = true;
            }

            $htaccess_path = $image_path . '/.htaccess';
            if ((is_file($htaccess_path)) && (strpos(file_get_contents($htaccess_path), 'deny from all') !== false)) {
                return array($_url, $is_image);
            }

            require_code('images');
            $is_image = is_image($_url, IMAGE_CRITERIA_WEBSAFE, true);
            $_url = ($custom ? get_custom_base_url() : get_base_url()) . '/' . $_url;
        }
    }

    return array($_url, $is_image);
}

/**
 * Get the Tempcode for a file upload input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  boolean $required Whether this is a required input field. Set this to false if you are using this field on an edit form and already have an uploaded file -- therefore you'd know no new file would mean not to replace the existing file
 * @param  ?string $default The default value for the field (null: none) (blank: none). Should only be passed if $required is false, because it creates a delete button for the existing file, implying that leaving it with no file is valid
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $plupload Whether plupload-style is preferred
 * @param  string $filter File-type filter to limit to, comma-separated file extensions (might not be supported)
 * @param  ?string $syndication_json JSON structure of what uploader syndications there will be (null: none)
 * @return Tempcode The input field
 */
function form_input_upload($pretty_name, $description, $name, $required, $default = null, $tabindex = null, $plupload = true, $filter = '', $syndication_json = null)
{
    if ($plupload) {
        require_javascript('plupload');
        require_css('widget_plupload');
    }

    if ($default === '') {
        $default = null;
    }

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';

    list($existing_url, $is_image) = make_previewable_url_absolute($default);

    $input = do_template('FORM_SCREEN_INPUT_UPLOAD', array(
        '_GUID' => 'f493edcc5298bb32fff8635f2d316d21',
        'FILTER' => $filter,
        'PRETTY_NAME' => $pretty_name,
        'EXISTING_URL' => $existing_url,
        'IS_IMAGE' => $is_image,
        'PLUPLOAD' => $plupload,
        'EDIT' => (($default !== null) && (!$required)),
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'SYNDICATION_JSON' => $syndication_json,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a multiple file upload input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  string $name The base name which this input field is for
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?array $default The default value for the field (null: none)
 * @param  boolean $plupload Whether plupload-style is preferred
 * @param  string $filter File-type filter to limit to, comma-separated file extensions (might not be supported)
 * @param  ?string $syndication_json JSON structure of what uploader syndications there will be (null: none)
 * @return Tempcode The input field
 */
function form_input_upload_multi($pretty_name, $description, $name, $required, $tabindex = null, $default = null, $plupload = true, $filter = '', $syndication_json = null)
{
    if ($plupload) {
        require_javascript('plupload');
        require_css('widget_plupload');
    }

    $tabindex = get_form_field_tabindex($tabindex);

    $_required = ($required) ? '-required' : '';

    $edit = mixed();
    if (($default !== null) && (count($default) > 0)) {
        list($edit, $is_image) = make_previewable_url_absolute($default[0]);
    } else {
        $edit = array();
    }
    $input = do_template('FORM_SCREEN_INPUT_UPLOAD_MULTI', array(
        '_GUID' => 'e8712ede08591604738762ac03852ac1',
        'TABINDEX' => strval($tabindex),
        'EDIT' => $edit,
        'FILTER' => $filter,
        'REQUIRED' => $_required,
        'PLUPLOAD' => $plupload,
        'NAME' => $name,
        'I' => '1',
        'NAME_STUB' => $name,
        'SYNDICATION_JSON' => $syndication_json,
    ));
    return _form_input('', $pretty_name, $description, $input, $required, false, $tabindex, false, true);
}

/**
 * Get the Tempcode for a listbox.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  Tempcode $content The list entries for our list; you compose these via attaching together form_input_list_entry calls
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $inline_list Whether this is an inline displayed list as opposed to a dropdown
 * @param  boolean $required Whether this is required
 * @param  ?array $images List of theme images that $content is allowing selection of (so that we can show the images within the list, if JS is enabled) (null: none)
 * @param  integer $size How much space the list takes up (inline lists only)
 * @return Tempcode The input field
 */
function form_input_list($pretty_name, $description, $name, $content, $tabindex = null, $inline_list = false, $required = true, $images = null, $size = 5)
{
    $tabindex = get_form_field_tabindex($tabindex);

    require_css('widget_select2');
    require_javascript('jquery');
    require_javascript('select2');

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_LIST', array(
        '_GUID' => '112dd79a8e0069aa21615594aec1e509',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'CONTENT' => $content,
        'INLINE_LIST' => $inline_list,
        'IMAGES' => $images,
        'SIZE' => strval($size),
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a huge listbox.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  Tempcode $content The list entries for our list; you compose these via attaching together form_input_list_entry calls
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $inline_list Whether this is an inline displayed list as opposed to a dropdown
 * @param  boolean $required Whether this is required
 * @param  ?integer $size Size of list (null: default)
 * @return Tempcode The input field
 */
function form_input_huge_list($pretty_name, $description, $name, $content, $tabindex = null, $inline_list = false, $required = true, $size = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    require_css('widget_select2');
    require_javascript('jquery');
    require_javascript('select2');

    $_required = ($required) ? '-required' : '';

    return do_template('FORM_SCREEN_INPUT_HUGE_LIST', array(
        '_GUID' => 'b29dbbaf09bb5c36410e22feafa2f968',
        'TABINDEX' => strval($tabindex),
        'SIZE' => ($size === null) ? null : strval($size),
        'REQUIRED' => $_required,
        'PRETTY_NAME' => $pretty_name,
        'DESCRIPTION' => $description,
        'NAME' => $name,
        'CONTENT' => $content,
        'INLINE_LIST' => $inline_list,
    ));
}

/**
 * Get the Tempcode for a listbox with multiple selections.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  Tempcode $content The list entries for our list; you compose these via attaching together form_input_list_entry calls
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  integer $size How much space the list takes up
 * @param  boolean $required Whether at least one must be selected
 * @param  ?ID_TEXT $custom_name Name for custom value to be entered to (null: no custom value allowed)
 * @param  ?mixed $custom_value Value for custom value, string (accept single value) or array (accept multiple values) (null: no custom value known)
 * @return Tempcode The input field
 */
function form_input_multi_list($pretty_name, $description, $name, $content, $tabindex = null, $size = 5, $required = false, $custom_name = null, $custom_value = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    require_css('widget_select2');
    require_javascript('jquery');
    require_javascript('select2');

    $input = do_template('FORM_SCREEN_INPUT_MULTI_LIST', array(
        '_GUID' => 'ed0739205c0bf5039e1d4fe2ddfc06da',
        'TABINDEX' => strval($tabindex),
        'SIZE' => strval($size),
        'NAME' => $name,
        'CONTENT' => $content,
        'CUSTOM_ACCEPT_MULTIPLE' => is_array($custom_value),
        'CUSTOM_NAME' => $custom_name,
        'CUSTOM_VALUE' => ($custom_value === null) ? '' : $custom_value,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a combo-box (listbox with free text input). Works best if HTML5 is available.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  string $default Current selection
 * @param  Tempcode $options The list entries for our list; you compose these via attaching together form_input_list_entry calls
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $required Whether this is required
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_combo($pretty_name, $description, $name, $default, $options, $tabindex = null, $required = true, $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_COMBO', array(
        '_GUID' => '4f4595c0b0dfcf09b004481e317d02a8',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'CONTENT' => $options,
        'DEFAULT' => $default,
        'AUTOCMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for an AJAX-powered tree listbox.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?ID_TEXT $root_id The ID to do under (null: root)
 * @param  string $hook The ajax tree-list hook that drives our data
 * @param  array $options A map of special options
 * @param  boolean $required Whether this is a required input field
 * @param  ?string $default The default value for the field (null: none)
 * @param  boolean $use_server_id Whether to use the server-ID in the list instead of the ID in the list
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $multi_select Whether multiple selections are allowed
 * @param  ?string $nice_label Label for default value (null: just use the literal)
 * @return Tempcode The input field
 */
function form_input_tree_list($pretty_name, $description, $name, $root_id, $hook, $options, $required, $default = null, $use_server_id = false, $tabindex = null, $multi_select = false, $nice_label = null)
{
    require_javascript('tree_list');

    require_code('hooks/systems/ajax_tree/' . filter_naughty_harsh($hook));
    $object = object_factory('Hook_ajax_tree_' . filter_naughty_harsh($hook));

    if (get_option('tree_lists') == '0') {
        $simple_content = new Tempcode();
        $simple_content->attach(form_input_list_entry('', false, do_lang('NA')));
        $simple_content->attach($object->simple($root_id, $options, $default));

        if ($simple_content->is_empty()) {
            if ($required) {
                inform_exit(do_lang_tempcode('NO_OF_THIS', $pretty_name));
            }
            return new Tempcode();
        }
        if ($multi_select) {
            return form_input_multi_list($pretty_name, $description, $name, $simple_content, $tabindex, 10, $required);
        }

        return form_input_list($pretty_name, $description, $name, $simple_content, $tabindex, false, $required);
    }

    $tabindex = get_form_field_tabindex($tabindex);

    if ($nice_label === null) {
        $nice_label = $default;
    }

    require_code('content');
    $content_type = preg_replace('#^choose_#', '', $hook);
    if ($content_type != '') {
        $cma_ob = get_content_object($content_type);
        if ($cma_ob !== null) {
            $cma_info = $cma_ob->info();
            if ($cma_info['parent_category_meta_aware_type'] !== null) {
                $content_type = $cma_info['parent_category_meta_aware_type'];
            }
        }
    }

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_TREE_LIST', array(
        '_GUID' => '21e9644eeac24356f38459ebe37f693a',
        'MULTI_SELECT' => $multi_select,
        'NICE_LABEL' => (($nice_label === null) || $nice_label == '-1') ? '' : $nice_label,
        'USE_SERVER_ID' => $use_server_id,
        'TABINDEX' => strval($tabindex),
        'NAME' => $name,
        'REQUIRED' => $_required,
        '_REQUIRED' => $required,
        'DEFAULT' => ($default === null) ? '' : $default,
        'HOOK' => $hook,
        'ROOT_ID' => ($root_id === null) ? '' : $root_id,
        'OPTIONS' => json_encode($options),
        'DESCRIPTION' => $description,
        'CONTENT_TYPE' => $content_type,
    ));
    return _form_input($name, $pretty_name, '', $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a complex input that chooses partials from a list ('all', 'all-except-these', or 'these').
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  string $base The base name which this input field is for
 * @param  Tempcode $list A list accumulation to select against
 * @param  string $type The current type of partial selection
 * @set + - *
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_all_and_not($pretty_name, $description, $base, $list, $type = '+', $tabindex = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $type = filter_form_field_default($base, $type);

    $radios = new Tempcode();
    $radios->attach(form_input_radio_entry($base, '*', $type == '*', do_lang_tempcode('USE_ALL'), $tabindex));
    $radios->attach(form_input_radio_entry($base, '-', $type == '-', do_lang_tempcode('USE_ALL_EXCEPT_SELECTED'), $tabindex));
    $radios->attach(form_input_radio_entry($base, '+', $type == '+', do_lang_tempcode('USE_ALL_SELECTED'), $tabindex));
    $input = do_template('FORM_SCREEN_INPUT_ALL_AND_NOT', array('_GUID' => '32063ca0237a3b46e8fa08bb71a6e41c', 'TABINDEX' => strval($tabindex), 'BASE' => $base, 'RADIOS' => $radios, 'LIST' => $list));
    return _form_input($base . '_list', $pretty_name, $description, $input, false, false, $tabindex);
}

/**
 * Get the Tempcode for a radio group.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  Tempcode $content The radio buttons for our radio group; you compose these via attaching together form_input_radio_entry calls
 * @param  boolean $required Whether a radio selection is required
 * @param  boolean $picture_contents Whether this is a picture-based radio list
 * @param  string $selected_path Default value (only appropriate if has picture contents)
 * @return Tempcode The input field
 */
function form_input_radio($pretty_name, $description, $name, $content, $required = false, $picture_contents = false, $selected_path = '')
{
    $map = array('_GUID' => '26021f9ae8a0cd83b93874bfa80052ca', 'NAME' => $name, 'REQUIRED' => $required, 'CONTENT' => $content, 'IMAGES' => $picture_contents);
    if ($picture_contents) {
        $map = array_merge($map, array('CODE' => $selected_path,));
    }
    $input = do_template('FORM_SCREEN_INPUT_RADIO_LIST', $map);
    return _form_input(($GLOBALS['DOING_ALTERNATE_FIELDS_SET'] !== null) ? $name : '', $pretty_name, $description, $input, $required);
}

/**
 * Get the Tempcode for a radio input. (You would gather together the outputs of several of these functions, then put them in as the $content in a form_input_radio function call).
 *
 * @param  string $name The name of the radio button group this will be put in (i.e. the name the value presented here will be possibly matched against)
 * @param  string $value The value for this entry
 * @param  boolean $selected Whether this entry is selected by default or not
 * @param  mixed $text The text associated with this choice (blank: just use value for text)
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  mixed $description An additional long description (blank: no description)
 * @return Tempcode The input field
 */
function form_input_radio_entry($name, $value, $selected = false, $text = '', $tabindex = null, $description = '')
{
    $tabindex = get_form_field_tabindex($tabindex);

    if ((is_string($text)) && ($text == '')) {
        $text = $value;
    }

    $selected = (filter_form_field_default($name, $selected ? '1' : '') == '1');

    return do_template('FORM_SCREEN_INPUT_RADIO_LIST_ENTRY', array(
        '_GUID' => 'e2fe4ba6e8b3f705651dba13ea27f61d',
        'DESCRIPTION' => $description,
        'CHECKED' => $selected,
        'TABINDEX' => strval($tabindex),
        'NAME' => $name,
        'VALUE' => $value,
        'TEXT' => $text,
    ));
}

/**
 * Get the Tempcode to choose a picture from the given list of images in the theme image system, with sub-categorisation.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  array $ids A list of image IDs (codes) we can choose from, probably found via get_all_image_ids_type
 * @param  ?URLPATH $selected_url The currently selected entry in our picture choosing, by URL (null: none)
 * @param  ?string $selected_code The currently selected entry in our picture choosing, by code (null: none)
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $allow_none Whether to allow the selection of 'no' picture
 * @param  ?object $db The database connector to the Conversr install we are choosing images from (null: site db)
 * @param  ?ID_TEXT $theme Theme to use (null: current theme)
 * @param  ?ID_TEXT $lang Language to use (null: current language)
 * @param  boolean $linear Whether choices are presented in a list (as opposed to a grid); useful when sizes are irregular
 * @param  boolean $direct_titles Whether to show direct codenames, rather than trying to prettify them into titles
 * @return Tempcode The input field
 */
function form_input_theme_image($pretty_name, $description, $name, $ids, $selected_url = null, $selected_code = null, $tabindex = null, $allow_none = false, $db = null, $theme = null, $lang = null, $linear = false, $direct_titles = false)
{
    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }

    if (count($ids) == 0) {
        return new Tempcode();
    }

    $tabindex = get_form_field_tabindex($tabindex);

    require_code('images');

    $selected_code = filter_form_field_default($name, ($selected_code === null) ? '' : $selected_code);
    if ($selected_code == '') {
        $selected_code = null;
    }

    // Split into lists of categories based on path division
    $current_path = ''; // Initialise type to string
    $current_path = null;
    $category = array();
    $categories = array();
    foreach ($ids as $id) {
        $slash_pos = strrpos($id, '/');
        if ($slash_pos === false) {
            $slash_pos = 0;
        }
        $new_path = substr($id, 0, $slash_pos);
        if ($new_path !== $current_path) {
            if ($current_path !== null) {
                if (!array_key_exists($current_path, $categories)) {
                    $categories[$current_path] = array();
                }
                $categories[$current_path] = array_merge($categories[$current_path], $category);
                $category = array();
            }
            $current_path = $new_path;
        }
        $category[] = $id;
    }
    if ($current_path !== null) {
        if (!array_key_exists($current_path, $categories)) {
            $categories[$current_path] = array();
        }
        $categories[$current_path] = array_merge($categories[$current_path], $category);
    }

    // Sorting but fudge it so 'cns_default_avatars/default_set' always comes first
    ksort($categories, SORT_NATURAL | SORT_FLAG_CASE);
    $avatars = (array_key_exists(0, $category)) && (substr($category[0], 0, 20) == 'cns_default_avatars/');
    if ((array_key_exists('cns_default_avatars/default_set', $categories)) && ($avatars)) {
        $def = $categories['cns_default_avatars/default_set'];
        unset($categories['cns_default_avatars/default_set']);
        $categories = array_merge(array('cns_default_avatars/default_set' => $def), $categories);
    }
    // Add in the 'N/A' option
    if (($allow_none) && (!array_key_exists('', $categories))) {
        if (count($categories) == 1) {
            array_unshift($categories[$current_path], '');
        } else {
            $categories[do_lang('NA')] = array('');
        }
    }

    // Show each category
    $content = new Tempcode();
    foreach ($categories as $cat => $ids) {
        $cat = $direct_titles ? $cat : titleify($cat);

        if ($avatars) {
            $cut_pos = strpos($cat, '/');
            $cut_pos = ($cut_pos === false) ? ($avatars ? strlen($cat) : 0) : ($cut_pos + 1);
            $cat = titleify(substr($cat, $cut_pos)); // Make the category name a bit nicer
        }

        if ($cat == '') {
            $cat = do_lang($avatars ? 'GENERAL' : 'UNNAMED');
        }

        $image_maps = array('without_widths' => array(), 'with_widths' => array());

        $_category = new Tempcode();
        $category_expanded = false;
        foreach ($ids as $id) {
            if ($selected_url !== null) {
                $pos = strpos($selected_url, '/' . $id);
                $selected = false;
                if ($id != '') {
                    $selected = (cms_rawurlrecode(find_theme_image($id, false, false, null, null, $db)) == cms_rawurlrecode($selected_url)) || (cms_rawurlrecode(find_theme_image($id, false, true, null, null, $db)) == cms_rawurlrecode($selected_url));
                }
                if ($selected) {
                    $selected_code = $id;
                }
            } else {
                $selected = ($selected_code == $id);
            }
            if ($selected) {
                $category_expanded = true;
            }

            if ($id == '') {
                if ($selected_code === null) {
                    $selected = true;
                }
                $url = find_theme_image('na', false, false, $theme, $lang, $db);
                $pretty = do_lang_tempcode('NA_EM');
            } else {
                $url = find_theme_image($id, $theme != 'default', false, $theme, $lang, $db);
                if ($url == '') {
                    $url = find_theme_image($id, false, false, 'default', $lang, $db);
                }
                $pretty = $direct_titles ? make_string_tempcode($id) : make_string_tempcode(titleify((strrpos($id, '/') === false) ? $id : substr($id, strrpos($id, '/') + 1)));
            }
            if ($url == '') {
                continue;
            }

            $test = cms_getimagesize_url($url, true);
            if ($test !== false) {
                list($width, $height) = $test;
            } else {
                $width = null;
                $height = null;
            }

            $image_maps[($width === null) ? 'without_widths' : 'with_widths'][] = array(
                'width' => $width,
                'tpl_map' => array(
                    '_GUID' => '10005e2f08b44bfe17fce68685b4c884',
                    'LINEAR' => $linear,
                    'CHECKED' => $selected,
                    'PRETTY' => $pretty,
                    'NAME' => $name,
                    'CODE' => $id,
                    'URL' => $url,
                    'WIDTH' => ($width === null) ? null : strval($width),
                    'HEIGHT' => ($height === null) ? null : strval($height),
                    'VECTOR' => (substr($url, -4) == '.svg'),
                ),
            );
        }

        sort_maps_by($image_maps['with_widths'], 'width');

        foreach ($image_maps['without_widths'] as $image_map) {
            $tpl_map = $image_map['tpl_map'];
            if (count($image_maps['with_widths']) > 0) {
                $tpl_map = array('HEIGHT' => $image_maps['with_widths'][0]['tpl_map']['HEIGHT']) + $tpl_map;
            }
            $_category->attach(do_template('FORM_SCREEN_INPUT_THEME_IMAGE_ENTRY', $tpl_map));
        }
        foreach ($image_maps['with_widths'] as $image_map) {
            $_category->attach(do_template('FORM_SCREEN_INPUT_THEME_IMAGE_ENTRY', $image_map['tpl_map']));
        }

        $_category = do_template('FORM_SCREEN_INPUT_THEME_IMAGE_CATEGORY', array(
            '_GUID' => 'c2f429315b73bcaacc3bff8db11c0056',
            'DISPLAY' => $category_expanded ? 'block' : 'none',
            'FIELD_NAME' => $name,
            'CATEGORY' => $_category,
            'CATEGORY_NAME' => (count($categories) == 1) ? '' : $cat,
        ));
        $content->attach($_category);
    }

    $input = do_template('FORM_SCREEN_INPUT_RADIO_LIST', array(
        '_GUID' => '35fed772f022cf561f823543e56d63e8',
        'REQUIRED' => !$allow_none,
        'NAME' => $name,
        'CODE' => ($selected_code === null) ? '' : $selected_code,
        'TABINDEX' => strval($tabindex),
        'CONTENT' => $content,
        'IMAGES' => false, // Class applied in FORM_SCREEN_INPUT_THEME_IMAGE_CATEGORY instead
        'LINEAR' => $linear,
    ));

    return _form_input($GLOBALS['DOING_ALTERNATE_FIELDS_SET'] ? $name : '', $pretty_name, $description, $input, !$allow_none);
}

/**
 * Get the Tempcode for a date input, or if the system scheduler is not running return blank.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The parameter name for this input field
 * @param  boolean $required Whether this is a required field
 * @param  boolean $null_default Whether this field is empty by default
 * @param  boolean $do_time Whether to input time for this field also
 * @param  ?mixed $default_time The default timestamp to use (either TIME or array of time components) (null: now) [ignored if $null_default is set]
 * @param  integer $total_years_to_show The number of years to allow selection from (all into the future, as this field type is not meant for inputting past dates)
 * @param  ?integer $year_start The year to start from (null: this year)
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_date__cron($pretty_name, $description, $name, $required, $null_default, $do_time, $default_time = null, $total_years_to_show = 10, $year_start = null, $tabindex = null)
{
    if (cron_installed()) {
        return form_input_date($pretty_name, $description, $name, $required, $null_default, $do_time, $default_time, $total_years_to_show, $year_start, $tabindex);
    }
    return new Tempcode();
}

/**
 * Get the Tempcode for a date input. Use post_param_date to read the result.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The parameter name for this input field
 * @param  boolean $required Whether this is not a required field
 * @param  boolean $null_default Whether this field is empty by default
 * @param  boolean $do_time Whether to input time for this field also
 * @param  ?mixed $default_time The default timestamp to use (either TIME or array of time components) (null: now) [ignored if $null_default is set]
 * @param  ?integer $total_years_to_show The number of years to allow selection from (pass a negative number for selection of past years instead of future years) (null: no limit)
 * @param  ?integer $year_start The year to start from (null: this year)
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $do_date Whether to input date for this field (if false, will just do time)
 * @param  ?ID_TEXT $timezone Timezone to input in (null: current user's timezone)
 * @param  boolean $handle_timezone Convert $default_time to $timezone
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_date($pretty_name, $description, $name, $required, $null_default, $do_time, $default_time = null, $total_years_to_show = 10, $year_start = null, $tabindex = null, $do_date = true, $timezone = null, $handle_timezone = true, $autocomplete = null)
{
    $input = _form_input_date($name, $required, $null_default, $do_time, $default_time, $total_years_to_show, $year_start, $tabindex, $do_date, $timezone, $handle_timezone, $autocomplete);
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a date input, raw.
 *
 * @param  ID_TEXT $name The parameter name for this input field
 * @param  boolean $required Whether this is a required field
 * @param  boolean $null_default Whether this field is empty by default
 * @param  boolean $do_time Whether to input time for this field also
 * @param  ?mixed $default_time The default timestamp to use (either TIME or array of time components) (null: now) [ignored if $null_default is set]
 * @param  ?integer $total_years_to_show The number of years to allow selection from (pass a negative number for selection of past years instead of future years) (null: no limit)
 * @param  ?integer $year_start The year to start from (null: this year)
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  boolean $do_date Whether to input date for this field (if false, will just do time)
 * @param  ?ID_TEXT $timezone Timezone to input in (null: current user's timezone)
 * @param  boolean $handle_timezone Convert $default_time to $timezone
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 *
 * @ignore
 */
function _form_input_date($name, $required, $null_default, $do_time, $default_time = null, $total_years_to_show = 10, $year_start = null, $tabindex = null, $do_date = true, $timezone = null, $handle_timezone = true, $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $default_minute = null;
    $default_hour = null;
    $default_month = null;
    $default_day = null;
    $default_year = null;

    $required = filter_form_field_required($name, $required);

    if ((is_array($default_time)) && ($default_time[4] < 1970) && (@strftime('%Y', @mktime(0, 0, 0, 1, 1, 1963)) != '1963')) { // Some systems can't do negative timestamps. Actually the maximum negative integer size is also an issue
        list($default_minute, $default_hour, $default_month, $default_day, $default_year) = $default_time;
        if ($default_minute === null) {
            $default_minute = 0;
        }
        if ($default_hour === null) {
            $default_hour = 0;
        }
    } else {
        if (is_array($default_time)) {
            if ($default_time[4] === null) {
                $default_time = null;
            } else {
                list($default_minute, $default_hour, $default_month, $default_day, $default_year) = $default_time;
                $default_time = mktime($default_hour, $default_minute, 0, $default_month, $default_day, $default_year);
            }
        }

        $_default_time = filter_form_field_default($name, ($default_time === null) ? '' : strval($default_time));
        $default_time = ($_default_time == '') ? null : intval($_default_time);

        if (($default_time !== null) && ($handle_timezone)) {
            if ($timezone === null) {
                $timezone = get_users_timezone();
            }
            $default_time = tz_time($default_time, $timezone);
        }

        $default_minute = ($default_time === null) ? null : intval(date('i', $default_time));
        $default_hour = ($default_time === null) ? null : intval(date('H', $default_time));
        $default_day = ($default_time === null) ? null : intval(date('j', $default_time));
        $default_month = ($default_time === null) ? null : intval(date('n', $default_time));
        $default_year = ($default_time === null) ? null : intval(date('Y', $default_time));
    }

    if ($total_years_to_show < 0) {
        // Assumes $year_start = null; if it is not, weird parameters were passed
        $year_start = intval(date('Y')) + $total_years_to_show;
    }
    // Fix if out of range
    if (($year_start !== null) && ($default_year !== null) && ($default_year < $year_start)) {
        if (($default_year < $year_start) && ($total_years_to_show !== null)) {
            $total_years_to_show += ($year_start - $default_year);
        }
        $year_start = $default_year;
    }

    $year_end = null;
    if (($total_years_to_show !== null) && ($year_start !== null)) {
        if ($total_years_to_show >= 0) {
            $year_end = $year_start + $total_years_to_show;
        } else {
            $year_end = $year_start - $total_years_to_show;
        }
    }
    // Fix if out of range
    if (($default_year !== null) && ($year_end !== null) && ($default_year > $year_end)) {
        $year_end = $default_year;
    }

    if ($null_default) {
        $default_minute = null;
        $default_hour = null;
        $default_day = null;
        $default_month = null;
        $default_year = null;
    }

    if ($do_date) {
        $type = $do_time ? 'datetime' : 'date';
    } else {
        $type = 'time';
    }

    $autocomplete = $do_date ? _get_autocomplete_attribute_value($name, $autocomplete) : null;

    return do_template($do_date ? 'FORM_SCREEN_INPUT_DATE' : 'FORM_SCREEN_INPUT_TIME', array(
        '_GUID' => '5ace58dd0f540f70fb3bd440fb02a430',
        'REQUIRED' => $required,
        'TABINDEX' => strval($tabindex),
        'NAME' => $name,
        'TYPE' => $type,

        'YEAR' => ($default_year === null) ? '' : strval($default_year),
        'MONTH' => ($default_month === null) ? '' : strval($default_month),
        'DAY' => ($default_day === null) ? '' : strval($default_day),
        'HOUR' => ($default_hour === null) ? '' : strval($default_hour),
        'MINUTE' => ($default_minute === null) ? '' : strval($default_minute),

        'MIN_DATE_DAY' => ($year_start === null) ? '' : '1',
        'MIN_DATE_MONTH' => ($year_start === null) ? '' : '1',
        'MIN_DATE_YEAR' => ($year_start === null) ? '' : strval($year_start),
        'MAX_DATE_DAY' => ($year_end === null) ? '' : '31',
        'MAX_DATE_MONTH' => ($year_end === null) ? '' : '12',
        'MAX_DATE_YEAR' => ($year_end === null) ? '' : strval($year_end),

        'AUTOCOMPLETE' => $autocomplete,
    ));
}

/**
 * Get the Tempcode for a date component input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  boolean $want_year Gather year
 * @param  boolean $want_month Gather month
 * @param  boolean $want_day Gather day
 * @param  integer $start_year Start year in selection range
 * @param  integer $end_year End year in selection range
 * @param  ?integer $default_year Default year (null: current year)
 * @param  ?integer $default_month Default month (null: current month)
 * @param  ?integer $default_day Default day (null: current day)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_date_components($pretty_name, $description, $name, $want_year, $want_month, $want_day, $start_year, $end_year, $default_year, $default_month, $default_day, $required, $tabindex = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    require_lang('dates');

    $required = filter_form_field_required($name, $required);

    $default_timestamp = tz_time(time(), get_users_timezone());

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_DATE_COMPONENTS', array(
        '_GUID' => '8a75077992ed552dc9323183bb3c4e13',
        'REQUIRED' => $_required,
        'TABINDEX' => strval($tabindex),
        'NAME' => $name,
        'PRETTY_NAME' => $pretty_name,
        'WANT_YEAR' => $want_year,
        'START_YEAR' => strval(min($start_year, $default_year)),
        'END_YEAR' => strval(max($end_year, $default_year)),
        'YEAR' => ($default_year === null) ? date('Y', $default_timestamp) : strval($default_year),
        'WANT_MONTH' => $want_month,
        'MONTH' => ($default_month === null) ? date('m', $default_timestamp) : strval($default_month),
        'WANT_DAY' => $want_day,
        'DAY' => ($default_day === null) ? date('d', $default_timestamp) : strval($default_day),
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for an integer-only input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?integer $default The default value for this input field (null: no default)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @param  ?integer $maxlength Maximum input length (null: no maximum length, regular HTML5 number input)
 * @param  ~?mixed $autocomplete The autocomplete field name. (false: explicitly disable autocomplete) (null: no autocomplete attribute unless there's a default for this $name)
 * @return Tempcode The input field
 */
function form_input_integer($pretty_name, $description, $name, $default, $required, $tabindex = null, $maxlength = null, $autocomplete = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $_default = filter_form_field_default($name, ($default === null) ? '' : strval($default));
    $default = ($_default == '') ? null : intval($_default);

    $required = filter_form_field_required($name, $required);

    $_required = ($required) ? '-required' : '';

    $autocomplete = _get_autocomplete_attribute_value($name, $autocomplete);

    $input = do_template('FORM_SCREEN_INPUT_INTEGER', array(
        '_GUID' => 'da09e21f329f300f71dd4dd518cb6242',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => ($default === null) ? '' : strval($default),
        'MAXLENGTH' => ($maxlength === null) ? null : strval($maxlength),
        'AUTOCOMPLETE' => $autocomplete,
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for an width/height input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name_width The name which this input field is for: width part
 * @param  ID_TEXT $name_height The name which this input field is for: height part
 * @param  ?integer $default_width The default value for this input field: width part (null: no default)
 * @param  ?integer $default_height The default value for this input field: height part (null: no default)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_dimensions($pretty_name, $description, $name_width, $name_height, $default_width, $default_height, $required, $tabindex = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $_default_width = filter_form_field_default($name_width, ($default_width === null) ? '' : strval($default_width));
    $default_width = ($_default_width == '') ? null : intval($_default_width);
    $_default_height = filter_form_field_default($name_height, ($default_height === null) ? '' : strval($default_height));
    $default_height = ($_default_height == '') ? null : intval($_default_height);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_DIMENSIONS', array(
        '_GUID' => 'd8ccbe6813e4d1a0c41a25adb87d5c35',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME_WIDTH' => $name_width,
        'DEFAULT_WIDTH' => ($default_width === null) ? '' : strval($default_width),
        'NAME_HEIGHT' => $name_height,
        'DEFAULT_HEIGHT' => ($default_height === null) ? '' : strval($default_height),
    ));
    return _form_input($name_width, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Get the Tempcode for a float-only input.
 *
 * @param  mixed $pretty_name A human intelligible name for this input field
 * @param  mixed $description A description for this input field
 * @param  ID_TEXT $name The name which this input field is for
 * @param  ?float $default The default value for this input field (null: no default)
 * @param  boolean $required Whether this is a required input field
 * @param  ?integer $tabindex The tab index of the field (null: not specified)
 * @return Tempcode The input field
 */
function form_input_float($pretty_name, $description, $name, $default, $required, $tabindex = null)
{
    $tabindex = get_form_field_tabindex($tabindex);

    $_default = filter_form_field_default($name, ($default === null) ? '' : strval($default));
    $default = ($_default == '') ? null : floatval($_default);

    $required = filter_form_field_required($name, $required);

    $_required = ($required) ? '-required' : '';
    $input = do_template('FORM_SCREEN_INPUT_FLOAT', array(
        '_GUID' => '6db802ae840bfe7e87881f95c79133c4',
        'TABINDEX' => strval($tabindex),
        'REQUIRED' => $_required,
        'NAME' => $name,
        'DEFAULT' => ($default === null) ? '' : float_format($default, 10, true),
    ));
    return _form_input($name, $pretty_name, $description, $input, $required, false, $tabindex);
}

/**
 * Start off a field set.
 *
 * IMPORTANT: Note that this function uses global state -- any fields generated between alternate_fields_set__start and alternate_fields_set__end will be rendered using field set templating.
 *
 * @param  ID_TEXT $set_name The codename for this field set
 * @return Tempcode Tempcode to start attaching the field set to
 */
function alternate_fields_set__start($set_name)
{
    global $DOING_ALTERNATE_FIELDS_SET;
    if ($DOING_ALTERNATE_FIELDS_SET !== null) {
        warn_exit(do_lang_tempcode('INTERNAL_ERROR'));
    }
    $DOING_ALTERNATE_FIELDS_SET = $set_name;
    return new Tempcode();
}

/**
 * Show a field set that has just been finished off.
 *
 * @param  ID_TEXT $set_name The codename for this field set (blank: just collect raw fields, no actual field set)
 * @param  mixed $pretty_name The human-readable name for this field set
 * @param  mixed $description The human-readable description for this field set
 * @param  Tempcode $fields The field set Tempcode
 * @param  boolean $required Whether it is required that this field set be filled in
 * @param  ?URLPATH $existing_image_preview_url Image URL to show, of the existing selection for this field (null: N/A) (blank: N/A)
 * @param  boolean $raw Whether we just want the raw set contents, without any wrapper field row
 * @param  string $default_set The default set to pre-select
 * @return Tempcode The field set
 */
function alternate_fields_set__end($set_name, $pretty_name, $description, $fields, $required, $existing_image_preview_url = null, $raw = false, $default_set = '')
{
    global $DOING_ALTERNATE_FIELDS_SET;
    if ($DOING_ALTERNATE_FIELDS_SET === null) {
        return $fields; // Didn't actually start set, probably because some logic said not to - so just flow to append as normal
    }

    list($existing_image_preview_url, $is_image) = make_previewable_url_absolute($existing_image_preview_url);

    $set = do_template('FORM_SCREEN_FIELDS_SET', array(
        '_GUID' => 'ae81cf68280aef067de1e8e71b2919a7',
        'FIELDS' => $fields,
        'PRETTY_NAME' => $pretty_name,
        'SET_NAME' => $set_name,
        'REQUIRED' => $required,
        'EXISTING_IMAGE_PREVIEW_URL' => $existing_image_preview_url,
        'DEFAULT_SET' => $default_set,
    ));

    if ($DOING_ALTERNATE_FIELDS_SET === null) {
        warn_exit(do_lang_tempcode('INTERNAL_ERROR'));
    }
    $DOING_ALTERNATE_FIELDS_SET = null;

    if ($raw) {
        return $set;
    }

    return _form_input('', $pretty_name, $description, $set, $required);
}

/**
 * Start serving single field. This is used if you just need the raw widget, not the label (etc).
 */
function single_field__start()
{
    global $DOING_ALTERNATE_FIELDS_SET;
    $DOING_ALTERNATE_FIELDS_SET = '';
}

/**
 * Stop serving single field.
 */
function single_field__end()
{
    global $DOING_ALTERNATE_FIELDS_SET;
    $DOING_ALTERNATE_FIELDS_SET = null;
}

/**
 * Used to create a null option for field sets.
 *
 * @param  mixed $pretty_name The human-readable name for this field
 * @param  ?integer $tabindex The tab index (null: none specified)
 * @return Tempcode The field
 */
function form_input_na($pretty_name, $tabindex = null)
{
    return _form_input('', $pretty_name, new Tempcode(), new Tempcode(), false, false, null);
}

/**
 * Helper function to show an input field.
 *
 * @param  ID_TEXT $name The codename for this field (blank: N/A)
 * @param  mixed $pretty_name The human-readable name for this field
 * @param  mixed $description The human-readable description for this field
 * @param  Tempcode $input The actual raw input field
 * @param  boolean $required Whether it is required that this field be filled in
 * @param  boolean $comcode Whether this field may contain Comcode
 * @param  ?integer $tabindex The tab index (null: none specified)
 * @param  boolean $w Whether it is a textarea field
 * @param  boolean $skip_label Whether to skip displaying a label for the field
 * @param  mixed $description_side A secondary side description for this input field
 * @param  ?string $pattern_error Custom regex pattern validation error (null: none)
 * @return Tempcode The field
 *
 * @ignore
 */
function _form_input($name, $pretty_name, $description, $input, $required, $comcode = false, $tabindex = null, $w = false, $skip_label = false, $description_side = '', $pattern_error = null)
{
    global $_FORM_INPUT_PREFIX, $_FORM_INPUT_SUFFIX;
    if ($_FORM_INPUT_PREFIX !== null) {
        $_input = new Tempcode();
        $_input->attach($_FORM_INPUT_PREFIX);
        $_input->attach('<br />');
        $_input->attach('<br />');
        $_input->attach($input);
        if ($_FORM_INPUT_SUFFIX !== null) {
            $_input->attach($_FORM_INPUT_SUFFIX);
        }
        $input = $_input;
    } elseif ($_FORM_INPUT_SUFFIX !== null) {
        $input->attach('<br />');
        $input->attach('<br />');
        $input->attach($_FORM_INPUT_SUFFIX);
    }

    check_suhosin_request_quantity(2, ($name == '') ? 20 : strlen($name));

    if (($GLOBALS['DEV_MODE'])) {
        $discouraged_field_names = array(
            // Keys are the discouraged field names, values are the encouraged field names.
            'email_address' => 'email',
            'date_of_birth' => 'birthday',
            'dob' => 'birthday',
            'street_address' => 'address1',
            'post_code' => 'postalcode',
            'shipping_street_address' => 'shipping_address1',
            'shipping_post_code' => 'shipping_postalcode',
            'billing_street_address' => 'billing_address1',
            'billing_post_code' => 'billing_postalcode',
        );

        if (isset($discouraged_field_names[$name])) {
            fatal_exit(sprintf('Form field with $name "%s" is not allowed as it does not work reliably with autofill, use "%s" instead.', $name, $discouraged_field_names[$name]));
        }

        if (user_lang() == fallback_lang()) {
            $_description = trim(strip_tags(is_object($description) ? $description->evaluate() : $description));
            if (($_description != '') && (substr($_description, -1) != '.') && (substr(is_object($description) ? $description->evaluate() : $description, -6) != '</kbd>') && (substr($_description, -1) != '!') && (substr($_description, -1) != '?') && (substr($_description, -1) != ']') && (substr($_description, -1) != ')') && (!$GLOBALS['NO_DEV_MODE_FULLSTOP_CHECK'])) {
                fatal_exit('Form field $description parameters should end in full stops [' . $_description . '].');
            }
        }
    }

    $help_zone = get_comcode_zone('userguide_comcode', false);
    $_comcode = (($help_zone === null) || (!$comcode)) ? new Tempcode() : do_template('COMCODE_MESSAGE', array('_GUID' => '7668b8365e34b2484be7c2c271f82e79', 'NAME' => $name, 'W' => $w, 'URL' => build_url(array('page' => 'userguide_comcode'), $help_zone)));

    global $DOING_ALTERNATE_FIELDS_SET, $SKIPPING_LABELS;
    if ($DOING_ALTERNATE_FIELDS_SET !== null) {
        if ($DOING_ALTERNATE_FIELDS_SET == '') {
            return $input;
        }

        $tpl = do_template('FORM_SCREEN_FIELDS_SET_ITEM', array(
            '_GUID' => '23f2e2df7fcacc01d9f5158dc635e73d',
            'SET_NAME' => $DOING_ALTERNATE_FIELDS_SET,
            'REQUIRED' => $required,
            'SKIP_LABEL' => $skip_label || $SKIPPING_LABELS,
            'NAME' => $name,
            'PRETTY_NAME' => $pretty_name,
            'DESCRIPTION' => $description,
            'DESCRIPTION_SIDE' => $description_side,
            'INPUT' => $input,
            'COMCODE' => $_comcode,
        ));
        return $tpl;
    }

    $tpl = do_template('FORM_SCREEN_FIELD', array(
        '_GUID' => 'fa1402b7ad8319372f4bb5b152be7852',
        'REQUIRED' => $required,
        'SKIP_LABEL' => $skip_label || $SKIPPING_LABELS,
        'NAME' => $name,
        'PRETTY_NAME' => $pretty_name,
        'DESCRIPTION' => $description,
        'DESCRIPTION_SIDE' => $description_side,
        'INPUT' => $input,
        'COMCODE' => $_comcode,
        'PATTERN_ERROR' => $pattern_error,
    ));
    return $tpl;
}

/**
 * Gets the autocomplete attribute value for a field.
 *
 * @param  ID_TEXT $name The input field [name] attribute value
 * @param  ~?mixed $provided_autocomplete The provided autocomplete value (false: explicitly disable autocomplete) (null: try to find a value for the provided $name, otherwise return null)
 * @return ?string (null: don't use an autocomplete attribute)
 */
function _get_autocomplete_attribute_value($name, $provided_autocomplete)
{
    $autocomplete_field_names = array(
        // Keys ([name] attribute values) as agreed upon by "#0003470: Change our approach to autofill" https://compo.sr/tracker/view.php?id=3470
        // Values ([autocomplete] attribute values) from https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill-field
        'username'   => 'username',
        'password'   => 'current-password',
        'email'      => 'email',
        'firstname'  => 'given-name',
        'lastname'   => 'family-name',
        'name'       => 'name',
        'birthday'   => 'bday',
        'address1'   => 'street-address',
        'city'       => 'address-level2',
        'state'      => 'address-level1',
        'postalcode' => 'postal-code',
        'country'    => 'country',
        'phone'      => 'tel',
        'shipping_address1'   => 'shipping street-address',
        'shipping_city'       => 'shipping address-level2',
        'shipping_state'      => 'shipping address-level1',
        'shipping_postalcode' => 'shipping postal-code',
        'shipping_country'    => 'shipping country',
        'shipping_phone'      => 'shipping tel',
        'billing_address1'    => 'billing street-address',
        'billing_city'        => 'billing address-level2',
        'billing_state'       => 'billing address-level1',
        'billing_postalcode'  => 'billing postal-code',
        'billing_country'     => 'billing country',
        'billing_phone'       => 'billing tel',

    );

    $autocomplete = $provided_autocomplete;

    if (isset($autocomplete_field_names[$name])) {
        if ($GLOBALS['DEV_MODE'] && isset($provided_autocomplete)) {
            if (!$provided_autocomplete) {
                fatal_exit(sprintf('Field with $name "%s" is reserved for autocomplete enabled fields and should not have it disabled.', $name));
            }

            if ($autocomplete_field_names[$name] !== $provided_autocomplete) {
                fatal_exit(sprintf('Field with $name "%s" must have autocomplete field name "%s" but "%s" was provided.', $name, $autocomplete_field_names[$name], $provided_autocomplete));
            }
        }

        $autocomplete = $autocomplete_field_names[$name];
    } elseif (($provided_autocomplete === false) || (($provided_autocomplete === null) && (starts_with($name, 'edit_')))) {
        $autocomplete = 'autocomplete-disabled';
    }

    return $autocomplete;
}

/**
 * Look for editing conflicts, and setup editing pinging.
 *
 * @param  ?ID_TEXT $id The ID we're editing (null: get from param, 'id')
 * @param  boolean $only_staff Whether to only care about staff conflicts
 * @return array A pair: warning details, ping URL
 */
function handle_conflict_resolution($id = null, $only_staff = false)
{
    if (($only_staff) && (!$GLOBALS['FORUM_DRIVER']->is_staff(get_member()))) {
        return array(null, null);
    }

    if (get_param_integer('refreshing', 0) == 1) {
        return array(null, null);
    }

    if ($id === null) {
        $id = get_param_string('id', post_param_string('id', null));
        if ($id === null) {
            return array(null, null);
        }
    }

    $last_edit_screen_time = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'edit_pings WHERE ' . db_string_equal_to('the_page', cms_mb_substr(get_page_name(), 0, 80)) . ' AND ' . db_string_equal_to('the_type', cms_mb_substr(get_param_string('type', 'browse'), 0, 80)) . ' AND ' . db_string_equal_to('the_id', cms_mb_substr($id, 0, 80)) . ' AND the_member<>' . strval(get_member()) . ' ORDER BY the_time DESC', 1);
    if ((array_key_exists(0, $last_edit_screen_time)) && ($last_edit_screen_time[0]['the_time'] > time() - 20)) {
        $username = $GLOBALS['FORUM_DRIVER']->get_username($last_edit_screen_time[0]['the_member']);
        $warning_details = do_template('WARNING_BOX', array('_GUID' => '10c4e7c0d16df68b38b66d162919c068', 'WARNING' => do_lang_tempcode('EDIT_CONFLICT_WARNING', escape_html($username))));
    } else {
        $warning_details = null;
    }
    $keep = symbol_tempcode('KEEP');
    $ping_url = find_script('edit_ping') . '?page=' . urlencode(get_page_name()) . '&type=' . urlencode(get_param_string('type', 'browse')) . '&id=' . urlencode($id) . $keep->evaluate();

    return array($warning_details, $ping_url);
}

/**
 * Helper function for tab-index linearisation (serves as a filter).
 *
 * @param  ?integer $tabindex Requested tab-index (null: no specific request)
 * @return integer Used tab-index
 */
function get_form_field_tabindex($tabindex = null)
{
    if ($tabindex === null) {
        global $TABINDEX;
        $tabindex = $TABINDEX;
        $TABINDEX++;
    }
    return $tabindex;
}

/**
 * Put in default text to a Comcode field, if it's not pre-populated with anything.
 *
 * @param  ?string $default Default value (null: not set) (blank: not set)
 */
function handle_default_comcode_text(&$default)
{
    if (empty($default)) {
        $_dct = get_value('default_comcode_text', '');
        if ($_dct != '') {
            $default = str_replace('{content}', '', $_dct);
        }
    }
}

/**
 * Adjust quick replies to be wrapped with the default_comcode_text hidden option (if applicable).
 *
 * @param  string $post Post value
 */
function handle_default_comcode_text_input(&$post)
{
    if ($post != '') {
        if (post_param_integer('_comment_form_post', 0) == 1) {
            $_dct = get_value('default_comcode_text', '');
            if (($_dct != '') && (strpos($_dct, '{content}') !== false)) {
                $post = str_replace('{content}', $post, $_dct);
            }
        }
    }
}
