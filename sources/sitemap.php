<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*
Notes:
 - We cannot/do-not fully recurse the Sitemap with arbitrary permissions or as an arbitrary user.
   We do collect permission data, but this is collected for the Permissions Tree Editor, not for node availability meta processing.
   Node availability (of view access) is checked automatically as a part of the sitemap crawl.
   This isn't for no good reason - the Sitemap is intrinsically variable on a user-to-user basis, it is not necessarily shared.
 - When get_node is called, it is assumed that the node object really can handle the requested page-link.
   If it cannot, it is allowed to crash out in any way.
   This is why you should know what you are calling, or check with handles_page_link.
 - Any node called directly will not respect the content-type/validation requirements.
 - The system is designed to be able to recurse the whole structure without using a lot of memory. This is what the callbacks are for.
   If no callback is used, you should probably set a recurse depth limit.
 - Each recursion level should be operable independently, so that we can re-enter across separate AJAX requests.

Node structure includes the following special data for menu rendering:
 - modifiers (special modifier codes that indicate things: "~"->new_window, "+"->expanded, ("-"->nothing), "?"->check permissions)
 - only_to_page[string] (used to make links only show context-sensitively)
*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__sitemap()
{
    if (!defined('SITEMAP_GATHER_DESCRIPTION')) {
        // Defining what should be gathered with the Sitemap
        define('SITEMAP_GATHER_DESCRIPTION', 1);
        define('SITEMAP_GATHER_IMAGE', 2);
        define('SITEMAP_GATHER_TIMES', 4);
        define('SITEMAP_GATHER_SUBMITTER', 8);
        define('SITEMAP_GATHER_AUTHOR', 16);
        define('SITEMAP_GATHER_VIEWS', 32);
        define('SITEMAP_GATHER_RATING', 64);
        define('SITEMAP_GATHER_NUM_COMMENTS', 128);
        define('SITEMAP_GATHER_META', 256);
        define('SITEMAP_GATHER_CATEGORIES', 512);
        define('SITEMAP_GATHER_VALIDATED', 1024);
        define('SITEMAP_GATHER_DB_ROW', 2048);
        define('SITEMAP_GATHER__ALL', 0x7FFFFFF);

        // Defining how a node will be handle
        define('SITEMAP_NODE_NOT_HANDLED', 0);
        define('SITEMAP_NODE_HANDLED', 1);
        define('SITEMAP_NODE_HANDLED_VIRTUALLY', 2); // Not a real node, but a virtual node for which we can accumulate real nodes at

        // Sitemap importances
        define('SITEMAP_IMPORTANCE_NONE', 0.0);
        //define('SITEMAP_IMPORTANCE_', 0.1);
        define('SITEMAP_IMPORTANCE_LOW', 0.2);
        //define('SITEMAP_IMPORTANCE_', 0.3);
        //define('SITEMAP_IMPORTANCE_', 0.4);
        define('SITEMAP_IMPORTANCE_MEDIUM', 0.5);
        //define('SITEMAP_IMPORTANCE_', 0.6);
        //define('SITEMAP_IMPORTANCE_', 0.7);
        define('SITEMAP_IMPORTANCE_HIGH', 0.8);
        //define('SITEMAP_IMPORTANCE_', 0.9);
        define('SITEMAP_IMPORTANCE_ULTRA', 1.0);

        // Sitemap generation settings
        define('SITEMAP_GEN_NONE', 0);
        define('SITEMAP_GEN_REQUIRE_PERMISSION_SUPPORT', 1); // Only go so deep as needed to find nodes with permission-support (typically, stopping prior to the entry-level).
        define('SITEMAP_GEN_USE_PAGE_GROUPINGS', 2); // Whether to make use of page groupings, to organise stuff with the hook schema, supplementing the default zone organisation.
        define('SITEMAP_GEN_CONSIDER_SECONDARY_CATEGORIES', 4); // Whether to consider secondary categorisations for content that primarily exists elsewhere.
        define('SITEMAP_GEN_CONSIDER_VALIDATION', 8); // Whether to filter out non-validated content.
        define('SITEMAP_GEN_LABEL_CONTENT_TYPES', 16); // Whether to change title labels to show what nodes and what kinds of content (i.e. more technical).
        define('SITEMAP_GEN_NO_EMPTY_PAGE_LINKS', 32); // When iteratively expanding we need to make sure this is set, otherwise we won't be able to expand everything. But when generating menus we do not want it set.
        define('SITEMAP_GEN_KEEP_FULL_STRUCTURE', 64); // Avoid merging structure together to avoid page-link duplication.
        define('SITEMAP_GEN_COLLAPSE_ZONES', 128); // Simulate zone collapse in the Sitemap.
        define('SITEMAP_GEN_CHECK_PERMS', 256); // Check permissions when building up nodes.
        define('SITEMAP_GEN_USE_PAGE_GROUPINGS_SUPPRESS', 512); // Unset SITEMAP_GEN_USE_PAGE_GROUPINGS for one recursion only.
        define('SITEMAP_GEN_MACHINE_SITEMAP', 512); // Gather pages that should be on a machine sitemap (but not on a normal UX sitemap).
        define('SITEMAP_GEN_AS_GUEST', 1024); // Whether to evaluate permissions as guest.

        // Defining how the content-selection list should be put together
        define('CSL_PERMISSION_VIEW', 0);
        define('CSL_PERMISSION_ADD', 1);
        define('CSL_PERMISSION_EDIT', 2);
        define('CSL_PERMISSION_DELETE', 4);

        // Other constants
        define('SITEMAP_MAX_ROWS_PER_LOOP', 500);
    }

    global $IS_SITEMAP_STRUCTURE_LOOPING;
    $IS_SITEMAP_STRUCTURE_LOOPING = [];

    global $HAS_MANY_MATCH_KEYS, $MATCH_KEYS_CACHED;
    $HAS_MANY_MATCH_KEYS = null;
    $MATCH_KEYS_CACHED = null;
}

/**
 * Find details of a position in the Sitemap (shortcut into the object structure).
 *
 * @param  ID_TEXT $page_link The page-link we are finding (blank: root)
 * @param  ?mixed $callback Callback function to send discovered page-links to (null: return)
 * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
 * @param  ?integer $child_cutoff Maximum number of children before we cut off all children (null: no limit)
 * @param  ?integer $max_recurse_depth How deep to go from the Sitemap root (null: no limit)
 * @param  integer $options A bitmask of SITEMAP_GEN_* options
 * @param  ID_TEXT $zone The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
 * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
 * @return ?array Node structure (null: working via callback / error)
 */
function retrieve_sitemap_node(string $page_link = '', $callback = null, ?array $valid_node_types = null, ?int $child_cutoff = null, ?int $max_recurse_depth = null, int $options = 0, string $zone = '_SEARCH', int $meta_gather = 0) : ?array
{
    push_query_limiting(false);

    cms_profile_start_for('retrieve_sitemap_node');

    global $IS_SITEMAP_STRUCTURE_LOOPING;
    $IS_SITEMAP_STRUCTURE_LOOPING = [];

    $test = find_sitemap_object($page_link, $options);
    if ($test === null) {
        return null;
    }
    list($ob, $is_virtual) = $test;

    $disable_sitemap = get_value('disable_sitemap');
    if ($disable_sitemap === '2') {
        $valid_node_types = ['page_grouping', 'page', 'entry_point'];
    }
    if ($disable_sitemap === '1') {
        return null;
    }

    $old_limit = cms_extend_time_limit(TIME_LIMIT_EXTEND__MODEST);

    if ($is_virtual) {
        $children = $ob->get_virtual_nodes($page_link, $callback, $valid_node_types, $child_cutoff, $max_recurse_depth, 0, $options, $zone, $meta_gather);
        if ($children === null) {
            $children = [];
        }
        return ['children' => $children];
    }
    $ret = $ob->get_node($page_link, $callback, $valid_node_types, $child_cutoff, $max_recurse_depth, 1, $options, $zone, $meta_gather);

    cms_profile_end_for('retrieve_sitemap_node', $page_link);

    cms_set_time_limit($old_limit);

    return $ret;
}

/**
 * Find the Sitemap object that serves a particular page-link.
 *
 * @param  ID_TEXT $page_link The page-link we are finding a Sitemap object for (blank: root)
 * @param  integer $options A bitmask of SITEMAP_GEN_* options
 * @return ?array A pair: the Sitemap object, and whether you need to make a virtual call (null: cannot find one)
 */
function find_sitemap_object(string $page_link, int $options = 0) : ?array
{
    if ($page_link == '') {
        $hook = 'root';
        require_code('hooks/systems/sitemap/root');
        $ob = object_factory('Hook_sitemap_root');

        $is_virtual = false;
    } else {
        $page_link = preg_replace('#:keep_\w+=[^:]*#', '', $page_link);

        $hook = null;
        $matches = [];
        $hooks = find_all_hook_obs('systems', 'sitemap', 'Hook_sitemap_');
        foreach ($hooks as $_hook => $ob) {
            if ($ob->is_active()) {
                $is_handled = $ob->handles_page_link($page_link, $options);
                if ($is_handled != SITEMAP_NODE_NOT_HANDLED) {
                    $sup = $_hook;
                    if ($_hook == 'entry_point') {
                        $sup = 'aaa'/*high priority (we don't want content category hooks to capture it)*/;
                    }
                    if ($_hook == 'page') {
                        $sup = 'zzz'/*low priority*/;
                    }
                    $order_key = '_' . strval($is_handled) . '_' . $sup;
                    $matches[$order_key] = $_hook;
                }
            }
        }
        if (!empty($matches)) {
            ksort($matches);
            $hook = reset($matches);
            $ob = object_factory('Hook_sitemap_' . filter_naughty_harsh($hook));

            $is_handled = intval(substr(key($matches), 1, 1));
            $is_virtual = ($is_handled == SITEMAP_NODE_HANDLED_VIRTUALLY);
        }
        if ($hook === null) {
            attach_message(do_lang_tempcode('_MISSING_RESOURCE', escape_html($page_link)), 'warn');
            return null;
        }
    }

    return [$ob, $is_virtual];
}

/**
 * Sitemap node type base class.
 *
 * @package core
 */
abstract class Hook_sitemap_base
{
    /**
     * Take the specified parameters, and try to find the corresponding page.
     *
     * @param  ID_TEXT $page The codename of the page to load
     * @param  ID_TEXT $zone The zone the page is being loaded in
     * @param  ?ID_TEXT $page_type The type of page - for if you know it (null: don't know it)
     * @return ~array A list of details (false: page not found)
     */
    protected function _request_page_details(string $page, string $zone, ?string $page_type = null)
    {
        require_code('site');
        $details = _request_page($page, $zone, $page_type);
        if ($details !== false) {
            if ($details[0] == 'REDIRECT') {
                if ($details[1]['r_is_transparent'] == 0) {
                    return false;
                }

                $details = _request_page($details[1]['r_to_page'], $details[1]['r_to_zone'], $page_type, null, true);
            }
        }
        return $details;
    }

    /**
     * Find whether a page should be omitted from the sitemap.
     *
     * @param  ID_TEXT $zone The zone the page is being loaded in
     * @param  ID_TEXT $page The codename of the page to load
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  boolean $is_comcode_page Whether this is a Comcode page
     * @return boolean Whether the page should be omitted
     */
    protected function _is_page_omitted_from_sitemap(string $zone, string $page, int $options, bool $is_comcode_page) : bool
    {
        if (($is_comcode_page) && (($options & SITEMAP_GEN_MACHINE_SITEMAP) == 0)) {
            require_code('global4');
            if (!comcode_page_include_on_sitemap($zone, $page)) {
                return true;
            }
        }

        if (($options & SITEMAP_GEN_MACHINE_SITEMAP) == 0) {
            if ($page == 'sitemap') {
                return true;
            }

            // Pages shown in the footer should not repeat in the Sitemap
            if ((get_option('bottom_show_privacy_link') == '1') && ($page == 'privacy')) {
                return true;
            }
            if ((get_option('bottom_show_rules_link') == '1') && ($page == 'rules') && (($zone == '') || ($zone == 'site') || ($zone == 'forum'))) {
                return true;
            }
            if ((get_option('bottom_show_feedback_link') == '1') && ($page == 'feedback')) {
                return true;
            }
        } else {
            if ($page == 'login') {
                return true;
            }
        }

        // Disabled via a looped redirect?
        $test = _request_page__redirects($page, $zone);
        if ($test !== false) {
            return true;
        }

        // Note that other things are disabled via get_entry_points returning null

        return false;
    }

    /**
     * Find whether the hook is active.
     *
     * @return boolean Whether the hook is active
     */
    public function is_active() : bool
    {
        return true;
    }

    /**
     * Remap '_SEARCH' zones if we can derive the zone from the page-link / or fix _SEARCH in the page-link if there's a known zone.
     *
     * @param  ID_TEXT $zone The zone in the recurse tree (replaced by reference)
     * @param  ID_TEXT $page_link The page-link (replaced by reference)
     * @return ID_TEXT The page name (only returned because it could also be useful, saves some code)
     */
    protected function _make_zone_concrete(string &$zone, string &$page_link) : string
    {
        $matches = [];
        preg_match('#^([^:]*):([^:]*)#', $page_link, $matches);
        $page = $matches[2];

        if ($zone == '_SEARCH') { // Make zone concrete, from page-link
            if ($matches[1] === '_SEARCH') { // Do a search even, if we're desperate
                $zone = get_page_zone($page); // $page_link was unknown, $zone was unknown
            } else {
                $zone = $matches[1]; // $page_link was known, $zone was unknown, we assume $page_link can contain no error
            }
        } else {
            if ($matches[1] == '_SEARCH') { // Test zone, fix up if necessary
                // $page_link was unknown, $zone was known
                $details = $this->_request_page_details($page, $zone);
                if ($details === false) { // Do a search, if we're desperate
                    $zone = get_page_zone($page); // $page_link was unknown, $zone was known, but $zone was wrong
                }
            } elseif ($matches[1] != $zone) { // Correct the zone from what is in the page-link
                $zone = $matches[1]; // $page_link was known, $zone was known, but mismatch so assume $zone was wrong
            }
            // else change nothing ($page_link was known, $zone was known)
        }

        if (($zone == 'site') && (get_option('single_public_zone') == '1')) {
            $zone = '';
        }

        // Correct the page-link from the zone
        $page_link = preg_replace('#^_SEARCH(:|$)#', $zone . '${1}', $page_link);

        return $page;
    }

    /**
     * Find if a page-link will be covered by this node.
     *
     * @param  ID_TEXT $page_link The page-link
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @return integer A SITEMAP_NODE_* constant
     */
    abstract public function handles_page_link(string $page_link, int $options) : int;


    /**
     * Get a particular Sitemap object. Used for easily tying in a different kind of child node.
     *
     * @param  ID_TEXT $hook The hook, i.e. the Sitemap object type. Usually the same as a content type.
     * @return object The Sitemap object
     */
    protected function _get_sitemap_object(string $hook) : object
    {
        require_code('hooks/systems/sitemap/' . filter_naughty_harsh($hook, true));
        return object_factory('Hook_sitemap_' . filter_naughty_harsh($hook, true));
    }

    /**
     * Find all nodes at the top level position in the Sitemap for this hook.
     * May be a single node (i.e. a category root) or multiple nodes (if there's a flat structure).
     *
     * @param  ID_TEXT $page_link The page-link we are finding
     * @param  ?mixed $callback Callback function to send discovered page-links to (null: return)
     * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
     * @param  ?integer $child_cutoff Maximum number of children before we cut off all children (null: no limit)
     * @param  ?integer $max_recurse_depth How deep to go from the Sitemap root (null: no limit)
     * @param  integer $recurse_level Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by XML Sitemap [deeper is typically less important])
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  ID_TEXT $zone The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     * @param  boolean $return_anyway Whether to return the structure even if there was a callback. Do not pass this setting through via recursion due to memory concerns, it is used only to gather information to detect and prevent parent/child duplication of default entry points.
     * @return ?array List of node structures (null: working via callback)
     */
    public function get_virtual_nodes(string $page_link, $callback = null, ?array $valid_node_types = null, ?int $child_cutoff = null, ?int $max_recurse_depth = null, int $recurse_level = 0, int $options = 0, string $zone = '_SEARCH', int $meta_gather = 0, bool $return_anyway = false) : ?array
    {
        $nodes = ($callback === null || $return_anyway) ? [] : null;

        return $nodes;
    }

    /**
     * Find details of a position in the Sitemap.
     *
     * @param  ID_TEXT $page_link The page-link we are finding
     * @param  ?mixed $callback Callback function to send discovered page-links to (null: return)
     * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
     * @param  ?integer $child_cutoff Maximum number of children before we cut off all children (null: no limit)
     * @param  ?integer $max_recurse_depth How deep to go from the Sitemap root (null: no limit)
     * @param  integer $recurse_level Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by XML Sitemap [deeper is typically less important])
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  ID_TEXT $zone The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     * @param  ?array $row Database row (null: lookup)
     * @param  boolean $return_anyway Whether to return the structure even if there was a callback. Do not pass this setting through via recursion due to memory concerns, it is used only to gather information to detect and prevent parent/child duplication of default entry points.
     * @return ?array Node structure (null: working via callback / error)
     */
    abstract public function get_node(string $page_link, $callback = null, ?array $valid_node_types = null, ?int $child_cutoff = null, ?int $max_recurse_depth = null, int $recurse_level = 0, int $options = 0, string $zone = '_SEARCH', int $meta_gather = 0, ?array $row = null, bool $return_anyway = false) : ?array;


    /**
     * Make sure a Sitemap page-link is not recursively being evaluated due to some kind of issue (e.g. a cyclic category structure or a bug).
     *
     * @param  ID_TEXT $page_link The page-link we are finding
     * @return boolean Whether are are okay, not looping
     */
    protected function check_for_looping(string $page_link) : bool
    {
        global $IS_SITEMAP_STRUCTURE_LOOPING;

        $sz = serialize([$page_link, get_class($this)]);

        if (isset($IS_SITEMAP_STRUCTURE_LOOPING[$sz])) {
            return false;
        }

        $IS_SITEMAP_STRUCTURE_LOOPING[$sz] = true;
        return true;
    }

    /**
     * Find which member to evaluate permissions with.
     *
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @return MEMBER The member ID to evaluate for
     */
    protected function get_member(int $options) : int
    {
        if (($options & SITEMAP_GEN_AS_GUEST) != 0) {
            return $GLOBALS['FORUM_DRIVER']->get_guest_id();
        }

        return get_member();
    }

    /**
     * Check the permissions of the node structure, returning false if they fail for the current user.
     *
     * @param  array $struct Node structure
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @return boolean Whether the permissions pass
     */
    protected function _check_node_permissions(array $struct, int $options) : bool
    {
        if (($options & SITEMAP_GEN_CHECK_PERMS) == 0) {
            return true;
        }

        // Check defined permissions
        foreach ($struct['permissions'] as $permission) {
            switch ($permission['type']) {
                case 'non_guests':
                    if (is_guest($this->get_member($options))) {
                        return false;
                    }
                    break;

                case 'zone':
                    if (!has_zone_access($this->get_member($options), $permission['zone_name'])) {
                        return false;
                    }
                    break;

                case 'page':
                    if (!has_page_access($this->get_member($options), $permission['page_name'], $permission['zone_name'])) {
                        return false;
                    }
                    break;

                case 'category':
                    if (!has_category_access($this->get_member($options), $permission['permission_module'], $permission['category_name'])) {
                        return false;
                    }
                    break;
            }
        }

        // Checked implicit match-key permissions
        $matches = [];
        $page_link = $struct['page_link'];
        if (preg_match('#^([^:]*):([^:]*):([^:]*)#', $page_link, $matches) != 0) {
            $zone = $matches[1];
            $page = $matches[2];
            $type = $matches[3];

            $groups = get_permission_where_clause_groups($this->get_member($options), false);
            if ($groups !== null) {
                list(, $params) = page_link_decode($page_link);

                $groups2 = filter_group_permissivity($GLOBALS['FORUM_DRIVER']->get_members_groups($this->get_member($options), false));

                global $HAS_MANY_MATCH_KEYS, $MATCH_KEYS_CACHED;
                if ($HAS_MANY_MATCH_KEYS === null) {
                    $HAS_MANY_MATCH_KEYS = ($GLOBALS['SITE_DB']->query_value_if_there('SELECT COUNT(*) FROM ' . get_table_prefix() . 'group_page_access WHERE page_name LIKE \'' . db_encode_like('%:%') . '\'') > 50);
                }
                if ($HAS_MANY_MATCH_KEYS) {
                    $pg_where = '1=0';
                    $pg_where .= ' OR page_name LIKE \'' . db_encode_like('\_WILD:' . $page . ':%') . '\'';
                    $pg_where .= ' OR page_name LIKE \'' . db_encode_like($zone . ':' . $page . ':%') . '\'';
                    $pg_where .= ' OR page_name LIKE \'' . db_encode_like('\_WILD:\_WILD:%') . '\'';
                    $pg_where .= ' OR page_name LIKE \'' . db_encode_like($zone . ':\_WILD:%') . '\'';
                    $perhaps = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . get_table_prefix() . 'group_page_access WHERE (' . $pg_where . ') AND (' . $groups . ')', null, 0, false, true);
                } else {
                    // Optimisation, for when there are not a lot of match keys
                    if ($MATCH_KEYS_CACHED === null) {
                        $pg_where = 'page_name LIKE \'' . db_encode_like('%:%') . '\'';
                        $MATCH_KEYS_CACHED = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . get_table_prefix() . 'group_page_access WHERE (' . $pg_where . ') AND (' . $groups . ')', null, 0, false, true);
                    }
                    $perhaps = $MATCH_KEYS_CACHED;
                }

                $denied_groups = [];
                foreach ($groups2 as $group) {
                    foreach ($perhaps as $praps) {
                        if (($praps['group_id'] == $group) && ($praps['zone_name'] == '/')) {
                            if (match_key_match($praps['page_name'], true, $params, $zone, $page)) {
                                $denied_groups[$group] = true;
                            }
                        }
                    }
                }

                if (count($denied_groups) == count($groups2)) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Get the permission page that nodes matching $page_link in this hook are tied to.
     * The permission page is where privileges may be overridden against.
     *
     * @param  string $page_link The page-link
     * @return ?ID_TEXT The permission page (null: none)
     */
    public function get_privilege_page(string $page_link) : ?string
    {
        return null;
    }

    /**
     * Convert a page-link to a category ID and category permission module type.
     *
     * @param  ID_TEXT $page_link The page-link
     * @return ?array The pair (null: permission modules not handled)
     */
    public function extract_child_page_link_permission_pair(string $page_link) : ?array
    {
        return null;
    }

    /**
     * Find details for this node.
     *
     * @param  ?array $row Faked database row (null: derive)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     * @param  ID_TEXT $zone The zone
     * @param  ID_TEXT $page The page
     * @param  ID_TEXT $type The type
     * @param  ?ID_TEXT $id The ID (null: unknown)
     * @return ?array Faked database row (null: derive)
     */
    protected function _load_row_from_page_groupings(?array $row, int $meta_gather, string $zone, string $page, string $type = 'browse', ?string $id = null) : ?array
    {
        if (!isset($row[0])) { // If the first tuple element is not defined (a property map may be, for Comcode pages)
            // Find from page grouping

            if ($row === null) {
                $row = [];
            }

            $links = get_page_grouping_links();
            foreach ($links as $link) {
                if ($link === null) {
                    continue;
                }

                if (!is_array($link[2])) {
                    continue;
                }

                $is_a_match = true;
                if ($link[2][0] != $page) {
                    $is_a_match = false;
                } else {
                    if ((isset($link[2][1]['type'])) && ($link[2][1]['type'] != $type)) {
                        $is_a_match = false;
                    } else {
                        if (($link[2][2] != $zone) && ($page == DEFAULT_ZONE_PAGE_NAME)) {
                            $is_a_match = false;
                        } else {
                            if ((isset($link[2][1]['id'])) && ($link[2][1]['id'] !== $id)) {
                                $is_a_match = false;
                            }
                        }
                    }
                }
                if ($is_a_match) {
                    $title = $link[3];
                    $icon = $link[1];

                    $description = null;
                    if ((isset($link[4])) && (($meta_gather & SITEMAP_GATHER_DESCRIPTION) != 0)) {
                        $description = (is_object($link[4])) ? $link[4] : comcode_lang_string($link[4]);
                    }

                    $row = [$title, $icon, $description] + $row;

                    if ($link[2][2] == $zone) {
                        break; // If was a perfect match, break out
                    }
                }
            }

            if ($row === null) { // Get from editable menus?
                $test = $GLOBALS['SITE_DB']->query_select('menu_items', ['*'], ['i_url' => $zone . ':' . $page], '', 1);
                if (array_key_exists(0, $test)) {
                    $title = get_translated_tempcode('menu_items', $test[0], 'i_caption');
                    $icon = $test[0]['i_theme_img_code'];
                    $description = get_translated_tempcode('menu_items', $test[0], 'i_caption_long');
                    $row += [$title, $icon, $description];
                }
            }
        }

        return $row;
    }

    /**
     * Take some text and process it as a language string if applicable, otherwise just convert to Tempcode.
     *
     * @param  string $_title Input string
     * @return Tempcode Output string
     */
    protected function _lang_string_or_literal(string $_title) : object
    {
        if ((preg_match('#^[A-Z\_]+$#', $_title) == 0) || (do_lang($_title, null, null, null, null, false) === null)) {
            $title = make_string_tempcode($_title);
        } else {
            $title = protect_from_escaping(do_lang($_title))/*Need to bake it in using do_lang not do_lang_tempcode as lang file may not be present when restored from cache*/;
        }
        return $title;
    }

    /**
     * Extend the node structure with added details from our row data (if we have it).
     *
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  array $struct Structure
     * @param  ?array $row Faked database row (null: we don't have row data)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     */
    protected function _ameliorate_with_row(int $options, array &$struct, ?array $row, int $meta_gather)
    {
        if (array_key_exists(0, $row)) {
            $title = $row[0];
            $icon = $row[1];
            $description = $row[2];

            if (($options & SITEMAP_GEN_LABEL_CONTENT_TYPES) == 0) {
                if ($title !== null) {
                    if (is_string($title)) {
                        $title = $this->_lang_string_or_literal($title);
                    }

                    if (!$title->is_empty()) {
                        $struct['title'] = $title;
                    }
                }
            }

            if ($description !== null) {
                if (($meta_gather & SITEMAP_GATHER_DESCRIPTION) != 0) {
                    if (!isset($struct['extra_meta']['description'])) {
                        if (is_string($description)) {
                            $description = $this->_lang_string_or_literal($description);
                        }

                        $struct['extra_meta']['description'] = ($description === null) ? null : $description;
                    }
                }
            }

            if ($icon !== null) {
                if (($meta_gather & SITEMAP_GATHER_IMAGE) != 0) {
                    if (!isset($struct['extra_meta']['image'])) {
                        $struct['extra_meta']['image'] = ($icon === null) ? null : find_theme_image('icons/' . $icon);
                    }
                }
            }
        }
    }
}

/**
 * Sitemap node type for content types.
 *
 * @package core
 */
abstract class Hook_sitemap_content extends Hook_sitemap_base
{
    protected $content_type = null;
    protected $entry_content_type = null;
    protected $entry_sitetree_hook = null;
    protected $cma_ob = null;
    protected $cma_info = null;
    protected $screen_type = 'browse';

    /**
     * Find if a page-link will be covered by this node.
     *
     * @param  ID_TEXT $page_link The page-link
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @return integer A SITEMAP_NODE_* constant
     */
    public function handles_page_link(string $page_link, int $options) : int
    {
        $matches = [];
        if (preg_match('#^([^:]*):([^:]*)#', $page_link, $matches) != 0) {
            $zone = $matches[1];
            $page = $matches[2];

            $cma_info = $this->_get_cma_info();
            require_code('site');
            if (($cma_info !== null) && ($cma_info['module'] == $page) && (($zone == '_SEARCH') || (_request_page($page, $zone) !== false))) { // Ensure the given page matches the content type, and it really does exist in the given zone
                if ($matches[0] == $page_link) {
                    return SITEMAP_NODE_HANDLED_VIRTUALLY; // No type/ID specified
                }
                if (preg_match('#^([^:]*):([^:]*):' . $this->screen_type . '(:|$)#', $page_link, $matches) != 0) {
                    return SITEMAP_NODE_HANDLED;
                }
            }
        }
        return SITEMAP_NODE_NOT_HANDLED;
    }

    /**
     * Get a content ID via a page-link.
     *
     * @param  ID_TEXT $page_link The page-link
     * @return ?ID_TEXT The ID (null: unknown)
     */
    protected function _get_page_link_id(string $page_link) : ?string
    {
        $matches = [];
        if (preg_match('#^([^:]*):([^:]*):([^:]*):([^:]*)#', $page_link, $matches) == 0) {
            return null;
        }
        return $matches[4];
    }

    /**
     * Get the CMA object for our content hook.
     *
     * @return ?object The CMA object (null: disabled)
     */
    protected function _get_cma_ob() : ?object
    {
        if ($this->cma_ob === null) {
            require_code('content');
            $this->cma_ob = get_content_object($this->content_type);
        }
        return $this->cma_ob;
    }

    /**
     * Get the CMA info for our content hook.
     *
     * @return ?array The CMA info (null: disabled)
     */
    protected function _get_cma_info() : ?array
    {
        if ($this->cma_info === null) {
            $cma_ob = $this->_get_cma_ob();
            $this->cma_info = $cma_ob->info();
        }
        return $this->cma_info;
    }

    /**
     * Get the database row for some content.
     *
     * @param  ID_TEXT $content_id The content ID
     * @return ?array The content row (null: not found)
     */
    protected function _get_row(string $content_id) : ?array
    {
        $cma_info = $this->_get_cma_info();
        return content_get_row($content_id, $cma_info);
    }

    /**
     * Pre-fill part of the node structure, from what we know from the CMA hook.
     *
     * @param  ID_TEXT $page_link The page-link we are finding
     * @param  ?mixed $callback Callback function to send discovered page-links to (null: return)
     * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
     * @param  ?integer $child_cutoff Maximum number of children before we cut off all children (null: no limit)
     * @param  ?integer $max_recurse_depth How deep to go from the Sitemap root (null: no limit)
     * @param  integer $recurse_level Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by XML Sitemap [deeper is typically less important])
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  ID_TEXT $zone The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     * @param  ?array $row Database row (null: lookup)
     * @return ?array A tuple: content ID, row, partial node structure (null: filtered)
     */
    protected function _create_partial_node_structure(string $page_link, $callback, ?array $valid_node_types, ?int $child_cutoff, ?int $max_recurse_depth, int $recurse_level, int $options, string $zone, int $meta_gather, ?array $row) : ?array
    {
        if (($valid_node_types !== null) && (!in_array($this->content_type, $valid_node_types))) {
            return null;
        }

        $cma_ob = $this->_get_cma_ob();
        $cma_info = $this->_get_cma_info();
        if ($cma_info === null) {
            return null;
        }

        $content_id = $this->_get_page_link_id($page_link);
        if ($content_id === null) {
            return null;
        }
        if ($row === null) {
            $row = $this->_get_row($content_id);
            if ($row === null) {
                return null;
            }
        }

        $title = $cma_ob->get_title($row, FIELD_RENDER_HTML);

        $matches = [];
        preg_match('#^([^:]*):([^:]*):([^:]*):([^:]*)#', $page_link, $matches);
        if ($matches[1] != $zone) {
            if ($zone == '_SEARCH') {
                $zone = $matches[1];
            } else {
                warn_exit(do_lang_tempcode('INTERNAL_ERROR'));
            }
        }
        $page = $matches[2];

        $has_entries = ($cma_info['is_category']) && ($this->entry_content_type !== null);
        $has_subcategories = ($cma_info['parent_spec__parent_name'] !== null) && ($cma_info['parent_category_meta_aware_type'] == $this->content_type);

        $struct = [
            'title' => $title,
            'content_type' => $this->content_type,
            'content_id' => $content_id,
            'modifiers' => [],
            'only_on_page' => '',
            'page_link' => $page_link,
            'url' => null,
            'extra_meta' => [
                'description' => null,
                'image' => null,
                'add_time' => null,
                'edit_time' => null,
                'submitter' => null,
                'views' => null,
                'rating' => null,
                'meta_keywords' => null,
                'meta_description' => null,
                'categories' => null,
                'validated' => null,
                'db_row' => null,
            ],
            'permissions' => [
                [
                    'type' => 'zone',
                    'zone_name' => $zone,
                    'is_owned_at_this_level' => false,
                ],
                [
                    'type' => 'page',
                    'zone_name' => $zone,
                    'page_name' => $page,
                    'is_owned_at_this_level' => false,
                ],
            ],
            'has_possible_children' => $has_entries || $has_subcategories,
            'children' => null,

            // These are likely to be changed in individual hooks
            'sitemap_priority' => SITEMAP_IMPORTANCE_MEDIUM,
            'sitemap_refreshfreq' => 'monthly',
        ];

        if ($cma_info['permissions_type_code'] !== null) {
            if (is_array($cma_info['category_field'])) {
                $cma_info['category_field'] = array_pop($cma_info['category_field']);
            }
            $struct['permissions'][] = [
                'type' => 'category',
                'permission_module' => $cma_info['permissions_type_code'],
                'category_name' => @strval($cma_info['is_entry'] ? $row[$cma_info['category_field']] : $content_id),
                'page_name' => $page,
                'is_owned_at_this_level' => true,
            ];
        }

        /* Description field generally not appropriate for Sitemap
        if ((($meta_gather & SITEMAP_GATHER_DESCRIPTION) != 0) && ($cma_info['description_field'] !== null)) {
            $struct['extra_meta']['description'] = $cma_ob->get_description($row, FIELD_RENDER_HTML);
        }
        */

        if ((($meta_gather & SITEMAP_GATHER_IMAGE) != 0) && ($cma_info['image_field'] !== null)) {
            if (method_exists($this, '_find_theme_image')) {
                $this->_find_theme_image($row, $struct);
            } else {
                $struct['extra_meta']['image'] = $cma_ob->get_image_url($row);
                if ($struct['extra_meta']['image'] == '') {
                    $struct['extra_meta']['image'] = null;
                }
            }
        }

        if (($meta_gather & SITEMAP_GATHER_TIMES) != 0) {
            if ($cma_info['add_time_field'] !== null) {
                $struct['extra_meta']['add_time'] = $row[$cma_info['add_time_field']];
            }

            if ($cma_info['edit_time_field'] !== null) {
                $struct['extra_meta']['edit_time'] = $row[$cma_info['edit_time_field']];
            }
        }

        if ((($meta_gather & SITEMAP_GATHER_SUBMITTER) != 0) && ($cma_info['submitter_field'] !== null)) {
            $struct['extra_meta']['submitter'] = $row[$cma_info['submitter_field']];
        }

        if ((($meta_gather & SITEMAP_GATHER_AUTHOR) != 0) && ($cma_info['author_field'] !== null)) {
            $struct['extra_meta']['author'] = $row[$cma_info['author_field']];
        }

        if ((($meta_gather & SITEMAP_GATHER_VIEWS) != 0) && ($cma_info['views_field'] !== null)) {
            $struct['extra_meta']['views'] = $row[$cma_info['views_field']];
        }

        if ((($meta_gather & SITEMAP_GATHER_RATING) != 0) && ($cma_info['feedback_type_code'] !== null)) {
            $rating = $GLOBALS['SITE_DB']->query_select_value('rating', 'AVG(rating)', ['rating_for_type' => $cma_info['feedback_type_code'], 'rating_for_id' => $content_id]);
            $struct['extra_meta']['rating'] = @intval(round($rating));
        }

        if ((($meta_gather & SITEMAP_GATHER_NUM_COMMENTS) != 0) && ($cma_info['feedback_type_code'] !== null)) {
            $num_comments = 0;
            $topic_id = $GLOBALS['FORUM_DRIVER']->find_topic_id_for_topic_identifier(get_option('comments_forum_name'), $cma_info['feedback_type_code'] . '_' . $content_id, do_lang('COMMENT'));
            if ($topic_id !== null) {
                $_comments = $GLOBALS['FORUM_DRIVER']->get_forum_topic_posts($topic_id, $num_comments, 0, 0, false);

                $struct['extra_meta']['num_comments'] = $num_comments;
            }
        }

        if ((($meta_gather & SITEMAP_GATHER_META) != 0) && ($cma_info['seo_type_code'] !== null)) {
            list($struct['extra_meta']['meta_keywords'], $struct['extra_meta']['meta_description']) = seo_meta_get_for($this->content_type, $content_id);
        }

        if ((($meta_gather & SITEMAP_GATHER_VALIDATED) != 0) && ($cma_info['validated_field'] !== null)) {
            $struct['extra_meta']['validated'] = $row[$cma_info['validated_field']];
        }

        if (($meta_gather & SITEMAP_GATHER_DB_ROW) != 0) {
            $struct['extra_meta']['db_row'] = $row;
        }

        return [$content_id, $row, $struct];
    }

    /**
     * Find what fields we should select for the Sitemap to be buildable. We don't want to select too much for perf reasons.
     * Also find out what language fields we should load up for the table (returned by reference).
     *
     * @param  ?array $cma_info CMA info (null: standard for this hook)
     * @param  ?string $table_alias Table alias (null: none)
     * @param  ?array $lang_fields_filtered List of language fields to load (null: not passed)
     * @return array Map between field name and field type
     */
    protected function select_fields(?array $cma_info = null, ?string $table_alias = null, ?array &$lang_fields_filtered = null) : array
    {
        if ($cma_info === null) {
            $cma_info = $this->_get_cma_info();
        }

        $cma_fields = [
            'id',
            'title',
            'category',
            'image',
            'add_time',
            'edit_time',
            'submitter',
            'author',
            'views',
            'validated',
        ];

        $select = [];
        append_content_select_for_fields($select, $cma_info, $cma_fields, $table_alias);

        $table = $cma_info['table'];

        global $TABLE_LANG_FIELDS_CACHE;
        $lang_fields = isset($TABLE_LANG_FIELDS_CACHE[$table]) ? $TABLE_LANG_FIELDS_CACHE[$table] : [];
        $lang_fields_filtered = [];
        foreach ($lang_fields as $field => $type) {
            $f = $field;
            if ($table_alias !== null) {
                $f = $table_alias . '.' . $f;
            }
            if (in_array($f, $select)) {
                $lang_fields_filtered[$f] = $type;
            }
        }

        return $select;
    }

    /**
     * Get a list of child nodes, from what we know from the CMA hook.
     *
     * @param  ID_TEXT $content_id The content ID
     * @param  ID_TEXT $page_link The page-link we are finding
     * @param  ?mixed $callback Callback function to send discovered page-links to (null: return)
     * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
     * @param  ?integer $child_cutoff Maximum number of children before we cut off all children (null: no limit)
     * @param  ?integer $max_recurse_depth How deep to go from the Sitemap root (null: no limit)
     * @param  integer $recurse_level Our recursion depth (used to limit recursion, or to calculate importance of page-link, used for instance by XML Sitemap [deeper is typically less important])
     * @param  integer $options A bitmask of SITEMAP_GEN_* options
     * @param  ID_TEXT $zone The zone we will consider ourselves to be operating in (needed due to transparent redirects feature)
     * @param  integer $meta_gather A bitmask of SITEMAP_GATHER_* constants, of extra data to include
     * @param  ?array $row Database row (null: lookup)
     * @param  string $extra_where_entries Extra SQL piece for considering which entries to load
     * @param  ?string $explicit_order_by_entries Order by for entries (null: alphabetical title)
     * @param  ?string $explicit_order_by_subcategories Order by for categories (null: alphabetical title)
     * @return ?array Child nodes (null: not retrieved yet)
     */
    protected function _get_children_nodes(string $content_id, string $page_link, $callback, ?array $valid_node_types, ?int $child_cutoff, ?int $max_recurse_depth, int $recurse_level, int $options, string $zone, int $meta_gather, ?array $row, string $extra_where_entries = '', ?string $explicit_order_by_entries = null, ?string $explicit_order_by_subcategories = null) : ?array
    {
        if (($max_recurse_depth !== null) && ($recurse_level >= $max_recurse_depth)) {
            return null;
        }

        $this->_make_zone_concrete($zone, $page_link);

        $cma_info = $this->_get_cma_info();

        $matches = [];
        preg_match('#^([^:]*):([^:]*):([^:]*):([^:]*)#', $page_link, $matches);
        $page = $matches[2];

        $children = [];

        $has_entries = ($cma_info['is_category']) && ($this->entry_content_type !== null);
        $has_subcategories = ($cma_info['parent_spec__parent_name'] !== null) && ($cma_info['parent_category_meta_aware_type'] == $this->content_type);
        if (!$has_entries && !$has_subcategories) {
            return null;
        }

        $require_permission_support = (($options & SITEMAP_GEN_REQUIRE_PERMISSION_SUPPORT) != 0);

        $consider_validation = (($options & SITEMAP_GEN_CONSIDER_VALIDATION) != 0);

        // Entries...
        if ($has_entries) {
            for ($i = 0; $i < count($this->entry_content_type); $i++) {
                $entry_content_type = $this->entry_content_type[$i];
                $entry_sitetree_hook = $this->entry_sitetree_hook[$i];

                require_code('content');
                $cma_entry_ob = get_content_object($entry_content_type);
                $cma_entry_info = $cma_entry_ob->info();

                if ((!$require_permission_support) || (($cma_entry_info['permissions_type_code'] !== null) && ($cma_entry_info['is_category']/*Unlikely to be true!*/) && (!$cma_entry_info['is_entry']))) {
                    $child_hook_ob = $this->_get_sitemap_object($entry_sitetree_hook);

                    $children_entries = [];

                    $privacy_join = '';
                    $privacy_where = '';
                    if ($cma_entry_info['support_privacy']) {
                        if (addon_installed('content_privacy')) {
                            require_code('content_privacy');
                            list($privacy_join, $privacy_where) = get_privacy_where_clause($entry_content_type, 'r');
                        }
                    }

                    $where = [];
                    if (is_array($cma_entry_info['category_field'])) {
                        $cma_entry_info['category_field'] = array_pop($cma_entry_info['category_field']);
                    }
                    $where[$cma_entry_info['category_field']] = $cma_info['id_field_numeric'] ? intval($content_id) : $content_id;
                    if (($consider_validation) && ($cma_entry_info['validated_field'] !== null)) {
                        $where[$cma_entry_info['validated_field']] = 1;
                    }
                    $table = $cma_entry_info['table'] . ' r';
                    $table .= $privacy_join;

                    $lang_fields = [];
                    $select = $this->select_fields($cma_entry_info, 'r', $lang_fields);
                    if ($explicit_order_by_entries !== null) {
                        $select[] = preg_replace('# .*$#', '', $explicit_order_by_entries);
                    }

                    $db = get_db_for($cma_entry_info['table']);

                    $max_rows_per_loop = ($child_cutoff === null) ? SITEMAP_MAX_ROWS_PER_LOOP : min($child_cutoff + 1, SITEMAP_MAX_ROWS_PER_LOOP);

                    $start = 0;
                    do {
                        $rows = $cma_entry_info['db']->query_select($table, $select, $where, $extra_where_entries . $privacy_where . (($explicit_order_by_entries === null) ? '' : (' ORDER BY ' . $explicit_order_by_entries)), $max_rows_per_loop, $start, false, $lang_fields);

                        if (($start == 0) && ($child_cutoff !== null) && (count($rows) > $child_cutoff)) {
                            $rows = []; // Too many to process. We don't do with a COUNT(*) query because on balance of probability there won't be too many child rows and we can save a count query at the cost of the small risk of loading excess data
                        }

                        $child_page = ($cma_entry_info['module'] == $cma_info['module']) ? $page : $cma_entry_info['module']; // assumed in same zone
                        foreach ($rows as $child_row) {
                            $child_page_link = $zone . ':' . $child_page . ':' . $child_hook_ob->screen_type . ':' . ($cma_entry_info['id_field_numeric'] ? strval($child_row[$cma_entry_info['id_field']]) : $child_row[$cma_entry_info['id_field']]);
                            $child_node = $child_hook_ob->get_node($child_page_link, $callback, $valid_node_types, $child_cutoff, $max_recurse_depth, $recurse_level + 1, $options, $zone, $meta_gather, $child_row);
                            if ($child_node !== null) {
                                $children_entries[] = $child_node;
                            }
                        }

                        $start += $max_rows_per_loop;
                    } while (count($rows) == $max_rows_per_loop);

                    if ($explicit_order_by_entries === null) {
                        sort_maps_by($children_entries, 'title', false, true);
                    }
                    $children = array_merge($children, $children_entries);
                }
            }
        }

        // Subcategories...
        if ($has_subcategories) {
            $children_categories = [];

            $where = [];
            $where[$cma_info['parent_spec__parent_name']] = $cma_info['category_is_string'] ? $content_id : intval($content_id);
            if (($consider_validation) && ($cma_info['validated_field'] !== null)) {
                $where[$cma_info['validated_field']] = 1;
            }
            $table = $cma_info['parent_spec__table_name'] . ' r';

            $lang_fields = [];
            if ($cma_info['parent_spec__table_name'] != $cma_info['table']) {
                $select = $this->select_fields($cma_info, 'r2', $lang_fields);
                $select[] = 'r.' . $cma_info['parent_spec__field_name'];
                $table .= ' JOIN ' . $cma_info['db']->get_table_prefix() . $cma_info['table'] . ' r2 ON r2.' . $cma_info['id_field'] . '=r.' . $cma_info['parent_spec__field_name'];
            } else {
                $select = $this->select_fields($cma_info, 'r', $lang_fields);
            }
            if ($explicit_order_by_subcategories !== null) {
                $select[] = preg_replace('# .*$#', '', $explicit_order_by_subcategories);
            }

            $db = get_db_for($cma_info['table']);

            $max_rows_per_loop = ($child_cutoff === null) ? SITEMAP_MAX_ROWS_PER_LOOP : min($child_cutoff + 1, SITEMAP_MAX_ROWS_PER_LOOP);

            $lang_fields = isset($GLOBALS['TABLE_LANG_FIELDS_CACHE'][$cma_info['parent_spec__table_name']]) ? $GLOBALS['TABLE_LANG_FIELDS_CACHE'][$cma_info['parent_spec__table_name']] : [];

            $start = 0;
            do {
                $rows = $cma_info['db']->query_select($table, $select, $where, (($explicit_order_by_subcategories === null) ? '' : ('ORDER BY ' . $explicit_order_by_subcategories)), $max_rows_per_loop, $start, false, $lang_fields);

                if (($start == 0) && ($child_cutoff !== null) && (count($rows) > $child_cutoff)) {
                    $rows = []; // Too many to process. We don't do with a COUNT(*) query because on balance of probability there won't be too many child rows and we can save a count query at the cost of the small risk of loading excess data
                }

                foreach ($rows as $child_row) {
                    // FUDGE
                    if (($table == 'galleries r') && (addon_installed('galleries')) && (get_option('show_empty_galleries') == '0')) {
                        require_code('galleries');
                        if (!gallery_has_content($child_row['name'])) {
                            continue;
                        }
                    }

                    if ($this->content_type == 'comcode_page') {
                        $child_page_link = $zone . ':' . $child_row['the_page'];
                    } else {
                        $child_page_link = $zone . ':' . $page . ':' . $this->screen_type . ':' . ($cma_info['category_is_string'] ? $child_row[$cma_info['parent_spec__field_name']] : strval($child_row[$cma_info['parent_spec__field_name']]));
                    }
                    $child_node = $this->get_node($child_page_link, $callback, $valid_node_types, $child_cutoff, $max_recurse_depth, $recurse_level + 1, $options, $zone, $meta_gather, $child_row);
                    if ($child_node !== null) {
                        $children_categories[] = $child_node;
                    }
                }

                $start += $max_rows_per_loop;
            } while (count($rows) == $max_rows_per_loop);

            if ($explicit_order_by_subcategories === null) {
                sort_maps_by($children_categories, 'title', false, true);
            }
            $children = array_merge($children, $children_categories);
        }

        return $children;
    }

    /**
     * Convert a page-link to a category ID and category permission module type.
     *
     * @param  ID_TEXT $page_link The page-link
     * @return ?array The pair (null: permission modules not handled)
     */
    public function extract_child_page_link_permission_pair(string $page_link) : ?array
    {
        $matches = [];
        preg_match('#^([^:]*):([^:]*):browse:(.*)$#', $page_link, $matches);
        $id = $matches[3];

        $cma_info = $this->_get_cma_info();

        return [$id, $cma_info['permissions_type_code']];
    }
}

/**
 * Get all the details (links) of our page groupings.
 *
 * @return array List of link tuples (one of the elements of which defines the page grouping -- see the page grouping hooks to see the structure)
 */
function get_page_grouping_links() : array
{
    static $links = null;
    if ($links === null) {
        $links = [];

        $hooks = find_all_hook_obs('systems', 'page_groupings', 'Hook_page_groupings_');
        foreach ($hooks as $ob) {
            $links = array_merge($links, $ob->run());
        }
    }
    return $links;
}

/**
 * Get Comcode pages from a zone, that sit in the root of that zone.
 *
 * @param  ID_TEXT $zone The zone to get for
 * @param  boolean $include_zone Use page-links in the mapping rather than just page names
 * @return array Root Comcode pages, mapping page name to validation status
 */
function get_root_comcode_pages(string $zone, bool $include_zone = false) : array
{
    /*
    $rows[$zone] = $GLOBALS['SITE_DB']->query_select('comcode_pages', ['the_page', 'p_validated'], ['the_zone' => $zone, 'p_parent_page' => '']);
    return collapse_2d_complexity('the_page', 'p_validated', $rows[$zone]);
    */

    // This uses more memory than the above, but is needed as pages may not have got into the database yet...

    static $cache = [];
    if (isset($cache[$zone][$include_zone])) {
        return $cache[$zone][$include_zone];
    }

    disable_php_memory_limit();

    $pages = find_all_pages_wrap($zone, false, /*$consider_redirects = */true, /*$show_method = */0, /*$page_type = */'comcode');

    static $rows = [];
    if (!isset($rows[$zone])) {
        $rows[$zone] = $GLOBALS['SITE_DB']->query_select('comcode_pages', ['the_page', 'p_validated', 'p_parent_page'], ['the_zone' => $zone]);
    }
    $non_root = [];
    $root = [];
    foreach ($rows[$zone] as $row) {
        if (($row['p_parent_page'] == '') && (isset($pages[$row['p_parent_page']]))) {
            $root[$row['the_page']] = $row['p_validated'];
        } else {
            $non_root[$row['the_page']] = $row['p_validated'];
        }
    }

    foreach ($pages as $page => $page_type) {
        if (isset($non_root[$page])) {
            unset($pages[$page]);
        }
    }

    $page_links = [];
    foreach ($pages as $page => $page_type) {
        if (is_integer($page)) {
            $page = strval($page);
        }

        if ($include_zone) {
            $key = $zone . ':' . $page;
        } else {
            $key = $page;
        }

        $page_links[$key] = isset($root[$page]) ? $root[$page] : 1;
    }
    $cache[$zone][$include_zone] = $page_links;
    return $page_links;
}

/**
 * Get an HTML selection list for some part of the Sitemap.
 *
 * @param  ID_TEXT $root_page_link The page-link we are starting from
 * @param  boolean $under_only Create from under this node, rather than at it
 * @param  ?ID_TEXT $default Default selection (null: none)
 * @param  ?array $valid_node_types List of node types we will return/recurse-through (null: no limit)
 * @param  ?array $valid_selectable_content_types List of node types we will allow to be selectable (null: no limit)
 * @param  integer $check_permissions_against Check permissions according to this bitmask of possibilities (requiring all in the bitmask to be matched)
 * @param  ?MEMBER $check_permissions_for The member we are checking permissions for (null: current member)
 * @param  boolean $consider_validation Whether to filter out non-validated entries if the $check_permissions_for user doesn't have the privilege to see them AND doesn't own them
 * @param  ?MEMBER $only_owned The member we are only finding owned content of (null: no such limit); nodes leading up to owned content will be shown, but not as selectable
 * @param  boolean $use_compound_list Whether to produce selection IDs as a comma-separated list of all selectable sub-nodes
 * @param  ?mixed $filter_func Filter function for limiting what rows will be included (null: none)
 * @return Tempcode List
 */
function create_selection_list(string $root_page_link, bool $under_only = false, ?string $default = null, ?array $valid_node_types = null, ?array $valid_selectable_content_types = null, int $check_permissions_against = 0, ?int $check_permissions_for = null, bool $consider_validation = false, ?int $only_owned = null, bool $use_compound_list = false, $filter_func = null) : object
{
    if ($check_permissions_for === null) {
        $check_permissions_for = get_member();
    }

    $options = SITEMAP_GEN_NONE;
    $options |= SITEMAP_GEN_CHECK_PERMS;
    if ($consider_validation) {
        $options |= SITEMAP_GEN_CONSIDER_VALIDATION;
    }

    $out = new Tempcode();
    $root_node = retrieve_sitemap_node($root_page_link, null, null, null, null, $options, '_SEARCH', ($filter_func === null) ? 0 : SITEMAP_GATHER_DB_ROW);

    if (!$under_only) {
        _create_selection_list($out, $root_node, $default, $valid_selectable_content_types, $check_permissions_against, $check_permissions_for, $only_owned, $use_compound_list, $filter_func);
    } else {
        if (isset($root_node['children'])) {
            foreach ($root_node['children'] as $child_node) {
                _create_selection_list($out, $child_node, $default, $valid_selectable_content_types, $check_permissions_against, $check_permissions_for, $only_owned, $use_compound_list, $filter_func);
            }
        }
    }

    return $out;
}

/**
 * Recurse function for create_selection_list.
 *
 * @param  Tempcode $out Output Tempcode
 * @param  array $node Node being recursed
 * @param  ?ID_TEXT $default Default selection (null: none)
 * @param  ?array $valid_selectable_content_types List of node types we will allow to be selectable (null: no limit)
 * @param  integer $check_permissions_against Check permissions according to this bitmask of possibilities (requiring all in the bitmask to be matched)
 * @param  ?MEMBER $check_permissions_for The member we are checking permissions for (null: current member)
 * @param  ?MEMBER $only_owned The member we are only finding owned content of (null: no such limit); nodes leading up to owned content will be shown, but not as selectable
 * @param  boolean $use_compound_list Whether to produce selection IDs as a comma-separated list of all selectable sub-nodes
 * @param  ?mixed $filter_func Filter function for limiting what rows will be included (null: none)
 * @param  integer $depth Recursion depth
 * @return string Compound list
 *
 * @ignore
 */
function _create_selection_list(object &$out, array $node, ?string $default, ?array $valid_selectable_content_types, int $check_permissions_against, ?int $check_permissions_for, ?int $only_owned, bool $use_compound_list, $filter_func, int $depth = 0) : string
{
    // Skip?
    if ($check_permissions_for !== null) {
        foreach ($node['permissions'] as $permission) {
            if ($permission['type'] == 'privilege') {
                if (($check_permissions_against & CSL_PERMISSION_ADD) != 0) {
                    if (preg_match('#^submit_#', $permission['privilege']) != 0) {
                        if (!has_privilege($check_permissions_for, $permission['privilege'], $permission['page_name'], [$permission['permission_module'], $permission['category_name']])) {
                            return '';
                        }
                    }
                }
                if (($check_permissions_against & CSL_PERMISSION_EDIT) != 0) {
                    if (preg_match('#^edit_#', $permission['privilege']) != 0) {
                        if (!has_privilege($check_permissions_for, $permission['privilege'], $permission['page_name'], [$permission['permission_module'], $permission['category_name']])) {
                            return '';
                        }
                    }
                }
                if (($check_permissions_against & CSL_PERMISSION_DELETE) != 0) {
                    if (preg_match('#^delete_#', $permission['privilege']) != 0) {
                        if (!has_privilege($check_permissions_for, $permission['privilege'], $permission['page_name'], [$permission['permission_module'], $permission['category_name']])) {
                            return '';
                        }
                    }
                }
            }
        }
    }
    if ($only_owned !== null) {
        if ($node['submitter'] != $only_owned) {
            return '';
        }
    }
    if ($filter_func !== null) {
        if (!call_user_func($filter_func, $node)) {
            return '';
        }
    }

    $content_id = $node['content_id'];
    if ($content_id === null) {
        $content_id = $node['page_link'];
    }
    if ($content_id === null) {
        $content_id = '';
    }

    // Recurse, working out $children and $compound_list
    $children = new Tempcode();
    $child_compound_list = '';
    if (isset($node['children'])) {
        foreach ($node['children'] as $child_node) {
            $_child_compound_list = _create_selection_list($children, $child_node, $default, $valid_selectable_content_types, $check_permissions_against, $check_permissions_for, $only_owned, $use_compound_list, $filter_func, $depth + 1);
            if ($_child_compound_list != '') {
                $child_compound_list .= ($child_compound_list != '') ? (',' . $_child_compound_list) : $_child_compound_list;
            }
        }
    }
    $compound_list = $content_id . (($child_compound_list != '') ? (',' . $child_compound_list) : '');

    // Handle node
    $title = str_repeat('-', $depth) . $node['title']->evaluate();
    $selected = ($content_id === (is_integer($default) ? strval($default) : $default));
    $disabled = (($valid_selectable_content_types !== null) && (!in_array($node['content_type'], $valid_selectable_content_types)));
    $_content_id = $use_compound_list ? $compound_list : $content_id;
    $out->attach(form_input_list_entry($_content_id, $selected, $title, false, $disabled));

    // Attach recursion result
    $out->attach($children);

    return $compound_list;
}
