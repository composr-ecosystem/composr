<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    downloads
 */

/*EXTRA FUNCTIONS: shell_exec|zip_\w+*/

/**
 * Interstitial page for downloads.
 */
function download_gateway_script()
{
    if (!addon_installed('downloads')) {
        warn_exit(do_lang_tempcode('MISSING_ADDON', escape_html('downloads')));
    }

    header('X-Robots-Tag: noindex');

    require_code('downloads');

    $id = get_param_integer('id');
    $result = $GLOBALS['SITE_DB']->query_select('download_downloads', ['name', 'url_redirect'], ['id' => $id], '', 1);
    if (!isset($result[0])) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download'));
    }

    $name = $result[0]['name'];

    $url = $result[0]['url_redirect'];

    $download_url = generate_dload_url($id, false);

    if (!looks_like_url($url)) {
        list($zone, $attributes) = page_link_decode($url);
        $url = find_script('iframe') . '?zone=' . urlencode($zone);
        if (!empty($attributes)) {
            $url .= '&' . http_build_query($attributes);
        }
        $keep = symbol_tempcode('KEEP', ['0', '1']);
        $url .= $keep->evaluate();
    }

    attach_to_screen_header('<meta http-equiv="refresh" content="2; URL=' . $download_url->evaluate() . '">');

    if ($url != '') {
        require_lang('downloads');
        $title = get_screen_title('DOWNLOAD_GATEWAY', true, [escape_html($name)]);
        $tpl = do_template('DOWNLOAD_GATEWAY_SCREEN', ['_GUID' => 'ed996e64c34d2c26e43712ffd62c5236', 'TITLE' => $title, 'NAME' => $name, 'ID' => strval($id), 'DOWNLOAD_URL' => $download_url, 'URL' => $url]);
        $tpl_wrapped = globalise($tpl, null, '', true, true);
        $tpl_wrapped->evaluate_echo();
    } else {
        header('Location:' . escape_header($download_url->evaluate())); // assign_refresh not used, as it needs to be an invisible hop
    }
}

/**
 * Farm out the files for download.
 */
function dload_script()
{
    if (!addon_installed('downloads')) {
        warn_exit(do_lang_tempcode('MISSING_ADDON', escape_html('downloads')));
    }

    // Closed site
    $site_closed = get_option('site_closed');
    if (($site_closed != '0') && (!has_privilege(get_member(), 'access_closed_site')) && (!$GLOBALS['IS_ACTUALLY_ADMIN'])) {
        http_response_code(503);
        header('Content-Type: text/plain; charset=' . get_charset());
        @exit(get_option('closed'));
    }

    require_code('anti_leech');
    check_anti_leech();

    require_lang('downloads');
    require_code('downloads');

    // Security: We use resource GUID if Commandr is installed to prevent content scraping
    // LEGACY: The cms_version_time is to ensure we do not do this until 11 beta8
    require_code('version');
    if (addon_installed('commandr') && ((cms_version_time() > 1741833435) || $GLOBALS['DEV_MODE'])) {
        require_code('resource_fs');

        $__id = get_param_string('id');
        $_id = find_id_via_guid($__id);
        if ($_id === null) {
            warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download'));
        }
        $id = intval($_id);
    } else {
        $id = get_param_integer('id');
    }

    // Lookup
    $rows = $GLOBALS['SITE_DB']->query_select('download_downloads', ['*'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download'));
    }
    $myrow = $rows[0];

    // Permission
    if (!has_category_access(get_member(), 'downloads', strval($myrow['category_id']))) {
        $redirect_url = get_download_category_purchase_url($myrow['category_id']);
        if ($redirect_url !== null) {
            redirect_exit($redirect_url);
        }

        access_denied('CATEGORY_ACCESS');
    }
    $may_download = has_privilege(get_member(), 'download', 'downloads', ['downloads', strval($myrow['category_id'])]);
    if (!$may_download) {
        access_denied('PRIVILEGE', 'download');
    }
    if (addon_installed('content_privacy')) {
        require_code('content_privacy');
        check_privacy('download', strval($id));
    }

    // Cost?
    $got_before = $GLOBALS['SITE_DB']->query_select_value_if_there('download_logging', 'member_id', ['member_id' => get_member(), 'id' => $id]);
    if (addon_installed('points')) {
        if ($myrow['download_cost'] > 0) {
            require_code('points2');

            $member_id = get_member();
            if (is_guest($member_id)) {
                access_denied('NOT_AS_GUEST');
            }

            // Check they haven't downloaded this before (they only get charged once - maybe they are resuming)
            if ($got_before === null) {
                $cost = $myrow['download_cost'];

                $dif = $cost - points_balance($member_id);

                if ($dif > 0) {
                    require_lang('points');
                    warn_exit(do_lang_tempcode('LACKING_POINTS', escape_html(integer_format($dif, 0))));
                }
                require_code('points2');
                if ($myrow['download_submitter_gets_points'] == 1) {
                    points_transact($member_id, $myrow['submitter'], do_lang('DOWNLOADED_THIS', get_translated_text($myrow['name'])), $cost, 0, 1, true, 0, 'download', 'download', strval($id));
                } else {
                    points_debit_member($member_id, do_lang('DOWNLOADED_THIS', get_translated_text($myrow['name'])), $cost, 0, 1, false, 0, 'download', 'download', strval($id));
                }
            }
        }
    }

    // Filename
    $full = $myrow['url'];
    require_code('files');
    $extension = cms_strtolower_ascii(get_file_extension($full));
    if (url_is_local($full)) {
        $_full = get_custom_file_base() . '/' . rawurldecode(/*filter_naughty*/($full));
    } else {
        $_full = rawurldecode($full);
    }

    // Send header
    if ((strpos($myrow['original_filename'], "\n") !== false) || (strpos($myrow['original_filename'], "\r") !== false)) {
        log_hack_attack_and_exit('HEADER_SPLIT_HACK');
        warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('604ae8d6a3d15a789161233e6e8bdae2')));
    }
    require_code('mime_types');
    $mime_type = get_mime_type(get_file_extension($myrow['original_filename']), false);
    if ((get_option('immediate_downloads') == '1') && ($mime_type != 'application/octet-stream')) {
        header('Content-Type: ' . $mime_type);
        header('Content-Disposition: inline; filename="' . escape_header($myrow['original_filename'], true) . '"');
    } else {
        header('Content-Type: application/octet-stream');
        header('Content-Disposition: attachment; filename="' . escape_header($myrow['original_filename'], true) . '"');
    }

    cms_ini_set('ocproducts.xss_detect', '0');

    // Is it non-local? If so, redirect
    if ((!url_is_local($full)) || (!file_exists(get_custom_file_base() . '/' . rawurldecode(filter_naughty($full))))) {
        if (url_is_local($full)) {
            $full = get_custom_base_url() . '/' . $full;
        }
        if ((strpos($full, "\n") !== false) || (strpos($full, "\r") !== false)) {
            log_hack_attack_and_exit('HEADER_SPLIT_HACK');
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('bff797095d1c5197af14340db75cc745')));
        }
        header('Location: ' . escape_header($full)); // assign_refresh not used, as no UI here
        log_download($id, 0, $got_before !== null); // Bandwidth used is 0 for an external download
        return;
    }

    // Some basic security: don't fopen php files
    if ($extension == 'php') {
        log_hack_attack_and_exit('PHP_DOWNLOAD_INNOCENT', integer_format($id));
        warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('e62783cf99dc5213a57ccbc7502dd673')));
    }

    // Size, bandwidth
    if (!is_file($_full)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
    }
    $size = filesize($_full);
    if ($got_before === null) {
        $bandwidth = $GLOBALS['SITE_DB']->query_value_if_there('SELECT SUM(file_size) AS answer FROM ' . get_table_prefix() . 'download_logging l LEFT JOIN ' . get_table_prefix() . 'download_downloads d ON l.id=d.id WHERE date_and_time>' . strval(time() - 24 * 60 * 60 * 32) . ' AND date_and_time<=' . strval(time()));
        if ($bandwidth === null) {
            $bandwidth = 0.0;
        }
        if (!is_float($bandwidth)) {
            $bandwidth = floatval($bandwidth);
        }
        if ((($bandwidth + floatval($size)) > floatval(get_option('maximum_download')) * 1024.0 * 1024.0 * 1024.0) && (!has_privilege(get_member(), 'bypass_bandwidth_restriction'))) {
            warn_exit(do_lang_tempcode('TOO_MUCH_DOWNLOAD'));
        }

        require_code('files2');
        check_shared_bandwidth_usage($size);
    }

    header('Accept-Ranges: bytes');

    // Caching
    $time = ($myrow['edit_date'] === null) ? $myrow['add_date'] : $myrow['edit_date'];
    $time = max($time, filemtime($_full));
    set_http_caching($time);

    // Default to no resume
    $from = 0;
    $new_length = $size;

    disable_output_compression(); // So ranges work, plus workaround to bugs caused by IE being 'smart' http://blogs.msdn.com/b/ieinternals/archive/2014/10/21/http-compression-optimize-file-formats-with-deflate.aspx

    // They're trying to resume (so update our range)
    $httprange = $_SERVER['HTTP_RANGE'];
    if (strlen($httprange) > 0) {
        $_range = explode('=', $_SERVER['HTTP_RANGE']);
        if (count($_range) == 2) {
            if (strpos($_range[0], '-') === false) {
                $_range = array_reverse($_range);
            }
            $range = $_range[0];
            if (substr($range, 0, 1) == '-') {
                $range = strval($size - intval(substr($range, 1)) - 1) . $range;
            }
            $range = str_replace('-1099511627775', '-', $range); // FUDGE: curl does this when specifying no end range
            if (substr($range, -1, 1) == '-') {
                $range .= strval($size - 1);
            }
            $bits = explode('-', $range);
            if (count($bits) == 2) {
                list($from, $to) = array_map('intval', $bits);
                if ((min($to, $size) - $from != 0) || ($from == 0)) {
                    $new_length = min($to, $size) - $from;

                    header('HTTP/1.1 206 Partial Content');
                    header('Content-Range: bytes ' . $range . '/' . strval($size));
                } else {
                    $from = 0;
                }
            }
        }
    }
    header('Content-Length: ' . strval($new_length));
    cms_disable_time_limit();
    error_reporting(0);
    cms_ob_end_clean();

    if ($_SERVER['REQUEST_METHOD'] == 'HEAD') {
        return;
    }

    if ($from == 0) {
        log_download($id, $size, $got_before !== null);
    }

    // Send actual data
    $myfile = fopen($_full, 'rb');
    fseek($myfile, $from);
    if ($size == $new_length) {
        fpassthru($myfile);
    } else {
        $i = 0;
        while ($i < $new_length) {
            $content = fread($myfile, min($new_length - $i, 1048576));
            echo $content;
            $len = strlen($content);
            if ($len == 0) {
                break;
            }
            $i += $len;
        }
    }
    @fclose($myfile);
    /*

    Security note... at the download adding/editing stage, we ensured that
    only files accessible to the web server (in raw form) could end up in
    our database.
    Therefore we did not check here that our file was accessible in raw
    form.

    */
}

/**
 * Add a download category.
 *
 * @param  SHORT_TEXT $category The name of the download category
 * @param  ?AUTO_LINK $parent_id The parent download category (null: this is a root category)
 * @param  LONG_TEXT $description A description
 * @param  LONG_TEXT $notes Hidden notes pertaining to this download category
 * @param  URLPATH $rep_image The representative image for the category (blank: none)
 * @param  ?AUTO_LINK $id Force an ID (null: don't force an ID)
 * @param  ?TIME $add_time Add time (null: now)
 * @param  ?SHORT_TEXT $meta_keywords Meta keywords for this resource (null: do not edit) (blank: implicit)
 * @param  ?LONG_TEXT $meta_description Meta description for this resource (null: do not edit) (blank: implicit)
 * @return AUTO_LINK The ID of the newly added download category
 */
function add_download_category(string $category, ?int $parent_id, string $description, string $notes = '', string $rep_image = '', ?int $id = null, ?int $add_time = null, ?string $meta_keywords = '', ?string $meta_description = '') : int
{
    require_code('global4');
    prevent_double_submit('ADD_DOWNLOAD_CATEGORY', null, $category);

    if ($add_time === null) {
        $add_time = time();
    }

    $map = [
        'rep_image' => $rep_image,
        'add_date' => $add_time,
        'notes' => $notes,
        'parent_id' => $parent_id,
    ];
    $map += insert_lang('category', $category, 2);
    $map += insert_lang_comcode('the_description', $description, 2);
    if ($id !== null) {
        $map['id'] = $id;
    }
    $id = $GLOBALS['SITE_DB']->query_insert('download_categories', $map, true);

    reorganise_uploads__download_categories(['id' => $id]);

    log_it('ADD_DOWNLOAD_CATEGORY', strval($id), $category);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download_category', strval($id), null, null, true);
    }

    require_code('content2');
    if (($meta_keywords == '') && ($meta_description == '')) {
        seo_meta_set_for_implicit('downloads_category', strval($id), [$category, $description], $description);
    } else {
        seo_meta_set_for_explicit('downloads_category', strval($id), $meta_keywords, $meta_description);
    }

    if ($parent_id !== null) {
        require_code('notifications2');
        copy_notifications_to_new_child('download', strval($parent_id), strval($id));
    }

    require_code('member_mentions');
    dispatch_member_mention_notifications('download_category', strval($id));

    require_code('downloads');
    require_code('sitemap_xml');
    notify_sitemap_node_add('_SEARCH:downloads:browse:' . strval($id));

    return $id;
}

/**
 * Edit the given download category with the new details given.
 *
 * @param  AUTO_LINK $category_id The ID of the category being edited
 * @param  SHORT_TEXT $category The name of the download category
 * @param  ?AUTO_LINK $parent_id The parent download category (null: root)
 * @param  LONG_TEXT $description A description
 * @param  LONG_TEXT $notes Hidden notes pertaining to this download category
 * @param  ?URLPATH $rep_image The representative image for the category (blank: none) (null: do not edit)
 * @param  ?SHORT_TEXT $meta_keywords Meta keywords for this resource (null: do not edit)
 * @param  ?LONG_TEXT $meta_description Meta description for this resource (null: do not edit)
 * @param  ?TIME $add_time Add time (null: do not change)
 */
function edit_download_category(int $category_id, string $category, ?int $parent_id, string $description, string $notes, ?string $rep_image, ?string $meta_keywords, ?string $meta_description, ?int $add_time = null)
{
    $under_category_id = $parent_id;
    while (($under_category_id !== null) && ($under_category_id != INTEGER_MAGIC_NULL)) {
        if ($category_id == $under_category_id) {
            warn_exit(do_lang_tempcode('OWN_PARENT_ERROR', 'download_category'));
        }
        $_under_category_id = $GLOBALS['SITE_DB']->query_select_value('download_categories', 'parent_id', ['id' => $under_category_id]);
        if ($under_category_id === $_under_category_id) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('01014b1155ab555188da30df656d7917')));
        }
        $under_category_id = $_under_category_id;
    }

    require_code('urls2');
    suggest_new_idmoniker_for('downloads', 'browse', strval($category_id), '', $category);

    $rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['category', 'the_description'], ['id' => $category_id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_category'));
    }
    $_category = $rows[0]['category'];
    $_description = $rows[0]['the_description'];

    $update_map = [
        'notes' => $notes,
        'parent_id' => $parent_id,
    ];
    $update_map += lang_remap('category', $_category, $category);
    $update_map += lang_remap_comcode('the_description', $_description, $description);
    if ($rep_image !== null) {
        $update_map['rep_image'] = $rep_image;
        require_code('files2');
        delete_upload('uploads/repimages', 'download_categories', 'rep_image', 'id', $category_id, $rep_image);
    }
    if ($add_time !== null) {
        $update_map['add_date'] = $add_time;
    }
    $GLOBALS['SITE_DB']->query_update('download_categories', $update_map, ['id' => $category_id], '', 1);

    require_code('content2');
    seo_meta_set_for_explicit('downloads_category', strval($category_id), $meta_keywords, $meta_description);

    reorganise_uploads__download_categories(['id' => $category_id]);

    log_it('EDIT_DOWNLOAD_CATEGORY', strval($category_id), $category);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download_category', strval($category_id));
    }

    require_code('downloads');
    require_code('sitemap_xml');
    notify_sitemap_node_edit('_SEARCH:downloads:browse:' . strval($category_id));
}

/**
 * Delete a download category.
 *
 * @param  AUTO_LINK $category_id The download category to delete
 */
function delete_download_category(int $category_id)
{
    $root_category = $GLOBALS['SITE_DB']->query_select_value('download_categories', 'MIN(id)');
    if ($category_id == $root_category) {
        warn_exit(do_lang_tempcode('NO_DELETE_ROOT', 'download_category'));
    }

    $rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['category', 'the_description', 'parent_id'], ['id' => $category_id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_category'));
    }
    $category = $rows[0]['category'];
    $description = $rows[0]['the_description'];

    require_code('files2');
    delete_upload('uploads/repimages', 'download_categories', 'rep_image', 'id', $category_id);

    if (addon_installed('catalogues')) {
        update_catalogue_content_ref('download_category', strval($category_id), '');
    }

    $GLOBALS['SITE_DB']->query_delete('download_categories', ['id' => $category_id], '', 1);
    $GLOBALS['SITE_DB']->query_update('download_downloads', ['category_id' => $rows[0]['parent_id']], ['category_id' => $category_id]);
    $GLOBALS['SITE_DB']->query_update('download_categories', ['parent_id' => $rows[0]['parent_id']], ['parent_id' => $category_id]);

    delete_lang($category);
    delete_lang($description);

    require_code('content2');
    seo_meta_erase_storage('downloads_category', strval($category_id));

    $GLOBALS['SITE_DB']->query_delete('group_category_access', ['module_the_name' => 'downloads', 'category_name' => strval($category_id)]);
    $GLOBALS['SITE_DB']->query_delete('group_privileges', ['module_the_name' => 'downloads', 'category_name' => strval($category_id)]);

    $GLOBALS['SITE_DB']->query_delete('ecom_prods_permissions', ['p_module' => 'downloads', 'p_category' => strval($category_id)]);

    $GLOBALS['SITE_DB']->query_update('url_id_monikers', ['m_deprecated' => 1], ['m_resource_page' => 'downloads', 'm_resource_type' => 'browse', 'm_resource_id' => strval($category_id)]);

    require_code('uploads2');
    clean_empty_upload_directories('uploads/repimages');

    log_it('DELETE_DOWNLOAD_CATEGORY', strval($category_id), get_translated_text($category));

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        expunge_resource_fs_moniker('download_category', strval($category_id));
    }

    require_code('sitemap_xml');
    notify_sitemap_node_delete('_SEARCH:downloads:browse:' . strval($category_id));

    if (addon_installed('ecommerce')) {
        require_code('ecommerce_permission_products');
        delete_prod_permission('downloads', strval($category_id));
    }
}

/**
 * Create a data-mash from the file at a URL. This is data useful for the search engine.
 *
 * @param  URLPATH $url The URL to make a data-mash of, or a filename if $data isn't blank
 * @param  ?string $data Data (null: use URL)
 * @param  ?ID_TEXT $extension File extension (null: get from URL)
 * @param  boolean $direct_path Whether a direct file path was given instead of a URL
 * @return LONG_TEXT The data-mash
 */
function create_data_mash(string $url, ?string $data = null, ?string $extension = null, bool $direct_path = false) : string
{
    if (get_option('dload_search_index') == '0') {
        return '';
    }

    if (running_script('stress_test_loader')) {
        return '';
    }

    if ($extension === null) {
        $extension = get_file_extension($url);
    }

    $tmp_file = null;

    if ($data === null) {
        if (($direct_path) || (url_is_local($url))) {
            $actual_path = $direct_path ? $url : (get_custom_file_base() . '/' . rawurldecode($url));

            if (file_exists($actual_path)) {
                switch ($extension) {
                    case 'zip':
                    case 'odt':
                    case 'odp':
                    case 'docx':
                    case 'tar':
                    case 'gz':
                        if (filesize($actual_path) > 1024 * 1024 * 3) {
                            return '';
                        }
                        break;
                }

                $tmp_file = $actual_path;
                if (filesize($actual_path) > 1024 * 1024 * 3) {
                    $myfile = fopen($actual_path, 'rb');
                    flock($myfile, LOCK_SH);
                    $data = '';
                    for ($i = 0; $i < 384; $i++) {
                        $data .= fread($myfile, 8192);
                    }
                    flock($myfile, LOCK_UN);
                    fclose($myfile);
                } else {
                    $data = cms_file_get_contents_safe($actual_path, FILE_READ_LOCK);
                    if ($data === false) {
                        return '';
                    }
                }
            } else {
                return '';
            }
        } else {
            switch ($extension) {
                case 'txt':
                case '1st':
                case 'rtf':
                case 'pdf':
                case 'htm':
                case 'html':
                case 'xml':
                case 'doc':
                case 'xls':
                    break; // Continue through to download good stuff

                default:
                    return ''; // Don't download, it's not worth it
                    break;
            }

            $data = http_get_contents($url, ['trigger_error' => false, 'byte_limit' => 3 * 1024 * 1024]); // 3MB is enough
            if ($data === null) {
                return '';
            }
        }
    }

    // Sanity check: if data is still not a string, or for optimisation if it is blank, then we should not proceed.
    if (!is_string($data) || $data == '') {
        return '';
    }

    $mash = '';

    switch ($extension) {
        case 'zip':
        case 'odt':
        case 'odp':
        case 'docx':
            if (!class_exists('ZipArchive', false)) {
                break; // Don't error; just don't make a mash
            }

            $tmp_file = cms_tempnam();
            file_put_contents($tmp_file, $data);

            $zip_archive = new ZipArchive();

            $in_file = $zip_archive->open($tmp_file);
            if ($in_file !== true) { // Just clean up and don't make a mash on error
                @unlink($tmp_file);
                break;
            }

            for ($i = 0; $i < $zip_archive->numFiles; $i++) {
                $entry_name = $zip_archive->getNameIndex($i);
                $mash .= ' ' . $entry_name;
                if (substr($entry_name, -1) != '/') {
                    $file_data = $zip_archive->getFromIndex($i);
                    if (($file_data === false) || ($file_data == '')) {
                        continue;
                    }
                    $file_data = substr($file_data, 0, (3 * 1024 * 1024));

                    $mash .= ' ' . create_data_mash($entry_name, $file_data);
                    if (strlen($mash) >= 3 * 1024 * 1024) {
                        break; // 3MB is enough
                    }
                }
            }

            $zip_archive->close();
            unset($zip_archive);
            @unlink($tmp_file);
            break;

        case 'tar':
            require_code('tar');
            $tmp_file = cms_tempnam();
            file_put_contents($tmp_file, $data);
            $myfile_tar = tar_open($tmp_file, 'rb');
            if ($myfile_tar !== false) {
                $directory = tar_get_directory($myfile_tar);
                foreach ($directory as $entry) {
                    $entry_name = $entry['path'];
                    $mash .= ' ' . $entry_name;
                    if ($entry['size'] >= 3 * 1024 * 1024) {
                        continue; // 3MB is enough
                    }
                    $_entrya = tar_get_file($myfile_tar, $entry['path']);
                    if ($_entrya !== null) {
                        $mash .= ' ' . create_data_mash($entry_name, $_entrya['data']);
                        if (strlen($mash) >= 3 * 1024 * 1024) {
                            break; // 3MB is enough
                        }
                    }
                }
                tar_close($myfile_tar);
            }
            @unlink($tmp_file);
            break;

        case 'gz':
            if ((function_exists('gzopen')) && (function_exists('gzclose'))) {
                if ((function_exists('gzeof')) && (function_exists('gzread'))) {
                    $tmp_file = cms_tempnam();
                    file_put_contents($tmp_file, $data);
                    $myfile = gzopen($tmp_file, 'rb');
                    if ($myfile !== false) {
                        $file_data = '';
                        while (!gzeof($myfile)) {
                            $it = gzread($myfile, 1024);
                            $file_data .= $it;
                            if (strlen($file_data) >= 3 * 1024 * 1024) {
                                break; // 3MB is enough
                            }
                        }
                        gzclose($myfile);
                        $mash = ' ' . create_data_mash(preg_replace('#\.gz#i', '', $url), $file_data);
                    }
                    @unlink($tmp_file);
                }
            }
            break;

        case 'txt':
        case '1st':
            $mash .= $data;
            break;

        case 'rtf':
            $len = strlen($data);
            $skipping_section_depth = 0;
            $escape = false;
            for ($i = 0; $i < $len; $i++) {
                $byte = $data[$i];
                if ((!$escape) && ($byte == "\\")) {
                    $escape = true;
                } elseif ((!$escape) && ($byte == '{')) {
                    if ($skipping_section_depth != 0) {
                        $skipping_section_depth++;
                    }
                } elseif ((!$escape) && ($byte == '}')) {
                    if ($skipping_section_depth != 0) {
                        $skipping_section_depth--;
                    }
                } elseif (($escape) && ($byte != '{') && ($byte != "\\") && ($byte != '}')) {
                    $end_pos_1 = strpos($data, "\\", $i + 1);
                    if ($end_pos_1 === false) {
                        $end_pos_1 = $len;
                    }
                    $end_pos_2 = strpos($data, "\n", $i + 1);
                    if ($end_pos_2 === false) {
                        $end_pos_2 = $len;
                    }
                    $end_pos_3 = strpos($data, ' ', $i + 1);
                    if ($end_pos_3 === false) {
                        $end_pos_3 = $len;
                    }
                    $end_pos_4 = strpos($data, "\t", $i + 1);
                    if ($end_pos_4 === false) {
                        $end_pos_4 = $len;
                    }
                    $end_pos_5 = strpos($data, '{', $i + 1);
                    if ($end_pos_5 === false) {
                        $end_pos_5 = $len;
                    }
                    $end_pos_6 = strpos($data, '}', $i + 1);
                    if ($end_pos_6 === false) {
                        $end_pos_6 = $len;
                    }
                    $end_pos = min($end_pos_1, $end_pos_2, $end_pos_3, $end_pos_4, $end_pos_5, $end_pos_6);
                    $tag = substr($data, $i, $end_pos - $i);
                    $tag = preg_replace('#[\-0-9]*#', '', $tag);
                    if (($skipping_section_depth == 0) && (($tag == 'pgdsc') || ($tag == 'comment') || ($tag == 'object') || ($tag == 'pict') || ($tag == 'stylesheet') || ($tag == 'fonttbl'))) {
                        $skipping_section_depth = 1;
                    }
                    if ($tag == 'par') {
                        $mash .= "\n";
                    }
                    $i = $end_pos - 1;
                    $escape = false;
                } elseif ($skipping_section_depth == 0) {
                    if (($byte != "\r") && ($byte != "\n")) {
                        $mash .= $byte;
                    }
                    $escape = false;
                } else {
                    $escape = false;
                }
            }
            break;

        case 'pdf':
            if (php_function_allowed('shell_exec')) {
                $tmp_file = cms_tempnam();
                file_put_contents($tmp_file, $data);
                $enc = (get_charset() == 'utf-8') ? ' -enc UTF-8' : '';
                $path = '"' . _find_pdftohtml() . '" -i -noframes -stdout -hidden' . $enc . ' -q -xml ' . cms_escapeshellarg($tmp_file);
                $tmp_file_2 = cms_tempnam();
                @shell_exec($path . ' > ' . $tmp_file_2);
                $mash = create_data_mash($tmp_file_2, null, 'xml', true);
                @unlink($tmp_file_2);
            }
            break;

        case 'htm':
        case 'html':
            $head_patterns = ['#<\s*script.*<\s*/\s*script\s*>#misU', '#<\s*link[^<>]*>#misU', '#<\s*style.*<\s*/\s*style\s*>#misU'];
            foreach ($head_patterns as $pattern) {
                $data = preg_replace($pattern, '', $data);
            }
            // no break
        case 'xml':
            $mash = str_replace('&apos;', '\'', str_replace(' false ', ' ', str_replace(' true ', ' ', @html_entity_decode(preg_replace('#<[^<>]*>#', ' ', $data), ENT_QUOTES))));
            $mash = preg_replace('#Error : Bad \w+#', '', $mash);
            break;

        case 'xls':
        case 'doc':
        case 'ppt':
        case 'hlp':
            //default: // Binary formats are complex to parse, but whatsmore, as textual tagging isn't used, extraction can be done automatically as all identified text is good.
            $data = str_replace("\0", '', $data); // Strip out interleaved nulls because they are used in wide-chars, obscuring the data
            $mash = '';
            $needs_delimiter_next = false;
            $in_portion = false;
            $min_length = 10;
            if ($extension == 'xls') {
                $min_length = 4;
            }
            for ($i = 0; $i < strlen($data); $i++) {
                $ch = $data[$i];
                $chx = 1;
                $next_ok = _is_valid_data_mash_char($ch);
                if (($next_ok) && (!$in_portion)) {
                    $x = $ch;
                    for ($j = $i + 1; $j < strlen($data); $j++) { // Count how far a new word goes
                        $_ch = $data[$j];
                        $_next_ok = _is_valid_data_mash_char($_ch);
                        if ($_next_ok) {
                            $x .= $_ch;
                            $chx++;
                        } else {
                            break;
                        }
                    }
                    if ((strlen($x) < $min_length) || ($x == cms_strtoupper_ascii($x)) || ($x == 'Microsoft Word Document') || ($x == 'WordDocument') || ($x == 'SummaryInformation') || ($x == 'DocumentSummaryInformation')) { // Valid word okay
                        $i = $j;
                        continue;
                    }
                }

                if (($next_ok) && ($in_portion)) {
                    $mash .= $ch;
                } elseif (($next_ok) && ($chx >= $min_length)) {
                    if ($needs_delimiter_next) {
                        $mash .= ' ';
                        $needs_delimiter_next = false;
                    }
                    $mash .= $ch;
                    $in_portion = true;
                } else {
                    if ($in_portion) {
                        $needs_delimiter_next = true;
                        $in_portion = false;
                    }
                }
            }
            break;
    }

    if (strlen($mash) > 1024 * 1024 * 3) {
        $mash = substr($mash, 0, 1024 * 1024 * 3);
    }
    $mash = preg_replace('# +#', ' ', preg_replace('#[^\w\-\']#', ' ', $mash));
    if (strlen($mash) > intval(1024 * 1024 * 1 * 0.4)) {
        $mash = substr($mash, 0, intval(1024 * 1024 * 0.4));
    }

    return $mash;
}

/**
 * Find the pdftohtml executable, or just assume it is in the path if appropriate.
 *
 * @return string Path to executable
 *
 * @ignore
 */
function _find_pdftohtml() : string
{
    $path = 'pdftohtml';
    if (cms_strtoupper_ascii(substr(PHP_OS, 0, 3)) == 'WIN') {
        $_path = get_file_base() . '/data_custom/pdftohtml.exe';
        if (is_file($_path)) {
            $path = $_path;
        }
    } else {
        $search = [
            '/usr/local/bin/pdftohtml',
            '/usr/bin/pdftohtml',
        ];
        foreach ($search as $_path) {
            if (is_file($_path)) {
                $path = $_path;
                break;
            }
        }
    }
    return $path;
}

/**
 * Find if a character is basically a part of a text string.
 *
 * @param  string $ch Character to test
 * @return boolean Whether the character is valid
 *
 * @ignore
 */
function _is_valid_data_mash_char(string &$ch) : bool
{
    $c = ord($ch);
    if (($c == 145) || ($c == 146)) {
        $ch = "'";
    }
    return (($c >= 65 && $c <= 90) || ($c >= 97 && $c <= 122) || ($ch == "'") || ($ch == '-'));
}

/**
 * Add a download.
 *
 * @param  AUTO_LINK $category_id The ID of the category the download is to be in
 * @param  SHORT_TEXT $name The name of the download
 * @param  URLPATH $url The URL to the download
 * @param  LONG_TEXT $description The description of the download
 * @param  ID_TEXT $author The author of the download (not necessarily same as the submitter)
 * @param  LONG_TEXT $additional_details The supplementary description for the download
 * @param  ?AUTO_LINK $out_mode_id The out-mode-id (the ID of a download that this download is an old version of). Often people wonder why this is specified with the old version, and not the opposite with the new version - it is because statistically, we perceive more chance of downloads merging than splitting (null: none)
 * @param  BINARY $validated Whether the download has been validated
 * @param  BINARY $allow_rating Whether the download may be rated
 * @param  SHORT_INTEGER $allow_comments Whether comments are allowed (0=no, 1=yes, 2=review style)
 * @param  BINARY $allow_trackbacks Whether the download may be trackbacked
 * @param  LONG_TEXT $notes Hidden notes pertaining to the download
 * @param  SHORT_TEXT $original_filename The downloads original filename (the URL may be obfuscated)
 * @param  integer $file_size The file size of the download (we can't really detect this in real-time for remote URLs)
 * @param  integer $cost The cost of the download that members will have to pay to get it
 * @param  BINARY $submitter_gets_points Whether the submitter gets the points for the download (they are selling it) (otherwise they are just thrown out, which is an alternative model - one of enforcing community point building)
 * @param  ?AUTO_LINK $licence The licence to use (null: none)
 * @param  ?TIME $add_date The add date for the download (null: now)
 * @param  integer $num_downloads The number of downloads that this download has had
 * @param  integer $views The number of views that this download has had
 * @param  ?MEMBER $submitter The submitter (null: current user)
 * @param  ?TIME $edit_date The edit date (null: never)
 * @param  ?AUTO_LINK $id Force an ID (null: don't force an ID)
 * @param  SHORT_TEXT $meta_keywords Meta keywords for this resource (blank: implicit)
 * @param  LONG_TEXT $meta_description Meta description for this resource (blank: implicit)
 * @param  integer $default_pic The ordered number of the gallery image to use as the download representative image
 * @param  URLPATH $url_redirect The URL to redirect
 * @return AUTO_LINK The ID of the newly added download
 */
function add_download(int $category_id, string $name, string $url, string $description, string $author, string $additional_details, ?int $out_mode_id, int $validated, int $allow_rating, int $allow_comments, int $allow_trackbacks, string $notes, string $original_filename, int $file_size, int $cost = 0, int $submitter_gets_points = 0, ?int $licence = null, ?int $add_date = null, int $num_downloads = 0, int $views = 0, ?int $submitter = null, ?int $edit_date = null, ?int $id = null, string $meta_keywords = '', string $meta_description = '', int $default_pic = 1, string $url_redirect = '') : int
{
    require_code('global4');
    prevent_double_submit('ADD_DOWNLOAD', null, $name);

    if ($add_date === null) {
        $add_date = time();
    }

    if ($submitter === null) {
        $submitter = get_member();
    }

    if (($file_size == 0) || (url_is_local($url))) {
        if (url_is_local($url)) {
            $file_size = @filesize(get_custom_file_base() . '/' . rawurldecode($url)) or $file_size = null;
        } else {
            $http_result = cms_http_request($url, ['trigger_error' => false, 'byte_limit' => 0]);
            $file_size = $http_result->download_size;
        }
    }

    if (($file_size < 0) || ($file_size > 2147483647)) { // TODO: #3046 in tracker
        $file_size = 2147483647;
    }

    if (!addon_installed('validation')) {
        $validated = 1;
    }

    $map = [
        'download_data_mash' => '', // Will be populated later
        'download_licence_id' => $licence,
        'rep_image' => '',
        'edit_date' => $edit_date,
        'download_submitter_gets_points' => $submitter_gets_points,
        'download_cost' => $cost,
        'original_filename' => $original_filename,
        'download_views' => $views,
        'allow_rating' => $allow_rating,
        'allow_comments' => $allow_comments,
        'allow_trackbacks' => $allow_trackbacks,
        'notes' => $notes,
        'submitter' => $submitter,
        'default_pic' => $default_pic,
        'num_downloads' => $num_downloads,
        'out_mode_id' => $out_mode_id,
        'category_id' => $category_id,
        'url' => $url,
        'author' => cms_mb_substr($author, 0, 80),
        'url_redirect' => $url_redirect,
        'validated' => $validated,
        'add_date' => $add_date,
        'file_size' => $file_size,
    ];
    $map += insert_lang('name', $name, 2);
    $map += insert_lang_comcode('the_description', $description, 3);
    $map += insert_lang_comcode('additional_details', $additional_details, 3);

    if ($id !== null) {
        $map['id'] = $id;
        $GLOBALS['SITE_DB']->query_insert('download_downloads', $map);
    } else {
        $id = $GLOBALS['SITE_DB']->query_insert('download_downloads', $map, true);
    }

    $reorganise_uploads = reorganise_uploads__downloads(['id' => $id]);
    $actual_url = $url;
    if (array_key_exists('download_downloads:' . strval($id), $reorganise_uploads)) {
        $actual_url = $reorganise_uploads['download_downloads:' . strval($id)];
    }

    require_code('tasks');
    require_lang('downloads');
    call_user_func_array__long_task(do_lang('INDEX_DOWNLOAD'), null, 'index_download', [$id, $actual_url, $original_filename], false, false, false);

    require_code('content2');
    if (($meta_keywords == '') && ($meta_description == '')) {
        seo_meta_set_for_implicit('downloads_download', strval($id), [$name, $description, $additional_details], $description);
    } else {
        seo_meta_set_for_explicit('downloads_download', strval($id), $meta_keywords, $meta_description);
    }

    // Make its gallery
    if ((addon_installed('galleries')) && (!running_script('stress_test_loader'))) {
        $test = $GLOBALS['SITE_DB']->query_select_value_if_there('galleries', 'name', ['name' => 'download_' . strval($id)]);
        if ($test === null) {
            require_lang('downloads');
            require_code('galleries2');
            $download_gallery_root = get_option('download_gallery_root');
            add_gallery('download_' . strval($id), do_lang('GALLERY_FOR_DOWNLOAD', $name), '', '', $download_gallery_root);
            set_download_gallery_permissions($id, $submitter);
        }
    }

    // Stat
    update_stat('num_archive_downloads', 1);
    if ($file_size > 0) {
        update_stat('archive_size', $file_size);
    }

    if ($validated == 1) {
        if (addon_installed('content_privacy')) {
            require_code('content_privacy');
            $privacy_limits = privacy_limits_for('download', strval($id));
        } else {
            $privacy_limits = null;
        }

        require_lang('downloads');
        require_code('notifications');
        $subject = do_lang('DOWNLOAD_NOTIFICATION_MAIL_SUBJECT', get_site_name(), $name);
        $self_url = build_url(['page' => 'downloads', 'type' => 'entry', 'id' => $id], get_module_zone('downloads'), [], false, false, true);
        $mail = do_notification_lang('DOWNLOAD_NOTIFICATION_MAIL', comcode_escape(get_site_name()), comcode_escape($name), [comcode_escape($self_url->evaluate())]);
        dispatch_notification('download', strval($category_id), $subject, $mail, $privacy_limits);
    }

    log_it('ADD_DOWNLOAD', strval($id), $name);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download', strval($id), null, null, true);
    }

    require_code('member_mentions');
    dispatch_member_mention_notifications('download', strval($id), $submitter);

    require_code('downloads');
    require_code('sitemap_xml');
    if ($validated == 1) {
        require_code('sitemap_xml');
        notify_sitemap_node_add('_SEARCH:downloads:entry:' . strval($id));
    }

    return $id;
}

/**
 * Set the permissions for a download gallery.
 *
 * @param  ?AUTO_LINK $id The ID of the download (null: lookup from download)
 * @param  ?MEMBER $submitter The submitter (null: work out automatically)
 */
function set_download_gallery_permissions(?int $id, ?int $submitter = null)
{
    if ($submitter === null) {
        $submitter = $GLOBALS['SITE_DB']->query_select_value('download_downloads', 'submitter', ['id' => $id]);
    }

    $download_gallery_root = get_option('download_gallery_root');

    // Copy through requisite permissions
    $GLOBALS['SITE_DB']->query_delete('group_category_access', ['module_the_name' => 'galleries', 'category_name' => 'download_' . strval($id)]);

    $start = 0;
    $max = 100;
    do {
        $perms = $GLOBALS['SITE_DB']->query_select('group_category_access', ['*'], ['module_the_name' => 'galleries', 'category_name' => $download_gallery_root], '', $max, $start);
        foreach ($perms as $perm) {
            $perm['category_name'] = 'download_' . strval($id);
            $GLOBALS['SITE_DB']->query_insert('group_category_access', $perm);
        }

        $start += $max;
    } while (!empty($perms));

    $GLOBALS['SITE_DB']->query_delete('group_privileges', ['module_the_name' => 'galleries', 'category_name' => 'download_' . strval($id)]);

    $start = 0;
    $max = 100;
    do {
        $perms = $GLOBALS['SITE_DB']->query_select('group_privileges', ['*'], ['module_the_name' => 'galleries', 'category_name' => $download_gallery_root], '', $max, $start);
        foreach ($perms as $perm) {
            $perm['category_name'] = 'download_' . strval($id);
            $GLOBALS['SITE_DB']->query_insert('group_privileges', $perm);
        }

        $start += $max;
    } while (!empty($perms));

    // If they were able to submit the download, they should be able to submit extra images
    $GLOBALS['SITE_DB']->query_delete('member_privileges', ['module_the_name' => 'galleries', 'category_name' => 'download_' . strval($id)]);
    foreach (['submit_midrange_content'] as $privilege) {
        $GLOBALS['SITE_DB']->query_insert('member_privileges', ['active_until' => null, 'member_id' => $submitter, 'privilege' => $privilege, 'the_page' => '', 'module_the_name' => 'galleries', 'category_name' => 'download_' . strval($id), 'the_value' => 1]);
    }
}

/**
 * Edit a download.
 *
 * @param  AUTO_LINK $id The ID of the download to edit
 * @param  AUTO_LINK $category_id The ID of the category the download is to be in
 * @param  SHORT_TEXT $name The name of the download
 * @param  URLPATH $url The URL to the download
 * @param  LONG_TEXT $description The description of the download
 * @param  ID_TEXT $author The author of the download (not necessarily same as the submitter)
 * @param  LONG_TEXT $additional_details The supplementary description for the download
 * @param  ?AUTO_LINK $out_mode_id The out-mode-id (the ID of a download that this download is an old version of). Often people wonder why this is specified with the old version, and not the opposite with the new version - it is because statistically, we perceive more chance of downloads merging than splitting (null: none)
 * @param  integer $default_pic The ordered number of the gallery image to use as the download representative image
 * @param  BINARY $validated Whether the download has been validated
 * @param  BINARY $allow_rating Whether the download may be rated
 * @param  SHORT_INTEGER $allow_comments Whether comments are allowed (0=no, 1=yes, 2=review style)
 * @param  BINARY $allow_trackbacks Whether the download may be trackbacked
 * @param  LONG_TEXT $notes Hidden notes pertaining to the download
 * @param  SHORT_TEXT $original_filename The downloads original filename (the URL may be obfuscated)
 * @param  integer $file_size The file size of the download (we can't really detect this in real-time for remote URLs)
 * @param  integer $cost The cost of the download that members will have to pay to get it
 * @param  BINARY $submitter_gets_points Whether the submitter gets the points for the download (they are selling it) (otherwise they are just thrown out, which is an alternative model - one of enforcing community point building)
 * @param  ?AUTO_LINK $licence The licence to use (null: none)
 * @param  SHORT_TEXT $meta_keywords Meta keywords
 * @param  LONG_TEXT $meta_description Meta description
 * @param  ?TIME $edit_time Edit time (null: either means current time, or if $null_is_literal, means reset to to null)
 * @param  ?TIME $add_time Add time (null: do not change)
 * @param  ?integer $views Number of views (null: do not change)
 * @param  ?MEMBER $submitter Submitter (null: do not change)
 * @param  ?integer $num_downloads The number of downloads that this download has had (null: do not change)
 * @param  boolean $null_is_literal Determines whether some nulls passed mean 'use a default' or literally mean 'set to null'
 * @param  URLPATH $url_redirect The URL to redirect
 */
function edit_download(int $id, int $category_id, string $name, string $url, string $description, string $author, string $additional_details, ?int $out_mode_id, int $default_pic, int $validated, int $allow_rating, int $allow_comments, int $allow_trackbacks, string $notes, string $original_filename, int $file_size, int $cost, int $submitter_gets_points, ?int $licence, string $meta_keywords, string $meta_description, ?int $edit_time = null, ?int $add_time = null, ?int $views = null, ?int $submitter = null, ?int $num_downloads = null, bool $null_is_literal = false, string $url_redirect = '')
{
    if ($edit_time === null) {
        $edit_time = $null_is_literal ? null : time();
    }

    $rows = $GLOBALS['SITE_DB']->query_select('download_downloads', ['name', 'the_description', 'additional_details', 'category_id'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download'));
    }
    $myrow = $rows[0];

    require_code('urls2');
    suggest_new_idmoniker_for('downloads', 'view', strval($id), '', $name);

    if (fractional_edit()) {
        $file_size = INTEGER_MAGIC_NULL;
    } else {
        if (($file_size == 0) || (url_is_local($url))) {
            if (url_is_local($url)) {
                $file_size = @filesize(get_custom_file_base() . '/' . rawurldecode($url));
                if ($file_size === false) {
                    $file_size = 0;
                }
            } else {
                $http_result = cms_http_request($url, ['trigger_error' => false, 'byte_limit' => 0]);
                $file_size = $http_result->download_size;
            }
        }
    }

    if (($file_size < 0) || ($file_size > 2147483647)) { // TODO: #3046 in tracker
        $file_size = 2147483647;
    }

    require_code('content2');
    seo_meta_set_for_explicit('downloads_download', strval($id), $meta_keywords, $meta_description);

    require_code('files2');
    delete_upload('uploads/downloads', 'download_downloads', 'url', 'id', $id, $url);

    if (!addon_installed('validation')) {
        $validated = 1;
    }

    require_code('submit');
    $just_validated = (!content_validated('download', strval($id))) && ($validated == 1);
    if ($just_validated) {
        send_content_validated_notification('download', strval($id));
        $username = $GLOBALS['FORUM_DRIVER']->get_username(get_member());
        log_it('VALIDATE_DOWNLOAD', strval($id), $username);
    }

    $update_map = [
        'download_licence_id' => $licence,
        'original_filename' => $original_filename,
        'download_submitter_gets_points' => $submitter_gets_points,
        'download_cost' => $cost,
        'edit_date' => $edit_time,
        'file_size' => $file_size,
        'allow_rating' => $allow_rating,
        'allow_comments' => $allow_comments,
        'allow_trackbacks' => $allow_trackbacks,
        'notes' => $notes,
        'validated' => $validated,
        'category_id' => $category_id,
        'url' => $url,
        'author' => cms_mb_substr($author, 0, 80),
        'url_redirect' => $url_redirect,
        'default_pic' => $default_pic,
        'out_mode_id' => $out_mode_id,
    ];
    $update_map += lang_remap('name', $myrow['name'], $name);
    $update_map += lang_remap_comcode('the_description', $myrow['the_description'], $description);
    $update_map += lang_remap_comcode('additional_details', $myrow['additional_details'], $additional_details);

    $update_map['edit_date'] = $edit_time;
    if ($add_time !== null) {
        $update_map['add_date'] = $add_time;
    }
    if ($views !== null) {
        $update_map['download_views'] = $views;
    }
    if ($submitter !== null) {
        $update_map['submitter'] = $submitter;
    }
    if ($num_downloads !== null) {
        $update_map['num_downloads'] = $num_downloads;
    }

    $GLOBALS['SITE_DB']->query_update('download_downloads', $update_map, ['id' => $id], '', 1);

    $self_url = build_url(['page' => 'downloads', 'type' => 'entry', 'id' => $id], get_module_zone('downloads'), [], false, false, true);

    if ($just_validated) {
        if (addon_installed('content_privacy')) {
            require_code('content_privacy');
            $privacy_limits = privacy_limits_for('download', strval($id));
        } else {
            $privacy_limits = null;
        }

        require_lang('downloads');
        require_code('notifications');
        $subject = do_lang('DOWNLOAD_NOTIFICATION_MAIL_SUBJECT', get_site_name(), $name);
        $mail = do_notification_lang('DOWNLOAD_NOTIFICATION_MAIL', comcode_escape(get_site_name()), comcode_escape($name), [comcode_escape($self_url->evaluate())]);
        dispatch_notification('download', strval($category_id), $subject, $mail, $privacy_limits);
    }

    $reorganise_uploads = reorganise_uploads__downloads(['id' => $id]);

    if (!fractional_edit()) {
        $actual_url = $url;
        if (array_key_exists('download_downloads:' . strval($id), $reorganise_uploads)) {
            $actual_url = $reorganise_uploads['download_downloads:' . strval($id)];
        }

        require_code('tasks');
        require_lang('downloads');
        call_user_func_array__long_task(do_lang('INDEX_DOWNLOAD'), null, 'index_download', [$id, $actual_url, $original_filename], false, false, false);
    }

    log_it('EDIT_DOWNLOAD', strval($id), get_translated_text($myrow['name']));

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download', strval($id));
    }

    if (addon_installed('galleries')) {
        // Change its gallery (or create it if it doesn't exist for some reason)
        require_code('galleries2');
        $download_gallery_root = get_option('download_gallery_root');
        $test = $GLOBALS['SITE_DB']->query_select_value_if_there('galleries', 'parent_id', ['name' => 'download_' . strval($id)]);
        if ($test !== null) {
            edit_gallery('download_' . strval($id), 'download_' . strval($id), do_lang('GALLERY_FOR_DOWNLOAD', $name), '', '', $download_gallery_root);
        } else {
            require_lang('downloads');
            $download_gallery_root = get_option('download_gallery_root');
            add_gallery('download_' . strval($id), do_lang('GALLERY_FOR_DOWNLOAD', $name), '', '', $download_gallery_root);
            if ($submitter === null) {
                $_submitter = $GLOBALS['SITE_DB']->query_select_value('download_downloads', 'submitter', ['id' => $id]);
            } else {
                $_submitter = $submitter;
            }
            set_download_gallery_permissions($id, $_submitter);
        }
    }

    require_code('feedback');
    update_spacer_post(
        $allow_comments != 0,
        'downloads',
        strval($id),
        $self_url,
        $name,
        process_overridden_comment_forum('downloads', strval($id), strval($category_id), strval($myrow['category_id']))
    );

    require_code('downloads');
    require_code('sitemap_xml');
    if ($validated == 1) {
        notify_sitemap_node_edit('_SEARCH:downloads:entry:' . strval($id));
    } else {
        notify_sitemap_node_delete('_SEARCH:downloads:entry:' . strval($id));
    }
}

/**
 * Delete a download.
 *
 * @param  AUTO_LINK $id The ID of the download to delete
 * @param  boolean $leave Whether to leave the actual file behind
 */
function delete_download(int $id, bool $leave = false)
{
    $rows = $GLOBALS['SITE_DB']->query_select('download_downloads', ['name', 'the_description', 'additional_details'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download'));
    }
    $myrow = $rows[0];

    if (addon_installed('catalogues')) {
        update_catalogue_content_ref('download', strval($id), '');
    }

    delete_lang($myrow['name']);
    delete_lang($myrow['the_description']);
    delete_lang($myrow['additional_details']);

    require_code('content2');
    seo_meta_erase_storage('downloads_download', strval($id));

    if (!$leave) {
        require_code('files2');
        delete_upload('uploads/downloads', 'download_downloads', 'url', 'id', $id);
    }

    // Delete from database
    $GLOBALS['SITE_DB']->query_delete('download_downloads', ['id' => $id], '', 1);
    $GLOBALS['SITE_DB']->query_delete('download_logging', ['id' => $id]);
    $GLOBALS['SITE_DB']->query_delete('rating', ['rating_for_type' => 'downloads', 'rating_for_id' => strval($id)]);
    $GLOBALS['SITE_DB']->query_delete('trackbacks', ['trackback_for_type' => 'downloads', 'trackback_for_id' => strval($id)]);
    require_code('notifications');
    delete_all_notifications_on('comment_posted', 'downloads_' . strval($id));

    $GLOBALS['SITE_DB']->query_update('download_downloads', ['out_mode_id' => null], ['out_mode_id' => $id], '', 1);

    if (addon_installed('galleries')) {
        // Delete gallery
        $name = 'download_' . strval($id);
        require_code('galleries2');
        $test = $GLOBALS['SITE_DB']->query_select_value_if_there('galleries', 'parent_id', ['name' => 'download_' . strval($id)]);
        if ($test !== null) {
            delete_gallery($name);
        }
    }

    $GLOBALS['SITE_DB']->query_update('url_id_monikers', ['m_deprecated' => 1], ['m_resource_page' => 'downloads', 'm_resource_type' => 'view', 'm_resource_id' => strval($id)]);

    require_code('uploads2');
    clean_empty_upload_directories('uploads/downloads');

    log_it('DELETE_DOWNLOAD', strval($id), get_translated_text($myrow['name']));

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        expunge_resource_fs_moniker('download', strval($id));
    }

    require_code('sitemap_xml');
    notify_sitemap_node_delete('_SEARCH:downloads:entry:' . strval($id));
}

/**
 * Add a download licence.
 *
 * @param  SHORT_TEXT $title The title of the download licence
 * @param  LONG_TEXT $text The text of the download licence
 * @return AUTO_LINK The ID of the new download licence
 */
function add_download_licence(string $title, string $text) : int
{
    require_code('global4');
    prevent_double_submit('ADD_DOWNLOAD_LICENCE', null, $title);

    $id = $GLOBALS['SITE_DB']->query_insert('download_licences', ['l_title' => $title, 'l_text' => $text], true);

    log_it('ADD_DOWNLOAD_LICENCE', strval($id), $title);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download_licence', strval($id), null, null, true);
    }

    return $id;
}

/**
 * Edit a download licence.
 *
 * @param  AUTO_LINK $id The ID of the download licence to edit
 * @param  SHORT_TEXT $title The title of the download licence
 * @param  LONG_TEXT $text The text of the download licence
 */
function edit_download_licence(int $id, string $title, string $text)
{
    $rows = $GLOBALS['SITE_DB']->query_select('download_licences', ['l_title'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_licence'));
    }

    $GLOBALS['SITE_DB']->query_update('download_licences', ['l_title' => $title, 'l_text' => $text], ['id' => $id], '', 1);

    log_it('EDIT_DOWNLOAD_LICENCE', strval($id), $title);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        generate_resource_fs_moniker('download_licence', strval($id));
    }
}

/**
 * Delete a download licence.
 *
 * @param  AUTO_LINK $id The ID of the download licence to delete
 */
function delete_download_licence(int $id)
{
    $rows = $GLOBALS['SITE_DB']->query_select('download_licences', ['l_title'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_licence'));
    }
    $myrow = $rows[0];

    $GLOBALS['SITE_DB']->query_delete('download_licences', ['id' => $id], '', 1);

    $GLOBALS['SITE_DB']->query_update('download_downloads', ['download_licence_id' => null], ['download_licence_id' => $id]);

    log_it('DELETE_DOWNLOAD_LICENCE', strval($id), $myrow['l_title']);

    if ((addon_installed('commandr')) && (!running_script('install')) && (!get_mass_import_mode())) {
        require_code('resource_fs');
        expunge_resource_fs_moniker('download_licence', strval($id));
    }
}

/**
 * Log a file download, update the downloads counter and the download bandwidth counter.
 *
 * @param  AUTO_LINK $id The ID of the download being downloaded
 * @param  integer $size The size of the download (if zero, no bandwidth will be done - zero implies either an empty file, or a remote file that doesn't affect our bandwidth)
 * @param  boolean $got_before Whether the download has been downloaded before
 */
function log_download(int $id, int $size, bool $got_before)
{
    // Log
    if (!$got_before) {
        $GLOBALS['SITE_DB']->query_insert('download_logging', ['id' => $id, 'member_id' => get_member(), 'ip' => get_ip_address(), 'date_and_time' => time()], false, true); // Suppress errors in case of race condition
    }

    // Update download count
    $GLOBALS['SITE_DB']->query('UPDATE ' . get_table_prefix() . 'download_downloads SET num_downloads=(num_downloads+1) WHERE id=' . strval($id), 1, 0, true); // Suppress errors in case DB access lost

    // Update stats
    $GLOBALS['SITE_DB']->query('UPDATE ' . get_table_prefix() . 'values SET the_value=' . db_cast('(' . db_cast('the_value', 'INT') . '+1)', 'CHAR') . ' WHERE ' . db_string_equal_to('the_name', 'num_downloads_downloaded'), 1, 0, true); // Suppress errors in case DB access lost
    if ($size != 0) {
        $GLOBALS['SITE_DB']->query('UPDATE ' . get_table_prefix() . 'values SET the_value=' . db_cast('(' . db_cast('the_value', 'INT') . '+' . strval($size) . ')', 'CHAR') . ' WHERE ' . db_string_equal_to('the_name', 'download_bandwidth'), 1, 0, true); // Suppress errors in case DB access lost
    }
}

/**
 * Reorganise the download category uploads.
 *
 * @param  array $where Limit reorganisation to rows matching this WHERE map
 * @param  boolean $tolerate_errors Whether to tolerate missing files (false = give an error)
 */
function reorganise_uploads__download_categories(array $where = [], bool $tolerate_errors = false)
{
    require_code('uploads2');
    reorganise_uploads('download_category', 'uploads/repimages', 'rep_image', $where, true, $tolerate_errors);
}

/**
 * Reorganise the download entry uploads.
 *
 * @param  array $where Limit reorganisation to rows matching this WHERE map
 * @param  boolean $tolerate_errors Whether to tolerate missing files (false = give an error)
 * @return array Map of db_table:id to the new upload URL
 */
function reorganise_uploads__downloads(array $where = [], bool $tolerate_errors = false) : array
{
    require_code('uploads2');
    return reorganise_uploads('download', 'uploads/downloads', 'url', $where, false, $tolerate_errors);
}
