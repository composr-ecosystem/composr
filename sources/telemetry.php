<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: sodium_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_privacy
 */

/**
 * Determine whether encryption support is available for telemetry.
 * This also checks if all keys are in place including the software key and the site keys.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled_telemetry() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $available = is_encryption_available_telemetry();
        $site_keys_exist = file_exists(get_file_base() . '/data_custom/keys/telemetry-site.json');
        $enabled = (($available) && ($site_keys_exist));
    }
    return $enabled;
}

/**
 * Determine whether encryption support is available for telemetry.
 * This does not check if the site keys are in place, but it will check if the software key is. Use is_encryption_enabled_telemetry for a full check.
 *
 * @return boolean Encryption available?
 */
function is_encryption_available_telemetry() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key_exists = file_exists(get_file_base() . '/data/keys/telemetry.json');
        $available = function_exists('sodium_crypto_box_seal');
        $enabled = (($available) && ($public_key_exists));
    }
    return $enabled;
}

/**
 * Get the software keys for telemetry use.
 *
 * @param  ?float $version The major.minor version number of which to get the keys (null: get the distributed public key for this version)
 * @return array A double; the public key and the private key (private key will be null if $version is null)
 */
function get_software_keys_telemetry(?float $version = null) : array
{
    require_code('global3');

    if ($version === null) {
        $path = get_file_base() . '/data/keys/telemetry.json';
        if (!is_file($path)) {
            warn_exit(do_lang_tempcode('MISSING_SOFTWARE_KEYS'));
        }

        $_contents = cms_file_get_contents_safe($path);
        $contents = @json_decode($_contents, true);
        if ((!$contents) || (!isset($contents['public']))) {
            warn_exit(do_lang_tempcode('CORRUPT_SOFTWARE_KEYS'));
        }

        return [$contents['public'], null];
    }

    $version_str = float_to_raw_string($version, 2, true);

    $relative_path = 'data_custom/keys/telemetry-' . $version_str . '.json';
    $path = get_file_base() . '/' . $relative_path;
    if (!is_file($path)) {
        warn_exit(do_lang_tempcode('_MISSING_SOFTWARE_KEYS', escape_html($version_str)));
    }

    $_contents = cms_file_get_contents_safe($path);
    $contents = @json_decode($_contents, true);
    if ((!$contents) || (!isset($contents['public'])) || (!isset($contents['private']))) {
        warn_exit(do_lang_tempcode('_CORRUPT_SOFTWARE_KEYS', escape_html($version_str)));
    }

    return [$contents['public'], $contents['private']];
}

/**
 * Get the site keys for use in telemetry.
 *
 * @return array Public encryption key, private encryption key, public signature key, private signature key
 */
function get_site_keys_telemetry() : array
{
    $relative_path = 'data_custom/keys/telemetry-site.json';
    $path = get_file_base() . '/' . $relative_path;
    if (!is_file($path)) {
        warn_exit(do_lang_tempcode('MISSING_SITE_KEYS'));
    }

    $_contents = cms_file_get_contents_safe($path);
    $contents = @json_decode($_contents, true);
    if ((!$contents) || (!isset($contents['encryption'])) || (!isset($contents['signature']))) {
        warn_exit(do_lang_tempcode('CORRUPT_SITE_KEYS'));
    }
    if ((!isset($contents['encryption']['public'])) || (!isset($contents['encryption']['private']))) {
        warn_exit(do_lang_tempcode('CORRUPT_SITE_KEYS'));
    }
    if ((!isset($contents['signature']['public'])) || (!isset($contents['signature']['private']))) {
        warn_exit(do_lang_tempcode('CORRUPT_SITE_KEYS'));
    }

    return [$contents['encryption']['public'], $contents['encryption']['private'], $contents['signature']['public'], $contents['signature']['private']];
}

/**
 * Encrypt some data for telemetry using symmetric encryption and just the software's public key.
 *
 * @param  string $data The data to encrypt
 * @return array Map of parameters for the JSON payload
 */
function encrypt_data_telemetry(string $data) : array
{
    require_code('version');

    // Get the software public key
    $software_keys = get_software_keys_telemetry();
    $public_key = base64_decode($software_keys[0]);

    // Encrypt the message
    $session_key = random_bytes(SODIUM_CRYPTO_SECRETBOX_KEYBYTES);
    $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES);
    $encrypted_data = sodium_crypto_secretbox($data, $nonce, $session_key);

    // Encrypt the session key
    $encrypted_session_key = sodium_crypto_box_seal($session_key, $public_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($encrypted_data);
    $encrypted_session_key_base64 = base64_encode($encrypted_session_key);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'encrypted_session_key' => $encrypted_session_key_base64,
        'version' => cms_version_number(),
    ];
}

/**
 * Decrypt some data for telemetry using symmetric decryption and the software's private key.
 *
 * @param  string $nonce_base64 The base64-encoded nonce
 * @param  string $encrypted_data_base64 The base64-encoded encrypted data
 * @param  string $encrypted_session_key_base64 The base64-encoded encrypted session key
 * @param  float $version The version of the software which encrypted the data
 * @return string The decrypted data
 */
function decrypt_data_telemetry(string $nonce_base64, string $encrypted_data_base64, string $encrypted_session_key_base64, float $version) : string
{
    // Get the relevant keys
    $software_keys = get_software_keys_telemetry($version);
    $public_key = base64_decode($software_keys[0]);
    $private_key = base64_decode($software_keys[1]);

    // Make a key pair from our keys
    $key_pair = sodium_crypto_box_keypair_from_secretkey_and_publickey($private_key, $public_key);

    // Decode base64-encoded data
    $encrypted_data = base64_decode($encrypted_data_base64);
    $encrypted_session_key = base64_decode($encrypted_session_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_data === false) || ($encrypted_session_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the session key
    $session_key = sodium_crypto_box_seal_open($encrypted_session_key, $key_pair);
    if ($session_key === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the data using the session key and nonce
    $data = sodium_crypto_secretbox_open($encrypted_data, $nonce, $session_key);
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    return $data;
}

/**
 * Encrypt some data using the site and software keys for sending in telemetry.
 *
 * @param  string $data The data to encrypt
 * @return ?array Map of parameters for the JSON payload (null: could not encrypt the data)
 */
function encrypt_data_site_telemetry(string $data) : ?array
{
    // Get the software public key
    $software_keys = get_software_keys_telemetry();
    $software_public_key = base64_decode($software_keys[0]);

    // Get the site keys
    $site_keys = get_site_keys_telemetry();
    $site_public_key = base64_decode($site_keys[0]);
    $site_private_key = base64_decode($site_keys[1]);
    $site_s_public_key = base64_decode($site_keys[2]);
    $site_s_private_key = base64_decode($site_keys[3]);

    // Create a key-pair with the site private key and the software public key
    $shared_key = sodium_crypto_box_keypair_from_secretkey_and_publickey(
        $site_private_key,
        $software_public_key
    );

    // Encrypt the message
    $nonce = random_bytes(SODIUM_CRYPTO_BOX_NONCEBYTES);
    $encrypted = sodium_crypto_box(
        $data,
        $nonce,
        $shared_key
    );

    // Sign the message
    $signed_message = sodium_crypto_sign($encrypted, $site_s_private_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($signed_message);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'website_url' => get_base_url(),
        'version' => cms_version_number(),
    ];
}

/**
 * Decrypt data encrypted with encrypt_data_site_telemetry.
 *
 * @param  string $nonce_base64 The base64-encoded nonce
 * @param  string $encrypted_data_base64 The base64-encoded encrypted and signed data
 * @param  string $public_key_base64 The base64-encoded sender's public key
 * @param  string $sign_public_key_base64 The base64-encoded sender's signing public key
 * @param  float $version The software version used
 * @return string The decrypted data
 */
function decrypt_data_site_telemetry(string $nonce_base64, string $encrypted_data_base64, string $public_key_base64, string $sign_public_key_base64, float $version) : string
{
    // Decode base64-encoded data
    $encrypted_signed_data = base64_decode($encrypted_data_base64);
    $public_key = base64_decode($public_key_base64);
    $sign_public_key = base64_decode($sign_public_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_signed_data === false) || ($public_key === false) || ($sign_public_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Verify the signed message
    $encrypted_data = sodium_crypto_sign_open($encrypted_signed_data, $sign_public_key);
    if ($encrypted_data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Get the software private key
    $software_keys = get_software_keys_telemetry($version);
    $software_private_key = base64_decode($software_keys[1]);

    // Create a key-pair with the software private key and the site public key
    $shared_key = sodium_crypto_box_keypair_from_secretkey_and_publickey(
        $software_private_key,
        $public_key
    );

    // Decrypt the message
    $data = sodium_crypto_box_open(
        $encrypted_data,
        $nonce,
        $shared_key
    );
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    return $data;
}

/**
 * Generate a public and private key pair for this version of the software and save it into the data_custom/keys directory.
 *
 * @param  float $version The major.minor version for which we are generating a key pair
 * @param  boolean $overwrite_existing Whether to overwrite an existing key pair
 * @throws SodiumException
 */
function generate_telemetry_key_pair(float $version, bool $overwrite_existing = false)
{
    require_code('files2');

    $key_path = get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true) . '.json';

    if (!$overwrite_existing) {
        // Key already exists, so nothing to do
        if (file_exists($key_path)) {
            return;
        }

        // Try calling homesite to retrieve this version's public key in case we accidentally deleted it
        require_code('global3');
        $homesite_call = cms_http_request(get_brand_base_url() . '/data/endpoint.php/cms_homesite/telemetry/' . float_to_raw_string($version, 2, true) . '?type=key', ['convert_to_internal_encoding' => true, 'timeout' => 10.0, 'trigger_error' => false]);
        if ($homesite_call->data !== null) {
            $data = @json_decode($homesite_call->data, true);
            if (($data !== false) && ($data['success'] === true)) {
                $to_json = ['public' => $data['response_data']['key']];
                cms_file_put_contents_safe($key_path, json_encode($to_json), FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
                return;
            }
        }
    }

    $key_pair = sodium_crypto_box_keypair();

    // Extract the public and private keys
    $public_key = sodium_crypto_box_publickey($key_pair);
    $private_key = sodium_crypto_box_secretkey($key_pair);

    // Convert keys to base64
    $public_key_base64 = base64_encode($public_key);
    $private_key_base64 = base64_encode($private_key);

    // Save our keys
    $to_json = [];
    $to_json['public'] = $public_key_base64;
    $to_json['private'] = $private_key_base64;
    cms_file_put_contents_safe($key_path, json_encode($to_json), FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
}

/**
 * Generate a site key-pair for use in signing messages to the homesite telemetry service.
 * This function will always overwrite existing public and private keys, so use with care!
 *
 * @return array Public key, private key, signing public key, signing private key
 * @throws SodiumException
 */
function generate_site_telemetry_key_pair() : array
{
    require_code('files2');

    /* Encryption keys */

    $key_path = get_file_base() . '/data_custom/keys/telemetry-site.json';

    $key_pair = sodium_crypto_box_keypair();

    // Extract the public and private keys
    $private_key = sodium_crypto_box_secretkey($key_pair);
    $public_key = sodium_crypto_box_publickey($key_pair);

    // Convert keys to base64
    $public_key_base64 = base64_encode($public_key);
    $private_key_base64 = base64_encode($private_key);

    /* Signing keys */

    $s_key_pair = sodium_crypto_sign_keypair();

    // Extract the public and private keys
    $s_private_key = sodium_crypto_sign_secretkey($s_key_pair);
    $s_public_key = sodium_crypto_sign_publickey($s_key_pair);

    // Convert keys to base64
    $s_public_key_base64 = base64_encode($s_public_key);
    $s_private_key_base64 = base64_encode($s_private_key);

    /* Save our keys */

    $to_json = [
        'encryption' => [
            'public' => $public_key_base64,
            'private' => $private_key_base64,
        ],
        'signature' => [
            'public' => $s_public_key_base64,
            'private' => $s_private_key_base64,
        ]
    ];

    cms_file_put_contents_safe($key_path, json_encode($to_json), FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);

    return [$public_key_base64, $private_key_base64, $s_public_key_base64, $s_private_key_base64];
}

/**
 * Script to encrypt some data (with telemetry keys) and output the encrypted payload (from encrypt_data_telemetry) in JSON formatted base64.
 */
function encrypt_data_script()
{
    require_code('global2');

    prepare_backend_response('text/plain');

    cms_ini_set('ocproducts.xss_detect', '0');

    $_data = post_param_string('data');

    $data = encrypt_data_telemetry($_data);
    echo base64_encode(json_encode($data));
}

/**
 * Register this site with the homesite telemetry service if options and server environment permit.
 * This should also be called when we need to update the homesite with this site's name, version, or may feature setting.
 *
 * @param  boolean $skip_creation Whether to skip creating a site key-pair and registering if one does not exist; this should be true when calling from an error handler
 * @return boolean Whether the site has been registered or is already registered
 */
function register_site_telemetry(bool $skip_creation = false) : bool
{
    // Is telemetry disabled?
    $telemetry = get_option('telemetry');
    if ($telemetry == '0') {
        return false;
    }

    // Are we not able to support telemetry?
    if (!is_encryption_available_telemetry()) {
        return false;
    }

    // If we are skipping creation, but we do not have a site key-pair, this is a failure
    if (!is_encryption_enabled_telemetry() && $skip_creation) {
        return false;
    }

    // Get or create the key-pairs for this site
    if (is_encryption_enabled_telemetry()) {
        list($public_key, $private_key, $sign_public_key, $sign_private_key) = get_site_keys_telemetry();
    } else {
        list($public_key, $private_key, $sign_public_key, $sign_private_key) = generate_site_telemetry_key_pair();
    }

    // Create a telemetry challenge to verify site ownership with the homesite on registration
    require_code('crypt');
    require_code('files2');

    $challenge = get_secure_random_string(32, CRYPT_BASE64);
    cms_file_put_contents_safe(get_custom_file_base() . '/data_custom/telemetry_challenge.txt', $challenge);

    require_code('version');

    // We must send the data encrypted using the software keys, not the site keys, because the homesite does not yet know this site's public key
    $__payload = [
        'website_url' => get_base_url(),
        'website_name' => get_site_name(),
        'may_feature' => (get_option('telemetry_may_feature') == '1') ? 1 : 0,
        'version' => cms_version_pretty(),
        'public_key' => $public_key,
        'sign_public_key' => $sign_public_key,
        'challenge' => $challenge,
    ];
    $_payload = encrypt_data_telemetry(serialize($__payload));
    $payload = json_encode($_payload);

    // Register the site (which will also trigger the homesite to check the challenge)
    $url = get_brand_base_url() . '/data/endpoint.php/cms_homesite/telemetry?type=register';
    $error_code = null;
    $error_message = '';
    $response = cms_fsock_request($payload, $url, $error_code, $error_message);

    // No success?
    if (($response === null) || (strpos($response, '"success":true') === false)) {
        return false;
    }

    return true;
}

/**
 * Establish a guest session ID with the homesite and return it.
 *
 * @param  boolean $get_hashed Whether to get the hashed session ID instead of the actual one
 * @return ?ID_TEXT The session ID (null: error)
 */
function get_brand_session(bool $get_hashed = true) : ?string
{
    // HACKHACK: You must un-comment the 'session_id' line in the endpoints hook cms_homesite/telemetry if you want raw session IDs; not returned by default for security.
    // Prepare request to the homesite
    $__payload = [
        'version' => cms_version_pretty(),
        'request' => 'get_session',
    ];
    $_payload = encrypt_data_telemetry(serialize($__payload));
    $payload = json_encode($_payload);
    $post = ['data' => $payload];
    $url = get_brand_base_url() . '/data/endpoint.php/cms_homesite/get_session';

    // Make the request
    $data = cms_http_request($url, ['post_params' => $post, 'timeout' => 6.0, 'trigger_error' => false]);
    if (($data->message != '200') || ($data->data === null)) {
        return null;
    }

    // Parse response
    $http_result = @json_decode($data->data, true);
    if (($http_result === false) || ($http_result['success'] === false)) {
        return null;
    }

    if ($get_hashed) {
        return $http_result['response_data']['session_id_hashed'];
    }

    return $http_result['response_data']['session_id'];
}
