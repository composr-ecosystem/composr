<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_upgrader
 */

/**
 * Do upgrader screen: file upgrade UI.
 *
 * @ignore
 * @return string Output messages
 */
function upgrader_file_upgrade_screen() : string
{
    $out = '';

    require_code('version2');
    $personal_upgrader_generation_url = get_brand_base_url() . '/uploads/website_specific/composr.app/scripts/build_personal_upgrader.php?from=' . urlencode(get_version_dotted());
    if (function_exists('gzopen')) {
        $personal_upgrader_generation_url .= '&supports_gzip=1';
    }
    if ((function_exists('zip_open')) || (get_option('unzip_cmd') == '')) {
        $personal_upgrader_generation_url .= '&supports_zip=1';
    }
    $hooks = find_all_hooks('systems', 'addon_registry');
    foreach (array_keys($hooks) as $hook) {
        if (is_file(get_file_base() . '/sources/hooks/systems/addon_registry/' . $hook . '.php')) {
            $personal_upgrader_generation_url .= '&addon_' . $hook . '=1';
        }
    }

    require_code('files2');
    $found_upgraders = [];
    foreach (['/data_custom', ''] as $upgrader_place) {
        $files = get_directory_contents(get_file_base() . $upgrader_place, get_file_base() . $upgrader_place, null, false, true, ['cms', 'gz', 'zip']);
        foreach ($files as $file_path) {
            if (preg_match('#^.*/(omni-)?upgrade-' . preg_quote(get_version_dotted(), '#') . '-[^/]*\.(cms(\.gz)?|zip)$#', $file_path) != 0) {
                $found_upgraders[get_base_url() . $upgrader_place . '/' . basename($file_path)] = filemtime($file_path);
            }
        }
    }
    if (empty($found_upgraders)) {
        $upgrader_tar_url = base64_decode(get_param_string('tar_url', '', INPUT_FILTER_URL_GENERAL));
    } else {
        arsort($found_upgraders);
        $found_upgraders = array_keys($found_upgraders);
        $upgrader_tar_url = $found_upgraders[0];
    }

    if ($upgrader_tar_url == '') {
        $out .= do_lang('UPGRADER_FILE_UPGRADE_INFO', escape_html(get_brand_base_url()));
    }

    $out .= do_lang('UPGRADER_FILE_UPGRADE_INFO_MANUAL', escape_html($personal_upgrader_generation_url));
    $out .= '<form title="' . do_lang('PROCEED') . '" enctype="multipart/form-data" action="upgrader.php?type=_file_upgrade" method="post">' . post_fields_relay();
    $out .= '<p><label for="url">' . do_lang('URL') . '</label> <input type="text" id="url" name="url" size="80" value="' . escape_html($upgrader_tar_url) . '" /></p>';
    $out .= '<p><label for="dry_run"><input type="checkbox" id="dry_run" name="dry_run" value="1" /> ' . do_lang('UPGRADER_DRY_RUN') . '</label></p>';
    if ((get_base_url() == get_brand_base_url()) || ($GLOBALS['DEV_MODE'])) { // for the core team to use on own site, for testing
        $out .= '<p><label for="upload">' . do_lang('ALT_FIELD', do_lang('UPLOAD')) . '</label> <input type="file" id="upload" name="upload" /></p>';
        $out .= '<script ' . csp_nonce_html() . '>var url=document.getElementById(\'url\'); url.addEventListener(\'change\', function() { document.getElementById(\'upload\').disabled=url.value!=\'\'; });</script>';
    }
    $proceed_icon = do_template('ICON', ['_GUID' => '7a84502d5457fd3960d8e5056ee1cb49', 'NAME' => 'buttons/proceed']);
    $out .= '<p><button class="btn btn-primary btn-scr buttons--proceed" type="submit">' . $proceed_icon->evaluate() . ' ' . do_lang('PROCEED') . '</button></p>';
    $out .= '</form>';

    return $out;
}

/**
 * Do upgrader screen: file upgrade actualiser.
 *
 * @ignore
 * @return string Output messages
 */
function _upgrader_file_upgrade_screen() : string
{
    $out = '';

    // Dry run?
    $dry_run = (post_param_integer('dry_run', 0) == 1);
    if ($dry_run) {
        $out .= '<p>' . do_lang('UPGRADER_DOING_DRY_RUN') . '</p>';
    } else {
        log_it('UPGRADER_DOWNLOAD');
    }

    // Turn off limits, this may be exhaustive
    cms_extend_time_limit(TIME_LIMIT_EXTEND__CRAWL);
    disable_php_memory_limit();

    // How we can get file
    define('FILE_RETRIEVAL_UPLOAD', 0);
    define('FILE_RETRIEVAL_HTTP', 1);
    define('FILE_RETRIEVAL_LOCAL', 2);

    // Get file
    require_code('tar');
    if ((post_param_string('url', '', INPUT_FILTER_URL_GENERAL) == '') && ((get_base_url() == get_brand_base_url()) || ($GLOBALS['DEV_MODE']))) {
        $upgrade_path = $_FILES['upload']['tmp_name'];
        $original_filename = $_FILES['upload']['name'];
        $retrieval_method = FILE_RETRIEVAL_UPLOAD;
    } else {
        if (post_param_string('url', '', INPUT_FILTER_URL_GENERAL) == '') {
            warn_exit(do_lang_tempcode('NO_PARAMETER_SENT', 'url'));
        }

        $url = post_param_string('url', false, INPUT_FILTER_URL_GENERAL);
        if (substr($url, 0, strlen(get_base_url() . '/')) == get_base_url() . '/') {
            $upgrade_path = get_file_base() . '/' . rawurldecode(substr($url, strlen(get_base_url() . '/')));
            if (!is_file($upgrade_path)) {
                warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
            }
            $original_filename = basename($upgrade_path);
            $retrieval_method = FILE_RETRIEVAL_LOCAL;
        } else {
            $upgrade_path = cms_tempnam();
            $upgrade_path_handle = fopen($upgrade_path, 'wb');
            $request = cms_http_request($url, ['write_to_file' => $upgrade_path_handle, 'timeout' => 30.0]);
            fclose($upgrade_path_handle);
            $original_filename = $request->filename;
            $retrieval_method = FILE_RETRIEVAL_HTTP;
        }
    }
    $may_delete_upgrade_path = ($retrieval_method != FILE_RETRIEVAL_LOCAL);

    // We do support using a .zip (e.g. manual installer package), but we need to convert it
    if (cms_strtolower_ascii(substr($original_filename, -4)) == '.zip') {
        require_code('tar2');
        $upgrade_path_new = null;
        convert_zip_to_tar($upgrade_path, $upgrade_path_new);
        if ($may_delete_upgrade_path) {
            @unlink($upgrade_path);
        }
        $upgrade_path = $upgrade_path_new;
        fix_permissions($upgrade_path);
    }

    // Open up TAR (or tarball)
    $upgrade_resource = tar_open($upgrade_path, 'rb', false, $original_filename);
    //tar_extract_to_folder($upgrade_resource, '', true);
    $directory = tar_get_directory($upgrade_resource); // Uses up to around 5MB of RAM

    // Hopefully $popup_simple_extract will be true (i.e. suEXEC mode), as it is safer
    $popup_simple_extract = (_ftp_info() === false);
    if ($popup_simple_extract) {
        $metadata = ['todo' => []];
    } else {
        $out .= '<p>' . do_lang('EXTRACTING_MESSAGE') . '</p>';
    }

    // Find addons
    $addon_contents = [];
    foreach ($directory as $upgrade_file2) {
        // See if we can find an addon registry file in our upgrade file
        if ((strpos($upgrade_file2['path'], '/addon_registry/') !== false) && (substr($upgrade_file2['path'], -4) == '.php')) {
            $file_data = tar_get_file($upgrade_resource, $upgrade_file2['path']);
            $addon_contents[basename($upgrade_file2['path'], '.php')] = $file_data['data'];
        }
    }
    $files_for_tar_updating = [];

    // Process files
    $i = 0;
    $cnt = count($directory);
    foreach ($directory as $offset => $upgrade_file) {
        $i++;
        $out .= '<!-- Looking at ' . escape_html($upgrade_file['path']) . ' (' . strval($i) . ' / ' . strval($cnt) . ') -->';

        // Skip over these, from manual installer package (which may be used for an upgrade)
        if ($upgrade_file['path'] == '_config.php') {
            continue;
        }
        if ($upgrade_file['path'] == 'install.php') {
            continue;
        }
        if ($upgrade_file['path'] == 'install.sql' || $upgrade_file['path'] == '_config.php.template') {
            continue;
        }

        $is_directory = (substr($upgrade_file['path'], -1) == '/');

        if (!$popup_simple_extract) {
            // See if we can skip the file, if the on-disk version is identical?
            if ((file_exists(get_file_base() . '/' . $upgrade_file['path'])) && (($is_directory) || (filesize(get_file_base() . '/' . $upgrade_file['path']) == $upgrade_file['size']))) {
                $tar_data = tar_get_file($upgrade_resource, $upgrade_file['path']);
                if (cms_file_get_contents_safe(get_file_base() . '/' . $upgrade_file['path'], FILE_READ_LOCK) == $tar_data['data']) {
                    $out .= do_lang('UPGRADER_SKIPPING_MESSAGE', escape_html($upgrade_file['path'])) . '<br />';
                    continue;
                }
            }
        }

        // Addon file. Check to see if we should extract this via if it exists on disk either through its current name or a past name (or is core_*).
        $extract_addon = false;
        if ((strpos($upgrade_file['path'], '/addon_registry/') !== false)) {
            if (((file_exists(get_file_base() . '/' . $upgrade_file['path'])) || (strpos($upgrade_file['path'], '/core_') !== false))) {
                $extract_addon = true;
            } else {
                require_code('global3');
                $file_data = tar_get_file($upgrade_resource, $upgrade_file['path']);
                $matches = [];
                if (cms_preg_match_all_safe("/'previously_in_addon'\s*=>\s*\[(.*?)\]/", $file_data['data'], $matches) !== false) {
                    foreach ($matches[1] as $match) {
                        $previous_names = explode(", ", $match);
                        foreach ($previous_names as $previous_name) {
                            if (file_exists(get_file_base() . '/' . dirname($upgrade_file['path']) . '/' . trim($previous_name, "'") . '.php')) {
                                $extract_addon = true;

                                // We need to update the database accordingly with the new name of the addon
                                $GLOBALS['SITE_DB']->query_update('addons', [
                                    'addon_name' => str_replace('.php', '', basename($upgrade_file['path'])),
                                ], ['addon_name' => trim($previous_name, "'")], '', 1);

                                $out .= do_lang('UPGRADER_RENAMED_ADDON_MESSAGE', escape_html(trim($previous_name, "'")), escape_html(str_replace('.php', '', basename($upgrade_file['path'])))) . '<br />';
                            }
                        }
                    }
                }
            }
        }

        // What kind of file did we find?
        if ($extract_addon) {
            // Addon registry file, for installed addon, renamed installed addon, or core addon...

            if (!$is_directory) {
                $metadata['todo'][] = [$upgrade_file['path'], $upgrade_file['mtime'], $offset + 512, $upgrade_file['size'], ($upgrade_file['mode'] & 0002) != 0];

                if (!$popup_simple_extract) {
                    $file_data = tar_get_file($upgrade_resource, $upgrade_file['path']);
                    if (!$dry_run) {
                        afm_make_file($upgrade_file['path'], $file_data['data'], ($file_data['mode'] & 0002) != 0);
                    }
                    $out .= do_lang('UPGRADER_EXTRACTING_MESSAGE', escape_html($upgrade_file['path'])) . '<br />';
                }
            }
        } else {
            // Some other file...

            $found = null;
            if (!$is_directory) {
                foreach ($addon_contents as $addon_name => $addon_data) {
                    // See if this is the addon for the file
                    $addon_file_path = $upgrade_file['path'];
                    if (strpos($addon_data, '\'' . addslashes($addon_file_path) . '\'') !== false) {
                        $found = $addon_name;
                        if (file_exists(get_file_base() . '/sources/hooks/systems/addon_registry/' . $found . '.php')) {
                            break;
                        }
                        // ^ otherwise keep looking for an addon we have installed containing this file
                    }
                }
            }

            // Install if it's a file in an addon we have installed or for a core addon
            //  (if we couldn't find the addon for it we have to assume a corrupt upgrade TAR and must skip the file)
            $install_alien_files = false;
            if ((($found !== null) || ($install_alien_files))) {
                if ($is_directory) {
                    if (!$dry_run) {
                        afm_make_directory($upgrade_file['path'], false, true);
                    }
                } else {
                    $metadata['todo'][] = [$upgrade_file['path'], $upgrade_file['mtime'], $offset + 512, $upgrade_file['size'], ($upgrade_file['mode'] & 0002) != 0];

                    if (!$popup_simple_extract) {
                        $file_data = tar_get_file($upgrade_resource, $upgrade_file['path']);
                        if (!$dry_run) {
                            if (!file_exists(get_file_base() . '/' . dirname($upgrade_file['path']))) {
                                afm_make_directory(dirname($upgrade_file['path']), false, true);
                            }
                            afm_make_file($upgrade_file['path'], $file_data['data'], ($file_data['mode'] & 0002) != 0);
                        }

                        $out .= do_lang('UPGRADER_EXTRACTING_MESSAGE', escape_html($upgrade_file['path'])) . '<br />';
                    }
                }
            }

            // Record to copy it into our archived addon so that addon is kept up-to-date
            if (!$is_directory) {
                if (($found !== null) && (file_exists(get_file_base() . '/imports/addons/' . $found . '.tar'))) {
                    $files_for_tar_updating[$found][$upgrade_file['path']] = [$upgrade_file['mode'], $upgrade_file['mtime']];
                }
            }
        }
    }

    $files_previous_path = 'data/files_previous.bin';
    $file_data = tar_get_file($upgrade_resource, $files_previous_path);
    if ($file_data !== null) {
        $files_previous = unserialize($file_data['data']);
    } else {
        $files_previous = [];
    }
    $files_current_path = 'data/files.bin';
    $file_data = tar_get_file($upgrade_resource, $files_current_path);
    if ($file_data !== null) {
        $files_current = unserialize($file_data['data']);
    } else {
        $files_current = [];
    }

    // Copy it into our archived addon so that addon is kept up-to-date
    foreach ($files_for_tar_updating as $found => $files) {
        $old_addon_file = tar_open(get_file_base() . '/imports/addons/' . $found . '.tar', 'rb');
        $directory2 = tar_get_directory($old_addon_file, true);
        if ($directory2 !== null) {
            // New version of TAR file
            $new_addon_file = tar_open(get_file_base() . '/imports/addons/' . $found . '.new.tar', 'wb');

            // Add files from old TAR file, except ones we are replacing or ones that should no longer exist
            foreach ($directory2 as $d) {
                if (substr($d['path'], -1) == '/') {
                    // Ignore folders
                    continue;
                }

                if (array_key_exists($d['path'], $files)) {
                    // We are replacing this
                    continue;
                }

                if ((array_key_exists($d['path'], $files_previous)) && (!array_key_exists($d['path'], $files_current))) {
                    // Has been deleted
                    continue;
                }

                $file_data = tar_get_file($old_addon_file, $d['path']);

                $file_data['data'] = preg_replace('#^version=.*#m', 'version=(version-synched)', $file_data['data']);

                tar_add_file($new_addon_file, $d['path'], $file_data['data'], $d['mode'], $d['mtime']);
            }
            tar_close($old_addon_file);

            foreach ($files as $file_to_update => $_file_to_update) {
                list($file_to_update_mode, $file_to_update_mtime) = $_file_to_update;

                $file_data = tar_get_file($upgrade_resource, $file_to_update);

                tar_add_file($new_addon_file, $file_to_update, $file_data['data'], $upgrade_file['mode'], $upgrade_file['mtime']);

                $out .= do_lang('UPGRADER_PACKING_MESSAGE', escape_html($file_to_update)) . '<br />';
            }

            tar_close($new_addon_file);

            if (!$dry_run) {
                unlink(get_file_base() . '/imports/addons/' . $found . '.tar');
                rename(get_file_base() . '/imports/addons/' . $found . '.new.tar', get_file_base() . '/imports/addons/' . $found . '.tar');
            } else {
                unlink(get_file_base() . '/imports/addons/' . $found . '.new.tar');
            }
            sync_file(get_file_base() . '/imports/addons/' . $found . '.tar');
        }
    }

    // Immediately upgrade these as the secondary upgrader (iframe) depends on them
    $immediately_upgrade = [
        'data/upgrader2.php',
        'sources/crypt_master.php',
    ];
    foreach ($immediately_upgrade as $path) {
        $file_data = tar_get_file($upgrade_resource, $path);
        if ($file_data !== null) {
            if (!$dry_run) {
                afm_make_file($path, $file_data['data'], ($file_data['mode'] & 0002) != 0);
            }
            $out .= do_lang('UPGRADER_EXTRACTING_MESSAGE', escape_html($path)) . '<br />';
        }
    }

    tar_close($upgrade_resource);

    // Do extraction within iframe, if possible
    if ($popup_simple_extract) {
        // These are standardised temp files upgrader2.php will expect
        $tmp_upgrade_path = get_custom_file_base() . '/data_custom/upgrader.cms.tmp';
        $tmp_metadata_path = get_custom_file_base() . '/data_custom/upgrader.tmp';

        // Remove standardised temp files
        @unlink($tmp_upgrade_path);
        @unlink($tmp_metadata_path);

        // How do we get our $upgrade_path file into $tmp_upgrade_path?
        switch ($retrieval_method) {
            case FILE_RETRIEVAL_UPLOAD:
                move_uploaded_file($upgrade_path, $tmp_upgrade_path);
                break;
            case FILE_RETRIEVAL_HTTP:
                rename($upgrade_path, $tmp_upgrade_path);
                break;
            case FILE_RETRIEVAL_LOCAL:
                copy($upgrade_path, $tmp_upgrade_path);
                break;
        }

        // Save our metadata
        require_code('files');
        cms_file_put_contents_safe($tmp_metadata_path, serialize($metadata));

        // LEGACY: Copy by old password key if needed
        global $SITE_INFO;
        if (isset($GLOBALS['SITE_INFO']['admin_password'])) {
            $GLOBALS['SITE_INFO']['maintenance_password'] = $GLOBALS['SITE_INFO']['admin_password'];
            unset($GLOBALS['SITE_INFO']['admin_password']);
        }
        if (isset($GLOBALS['SITE_INFO']['master_password'])) {
            $GLOBALS['SITE_INFO']['maintenance_password'] = $GLOBALS['SITE_INFO']['master_password'];
            unset($GLOBALS['SITE_INFO']['master_password']);
        }

        if (!$dry_run) {
            // Create the iframe
            $extract_url = get_base_url() . '/data/upgrader2.php';
            $extract_url .= '?hashed_password=' . urlencode($SITE_INFO['maintenance_password']);
            $extract_url .= '&file_offset=0';
            $extract_url .= '&done=' . urlencode(do_lang('DONE'));
            $extract_url .= '&original_filename=' . urlencode($original_filename);
            $extract_url .= '&may_delete_upgrade_path=' . strval($may_delete_upgrade_path ? 1 : 0);
            $out .= '<p>' . do_lang('UPGRADER_EXTRACTING_WINDOW', integer_format(count($metadata['todo']))) . '</p>';
            $out .= '<iframe frameBorder="0" style="width: 100%; height: 400px" src="' . escape_html($extract_url) . '"></iframe>';
        } else {
            // Show the dry-run results
            $out .= '<p>' . do_lang('FILES') . ':</p>';
            $out .= '<ul>';
            if (empty($metadata['todo'])) {
                $out .= '<li><em>' . do_lang('NONE') . '</em></li>';
            } else {
                foreach ($metadata['todo'] as $file) {
                    $out .= '<li><kbd>' . escape_html($file[0]) . '</kbd></li>';
                }
            }
            $out .= '</ul>';
        }
    } else {
        // We extracted live, so just tidy up
        $out .= '<p>' . do_lang('SUCCESS') . '</p>';
        if ($may_delete_upgrade_path) {
            @unlink($upgrade_path);
        }
    }

    unset($_POST['news_id']);
    unset($_POST['from_version']);

    return $out;
}
