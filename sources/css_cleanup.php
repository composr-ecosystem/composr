<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2023

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_themeing
 */

/**
 * Base class for CSS conversions.
 *
 * @package core_themeing
 */
abstract class CSSCleanup
{
    protected $theme = 'default';
    protected $css_files = [];
    protected $css_files_old_names = [];
    protected $do_as_overrides = true;
    protected $carry_from_default = true;

    /**
     * Constructor.
     *
     * @param  string $theme Theme to operate on
     * @param  boolean $do_as_overrides Whether to save as overrides
     * @param  boolean $carry_from_default Whether to copy files from the default theme that are not in the $theme theme already
     */
    public function __construct(string $theme = 'default', bool $do_as_overrides = true, bool $carry_from_default = true)
    {
        $this->theme = $theme;
        $this->do_as_overrides = $do_as_overrides;
        $this->carry_from_default = $carry_from_default;
    }

    /**
     * Calculate changes.
     */
    abstract public function work_out_changes();

    /**
     * Save the changes.
     */
    public function save_changes()
    {
        if (empty($this->css_files)) {
            $this->work_out_changes();
        }

        foreach ($this->css_files as $path => $c) {
            $old_path = $this->css_files_old_names[$path];
            if (cms_file_get_contents_safe($old_path, FILE_READ_LOCK | FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM) != $c) {
                if (is_file($path)) {
                    $revision_path = $path . '.' . strval(time());
                    copy($old_path, $revision_path);
                    fix_permissions($revision_path);
                    sync_file($revision_path);
                } else {
                    $editfrom_path = $path . '.editfrom';
                    copy($old_path, $editfrom_path);
                    fix_permissions($editfrom_path);
                    sync_file($editfrom_path);
                }

                cms_file_put_contents_safe($path, $c, FILE_WRITE_BOM);
            }
        }
    }

    /**
     * Find all the CSS files in the theme.
     */
    protected function find_css_files()
    {
        if (!empty($this->css_files)) {
            return; // Already done
        }

        $this->css_files = [];

        if ($this->carry_from_default) {
            $themes = array_unique(['default', $this->theme]);
        } else {
            $themes = [$this->theme];
        }
        foreach ($themes as $theme) {
            foreach (['css', 'css_custom'] as $_dir) {
                $dir = get_file_base() . '/themes/' . $theme . '/' . $_dir;
                $dh = opendir($dir);
                while (($f = readdir($dh)) !== false) {
                    if (substr($f, -4) == '.css') {
                        $path = $dir . '/' . $f;
                        $c = cms_file_get_contents_safe($path, FILE_READ_LOCK | FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM);

                        $new_path = $path;
                        $new_path = str_replace('/themes/default/', '/themes/' . $this->theme . '/', $new_path);
                        if ($this->do_as_overrides) {
                            $new_path = str_replace('/themes/' . $this->theme . '/css/', '/themes/' . $this->theme . '/css_custom/', $new_path);
                        }

                        $this->css_files[$new_path] = $c;

                        $this->css_files_old_names[$new_path] = $path;
                    }
                }
                closedir($dh);
            }
        }
    }
}

/**
 * Class to convert em units to px units.
 *
 * This code is an approximation.
 * Even if we did it using a full CSS selector engine, it would still be an approximation.
 * So we have made the decision to hard-code it to Composr's default theme.
 * Key assumptions made are mentioned within code comments.
 *
 * @package core_themeing
 */
class DirSimplify extends CSSCleanup
{
    protected $selectors = [];

    /**
     * Calculate changes.
     */
    public function work_out_changes()
    {
        $this->find_css_files();

        foreach ($this->css_files as $path => &$c) {
            $c = str_replace(['{!dir}', '{!en_left}', '{!en_right}'], [do_lang('dir'), do_lang('en_left'), do_lang('en_right')], $c);
        }
    }

    /**
     * Save The changes.
     */
    public function save_changes()
    {
        parent::save_changes();
    }
}

/**
 * Class to convert em units to px units.
 *
 * This code is an approximation.
 * Even if we did it using a full CSS selector engine, it would still be an approximation.
 * So we have made the decision to hard-code it to Composr's default theme.
 * Key assumptions made are mentioned within code comments.
 *
 * @package core_themeing
 */
class EmToPx extends CSSCleanup
{
    protected $selectors = [];

    /**
     * Calculate changes.
     */
    public function work_out_changes()
    {
        $this->find_css_files();

        $this->find_selectors();

        foreach ($this->selectors as $selector => &$_selectors) {
            foreach ($_selectors as $_selector) {
                $full_orig = $_selector[1];

                $selector_contents = &$_selector[0];
                $full = &$_selector[1];
                $font_size = &$_selector[2];
                $offset = &$_selector[3];
                $path = &$_selector[4];

                $full_new = $full;

                $matches = [];
                $num_em_parts = preg_match_all('#([\d\.]+)em([^\w]|$)#', $full, $matches, PREG_OFFSET_CAPTURE);
                for ($i = 0; $i < $num_em_parts; $i++) {
                    $offset = $matches[1][$i][1];
                    $_full = substr($full, 0, $offset);
                    $back_offset = max(strrpos($_full, ';'), strrpos($_full, '{')) + 1;
                    $colon_offset = strrpos($_full, ':');
                    $property = trim(substr($full, $back_offset, $colon_offset - $back_offset));
                    $is_for_font_size = (cms_strtolower_ascii($property) == 'font-size');

                    $_amount_em = $matches[1][$i][0];
                    $amount_em = floatval($_amount_em);

                    $amount_px = $this->convert_em_to_px($amount_em, $selector, $is_for_font_size);
                    $_amount_px = float_to_raw_string($amount_px, 0, true);

                    $font_size = $_amount_px . 'px';

                    $full = str_replace(
                        $_amount_em . 'em',
                        $_amount_px . 'px',
                        $full
                    );
                }

                $this->css_files[$path] = str_replace($full_orig, $full, $this->css_files[$path]);
            }
        }
    }

    /**
     * Save The changes.
     */
    public function save_changes()
    {
        parent::save_changes();
    }

    /**
     * Find all the selectors in all the CSS files.
     */
    protected function find_selectors()
    {
        if (count($this->selectors) > 0) {
            return; // Already done
        }

        $this->selectors = [];

        foreach ($this->css_files as $path => $c) {
            $len = strlen($c);
            $matches = [];
            $num_selectors = preg_match_all('#^\s*?([^{};/@\s][^{};/]*)\s*\{(?![\$\!])#Um', $c, $matches, PREG_OFFSET_CAPTURE);
            for ($i = 0; $i < $num_selectors; $i++) {
                $offset = $matches[0][$i][1];
                $offset_selector_contents = $offset + strlen($matches[0][$i][0]);
                $selector = $matches[1][$i][0];
                $selector_contents = '';
                $balance = 1;
                for ($j = $offset_selector_contents; $j < $len; $j++) {
                    if ($c[$j] == '{') {
                        $balance++;
                    }
                    if ($c[$j] == '}') {
                        $balance--;
                    }
                    if ($balance == 0) {
                        break;
                    }
                    $selector_contents .= $c[$j];
                }
                $full = $matches[0][$i][0] . $selector_contents . '}';

                $font_size = null;
                $matches2 = [];
                if (preg_match('#font-size:\s*([\d\.]+(px|em|%|pt))#i', $selector_contents, $matches2) != 0) {
                    $font_size = $this->normalise_font_size($matches2[1]);
                }

                $_selector = [
                    $selector_contents,
                    $full,
                    $font_size,
                    $offset,
                    $path,
                    $selector,
                ];
                if (!isset($this->selectors[$selector])) {
                    $this->selectors[$selector] = [];
                }
                $this->selectors[$selector][] = $_selector;
            }
        }
    }

    /**
     * Convert font units. We only want em/rem/px font sizes, so do conversions from the other possible unit types.
     *
     * @param  string $font_size Font size
     * @return string Normalised font size
     */
    protected function normalise_font_size(string $font_size) : string
    {
        $font_size = cms_strtolower_ascii($font_size);

        if (substr($font_size, -1) == '%') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 1);
            $font_size = float_to_raw_string(floatval($_font_size) * (48.0) / (300.0), 0) . 'px';
        } elseif (substr($font_size, -2) == 'pt') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 2);
            $font_size = float_to_raw_string(floatval($_font_size) * (48.0) / (36.0), 0) . 'px';
        } elseif (substr($font_size, -2) == 'cm') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 2);
            $font_size = float_to_raw_string(floatval($_font_size) * (28.35 * 48.0) / (36.0), 0) . 'px';
        } elseif (substr($font_size, -2) == 'mm') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 2);
            $font_size = float_to_raw_string(floatval($_font_size) * (2.835 * 48.0) / (36.0), 0) . 'px';
        } elseif (substr($font_size, -2) == 'in') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 2);
            $font_size = float_to_raw_string(floatval($_font_size) * (72.0 * 48.0) / (36.0), 0) . 'px';
        } elseif (substr($font_size, -2) == 'pc') {
            $_font_size = substr($font_size, 0, strlen($font_size) - 2);
            $font_size = float_to_raw_string(floatval($_font_size) * (48.0) / (36.0 * 12.0), 0) . 'px';
        } elseif ($font_size == 'xx-large') {
            $font_size = '32px';
        } elseif ($font_size == 'x-large') {
            $font_size = '24px';
        } elseif ($font_size == 'large') {
            $font_size = '18px';
        } elseif ($font_size == 'medium') {
            $font_size = '16px';
        } elseif ($font_size == 'small') {
            $font_size = '13px';
        } elseif ($font_size == 'x-small') {
            $font_size = '10px';
        } elseif ($font_size == 'xx-small') {
            $font_size = '9px';
        } elseif (substr($font_size, -2) == 'ex') {
            $font_size = substr($font_size, 0, strlen($font_size) - 2) . 'px';
        } elseif (substr($font_size, -2) == 'ch') {
            $font_size = substr($font_size, 0, strlen($font_size) - 2) . 'px';
        } elseif (substr($font_size, -2) == 'em') {
            // Good
        } elseif (substr($font_size, -3) == 'rem') {
            // Good
        } elseif (substr($font_size, -2) == 'px') {
            // Good
        } else {
            $font_size = null; // We can't actually use it (e.g. viewport units)
        }

        return $font_size;
    }

    /**
     * Convert em to px units for a given selector.
     *
     * @param  float $amount_em Size in em units
     * @param  string $selector Selector
     * @param  boolean $is_for_font_size It is for a font size property
     * @return float Size in px units
     */
    protected function convert_em_to_px(float $amount_em, string $selector, bool $is_for_font_size = false) : float
    {
        // We do our big approximations in here. We assume we can predict all places font-sizes may raise based on html, body, and the trail of our selector, and that nothing compounds across multiple elements matching the same selector.
        // Practically speaking, these approximations are good enough, especially given that:
        //  (a) we tend to over-specify our selectors for clarity
        //  (b) compounding can't be represented in px anyway
        //  (c) we don't have many places we re-set font size in practice, because consistent font-size is good design practice

        $chain = [];

        if (!$this->selector_corresponds('html', $selector, [], true)) {
            $chain[] = 'html';
        }

        if (!$this->selector_corresponds('body', $selector, ['html'], true)) {
            $chain[] = 'body.website-body'; // Assumption of our default theme that we use ".website-body"
        }

        $parts = explode(',', $selector);
        $part = trim($parts[0]);
        $_parts = preg_split('#[ >]#', $part);
        foreach ($_parts as $__part) {
            if ((!$this->selector_corresponds('html', $__part, [], true)) && (!$this->selector_corresponds('body', $__part, ['html'], true))) {
                $chain[] = $__part;
            }
        }

        $inherited_font_size = $this->find_font_size_from_chain($chain, $selector);

        if ($is_for_font_size) {
            $amount_em = 1.0; // We we are considering our own font-size in $inherited_font_size already
        }

        return $amount_em * $inherited_font_size;
    }

    /**
     * Find the font size given a chain of possible parent selectors.
     *
     * @param  array $chain Possible parent selectors
     * @param  string $context_selector The selector this is for (useful for debugging, not used for calculation)
     * @return integer Font size in px units
     */
    protected function find_font_size_from_chain(array $chain, string $context_selector) : int
    {
        $font_size = 16;
        $root_font_size = $font_size;

        $may_be_chained_by = [];

        foreach ($chain as $selector) {
            $may_be_chained_by_copy = $may_be_chained_by;
            foreach ($may_be_chained_by_copy as $_may_be_chained_by) {
                $may_be_chained_by[] = $_may_be_chained_by . ' ' . $selector;
                $may_be_chained_by[] = $_may_be_chained_by . '>' . $selector;
                $may_be_chained_by[] = $_may_be_chained_by . ' > ' . $selector;
            }
            $may_be_chained_by[] = $selector;

            //$_selectors = isset($this->selectors[$selector]) ? $this->selectors[$selector] : []; Actually we might have selectors that have multiple comma-d components, so this is too naive even for our approximations
            $_selectors = [];
            foreach ($this->selectors as $__selector => $__selectors) {
                if ($this->selector_corresponds($selector, $__selector, $may_be_chained_by)) {
                    $_selectors = array_merge($_selectors, $__selectors);
                }
            }

            foreach (array_reverse($_selectors) as $_selector) {
                $_font_size = $_selector[2];
                if ($_font_size !== null) {
                    if ($_font_size == 'larger') {
                        $_font_size = '1.2em';
                    } elseif ($_font_size == 'smaller') {
                        $_font_size = '0.9em';
                    }

                    if (substr($_font_size, -2) == 'px') {
                        $font_size = intval(substr($_font_size, 0, strlen($_font_size) - 2));
                    } elseif (substr($_font_size, -2) == 'em') {
                        $font_size = $font_size * floatval(substr($_font_size, 0, strlen($_font_size) - 2));
                    } elseif (substr($_font_size, -3) == 'rem') {
                        $font_size = $root_font_size * floatval(substr($_font_size, 0, strlen($_font_size) - 3));
                    }

                    if ($selector == 'html') {
                        $root_font_size = $font_size;
                    }
                    continue 2; // We'll use last instance of selector that has font size with highest priority and no others; must not em-compound multiple times within a single element
                }
            }
        }

        return $font_size;
    }

    /**
     * Whether the $complex selector corresponds to the $simple selector.
     *
     * @param  string $simple Simple selector
     * @param  string $complex Complex selector
     * @param  array $may_be_chained_by Possible prefixes to the simple selector to make the complex selector
     * @param  boolean $just_element Just check the element part of the selector, ignore any complex selector parts of it (like attribute selector)
     * @return boolean Whether it corresponds
     */
    protected function selector_corresponds(string $simple, string $complex, array $may_be_chained_by = [], bool $just_element = false) : bool
    {
        if ($simple == '') {
            return false;
        }

        if (strpos($complex, $simple) === false) {
            return false; // Optimised code path
        }

        $parts = explode(',', $complex);
        foreach ($parts as $part) {
            $part = trim($part);

            if ($just_element) {
                $part = preg_replace('#[^\w][^ ]*$#', '', $part);
            }

            if ($may_be_chained_by !== null) {
                foreach ($may_be_chained_by as $_may_be_chained_by) {
                    if ($part == $_may_be_chained_by . ' ' . $simple) {
                        return true;
                    }
                    if ($part == $_may_be_chained_by . '>' . $simple) {
                        return true;
                    }
                    if ($part == $_may_be_chained_by . ' > ' . $simple) {
                        return true;
                    }
                }
            }

            if ($part == $simple) {
                return true;
            }
        }

        return false;
    }
}
