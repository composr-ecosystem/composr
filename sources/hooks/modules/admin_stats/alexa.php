<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2021

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    stats
 */

/**
 * Hook class.
 */
class Hook_admin_stats_alexa extends CMSStatsProvider
{
    /**
     * Find metadata about stats graphs that are provided by this stats hook.
     *
     * @param  boolean $for_kpi Whether this is for setting up a KPI
     * @return ?array Map of metadata (null: hook is disabled)
     */
    public function info(bool $for_kpi = false) : ?array
    {
        return [
            'alexa_ranking' => [
                'label' => do_lang_tempcode('ALEXA_RANKING'),
                'category' => 'hits',
                'filters' => [
                    'alexa_ranking__month_range' => new CMSStatsDateMonthRangeFilter('alexa_ranking__month_range', do_lang_tempcode('DATE_RANGE'), null, $for_kpi),
                ],
                'pivot' => null,
                'support_kpis' => self::KPI_LOW_IS_GOOD,
            ],
            'alexa_links' => [
                'label' => do_lang_tempcode('ALEXA_LINKS'),
                'category' => 'referrers_and_referrals',
                'filters' => [
                    'alexa_links__month_range' => new CMSStatsDateMonthRangeFilter('alexa_links__month_range', do_lang_tempcode('DATE_RANGE'), null, $for_kpi),
                ],
                'pivot' => null,
                'support_kpis' => self::KPI_HIGH_IS_GOOD,
            ],
        ];
    }

    /**
     * Preprocess raw data in the database into something we can efficiently draw graphs/conclusions from.
     *
     * @param  TIME $start_time Start timestamp
     * @param  TIME $end_time End timestamp
     * @param  array $data_buckets Map of data buckets; a map of bucket name to nested maps with the following maps in sequence: 'month', 'pivot', 'value' (then further map data) ; extended and returned by reference
     */
    public function preprocess_raw_data(int $start_time, int $end_time, array &$data_buckets)
    {
        list($rank, $links) = get_alexa_rank();

        $month = get_stats_month_for_timestamp(time());

        $data_buckets['alexa_ranking'][$month][''] = $rank;
        $data_buckets['alexa_links'][$month][''] = $links;
    }

    /**
     * Generate final data from preprocessed data.
     *
     * @param  string $bucket Data bucket we want data for
     * @param  string $pivot Pivot value
     * @param  array $filters Map of filters (including pivot if applicable)
     * @return array Final data in standardised map format
     */
    public function generate_final_data(string $bucket, string $pivot, array $filters) : array
    {
        $data = [];

        $where = [
            'p_bucket' => $bucket,
            'p_pivot' => $pivot,
        ];
        $extra = '';
        $extra .= ' AND p_month>=' . strval($filters[$bucket . '__month_range'][0]);
        $extra .= ' AND p_month<=' . strval($filters[$bucket . '__month_range'][1]);
        $data_rows = $GLOBALS['SITE_DB']->query_select('stats_preprocessed', ['p_data', 'p_month'], $where, $extra);
        foreach ($data_rows as $data_row) {
            $month = $data_row['p_month'];
            $pivotish_value = $this->make_date_pivot_value_nice('month_series', $month);

            $value = @unserialize($data_row['p_data']);
            $data[$pivotish_value] = $value;
        }

        switch ($bucket) {
            case 'alexa_ranking':
                $y_label = do_lang_tempcode('ALEXA_RANKING');
                break;

            case 'alexa_links':
                $y_label = do_lang_tempcode('COUNT_TOTAL');
                break;

            default:
                fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));
        }

        return [
            'type' => self::GRAPH_LINE_CHART,
            'data' => $data,
            'x_axis_label' => do_lang_tempcode('TIME_IN_TIMEZONE', escape_html(make_nice_timezone_name(get_site_timezone()))),
            'y_axis_label' => $y_label,
        ];
    }
}
