<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2020

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    stats
 */

/**
 * Hook class.
 */
class Hook_admin_stats_content extends CMSStatsProvider
{
    /**
     * Find metadata about stats graphs that are provided by this stats hook.
     *
     * @param  boolean $for_kpi Whether this is for setting up a KPI
     * @return ?array Map of metadata (null: hook is disabled)
     */
    public function info($for_kpi = false)
    {
        return [
            'content_views' => [
                'label' => do_lang_tempcode('CONTENT_VIEWS'),
                'category' => 'hits',
                'filters' => [
                    'content_views__content_type' => new CMSStatsListFilter('content_views__content_type', do_lang_tempcode('CONTENT_TYPE'), $this->find_all_content_types()),
                ],
                'pivot' => null,
            ],
            'content_views_per_content_day' => [
                'label' => do_lang_tempcode('CONTENT_VIEWS_PER_CONTENT_DAY'),
                'category' => 'hits',
                'filters' => [
                    'content_views__content_type' => new CMSStatsListFilter('content_views__content_type', do_lang_tempcode('CONTENT_TYPE'), $this->find_all_content_types()),
                ],
                'pivot' => null,
            ],
        ];
    }

    /**
     * Preprocess raw data in the database into something we can efficiently draw graphs/conclusions from.
     * This is for flat and timeless data.
     *
     * @param  TIME $start_time Start timestamp
     * @param  TIME $end_time End timestamp
     * @param  array $data_buckets Map of data buckets; a map of bucket name to nested maps
     */
    public function preprocess_raw_data_flat($start_time, $end_time, &$data_buckets)
    {
        $server_timezone = get_server_timezone();

        $date_pivots = $this->get_date_pivots();

        $limit_per_content_type = 100;

        $data_buckets['content_views'] = [];
        $data_buckets['content_views_per_content_day'] = [];

        $cma_hooks = find_all_hook_obs('systems', 'content_meta_aware', 'Hook_content_meta_aware_');
        $content_types = [];
        foreach ($cma_hooks as $content_type => $hook_ob) {
            $info = $hook_ob->info();
            if (($info !== null) && ($info['views_field'] !== null) && (is_string($info['id_field'])) && ($info['title_field'] !== null) && (strpos($info['title_field'], 'CALL:') === false)) {
                $db = $info['db'];
                $table = $info['table'];
                $title_field = $info['title_field'];
                $title_field_dereference = $info['title_field_dereference'];
                $id_field = $info['id_field'];
                $views_field = $info['views_field'];
                $add_time_field = $info['add_time_field'];

                $fields = [$title_field, $id_field, $views_field];
                if ($add_time_field !== null) {
                    $fields[] = $add_time_field;
                }
                $rows = $db->query_select($table, $fields, [], 'ORDER BY ' . $views_field . ' DESC', $limit_per_content_type);
                foreach ($rows as $row) {
                    $title = $title_field_dereference ? get_translated_text($row[$title_field], $db) : $row[$title_field];
                    $id = $row[$id_field];
                    if (is_integer($id)) {
                        $id = strval($id);
                    }
                    $views = $row[$views_field];

                    $data_buckets['content_views'][$content_type][$title . ' (#' . $id . ')'] = $views;

                    if ($add_time_field !== null) {
                        $add_time = $row[$add_time_field];
                        if ($add_time !== null) {
                            $days = floatval(time() - $add_time + 1/*prevent divide by zero errors*/) / floatval(60 * 60 * 24);
                            $data_buckets['content_views_per_content_day'][$content_type][$title . ' (#' . $id . ')'] = floatval($views) / $days;
                        }
                    }
                }
            }
        }
    }

    /**
     * Generate final data from preprocessed data.
     *
     * @param  string $bucket Data bucket we want data for
     * @param  string $pivot Pivot value
     * @param  array $filters Map of filters (including pivot if applicable)
     * @return array Final data in standardised map format
     */
    public function generate_final_data($bucket, $pivot, $filters)
    {
        $data = [];

        $content_types = $this->find_all_content_types();

        $where = [
            'p_bucket' => $bucket,
        ];
        $_data = $GLOBALS['SITE_DB']->query_select_value_if_there('stats_preprocessed_flat', 'p_data', $where);
        if ($_data !== null) {
            $__data = @unserialize($_data);
            if ($__data !== false) {
                foreach ($__data as $content_type => $_) {
                    if ((!empty($filters[$bucket . '__content_type'])) && ($filters[$bucket . '__content_type'] != $content_type)) {
                        continue;
                    }

                    $prefix = array_key_exists($content_type, $content_types) ? $content_types[$content_type] : $content_type;

                    foreach ($_ as $title => $total) {
                        $data[$prefix . ': ' . $title] = $total;
                    }
                }
            }
        }

        switch ($bucket) {
            case 'content_views':
                $y_label = do_lang_tempcode('VIEWS');
                break;

            case 'content_views_per_content_day':
                $y_label = do_lang_tempcode('CONTENT_VIEWS_PER_CONTENT_DAY');
                break;

            default:
                fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));
        }

        return [
            'type' => self::GRAPH_BAR_CHART,
            'data' => $data,
            'x_axis_label' => do_lang_tempcode('TIME_IN_TIMEZONE', escape_html(make_nice_timezone_name(get_site_timezone()))),
            'y_axis_label' => $y_label,
            'limit_bars' => true,
        ];
    }
}
