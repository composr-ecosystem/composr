<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_cleanup_tools
 */

/**
 * Hook class.
 */
class Hook_task_find_orphaned_uploads
{
    /**
     * Run the task hook.
     *
     * @return ?array A tuple of at least 2: Return mime-type, content (either Tempcode, or a string, or a filename and file-path pair to a temporary file), map of HTTP headers if transferring immediately, map of ini_set commands if transferring immediately (null: show standard success message)
     */
    public function run() : ?array
    {
        require_lang('cleanup');

        push_db_scope_check(false);

        // Find known paths
        $known_urls = [];
        $url_paths = $GLOBALS['SITE_DB']->query_select('db_meta', ['m_name', 'm_table'], ['m_type' => 'URLPATH']);
        $base_url = get_custom_base_url();
        foreach ($url_paths as $iteration => $url_path) {
            task_log($this, 'Processing table for referenced URLs, ' . $url_path['m_table'], $iteration, count($url_paths));

            $ofs = $GLOBALS['SITE_DB']->query_select($url_path['m_table'], [$url_path['m_name']]);
            foreach ($ofs as $of) {
                $url = $of[$url_path['m_name']];
                if (url_is_local($url)) {
                    $known_urls[rawurldecode($url)] = true;
                } else {
                    if (substr($url, 0, strlen($base_url)) == $base_url) {
                        $known_urls[rawurldecode(substr($url, strlen($base_url) + 1))] = true;
                    }
                }
            }
        }

        $all_files = $this->do_dir('uploads');
        sort($all_files);
        $orphaned = [];
        foreach ($all_files as $file) {
            if (!array_key_exists($file, $known_urls)) {
                $orphaned[] = [
                    'URL' => get_custom_base_url() . '/' . str_replace('%2F', '/', rawurlencode($file)),
                    'PATH' => $file,
                ];
            }
        }

        pop_db_scope_check();

        $ret = do_template('CLEANUP_ORPHANED_UPLOADS', [
            '_GUID' => '21049d738f67554cff0891d343c02ad3',
            'FOUND' => $orphaned,
        ]);
        return ['text/html', $ret];
    }

    /**
     * Search a directory recursively for files.
     *
     * @param  PATH $dir Path to search
     * @return array List of files
     */
    protected function do_dir(string $dir) : array
    {
        task_log($this, 'Processing ' . $dir . ' directory for uploads');

        $out = [];
        $_dir = ($dir == '') ? get_custom_file_base() : (get_custom_file_base() . '/' . $dir);
        $dh = @opendir($_dir);
        if ($dh !== false) {
            while (($file = readdir($dh)) !== false) {
                if ($file[0] != '.') {
                    if ($dir == 'uploads') {
                        if (in_array($file, ['filedump', 'auto_thumbs', 'website_specific', 'index.html', '.htaccess'])) {
                            continue;
                        }
                    }

                    if (is_file($_dir . '/' . $file)) {
                        $out[] = $dir . '/' . $file;
                    } elseif (is_dir($_dir . '/' . $file)) {
                        $out = array_merge($out, $this->do_dir($dir . (($dir != '') ? '/' : '') . $file));
                    }
                }
            }
            closedir($dh);
        }
        return $out;
    }
}
