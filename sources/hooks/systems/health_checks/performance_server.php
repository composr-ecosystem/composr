<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: tempnam*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    health_check
 */

/**
 * Hook class.
 */
class Hook_health_check_performance_server extends Hook_Health_Check
{
    protected $category_label = 'Server performance';

    /**
     * Standard hook run function to run this category of health checks.
     *
     * @param  ?array $sections_to_run Which check sections to run (null: all)
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     * @return array A pair: category label, list of results
     */
    public function run($sections_to_run, $check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->process_checks_section('testPersistentCacheAvailability', 'Persistent cache availability', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        }
        $this->process_checks_section('testDiskSpace', 'Disk space', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testCPUType', 'CPU type', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testCPUSpeed', 'CPU speed (slow)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testCPULoad', 'CPU load', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testServerUptime', 'Server uptime', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testIOSpeed', 'I/O speed (slow)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testIOLoad', 'I/O load', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testHangingProcesses', 'Hanging processes', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testRAM', 'RAM', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);

        return [$this->category_label, $this->results];
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testPersistentCacheAvailability($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        $has_persistent_cache = false;
        if ((class_exists('Memcached')) || (function_exists('apc_fetch')) || (function_exists('apcu_fetch')) || (function_exists('xcache_get')) || (function_exists('wincache_ucache_get'))) {
            $has_persistent_cache = true;
        }

        $suggested_cache = 'APCu';
        if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
            $suggested_cache = 'WinCache';
        }

        $this->assertTrue($has_persistent_cache, 'Persistent caching is not available on this server, consider installing the PHP [tt]' . $suggested_cache . '[/tt] extension');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testDiskSpace($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return; // We have a separate check for disk space at installation
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('disk_free_space')) {
            $disk_space_threshold = intval(get_option('hc_disk_space_threshold')) * 1024 * 1024;

            require_code('files');

            $free_space = disk_free_space(get_custom_file_base());
            $this->assertTrue($free_space > $disk_space_threshold, 'Disk space very low @ ' . clean_file_size($free_space));
        } else {
            $this->stateCheckSkipped('PHP [tt]disk_free_space[/tt] function not available');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testCPUType($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        $cpu_info = @cms_file_get_contents_safe('/proc/cpuinfo');

        if (!empty($cpu_info)) {
            $this->assertTrue(strpos($cpu_info, 'AArch64') === false, 'Using a server with an ARM processor may have severely degraded performance: these processors are designed for simple workloads at scale, not powering complex applications');
            $this->assertTrue(strpos($cpu_info, 'Intel(R) Atom') === false, 'Using a server with an Intel Atom processor may have severely degraded performance: these processors are designed for simple workloads at scale, not powering complex applications');
        } else {
            $this->stateCheckSkipped('Cannot access CPU info');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testCPUSpeed($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if (($check_context == CHECK_CONTEXT__INSTALL) && (get_param_integer('skip_slow_checks', 0) == 1)) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $threshold = 10;
        } else {
            $threshold = intval(get_option('hc_cpu_normative_threshold'));
        }

        require_code('global4');
        $performance = find_normative_performance();
        $this->assertTrue($performance > floatval($threshold), 'Server\'s normative performance score seems low, at ' . float_format($performance) . ' (at least ' . integer_format($threshold) . ' expected); 1.0 was set at the level of a 2014 iMac');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testCPULoad($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('shell_exec')) {
            $cpu = null;

            if (strpos(PHP_OS, 'Darwin') !== false) {
                $result = @explode("\n", shell_exec('iostat'));
                array_shift($result);
                array_shift($result);
                if (isset($result[0])) {
                    $matches = [];
                    if (preg_match('#(\d+)\s+(\d+)\s+(\d+)\s+\d+\.\d+\s+\d+\.\d+\s+\d+\.\d+\s*$#', $result[0], $matches) != 0) {
                        $cpu = floatval($matches[1]) + floatval($matches[2]);
                    }
                }
            } elseif (strpos(PHP_OS, 'Linux') !== false) {
                $result = @explode("\n", shell_exec('iostat'));
                array_shift($result);
                array_shift($result);
                array_shift($result);
                if (isset($result[0])) {
                    $matches = [];
                    if (preg_match('#^\s*(\d+\.\d+)\s+(\d+\.\d+)\s+(\d+\.\d+)#', $result[0], $matches) != 0) {
                        $cpu = floatval($matches[1]) + floatval($matches[2]) + floatval($matches[3]);
                    }
                }

                if ($cpu === null) {
                    $result = explode("\n", shell_exec('top -b -n 1'));
                    array_shift($result);
                    array_shift($result);
                    if (isset($result[0])) {
                        $matches = [];
                        if (preg_match('#^%Cpu\(s\):\s*(\d+\.\d+) us,\s*(\d+\.\d+) sy,\s*(\d+\.\d+) ni#', $result[0], $matches) != 0) {
                            $cpu = floatval($matches[1]) + floatval($matches[2]) + floatval($matches[3]);
                        }
                    }
                }
            } else {
                $this->stateCheckSkipped('No implementation for finding CPU load on this platform');
                return;
            }

            /*  This technique is okay in theory, but there's too much rounding when we're looking at a narrow threshold
            sleep(2); // Let CPU recover a bit from our own script
            $result = explode("\n", shell_exec('ps -A -o %cpu'));
            $cpu = 0.0;
            foreach ($result as $r) {
                if (is_numeric(trim($cpu))) {
                    $cpu += floatval($r);
                }
            }
            */

            if ($cpu !== null) {
                $threshold = floatval(get_option('hc_cpu_pct_threshold'));

                $this->assertTrue($cpu < $threshold, 'CPU utilisation is very high @ ' . float_format($cpu) . '%');
            } else {
                if (strpos(PHP_OS, 'Linux') !== false) {
                    $this->stateCheckSkipped('Failed to detect CPU load (might need to install [tt]sysstat[/tt])');
                } else {
                    $this->stateCheckSkipped('Failed to detect CPU load');
                }
            }
        } else {
            $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testServerUptime($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('shell_exec')) {
            $uptime = null;

            if (php_function_allowed('sys_getloadavg')) {
                $_uptime = sys_getloadavg();
                $uptime = $_uptime[0];
            } else {
                if (strtoupper(substr(PHP_OS, 0, 3)) != 'WIN') {
                    $data = shell_exec('uptime');

                    $matches = [];
                    if (preg_match('#load averages:\s*(\d+\.\d+)#', $data, $matches) != 0) {
                        $uptime = floatval($matches[1]);
                    }
                } else {
                    $this->stateCheckSkipped('No implementation for finding server load on this platform');
                    return;
                }
            }

            if ($uptime !== null) {
                $threshold = intval(get_option('hc_uptime_threshold'));
                $this->assertTrue($uptime < floatval($threshold), '"uptime" (server load) is very high @ ' . float_format($uptime) . '%');
            } else {
                $this->stateCheckSkipped('Failed to detect server load');
            }
        } else {
            $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testIOSpeed($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if (($check_context == CHECK_CONTEXT__INSTALL) && (get_param_integer('skip_slow_checks', 0) == 1)) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $threshold = 10.0;
        } else {
            $threshold = floatval(get_option('hc_io_mbs'));
        }

        // Write file
        if (!php_function_allowed('tempnam')) {
            $this->stateCheckSkipped('PHP [tt]tempnam[/tt] function disabled');
            return;
        }
        $temp = @tempnam(sys_get_temp_dir(), 'hc_');
        if ($temp === false) {
            $this->stateCheckSkipped('Could not create temporary file');
            return;
        }
        $myfile = fopen($temp, 'wb');
        $mb_to_write = 20; // By default (10 MB/s) it has to finish in 2 seconds, which seems pretty reasonable to get past any seek time and looping time
        $write_string = str_repeat('~0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~', 16); // 64 bytes repeated 16 times
        $size = 1024 * $mb_to_write;
        for ($i = 0; $i < $size; $i++) {
            fwrite($myfile, $write_string);
        }
        fclose($myfile);

        // Read file
        $time_start = microtime(true);
        $myfile = fopen($temp, 'rb');
        while (!feof($myfile)) {
            fread($myfile, 1024 * 128); // Load in 128KB chunks
        }
        fclose($myfile);
        $time_end = microtime(true);

        unlink($temp);

        $performance = $mb_to_write / ($time_end - $time_start);

        $this->assertTrue($performance > $threshold, 'Server\'s I/O read speed seems low, at ' . float_format($performance) . ' MB/s (at least ' . float_format($threshold) . ' MB/s expected)');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testIOLoad($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('shell_exec')) {
            $load = null;

            if (strpos(PHP_OS, 'Linux') !== false) {
                $result = @explode("\n", shell_exec('iostat'));
                array_shift($result);
                array_shift($result);
                array_shift($result);
                if (isset($result[0])) {
                    $matches = [];
                    if (preg_match('#^\s*(\d+\.\d+)\s+(\d+\.\d+)\s+(\d+\.\d+)\s+(\d+\.\d+)#', $result[0], $matches) != 0) {
                        $load = floatval($matches[4]);
                    }
                }

                if ($load === null) {
                    $result = explode("\n", shell_exec('top -b -n 1'));
                    array_shift($result);
                    array_shift($result);
                    if (isset($result[0])) {
                        $matches = [];
                        if (preg_match('#(\d+\.\d+) wa#', $result[0], $matches) != 0) {
                            $load = floatval($matches[1]);
                        }
                    }
                }
            } else {
                $this->stateCheckSkipped('No implementation for finding I/O load on this platform');
                return;
            }

            if ($load !== null) {
                $threshold = floatval(get_option('hc_io_pct_threshold'));

                $this->assertTrue($load < $threshold, 'I/O load is causing high wait time @ ' . float_format($load) . '%');
            } else {
                if (strpos(PHP_OS, 'Linux') !== false) {
                    $this->stateCheckSkipped('Failed to detect I/O load (might need to install [tt]sysstat[/tt])');
                } else {
                    $this->stateCheckSkipped('Failed to detect I/O load');
                }
            }
        } else {
            $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testHangingProcesses($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('shell_exec')) {
            $commands_regexp = get_option('hc_processes_to_monitor');
            if ($commands_regexp == '') {
                return;
            }
            $threshold_minutes = intval(get_option('hc_process_hang_threshold'));

            $ok = true;
            $done = false;
            $ps_cmd = 'ps -opid,etime,comm';
            if ($use_test_data_for_pass !== null) {
                $ps_cmd .= ' -A';
            }
            $_result = shell_exec($ps_cmd);
            $result = explode("\n", $_result);
            foreach ($result as $r) {
                $matches = [];
                if (preg_match('#^(\d+)\s+(\d+(:(\d+))*)\s+(' . $commands_regexp . ')\s*$#', $r, $matches) != 0) {
                    $seconds = 0;
                    $time_parts = array_reverse(explode(':', $matches[2]));
                    foreach ($time_parts as $i => $_time_part) {
                        $time_part = intval($_time_part);

                        switch ($i) {
                            case 0:
                                $seconds += $time_part;
                                break;

                            case 1:
                                $seconds += $time_part * 60;
                                break;

                            case 2:
                                $seconds += $time_part * 60 * 60;
                                break;

                            case 3:
                            default: // We assume anything else is days, we don't know what other units may be here, and it's longer than we care of anyway
                                $seconds += $time_part * 60 * 60 * 24;
                                break;
                        }
                    }

                    $cmd = $matches[5];
                    $pid = $matches[1];

                    $ok = $ok && ($seconds < 60 * $threshold_minutes);
                    $this->assertTrue($ok, 'Process [tt]' . $cmd . '[/tt] (' . $pid . ') has been running a long time @ ' . display_time_period($seconds));
                }
            }

            if ($ok) {
                $this->assertTrue(true, 'Hanging processes');
            }

            if (empty($_result)) {
                $this->stateCheckSkipped('Failed to list running processes');
            }
        } else {
            $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testRAM($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        if (php_function_allowed('shell_exec')) {
            require_code('files');

            $bytes_free = null;

            $matches = [];

            if (strpos(PHP_OS, 'Darwin') !== false) {
                $data = shell_exec('vm_stat');
                if (preg_match('#^Pages free:\s*(\d+)#m', $data, $matches) != 0) {
                    $bytes_free = intval($matches[1]) * 4 * 1024;
                    if (preg_match('#^Pages inactive:\s*(\d+)#m', $data, $matches) != 0) { // We consider this free. Mac is going to try and use all RAM for something, so we have to use a weird definition
                        $bytes_free += intval($matches[1]) * 4 * 1024;
                    }
                }
            } elseif (strpos(PHP_OS, 'Linux') !== false) {
                $data = shell_exec('free');
                if (preg_match('#^Mem:\s+(\d+)\s+(\d+)\s+(\d+)#m', $data, $matches) != 0) {
                    $bytes_free = intval($matches[3]) * 1024;
                }
            } elseif (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN') {
                $data = shell_exec('wmic OS get FreePhysicalMemory /Value');
                if (preg_match('#FreePhysicalMemory=(\d+)#m', $data, $matches) != 0) {
                    $bytes_free = intval($matches[1]) * 1024;
                }
            } else {
                $this->stateCheckSkipped('No implementation for finding free RAM on this platform');
                return;
            }

            if ($bytes_free !== null) {
                if ($check_context == CHECK_CONTEXT__INSTALL) {
                    $mb_threshold = 200;
                } else {
                    $mb_threshold = intval(get_option('hc_ram_threshold'));
                }
                $this->assertTrue($bytes_free > $mb_threshold * 1024 * 1024, 'Server is low on RAM @ ' . clean_file_size($bytes_free));
            } else {
                $this->stateCheckSkipped('Failed to detect free RAM');
            }
        } else {
            $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
        }
    }
}
