<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    health_check
 */

/**
 * Hook class.
 */
class Hook_health_check_security extends Hook_Health_Check
{
    protected $category_label = 'Security';

    /**
     * Standard hook run function to run this category of health checks.
     *
     * @param  ?array $sections_to_run Which check sections to run (null: all)
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     * @param  boolean $show_unusable_categories Whether to include categories that might not be accessible for some reason
     * @return array A pair: category label, list of results
     */
    public function run(?array $sections_to_run, int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null, bool $show_unusable_categories = false) : array
    {
        $this->process_checks_section('testExternalSecurityScan', 'External security scan', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        if (($show_unusable_categories) || ($check_context != CHECK_CONTEXT__INSTALL)) {
            if (($show_unusable_categories) || ((get_option('hc_google_safe_browsing_api_enabled') == '1') && (get_option('google_apis_api_key') != ''))) {
                $this->process_checks_section('testMalware', 'Malware', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
            }
        }
        $this->process_checks_section('testDirectorySecuring', 'Directory securing', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testSiteOrphaned', 'Site orphaning', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testAdminScriptAccess', 'Admin Script Access', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testIPBackdoor', 'IP backdoor left active', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testWebShells', 'WebShells in likely directories (backdoor scripts)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedPhpMyAdminScript', 'Exposed PhpMyAdmin utility', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedBigDumpScript', 'Exposed BigDump tool', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedPhpInfoScript', 'Exposed PHP-Info script', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedBackups', 'Exposed backups', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedExecuteTemp', 'Exposed execute_temp.php', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testExposedGitDirectory', 'Exposed .git directory', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testCAPTCHAMissing', 'Missing CAPTCHA on public website', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);

        return [$this->category_label, $this->results];
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExternalSecurityScan(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        if (!$manual_checks) {
            return;
        }

        // external_health_check (on maintenance sheet)
        $this->stateCheckManual('Check for [url="website security configuration issues"]https://observatory.mozilla.org[/url]');
        $this->stateCheckManual('Check for [url="server security configuration issues"]https://www.qualys.com/community-edition/[/url]');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testMalware(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        // API https://developers.google.com/safe-browsing/v4/

        if ($check_context != CHECK_CONTEXT__LIVE_SITE) {
            // Google can't index a non-live site, and thus won't report Safe Browsing results
            return;
        }

        $key = get_option('google_apis_api_key');

        if ($use_test_data_for_pass === null) {
            if (is_local_machine(get_base_url_hostname())) {
                $this->stateCheckSkipped('Could not scan for Malware on local domain');
                return;
            }

            $page_links = $this->process_urls_into_page_links();

            $urls = [];
            foreach ($page_links as $page_link) {
                $_url = page_link_to_url($page_link, true);
                if (!empty($_url)) {
                    $urls[] = ['url' => $_url];
                }
            }
        } else {
            if ($use_test_data_for_pass) {
                $urls = [['url' => 'http://example.com']];
            } else {
                $urls = [['url' => 'http://www23.omrtw.com']];
            }
        }

        $url = 'https://safebrowsing.googleapis.com/v4/threatMatches:find?key=' . urlencode(trim($key));

        require_code('version2');
        $data = [
            'client' => [
                'clientId' => 'Composr',
                'clientVersion' => get_version_dotted(),
            ],
            'threatInfo' => [
                'threatTypes' => ['MALWARE', 'SOCIAL_ENGINEERING'],
                'platformTypes' => ['ANY_PLATFORM'],
                'threatEntryTypes' => ['URL'],
                'threatEntries' => $urls,
            ],
        ];
        $_data = json_encode($data);
        require_code('character_sets');
        $_data = convert_to_internal_encoding($_data, get_charset(), 'utf-8');

        for ($i = 0; $i < 3; $i++) { // Try a few times in case of some temporary network issue or Google issue
            $http_result = cms_http_request($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false, 'post_params' => $_data, 'timeout' => 200.0, 'raw_content_type' => 'application/json', 'ignore_http_status' => true]);

            if ($http_result->data !== null) {
                break;
            }
            if (php_function_allowed('usleep')) {
                usleep(5000000);
            }
        }

        $result = @json_decode($http_result->data, true);

        if (isset($result['error']['message'])) {
            $error_message = $result['error']['message'];
        } else {
            $error_message = $http_result->message;
        }

        $this->assertTrue(!in_array($http_result->message, ['401', '403']), 'Error with our Google Safe Browsing API key (' . $error_message . ')');
        $this->assertTrue(!in_array($http_result->message, ['400', '501', '503', '504']), 'Internal error with our Google Safe Browsing check (' . $error_message . ')');

        $ok = in_array($http_result->message, ['200']);
        if ($ok) {
            if (empty($result['matches'])) {
                $this->assertTrue(true, 'Malware advisory provided by [url="Google"]https://developers.google.com/safe-browsing/v3/advisory[/url]');
            } else {
                foreach ($result['matches'] as $match) {
                    $this->assertTrue(false, 'Malware advisory provided by [url="Google"]https://developers.google.com/safe-browsing/v3/advisory[/url], ' . json_encode($match));
                }
            }
        } else {
            $this->stateCheckSkipped('Failed calling Google Safe Browsing API');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testDirectorySecuring(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        // This test may generate errors in the web server logs...

        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        $to_check = [
            'data_custom/ecommerce.log',
            'caches/test.txt',
            'temp/test.txt',
        ];
        foreach ($to_check as $c) {
            $full_path = get_custom_file_base() . '/' . $c;
            $exists = is_file($full_path);
            if (!$exists) {
                require_code('files');
                cms_file_put_contents_safe($full_path, '');
            }
            $http_result = cms_http_request(get_custom_base_url() . '/' . $c, ['trigger_error' => false]);
            $this->assertTrue($http_result->message == '403' || $http_result->message == '404', 'Should not be able to download [tt]' . $c . '[/tt], should be secured by some kind of server configuration');
            if (!$exists) {
                @unlink($full_path);
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testSiteOrphaned(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context != CHECK_CONTEXT__LIVE_SITE) {
            $this->log('Skipped; we are not running from a live site.');
            return;
        }

        $path = 'uploads/website_specific/orphaned-test.txt';
        require_code('crypt');
        $data = get_secure_random_string();
        require_code('files');
        cms_file_put_contents_safe(get_custom_file_base() . '/' . $path, $data);
        $result = http_get_contents(get_custom_base_url() . '/' . $path, ['trigger_error' => false]);
        $this->assertTrue($result === $data, 'Website does not seem to be running on the base URL that is configured');
        @unlink(get_custom_file_base() . '/' . $path);

        if (!is_local_machine(get_base_url_hostname())) {
            if (php_function_allowed('shell_exec')) {
                $domains = get_server_names(false);

                foreach ($domains as $domain) {
                    $regexp = '#\nName:\s+' . $domain . '\nAddress:\s+(.*)\n#';

                    $matches_local = [];
                    $dns_lookup_local = shell_exec('nslookup ' . $domain);
                    $matched_local = preg_match($regexp, $dns_lookup_local, $matches_local);
                    $matches_remote = [];
                    $dns_lookup_remote = shell_exec('nslookup ' . $domain . ' 8.8.8.8');
                    $matched_remote = preg_match($regexp, $dns_lookup_remote, $matches_remote);
                    if (($matched_local != 0) && ($matched_remote != 0)) {
                        $this->assertTrue($matches_local[1] == $matches_remote[1], 'DNS lookup for our domain seems to be looking up differently ([tt]' . $matches_local[1] . '[/tt] vs [tt]' . $matches_remote[1] . '[/tt])');
                    } else {
                        $this->stateCheckSkipped('Failed to get a recognisable DNS resolution via the command line for [tt]' . $domain . '[/tt]');
                    }
                }
            } else {
                $this->stateCheckSkipped('PHP [tt]shell_exec[/tt] function not available');
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testAdminScriptAccess(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        global $SITE_INFO;
        $ok = !isset($SITE_INFO['master_password']);
        if (!$ok) {
            $ok = (http_get_contents(get_base_url() . '/config_editor.php', ['trigger_error' => false]) === null);
        }
        $this->assertTrue($ok, 'Should not have a master password defined, or should control access to config scripts');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testIPBackdoor(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        global $SITE_INFO;
        $this->assertTrue(empty($SITE_INFO['backdoor_ip']), 'You have a [tt]backdoor_ip[/tt] setting left defined in _config.php');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testWebShells(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        require_code('files2');

        $fb = get_file_base();

        $files = $this->getBaseDirectoriesFiles();
        $files = array_merge($files, get_directory_contents($fb, '', 0, false, true, ['php'])); // base directory
        $files = array_merge($files, get_directory_contents($fb . '/uploads', 'uploads', 0, true, true, ['php'])); // common uploads location
        $files = array_merge($files, get_directory_contents($fb . '/themes', 'themes', 0, true, true, ['php'])); // common uploads location

        foreach (array_unique($files) as $file) {
            $c = @cms_file_get_contents_safe($fb . '/' . $file);
            if ($c !== false) {
                $trigger = $this->isLikelyWebShell($file, $c);
                if ($trigger !== null) {
                    $this->assertTrue(false, 'Likely webshell: [tt]' . $file . '[/tt]; triggered by [tt]' . $trigger . '[/tt]');
                }
            }
        }
    }

    /**
     * Find if a file is a likely webshell.
     *
     * @param  PATH $file Relative file path
     * @param  string $c File contents
     * @return ?string Trigger that found it (null: nothing)
     */
    protected function isLikelyWebShell(string $file, string $c) : ?string
    {
        $triggers = [
            '[^\w]system\(',
            '[^\w]exec\(',
            '[^\w]shell_exec\(',
            '[^\w]passthru\(',
            '[^\w]popen\(',
            '[^\w]proc_open\(',
            '[^\w]eval\(',
            '[^\w]move_uploaded_f[iI]le\(', // I is doubled up due to Turkish issue
            '\$\w+\(',
            '\$_FILES',
            '/etc/passwd',
            '(requ[iI]re|[iI]nclude)(_once)?\([\'"]https?://', // "
        ];

        foreach ($triggers as $trigger) {
            if (preg_match('#' . $trigger . '#i', $c) != 0) {
                return $trigger;
            }
        }

        return null;
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedPhpMyAdminScript(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        require_code('http');

        $files = $this->getBaseDirectoriesFiles(null, false);

        foreach ($files as $path) {
            if (stripos($path, 'phpMyAdmin') !== false) {
                $http_result = cms_http_request(get_base_url() . '/' . $path, ['trigger_error' => false]);
                $this->assertTrue($http_result->message != '200', 'Likely exposed phpMyAdmin script: [tt]' . $path . '[/tt]');
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedBigDumpScript(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        require_code('http');

        $files = $this->getBaseDirectoriesFiles();

        foreach ($files as $path) {
            if (stripos($path, 'bigdump') !== false) {
                $http_result = cms_http_request(get_base_url() . '/' . $path, ['trigger_error' => false]);
                $this->assertTrue($http_result->message != '200', 'Likely exposed BigDump script: [tt]' . $path . '[/tt]');
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedPhpInfoScript(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        require_code('http');

        $files = $this->getBaseDirectoriesFiles();

        foreach ($files as $path) {
            if (stripos($path, 'phpinfo.php') !== false) {
                $http_result = cms_http_request(get_base_url() . '/' . $path, ['trigger_error' => false]);
                $this->assertTrue($http_result->message != '200', 'Likely exposed PHP-Info script: [tt]' . $path . '[/tt]');
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedBackups(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        require_code('http');

        $files = $this->getBaseDirectoriesFiles(['tar', 'gz', 'zip', 'sql']);

        foreach ($files as $file) {
            if ((preg_match('#back.*\.(tar|gz|zip)$|\.(sql)$#i', basename($file)) != 0) && (!in_array($file, ['install.sql']))) {
                $http_result = cms_http_request(get_base_url() . '/' . $file, ['trigger_error' => false]);
                $this->assertTrue($http_result->message != '200', 'Likely exposed backup: [tt]' . $file . '[/tt]');
            }
        }
    }

    /**
     * Find files in base-like directories.
     *
     * @param  ?array $file_extensions File extensions to limit to (no dots), if $files_wanted set (null: no limit)
     * @param  boolean $files_wanted Whether to get files (if not, will return directories instead of files)
     * @return array List of file paths relative to real base directory
     */
    protected function getBaseDirectoriesFiles(?array $file_extensions = ['php'], bool $files_wanted = true) : array
    {
        require_code('files2');

        $fb = get_file_base();

        $files = [];

        $base_url_path = cms_parse_url_safe(get_base_url(), PHP_URL_PATH);
        if ($base_url_path != '/') {
            if (substr($fb, -strlen($base_url_path)) == $base_url_path) {
                $webroot_path = substr($fb, 0, strlen($fb) - strlen($base_url_path));
                $files = array_merge($files, get_directory_contents($webroot_path, '..', 0, false, $files_wanted, $file_extensions)); // webroot directory
            }
        }

        $files = array_merge($files, get_directory_contents($fb, '', 0, false, $files_wanted, $file_extensions)); // base directory

        // Common backup directories, if they exist
        foreach (['_old', 'old', '_backup', 'backup', '_backups', 'backups', '_temp', 'temp'] as $old_dir) {
            $files = array_merge($files, get_directory_contents($fb . '/' . $old_dir, '', 0, false, $files_wanted, $file_extensions));
        }

        return $files;
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedExecuteTemp(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        $et_path = get_file_base() . '/data_custom/execute_temp.php';
        $et_orig_path = get_file_base() . '/data_custom/execute_temp.php.bundle';

        $ok = !file_exists($et_path);
        if (!$ok) {
            $c = cms_file_get_contents_safe($et_path, FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM);
            $ok = (is_file($et_orig_path)) && ($c == cms_file_get_contents_safe($et_orig_path, FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM));
            if (!$ok) {
                $ok = (preg_match('#function execute_temp\(\)\s*\{\s*\}#', $c) != 0);
            }
        }

        $this->assertTrue($ok, 'Exposed non-empty [tt]data_custom/execute_temp.php[/tt]');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testExposedGitDirectory(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        $result = http_get_contents(get_base_url() . '/.git/config', ['trigger_error' => false]);

        $this->assertTrue(empty($result), 'The contents of the .git directory is exposed to web requests');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testCAPTCHAMissing(int $check_context, bool $manual_checks = false, bool $automatic_repair = false, ?bool $use_test_data_for_pass = null, ?array $urls_or_page_links = null, ?array $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            $this->log('Skipped; we are running from installer.');
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            $this->log('Skipped; running on specific page links.');
            return;
        }

        $hostname = get_base_url_hostname();
        $intranet = ((is_local_machine($hostname)) || (preg_match('#^\w+$#', $hostname) != 0));
        $ok = ((addon_installed('captcha')) && (get_option('use_captchas') == '1')) || ($intranet);
        $this->assertTrue($ok, 'CAPTCHA is not enabled and it looks like your website (based on the domain/IP) -- you could get attacked by spam bots');
    }
}
