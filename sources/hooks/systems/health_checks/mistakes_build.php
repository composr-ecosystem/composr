<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    health_check
 */

/**
 * Hook class.
 */
class Hook_health_check_mistakes_build extends Hook_Health_Check
{
    protected $category_label = 'Build mistakes';

    /**
     * Standard hook run function to run this category of health checks.
     *
     * @param  ?array $sections_to_run Which check sections to run (null: all)
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     * @return array A pair: category label, list of results
     */
    public function run($sections_to_run, $check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        $this->process_checks_section('testManualWebStandards', 'Manual checks for web standards', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testGuestAccess', 'Guest access', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testBrokenLinks', 'Broken links (slow)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testIncompleteContent', 'Incomplete content', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testLocalLinking', 'Local linking', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testBrokenWebPostForms', 'Broken web POST forms', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testForgottenIcons', 'Default icons', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testSpellingComcodePages', 'Spellchecking of all Comcode pages (slow)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testSpellingPages', 'Spellchecking of pages', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testSpellingContent', 'Spellchecking of miscellaneous content', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testComcodePageHeadings', 'Comcode page headings', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testComcodePageFormFields', 'Comcode page form fields', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testWebStandards', 'Web standards', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);
        $this->process_checks_section('testCommonMistakePatterns', 'Common mistake patterns (page_errors.xml)', $sections_to_run, $check_context, $manual_checks, $automatic_repair, $use_test_data_for_pass, $urls_or_page_links, $comcode_segments);

        return [$this->category_label, $this->results];
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testManualWebStandards($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        if (!$manual_checks) {
            return;
        }

        $this->stateCheckManual('Check [url="Open Graph metadata"]https://developers.facebook.com/tools/debug/[/url] on any key pages you expect to be shared');

        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        // external_health_check (on maintenance sheet)

        $this->stateCheckManual('Check [url="HTML5 validation"]https://validator.w3.org/[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');
        $this->stateCheckManual('Check [url="CSS validation"]https://jigsaw.w3.org/css-validator/[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');
        $this->stateCheckManual('Check [url="WCAG validation"]https://achecker.ca/checker/index.php[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');

        $this->stateCheckManual('Check schema.org/microformats validation on either [url="Google"]https://search.google.com/structured-data/testing-tool/[/url] or [url="Bing"]https://www.bing.com/toolbox/markup-validator[/url] or [url="Yandex"]https://webmaster.yandex.com/tools/microtest/[/url], on any key pages you want to be semantic');

        $this->stateCheckManual('Do a [url="general check"]https://www.woorank.com/[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');
        $this->stateCheckManual('Do a [url="general check"]https://website.grader.com/[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');
        $this->stateCheckManual('Do a [url="general check"]https://webhint.io/[/url] (take warnings with a pinch of salt, not every suggestion is appropriate)');

        $this->stateCheckManual('Test in Mozilla Firefox');
        $this->stateCheckManual('Test in Google Chrome');
        $this->stateCheckManual('Test in IE10');
        $this->stateCheckManual('Test in IE11');
        $this->stateCheckManual('Test in Microsoft Edge');
        $this->stateCheckManual('Test in Safari');
        $this->stateCheckManual('Test in Google Chrome (mobile)');
        $this->stateCheckManual('Test in Safari (mobile)');

        $this->stateCheckManual('Check the website would look good if printed');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testGuestAccess($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        $page_links = $this->process_urls_into_page_links([':', ':login']);

        foreach ($page_links as $page_link) {
            $http_result = $this->get_page_http_content($page_link);

            $this->assertTrue(!in_array($http_result->message, ['401', '403']), '"' . $page_link . '" page is not allowing guest access');
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testBrokenLinks($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments[] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $comcode_segment) {
                $html_segments[] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        $urls = [];
        foreach ($html_segments as $html) {
            $urls = array_merge($urls, $this->get_embed_urls_from_data($html));
            $urls = array_merge($urls, $this->get_link_urls_from_data($html));
        }
        $urls = array_unique($urls);

        $_urls = [];
        foreach ($urls as $url) {
            if (substr($url, 0, 2) == '//') {
                $url = 'http:' . $url;
            }

            // Don't check local URLs, we're interested in broken remote links (local validation is too much)
            if (substr($url, 0, strlen(get_base_url(false)) + 1) == get_base_url(false) . '/') {
                continue;
            }
            if (substr($url, 0, strlen(get_base_url(true)) + 1) == get_base_url(true) . '/') {
                continue;
            }
            if (strpos($url, '://') === false) {
                continue;
            }

            $_urls[] = $url;
        }

        foreach ($_urls as $url) {
            // Check
            /*
            $data = http_get_contents($url, ['byte_limit' => 0, 'trigger_error' => false]);
            $ok = ($data !== null);
            */
            for ($i = 0; $i < 3; $i++) { // Try a few times in case of some temporary network issue
                $ok = check_url_exists($url, 60 * 60 * 24 * 1);
                if ($ok) {
                    break;
                }
            }
            $this->assertTrue($ok, do_lang('BROKEN_LINK_PROBLEM', $url));
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testIncompleteContent($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        if ((!$manual_checks) && ($comcode_segments === null)) {
            $this->stateCheckSkipped('Will not check automatically because there could be false positives');
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $field_title => $comcode_segment) {
                $html_segments[$field_title] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        foreach ($html_segments as $field_title => $html) {
            $check_for = ['TODO', 'FIXME', 'Lorem Ipsum'];
            foreach ($check_for as $c) {
                $this->assertTrue(strpos($html, $c) === false, do_lang('INCOMPLETE_CONTENT_PROBLEM', $c, $field_title));
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testLocalLinking($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        if (is_local_machine(get_base_url_hostname())) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $field_title => $comcode_segment) {
                $html_segments[$field_title] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        $problematic_host_prefixes = [];
        foreach (get_localhost_names_and_ips() as $ip_or_hostname) {
            $problematic_host_prefixes[] = preg_quote($ip_or_hostname, '#') . '($|:|/)';
        }
        $problematic_host_prefixes[] = '10\.';
        $problematic_host_prefixes[] = '192\.168\.';
        if (!health_check__is_test_site()) {
            $problematic_host_prefixes[] = '(staging|sandbox)\.' . preg_quote(preg_replace('#^www\.#', '', get_base_url_hostname()), '#') . '($|:|/)';
        }

        foreach ($html_segments as $field_title => $html) {
            $regexp = '#https?://(';
            foreach ($problematic_host_prefixes as $i => $host_prefix) {
                if ($i != 0) {
                    $regexp .= '|';
                }
                $regexp .= $host_prefix;
            }
            $regexp .= ')#';

            $this->assertTrue(preg_match($regexp, $html) == 0, do_lang('LOCAL_LINKING_PROBLEM', $field_title));
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testBrokenWebPostForms($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context != CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $field_title => $comcode_segment) {
                $html_segments[$field_title] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        foreach ($html_segments as $field_title => $html) {
            if (stripos($html, '<form') !== false) {
                $matches = [];
                $num_matches = preg_match_all('#<form[^<>]*method="POST">#i', $html, $matches);
                for ($i = 0; $i < $num_matches; $i++) {
                    $match = $matches[0][$i];

                    $matches_action = [];
                    $has_action = (preg_match('#action=["\']([^"\']*)["\']#i', $match, $matches_action) != 0);
                    $this->assertTrue($has_action, do_lang('FORM_ACTION_PROBLEM'));

                    if ($has_action) {
                        $url = html_entity_decode($matches_action[1], ENT_QUOTES);

                        if ($url == '#' || $url == '#!') {
                            continue;
                        }

                        $is_absolute_url = (strpos($url, '://') !== false);
                        $this->assertTrue($is_absolute_url, do_lang('FORM_ACTION_RELATIVE_PROBLEM'));

                        if ($is_absolute_url) {
                            $result = cms_http_request($url, ['trigger_error' => false]);
                            $this->assertTrue($result->message == '400', do_lang('FORM_ACTION_ERROR_HANDLING_PROBLEM', $url, $result->message));
                        }
                    }
                }
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testForgottenIcons($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        $test = find_theme_image('favicon', false, true, $GLOBALS['FORUM_DRIVER']->get_theme(''));
        $this->assertTrue($test != 'themes/default/images/favicon.ico', 'Still using default favicon (the favicon theme image needs editing)');

        $test = find_theme_image('webclipicon', false, true, $GLOBALS['FORUM_DRIVER']->get_theme(''));
        $this->assertTrue($test != 'themes/default/images/webclipicon.ico', 'Still using default webclipicon (the webclipicon theme image needs editing)');
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testSpellingComcodePages($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        require_code('files2');
        require_code('spelling');

        if (_find_spell_checker() === null) {
            $this->assertTrue(false, 'pspell/enchant required for this test');
            return;
        }

        $paths = ['pages/comcode_custom/' . user_lang()];
        $zones = find_all_zones();
        foreach ($zones as $zone) {
            if ($zone != 'docs') { // Big, and we check this in an automated test
                $paths[] = $zone . '/pages/comcode_custom/' . user_lang();
            }
        }
        $all_files = [];
        foreach ($paths as $_path) {
            $files = get_directory_contents(get_file_base() . '/' . $_path, $_path, null, false, true, ['txt']);
            $all_files = array_merge($all_files, $files);
        }

        foreach ($all_files as $path) {
            $c = cms_file_get_contents_safe(get_file_base() . '/' . $path);
            $text = clean_comcode_for_spellcheck($c);

            $misspellings = run_spellcheck($text, null, true, false);
            foreach (array_keys($misspellings) as $word) {
                $this->assertTrue(false, do_lang('SPELLING_PROBLEM', $word, $path));
            }
        }

        spellchecker_shutdown();
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testSpellingPages($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        require_code('spelling');

        if (_find_spell_checker() === null) {
            $this->assertTrue(false, 'pspell/enchant required for this test');
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $field_title => $comcode_segment) {
                $html_segments[$field_title] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        foreach ($html_segments as $field_title => $html) {
            $text = clean_html_for_spellcheck($html);

            $misspellings = run_spellcheck($text, null, true, false);
            foreach (array_keys($misspellings) as $word) {
                $this->assertTrue(false, do_lang('SPELLING_PROBLEM', $word, $field_title));
            }
        }

        spellchecker_shutdown();
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testSpellingContent($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }
        if ($check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS) {
            return;
        }

        require_code('spelling');
        require_code('database_relations');

        if (_find_spell_checker() === null) {
            $this->assertTrue(false, 'pspell/enchant required for this test');
            return;
        }

        $okay_words = [
            // Stuff there by default
            'american',
            'cms',
            'composr',
            'ecommerce',
            'facebook',
            'firstname',
            'lastname',
            'ocproducts',
            'semihtml',
            'sku',
            'skype',
            'sr',
            'usergroup',
            'viewable',
            'yy',
            'amazon',
            'wishlist',
            'bandcamp',
            'dailymotion',
            'discord',
            'dropbox',
            'flattr',
            'github',
            'gitlab',
            'tiktok',
            'gitlab',
            'instagram',
            'linkedin',
            'patreon',
            'paypal',
            'pinterest',
            'quora',
            'reddit',
            'slashdot',
            'snapchat',
            'soundcloud',
            'spotify',
            'tumblr',
            'vimeo',
            'whatsapp',
            'youtube',
            'vk',
            'baidu',
            'tieba',
            'sina',
            'weibo',
            'tencentweibo',
            'viber',
            'wechat',
            'qzone',
            'playstation',
            'xbox',
            'steemit',
            'dtube',
            'mastodon',
            'diaspora',
            'bitcoin',
            'utopian',
        ];

        $spell_link = spellcheck_initialise();
        add_spellchecker_words_temp($spell_link, $okay_words);

        $field_types_wanted = [
            'SHORT_TEXT',
            '*SHORT_TEXT',
            'LONG_TEXT',
            '*LONG_TEXT',
            'SHORT_TRANS',
            '*SHORT_TRANS',
            'LONG_TRANS',
            '*LONG_TRANS',
        ];
        $or_list = '';
        foreach ($field_types_wanted as $field_type) {
            if ($or_list != '') {
                $or_list .= ' OR ';
            }
            $or_list .= db_string_equal_to('m_type', $field_type);
        }

        $db_fields = $GLOBALS['SITE_DB']->query_select('db_meta', ['m_table', 'm_name'], [], 'WHERE (' . $or_list . ')');
        foreach ($db_fields as $db_field) {
            $table = $db_field['m_table'];
            $name = $db_field['m_name'];

            if (in_array($table, [
                // User data
                'f_topics',
                'f_posts',

                // Irrelevant
                'config',
                'values',
                'f_emoticons',
                'url_id_monikers',
                'theme_images',
                'wordfilter', // Don't want to swear at the user running this either!

                // Will come in elsewhere
                'translate',
                'comcode_pages',
                'cached_comcode_pages',
            ])) {
                continue;
            }

            if (table_has_purpose_flag($table, TABLE_PURPOSE__FLUSHABLE | TABLE_PURPOSE__FLUSHABLE_AGGRESSIVE | TABLE_PURPOSE__AUTOGEN_STATIC | TABLE_PURPOSE__MISC_NO_MERGE)) {
                continue;
            }

            if (in_array($name, [
                // Irrelevant
                'author',
                'm_timezone_offset',
            ])) {
                continue;
            }

            $start = 0;
            $max = 100;
            do {
                $old_limit = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLUGGISH);

                push_db_scope_check(true);
                $rows = $GLOBALS['SITE_DB']->query_select($table, [$name], [], '', $max, $start);
                pop_db_scope_check();

                foreach ($rows as $row) {
                    $_c = $row[$name];
                    if (is_integer($_c)) {
                        $c = get_translated_text($_c);
                    } else {
                        $c = $_c;
                    }
                    $text = clean_comcode_for_spellcheck($c);

                    $misspellings = run_spellcheck($text, null, true, false);
                    foreach (array_keys($misspellings) as $word) {
                        $this->assertTrue(false, 'Misspelling: ' . $word . ' (' . $table . ')');
                    }
                }

                cms_set_time_limit($old_limit);

                $start += $max;
            } while (count($rows) == $max);
        }

        spellchecker_shutdown();
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testComcodePageHeadings($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $_comcode_segments = [];
        foreach ($page_links as $page_link) {
            $page_content = $this->get_comcode_page_content($page_link);

            if ($page_content === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            list($comcode, $html, , $page) = $page_content;

            $_comcode_segments['[tt]' . $page_link . '[/tt]'] = [$comcode, $html, $page];
        }

        if (($comcode_segments !== null) && (get_page_name() == 'cms_comcode_pages')) {
            foreach ($comcode_segments as $comcode_segment) {
                $_comcode_segments[do_lang('PREVIEW')] = [$comcode_segment, static_evaluate_tempcode(comcode_to_tempcode($comcode_segment)), get_param_string('page', '')];
            }
        }

        foreach ($_comcode_segments as $field_title => $page_content) {
            list($comcode, $html, $page) = $page_content;

            if ((substr($page, 0, 1) != '_') && (substr($page, 0, 6) != 'panel_') && (trim($comcode) != '') && (trim($html) != '')) {
                $found_l1 = ((strpos($html, '<h1') !== false) || (strpos($comcode, '[title]') !== false) || (strpos($comcode, '[title="1"]') !== false));
                $this->assertTrue($found_l1, do_lang('LEVEL_1_HEADERS_PROBLEM', $field_title));

                $matches = [];
                $okay_l2 = (strpos($html, '<h2') !== false) || (preg_match_all('#\n\[(b|font|size)\][^\.]+\[/(b|font|size)\]\r?\n#', $comcode, $matches) < 2);
                $this->assertTrue($okay_l2, do_lang('LEVEL_2_HEADERS_PROBLEM', $field_title));
            }
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testComcodePageFormFields($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $_comcode_segments = [];
        foreach ($page_links as $page_link) {
            $page_content = $this->get_comcode_page_content($page_link);

            if ($page_content === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            list(, $html) = $page_content;

            $_comcode_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $comcode_segment) {
                $_comcode_segments[do_lang('PREVIEW')] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        foreach ($_comcode_segments as $field_title => $html) {
            $html = preg_replace('#<form.*</form>#Uis', '', $html);
            $this->assertTrue(preg_match('#<(select|textarea|input|button)#i', $html) == 0, do_lang('FORM_ELEMENT_PROBLEM', $field_title));
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testWebStandards($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            $html_segments['[tt]' . $page_link . '[/tt]'] = $html;
        }

        if ($comcode_segments !== null) {
            foreach ($comcode_segments as $field_title => $comcode_segment) {
                $html_segments[$field_title] = static_evaluate_tempcode(comcode_to_tempcode($comcode_segment));
            }
        }

        $ignore_errors = explode("\n", get_option('hc_webstandards_whitelist'));

        foreach ($html_segments as $field_title => $html) {
            require_lang('webstandards');
            require_code('crypt');
            require_code('webstandards');
            $results = check_xhtml($html, false, true, true, true, true, true, false);

            $errors = [];
            if ($results !== null) {
                foreach ($results['errors'] as $error) {
                    $ignore = false;
                    foreach ($ignore_errors as $ignore_error) {
                        $ignore_error = trim($ignore_error);

                        if (($ignore_error != '') && (strpos($error['error'], $ignore_error) !== false)) {
                            $ignore = true;
                            break;
                        }
                    }

                    if (!$ignore) {
                        $errors[] = $error['error'];
                    }
                }
            }

            $this->assertTrue(empty($errors), do_lang('WEB_STANDARDS_PROBLEM', $field_title, '[html]' . implode('; ', $errors) . '[/html]'));
        }
    }

    /**
     * Run a section of health checks.
     *
     * @param  integer $check_context The current state of the website (a CHECK_CONTEXT__* constant)
     * @param  boolean $manual_checks Mention manual checks
     * @param  boolean $automatic_repair Do automatic repairs where possible
     * @param  ?boolean $use_test_data_for_pass Should test data be for a pass [if test data supported] (null: no test data)
     * @param  ?array $urls_or_page_links List of URLs and/or page-links to operate on, if applicable (null: those configured)
     * @param  ?array $comcode_segments Map of field names to Comcode segments to operate on, if applicable (null: N/A)
     */
    public function testCommonMistakePatterns($check_context, $manual_checks = false, $automatic_repair = false, $use_test_data_for_pass = null, $urls_or_page_links = null, $comcode_segments = null)
    {
        if ($check_context == CHECK_CONTEXT__INSTALL) {
            return;
        }

        $patterns = [];

        require_code('xml');

        $pattern_path = get_file_base() . '/data_custom/xml_config/page_errors.xml';
        if (!is_file($pattern_path)) {
            $pattern_path = get_file_base() . '/data/xml_config/page_errors.xml';
        }
        $parsed = new CMS_simple_xml_reader(cms_file_get_contents_safe($pattern_path, FILE_READ_LOCK | FILE_READ_BOM));

        list($root_tag, $root_attributes, , $this_children) = $parsed->gleamed;
        if ($root_tag == 'pageErrors') {
            foreach ($this_children as $_child) {
                if (!is_array($_child)) {
                    continue;
                }
                list($row_tag, $row_attributes, $row_value, $row_children) = $_child;

                $regexp = null;
                $description = null;
                if ($row_tag == 'pattern') {
                    foreach ($row_children as $__child) {
                        if (!is_array($__child)) {
                            continue;
                        }
                        list($row_tag, $row_attributes, $row_value, $row_children) = $__child;
                        switch ($row_tag) {
                            case 'regexp':
                                $regexp = $row_value;
                                break;
                            case 'description':
                                $description = $row_value;
                                break;
                        }
                    }
                }

                if ($regexp !== null) {
                    if ($description === null) {
                        $description = '[tt]' . $regexp . '[/tt]';
                    }

                    $patterns[$regexp] = $description;
                }
            }
        }

        $page_links = $this->process_urls_into_page_links($urls_or_page_links);

        $html_segments = [];
        foreach ($page_links as $page_link) {
            $html = $this->get_page_content($page_link, $check_context == CHECK_CONTEXT__SPECIFIC_PAGE_LINKS);

            if ($html === null) {
                $this->stateCheckSkipped(do_lang('HC_PAGE_DOWNLOAD_ERROR', $page_link));
                continue;
            }

            foreach ($patterns as $regexp => $description) {
                $matches = [];
                $result = @preg_match($regexp, $html, $matches);
                if ($result === false) {
                    attach_message('Bad regexp: ' . $regexp, 'warn', false, true);
                    continue;
                }
                /*if ($result != 0) { Debugging
                    @header('Content-Type: text/plain');@var_dump($matches);exit();
                }*/
                $this->assertTrue($result == 0, $description);
            }
        }
    }
}
