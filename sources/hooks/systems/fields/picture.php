<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_fields
 */

/**
 * Hook class.
 */
class Hook_fields_picture
{
    // ==============
    // Module: search
    // ==============

    /**
     * Get special Tempcode for inputting this field.
     *
     * @param  array $field The field details
     * @return ?array Specially encoded input detail rows (null: nothing special)
     */
    public function get_search_inputter(array $field) : ?array
    {
        return null;
    }

    /**
     * Get special SQL from POSTed parameters for this field.
     *
     * @param  array $field The field details
     * @param  integer $i We're processing for the ith row
     * @param  string $table_alias Table alias for catalogue entry table
     * @return ?array Tuple of SQL details (array: extra trans fields to search, array: extra plain fields to search, string: an extra table segment for a join, string: the name of the field to use as a title, if this is the title, extra WHERE clause stuff) (null: nothing special)
     */
    public function inputted_to_sql_for_search(array $field, int $i, string $table_alias = 'r') : ?array
    {
        return null;
    }

    // ===================
    // Backend: fields API
    // ===================

    /**
     * Get some info bits relating to our field type, that helps us look it up / set defaults.
     *
     * @param  ?array $field The field details (null: new field)
     * @param  ?boolean $required Whether a default value cannot be blank (null: don't "lock in" a new default value) (may be passed as false also if we want to avoid "lock in" of a new default value, but in this case possible cleanup of $default may still happen where appropriate)
     * @param  ?string $default The given default value as a string (null: don't "lock in" a new default value) (blank: only "lock in" a new default value if $required is true)
     * @return array Tuple of details (row-type,default-value-to-use,db row-type)
     */
    public function get_field_value_row_bits(?array $field, ?bool $required = null, ?string $default = null) : array
    {
        return ['short_unescaped', $default, 'short'];
    }

    /**
     * Convert a field value to something renderable.
     *
     * @param  array $field The field details
     * @param  mixed $ev The raw value
     * @param  integer $i Position in fieldset
     */
    public function preprocess_field(array &$field, $ev, int $i)
    {
        $is_metadata = option_value_from_field_array($field, 'is_metadata', '');
        if ($is_metadata != '0') {
            if ($is_metadata == '1') { // Take priority?
                global $METADATA;
                unset($METADATA['image']);
            }

            $img_url = $ev;
            if (url_is_local($img_url)) {
                $img_url = get_custom_base_url() . '/' . $img_url;
            }

            set_extra_request_metadata([
                'image' => $img_url,
            ]);
        }
    }

    /**
     * Convert a field value to something renderable.
     *
     * @param  array $field The field details
     * @param  mixed $ev The raw value
     * @param  integer $i Position in fieldset
     * @param  ?array $only_fields List of fields the output is being limited to (null: N/A)
     * @param  ?ID_TEXT $table The table we store in (null: N/A)
     * @param  ?AUTO_LINK $id The ID of the row in the table (null: N/A)
     * @param  ?ID_TEXT $id_field Name of the ID field in the table (null: N/A)
     * @param  ?ID_TEXT $field_id_field Name of the field ID field in the table (null: N/A)
     * @param  ?ID_TEXT $url_field Name of the URL field in the table (null: N/A)
     * @param  ?MEMBER $submitter Submitter (null: current member)
     * @param  ?mixed $ev_pure The 'pure' form of the raw value, meaning Comcode is not pre-parsed and string conversion has not been performed (null: unknown)
     * @return mixed Rendered field (string or Tempcode)
     */
    public function render_field_value(array &$field, $ev, int $i, ?array $only_fields, ?string $table = null, ?int $id = null, ?string $id_field = null, ?string $field_id_field = null, ?string $url_field = null, ?int $submitter = null, $ev_pure = null)
    {
        if (is_object($ev)) {
            return $ev;
        }

        if ($ev == '') {
            return '';
        }
        if ($ev == STRING_MAGIC_NULL) {
            return ''; // LEGACY: Fix to bad data that got in
        }

        $image_url = $ev;
        if (url_is_local($image_url)) {
            $image_url = get_custom_base_url() . '/' . $image_url;
        }

        if (!array_key_exists('c_name', $field)) {
            $field['c_name'] = 'other';
        }
        $tpl_set = $field['c_name'];

        if (url_is_local($ev)) {
            $keep = symbol_tempcode('KEEP');
            $download_url = find_script('catalogue_file') . '?file=' . urlencode(basename($image_url)) . '&table=' . urlencode(($table === null) ? '' : $table) . '&id=' . urlencode(strval($id)) . '&id_field=' . urlencode(($id_field === null) ? '' : $id_field) . '&url_field=' . urlencode(($url_field === null) ? '' : $url_field);
            $download_url .= '&inline=1';
            if ($field_id_field !== null) {
                $download_url .= '&field_id_field=' . urlencode($field_id_field) . '&field_id=' . urlencode(strval($field['id']));
            }
            $download_url .= $keep->evaluate();

            if ((($table === 'catalogue_efv_short') || ($table === 'catalogue_efv_long')) && ($id !== null)) {
                $c_name = $GLOBALS['SITE_DB']->query_select_value('catalogue_entries', 'c_name', ['id' => $id]);
                if (substr($c_name, 0, 1) != '_') { // Doesn't work on custom fields (this is documented)
                    $cc_id = $GLOBALS['SITE_DB']->query_select_value('catalogue_entries', 'cc_id', ['id' => $id]);
                    if (!has_category_access(get_member(), 'catalogues_catalogue', $c_name)) {
                        $download_url = '';
                    }
                    if (!has_category_access(get_member(), 'catalogues_category', strval($cc_id))) {
                        $download_url = '';
                    }
                    if ((is_file(get_file_base() . '/site/catalogue_file.php')) && (!has_zone_access(get_member(), 'site'))) {
                        $download_url = '';
                    }
                }
            }
        } else {
            $download_url = $image_url;
        }

        $width = option_value_from_field_array($field, 'width', '');
        $height = option_value_from_field_array($field, 'height', '');

        return do_template('CATALOGUE_' . $tpl_set . '_FIELD_PICTURE', [
            'I' => ($only_fields === null) ? '-1' : strval($i),
            'CATALOGUE' => $field['c_name'],
            'URL' => $download_url,
            'IMAGE_URL' => $image_url,
            'WIDTH' => $width,
            'HEIGHT' => $height,
        ], null, false, 'CATALOGUE_DEFAULT_FIELD_PICTURE');
    }

    // ======================
    // Frontend: fields input
    // ======================

    /**
     * Get form inputter.
     *
     * @param  string $_cf_name The field name
     * @param  string $_cf_description The field description
     * @param  array $field The field details
     * @param  ?string $actual_value The actual current value of the field (null: none)
     * @param  boolean $new Whether this is for a new entry
     * @return ?array A pair: The Tempcode for the input field, Tempcode for hidden fields (null: skip the field - it's not input)
     */
    public function get_field_inputter(string $_cf_name, string $_cf_description, array $field, ?string $actual_value, bool $new) : ?array
    {
        require_code('images');

        $say_required = ($field['cf_required'] == 1) && (empty($actual_value));

        $input_name = @cms_empty_safe($field['cf_input_name']) ? ('field_' . strval($field['id'])) : $field['cf_input_name'];

        $cf_description = protect_from_escaping(escape_html($_cf_description));
        if (($field['cf_required'] == 1) && (!empty($actual_value))) {
            $cf_description->attach(do_lang_tempcode('IF_UNCHANGED_CURRENT_FILE_REMAINS'));
        }

        $ffield = form_input_upload($_cf_name, $cf_description, $input_name, $say_required, ($field['cf_required'] == 1) ? null/*so unlink option not shown*/ : $actual_value, null, true, get_allowed_image_file_types(IMAGE_CRITERIA_WEBSAFE));

        $hidden = new Tempcode();
        handle_max_file_size($hidden, 'image');

        return [$ffield, $hidden];
    }

    /**
     * Find the posted value from the get_field_inputter field.
     *
     * @param  boolean $editing Whether we were editing (because on edit, it could be a fractional edit)
     * @param  array $field The field details
     * @param  ?string $upload_dir Where the files will be uploaded to (null: do not store an upload, return null if we would need to do so)
     * @param  ?array $old_value Former value of field (null: none)
     * @return ?string The value (null: could not process)
     */
    public function inputted_to_field_value(bool $editing, array $field, ?string $upload_dir = 'uploads/catalogues', ?array $old_value = null) : ?string
    {
        if ($upload_dir === null) {
            return null;
        }

        $id = $field['id'];
        $tmp_name = 'field_' . strval($id);
        if (!fractional_edit()) {
            require_code('uploads');

            $keep_gps = (option_value_from_field_array($field, 'keep_gps', 'off') == 'on');
            set_images_cleanup_pipeline_settings(IMG_RECOMPRESS_LOSSLESS, null, null, !$keep_gps);

            $temp = get_url($tmp_name . '_url', $tmp_name, $upload_dir, OBFUSCATE_LEAVE_SUFFIX, CMS_UPLOAD_IMAGE);

            reset_images_cleanup_pipeline_settings();

            $value = $temp[0];
            if (($editing) && ($value == '') && (post_param_integer($tmp_name . '_unlink', 0) != 1)) {
                return ($old_value === null) ? '' : $old_value['cv_value'];
            }

            if (($old_value !== null) && ($old_value['cv_value'] != '') && (($value != '') || (post_param_integer('custom_' . strval($field['id']) . '_value_unlink', 0) == 1))) {
                @unlink(get_custom_file_base() . '/' . rawurldecode($old_value['cv_value']));
                sync_file(rawurldecode($old_value['cv_value']));
            }
        } else {
            $value = STRING_MAGIC_NULL;
        }

        return $value;
    }

    /**
     * The field is being deleted, so delete any necessary data.
     *
     * @param  mixed $value Current field value
     */
    public function cleanup($value)
    {
        if ($value['cv_value'] != '') {
            @unlink(get_custom_file_base() . '/' . rawurldecode($value['cv_value']));
            sync_file(rawurldecode($value['cv_value']));
        }
    }

    /**
     * Determine what data should be used from this field in SEO.
     *
     * @param  string $val The value of the field
     * @param  integer $field_id The ID of the field
     * @param  ID_TEXT $content_type The content type using this field
     * @param  ?ID_TEXT $content_id The ID of the content using this field (null: not using a specific piece of content, such as adding a new entry)
     * @return mixed Either a string of the content to use in SEO, or a Tuple of [(string) content to use, (boolean) must use / high priority, (boolean) is a codename]
     */
    public function get_seo_source_map(string $val, int $field_id, string $content_type, ?string $content_id = null)
    {
        return ''; // Nothing to extract
    }

    /**
     * Define what type of field this should be treated as in the privacy system if marked sensitive.
     * This method should be defined on fields which should not be treated as "additional_anonymise_fields".
     *
     * @param  array $field The field details
     * @return ID_TEXT The type of field to treat this
     */
    public function privacy_field_type(array $field) : string
    {
        return 'file_fields';
    }
}
