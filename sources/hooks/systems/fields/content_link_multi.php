<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_fields
 */

/**
 * Hook class.
 */
class Hook_fields_content_link_multi
{
    /**
     * Find what field types this hook can serve. This method only needs to be defined if it is not serving a single field type with a name corresponding to the hook itself.
     *
     * @return array Map of field type to field type title
     */
    public function get_field_types() : array
    {
        $hooks = find_all_hooks('systems', 'content_meta_aware');
        $ret = [];
        foreach (array_keys($hooks) as $hook) {
            if ($hook != 'catalogue_entry'/*got a better field hook specifically for catalogue entries*/) {
                $ret['ax_' . $hook] = do_lang_tempcode('FIELD_TYPE_content_link_multi_x', escape_html($hook));
            }
        }
        return $ret;
    }

    // ==============
    // Module: search
    // ==============

    /**
     * Get special Tempcode for inputting this field.
     *
     * @param  array $field The field details
     * @return ?array Specially encoded input detail rows (null: nothing special)
     */
    public function get_search_inputter(array $field) : ?array
    {
        return null;
    }

    /**
     * Get special SQL from POSTed parameters for this field.
     *
     * @param  array $field The field details
     * @param  integer $i We're processing for the ith row
     * @param  string $table_alias Table alias for catalogue entry table
     * @return ?array Tuple of SQL details (array: extra trans fields to search, array: extra plain fields to search, string: an extra table segment for a join, string: the name of the field to use as a title, if this is the title, extra WHERE clause stuff) (null: nothing special)
     */
    public function inputted_to_sql_for_search(array $field, int $i, string $table_alias = 'r') : ?array
    {
        return exact_match_sql($field, $i, 'short', null, $table_alias);
    }

    // ===================
    // Backend: fields API
    // ===================

    /**
     * Get some info bits relating to our field type, that helps us look it up / set defaults.
     *
     * @param  ?array $field The field details (null: new field)
     * @param  ?boolean $required Whether a default value cannot be blank (null: don't "lock in" a new default value) (may be passed as false also if we want to avoid "lock in" of a new default value, but in this case possible cleanup of $default may still happen where appropriate)
     * @param  ?string $default The given default value as a string (null: don't "lock in" a new default value) (blank: only "lock in" a new default value if $required is true)
     * @return array Tuple of details (row-type,default-value-to-use,db row-type)
     */
    public function get_field_value_row_bits(?array $field, ?bool $required = null, ?string $default = null) : array
    {
        return ['long_unescaped', $default, 'long'];
    }

    /**
     * Convert a field value to something renderable.
     *
     * @param  array $field The field details
     * @param  mixed $ev The raw value
     * @param  integer $i Position in fieldset
     * @param  ?array $only_fields List of fields the output is being limited to (null: N/A)
     * @param  ?ID_TEXT $table The table we store in (null: N/A)
     * @param  ?AUTO_LINK $id The ID of the row in the table (null: N/A)
     * @param  ?ID_TEXT $id_field Name of the ID field in the table (null: N/A)
     * @param  ?ID_TEXT $field_id_field Name of the field ID field in the table (null: N/A)
     * @param  ?ID_TEXT $url_field Name of the URL field in the table (null: N/A)
     * @param  ?MEMBER $submitter Submitter (null: current member)
     * @param  ?mixed $ev_pure The 'pure' form of the raw value, meaning Comcode is not pre-parsed and string conversion has not been performed (null: unknown)
     * @return mixed Rendered field (string or Tempcode)
     */
    public function render_field_value(array &$field, $ev, int $i, ?array $only_fields, ?string $table = null, ?int $id = null, ?string $id_field = null, ?string $field_id_field = null, ?string $url_field = null, ?int $submitter = null, $ev_pure = null)
    {
        if (is_object($ev)) {
            return $ev;
        }

        if ($ev == '') {
            return '';
        }

        $type = preg_replace('#^choose_#', '', substr($field['cf_type'], 3));

        $out = [];
        $evs = explode("\n", $ev);
        foreach ($evs as $ev) {
            require_code('content');
            list($title, , $info) = content_get_details($type, $ev);
            if ($info === null) {
                continue;
            }

            $page_link = str_replace('_WILD', $ev, $info['view_page_link_pattern']);
            list($zone, $map) = page_link_decode($page_link);

            $out[] = [$title, $map, $zone];
        }

        $auto_sort = option_value_from_field_array($field, 'auto_sort', 'off');
        if ($auto_sort == 'on') {
            sort_maps_by($out, 0, false, true);
        }

        $ret = new Tempcode();
        foreach ($out as $o) {
            list($title, $map) = $o;
            $ret->attach(paragraph(hyperlink(build_url($map, $zone), $title, false, true), 'content_link_multi'));
        }

        return $ret;
    }

    // ======================
    // Frontend: fields input
    // ======================

    /**
     * Get form inputter.
     *
     * @param  string $_cf_name The field name
     * @param  string $_cf_description The field description
     * @param  array $field The field details
     * @param  ?string $actual_value The actual current value of the field (null: none)
     * @param  boolean $new Whether this is for a new entry
     * @return ?Tempcode The Tempcode for the input field (null: skip the field - it's not input)
     */
    public function get_field_inputter(string $_cf_name, string $_cf_description, array $field, ?string $actual_value, bool $new) : ?object
    {
        $options = [];
        $type = substr($field['cf_type'], 3);

        $input_name = @cms_empty_safe($field['cf_input_name']) ? ('field_' . strval($field['id'])) : $field['cf_input_name'];

        // Nice tree list selection
        if ((is_file(get_file_base() . '/sources/hooks/systems/ajax_tree/choose_' . $type . '.php')) || (is_file(get_file_base() . '/sources_custom/hooks/systems/ajax_tree/choose_' . $type . '.php'))) {
            return form_input_tree_list($_cf_name, $_cf_description, $input_name, null, 'choose_' . $type, $options, $field['cf_required'] == 1, str_replace("\n", ',', $actual_value), false, null, true);
        }

        // Simple list selection...

        require_code('content');
        $ob = get_content_object($type);
        $info = $ob->info();
        if ($info === null) {
            return new Tempcode();
        }
        $db = get_db_for($info['table']);
        $select = [];
        append_content_select_for_fields($select, $info, ['id', 'title', 'add_time']);
        $rows = $db->query_select($info['table'], $select, [], ($info['add_time_field'] === null) ? '' : ('ORDER BY ' . $info['add_time_field'] . ' DESC'), 2000/*reasonable limit*/);

        $list = new Tempcode();
        $_list = [];
        foreach ($rows as $row) {
            $id = $ob->get_id($row);
            $text = $ob->get_title($row);
            $_list[$id] = $text;
        }
        if (count($_list) < 2000) {
            cms_mb_asort($_list, SORT_NATURAL | SORT_FLAG_CASE);
        }

        foreach ($_list as $id => $text) {
            if (!is_string($id)) {
                $id = strval($id);
            }
            $list->attach(form_input_list_entry($id, (($actual_value === null) || $id == '') ? false : (strpos("\n" . $actual_value . "\n", $id) !== false), $text));
        }

        return form_input_multi_list($_cf_name, $_cf_description, $input_name, $list, null, 5, $field['cf_required'] == 1);
    }

    /**
     * Find the posted value from the get_field_inputter field.
     *
     * @param  boolean $editing Whether we were editing (because on edit, it could be a fractional edit)
     * @param  array $field The field details
     * @param  ?string $upload_dir Where the files will be uploaded to (null: do not store an upload, return null if we would need to do so)
     * @param  ?array $old_value Former value of field (null: none)
     * @return ?string The value (null: could not process)
     */
    public function inputted_to_field_value(bool $editing, array $field, ?string $upload_dir = 'uploads/catalogues', ?array $old_value = null) : ?string
    {
        $id = $field['id'];
        $i = 0;
        $value = '';
        $tmp_name = 'field_' . strval($id);
        $type = preg_replace('#^choose\_#', '', substr($field['cf_type'], 3));

        if (!array_key_exists($tmp_name, $_POST)) {
            return $editing ? STRING_MAGIC_NULL : '';
        }

        require_code('content');
        foreach (is_array($_POST[$tmp_name]) ? $_POST[$tmp_name] : explode(',', $_POST[$tmp_name]) as $_value) {
            if ($_value != '') {
                // Skip content that does not exist
                list($title) = content_get_details($type, $_value);
                if ($title === null) {
                    continue;
                }

                if ($value != '') {
                    $value .= "\n";
                }
                $value .= $_value;
            }
        }
        return $value;
    }

    /**
     * Determine what data should be used from this field in SEO.
     *
     * @param  string $val The value of the field
     * @param  integer $field_id The ID of the field
     * @param  ID_TEXT $content_type The content type using this field
     * @param  ?ID_TEXT $content_id The ID of the content using this field (null: not using a specific piece of content, such as adding a new entry)
     * @return mixed Either a string of the content to use in SEO, or a Tuple of [(string) content to use, (boolean) must use / high priority, (boolean) is a codename]
     */
    public function get_seo_source_map(string $val, int $field_id, string $content_type, ?string $content_id = null)
    {
        return ''; // Content link values are Composr specific and meaningless for SEO
    }
}
