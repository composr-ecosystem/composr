<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2023

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Hook class.
 */
class Hook_geocoding_bing
{
    /**
     * Whether the service is available.
     *
     * @param  boolean $reverse Whether reverse geocoding is requested
     * @return boolean Whether it is
     */
    public function is_available(bool $reverse = false) : bool
    {
        $key = get_option('bing_geocoding_api_key');
        return ($key != '');
    }

    /**
     * Geocode a written location.
     *
     * @param  string $location Written location
     * @param  ?Tempcode $errormsg Error message (returned by reference) (null: not set yet)
     * @return ?array A tuple: Latitude, Longitude, NE lat, NE lng, SW lat, SW lng (null: error)
     */
    public function geocode(string $location, ?object &$errormsg = null) : ?array
    {
        $url_params = urlencode($location);
        $result = $this->_geocode($url_params, $errormsg);
        if ($result === null) {
            return null;
        }

        if (!isset($result['resourceSets'][0]['resources'][0])) {
            $errormsg = do_lang_tempcode('GEOCODE_INCOMPLETE');
            return null;
        }
        $r = $result['resourceSets'][0]['resources'][0];

        if (!isset($r['point']['coordinates'])) {
            $errormsg = do_lang_tempcode('GEOCODE_INCOMPLETE');
            return null;
        }

        $latitude = $r['point']['coordinates'][0];
        $longitude = $r['point']['coordinates'][1];

        $ne_latitude = $r['bbox'][0];
        $ne_longitude = $r['bbox'][1];
        $sw_latitude = $r['bbox'][2];
        $sw_longitude = $r['bbox'][3];

        return [$latitude, $longitude, $ne_latitude, $ne_longitude, $sw_latitude, $sw_longitude];
    }

    /**
     * Geocode a latitude & longitude.
     *
     * @param  float $latitude Latitude
     * @param  float $longitude Longitude
     * @param  ?Tempcode $errormsg Error message (returned by reference) (null: not set yet)
     * @return ?array A tuple: Formatted address, Street Address, City, County, State, Zip/Postcode, Country, NE lat, NE lng, SW lat, SW lng (null: error)
     */
    public function reverse_geocode(float $latitude, float $longitude, ?object &$errormsg = null) : ?array
    {
        $url_params = urlencode(float_to_raw_string($latitude, 30)) . ',' . urlencode(float_to_raw_string($longitude, 30));
        $result = $this->_geocode($url_params, $errormsg);
        if ($result === null) {
            return null;
        }

        if (!isset($result['resourceSets'][0]['resources'][0])) {
            $errormsg = do_lang_tempcode('GEOCODE_INCOMPLETE');
            return null;
        }
        $r = $result['resourceSets'][0]['resources'][0];

        $street_address = @cms_empty_safe($r['address']['addressLine']) ? null : $r['address']['addressLine'];
        $city = empty($r['address']['locality']) ? null : $r['address']['locality'];
        $county = empty($r['address']['adminDistrict']) ? null : $r['address']['adminDistrict'];
        if ($county === $city) {
            $county = null;
        }
        $state = empty($r['address']['adminDistrict2']) ? null : $r['address']['adminDistrict2'];
        $postal_code = @cms_empty_safe($r['address']['postalCode']) ? null : $r['address']['postalCode'];
        $country = empty($r['address']['countryRegion']) ? null : $r['address']['countryRegion'];

        require_code('locations');
        $_country = find_iso_country_from_name($country);
        if ($_country !== null) {
            $country = $_country;
        }

        if (!isset($r['address']['formattedAddress'])) {
            $errormsg = do_lang_tempcode('GEOCODE_INCOMPLETE');
            return null;
        }
        $location = $r['address']['formattedAddress'];

        $ne_latitude = $r['bbox'][0];
        $ne_longitude = $r['bbox'][1];
        $sw_latitude = $r['bbox'][2];
        $sw_longitude = $r['bbox'][3];

        return [$location, $street_address, $city, $county, $state, $postal_code, $country, $ne_latitude, $ne_longitude, $sw_latitude, $sw_longitude];
    }

    /**
     * Geocode a written location.
     *
     * @param  string $url_params What to add into the URL
     * @param  ?Tempcode $errormsg Error message (returned by reference) (null: not set yet)
     * @return ?array Geocode results (null: error)
     * @ignore
     */
    protected function _geocode(string $url_params, ?object &$errormsg = null) : ?array
    {
        // Test to see if we know we were over the limit in the last 24h
        $limit_test = get_value_newer_than('over_geocode_query_limit', time() - 60 * 60 * 24, true);
        if ($limit_test === 1) {
            $errormsg = do_lang_tempcode('GEOCODE_OVER_QUERY_LIMIT');
            return null;
        }

        $url = 'http://dev.virtualearth.net/REST/v1/Locations/' . $url_params;
        $url .= '?o=json';
        $url .= '&key=' . urlencode(get_option('bing_geocoding_api_key'));

        $_result = cms_http_request($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false, 'ignore_http_status' => true]);

        if (empty($_result->data)) {
            $errormsg = do_lang_tempcode('GEOCODE_COULD_NOT_CONNECT', escape_html($_result->message));
            return null;
        }

        $result = @json_decode($_result->data, true);
        if (!is_array($result)) {
            $errormsg = do_lang_tempcode('GEOCODE_COULD_NOT_PARSE', escape_html($_result->message));
            return null;
        }

        if ($_result->message == '401') {
            set_value('over_geocode_query_limit', '1', true);
        }

        if ($_result->message != '200') {
            $errormsg = make_string_tempcode('Bing: ');
            foreach ($result['errorDetails'] as $i => $message) {
                if ($i != 0) {
                    $errormsg->attach(',');
                }
                $errormsg->attach($message);
            }
            return null;
        }

        return $result;
    }
}
