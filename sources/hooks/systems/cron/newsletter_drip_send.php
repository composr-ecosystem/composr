<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    newsletter
 */

/**
 * Hook class.
 */
class Hook_cron_newsletter_drip_send
{
    /**
     * Get info from this hook.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     * @param  ?boolean $calculate_num_queued Calculate the number of items queued, if possible (null: the hook may decide / low priority)
     * @return ?array Return a map of info about the hook (null: disabled)
     */
    public function info(?int $last_run, ?bool $calculate_num_queued) : ?array
    {
        if (!addon_installed('newsletter')) {
            return null;
        }

        // Calculate on low priority
        if ($calculate_num_queued === null) {
            $calculate_num_queued = true;
        }

        return [
            'label' => 'Send queued newsletters',
            'num_queued' => $calculate_num_queued ? $GLOBALS['SITE_DB']->query_select_value('newsletter_drip_send', 'COUNT(*)') : null,
            'minutes_between_runs' => intval(get_option('minutes_between_sends')),
            'enabled_by_default' => true,
        ];
    }

    /**
     * Run function for system scheduler hooks. Searches for things to do. ->info(..., true) must be called before this method.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     */
    public function run(?int $last_run)
    {
        $mails_per_send = intval(get_option('mails_per_send'));
        $minutes_between_sends = intval(get_option('minutes_between_sends'));

        $time = time();
        $last_time = intval(get_value('last_newsletter_drip_send', null, true));
        if (($last_time > time() - $minutes_between_sends * 60) && (!/*we do allow an admin to force it by Cron URL*/$GLOBALS['FORUM_DRIVER']->is_super_admin(get_member()))) {
            return;
        }
        set_value('last_newsletter_drip_send', strval($time), true);

        require_lang('newsletter');

        $to_send = $GLOBALS['SITE_DB']->query_select('newsletter_drip_send', ['*'], [], 'ORDER BY id DESC', $mails_per_send); // From disk-end, for maximum performance (truncating files to mark done is quicker?)
        if (!empty($to_send)) {
            // We'll cache messages here
            $cached_messages = [];

            // Send
            require_code('newsletter');
            require_code('mail');
            $sent = [];
            foreach ($to_send as $mail) {
                $message_id = $mail['d_message_id'];
                $email_address = $mail['d_to_email'];

                $message_binding = json_decode($mail['d_message_binding'], true);
                $forename = $message_binding['forename'];
                $surname = $message_binding['surname'];
                $name = $message_binding['name'];
                $send_id = $message_binding['send_id'];
                $hash = $message_binding['hash'];

                // Load message
                if (!isset($cached_messages[$message_id])) {
                    $newsletter_archive_rows = $GLOBALS['SITE_DB']->query_select('newsletter_archive', ['*'], ['id' => $message_id], '', 1);
                    $cached_messages[$message_id] = $newsletter_archive_rows[0];
                }
                $message_row = $cached_messages[$message_id];
                $lang = $message_row['language'];
                $message_raw = $message_row['newsletter'];
                $subject = $message_row['subject'];
                $from_email = $message_row['from_email'];
                $from_name = $message_row['from_name'];
                $priority = $message_row['priority'];
                $template = $message_row['template'];
                $html_only = $message_row['html_only'];

                $message_wrapped = newsletter_prepare($message_raw, $subject, $lang, $forename, $surname, $name, $email_address, $send_id, $hash);
                $is_html = newsletter_is_html($message_wrapped);

                $mail_ob = dispatch_mail(
                    $subject,
                    $message_wrapped,
                    '',
                    [$email_address],
                    [$mail['d_to_name']],
                    $from_email,
                    $from_name,
                    [
                        'priority' => $priority,
                        'no_cc' => true,
                        'as_admin' => true,
                        'in_html' => $is_html,
                        'mail_template' => $template,
                        //'bypass_queue' => true,
                        'bypass_queue' => false, // Not ideal but we want automatic mail failure handling
                        'smtp_sockets_use' => (get_option('newsletter_smtp_sockets_use') == '1'),
                        'smtp_sockets_host' => get_option('newsletter_smtp_sockets_host'),
                        'smtp_sockets_port' => intval(get_option('newsletter_smtp_sockets_port')),
                        'smtp_sockets_username' => get_option('newsletter_smtp_sockets_username'),
                        'smtp_sockets_password' => get_option('newsletter_smtp_sockets_password'),
                        'smtp_from_address' => get_option('newsletter_smtp_from_address'),
                        'enveloper_override' => (get_option('newsletter_enveloper_override') == '1'),
                        'allow_ext_images' => (get_option('newsletter_allow_ext_images') == '1'),
                        'website_email' => get_option('newsletter_website_email'),
                        'is_bulk' => true,
                        'leave_attachments_on_failure' => true,
                    ]
                );

                if ($mail_ob->worked) {
                    $sent[] = $mail['id'];
                }
            }

            // Mass cleanup for maximum performance
            $id_list = '';
            foreach ($to_send as $sent_id) {
                if ($id_list != '') {
                    $id_list .= ' OR ';
                }
                $id_list .= 'id=' . strval($sent_id['id']);
            }
            if ($id_list != '') {
                $GLOBALS['SITE_DB']->query('DELETE FROM ' . get_table_prefix() . 'newsletter_drip_send WHERE ' . $id_list, null, 0, false, true);
            }
        }

        if (count($to_send) < $mails_per_send) {
            // Don't make us wait if we aren't filling the buffer
            set_value('last_newsletter_drip_send', strval($time - $minutes_between_sends * 60), true);
        }
    }
}
