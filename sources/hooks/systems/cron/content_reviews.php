<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    content_reviews
 */

/**
 * Hook class.
 */
class Hook_cron_content_reviews
{
    protected $pending_content_reviews;

    /**
     * Get info from this hook.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     * @param  ?boolean $calculate_num_queued Calculate the number of items queued, if possible (null: the hook may decide / low priority)
     * @return ?array Return a map of info about the hook (null: disabled)
     */
    public function info(?int $last_run, ?bool $calculate_num_queued) : ?array
    {
        if (!addon_installed('content_reviews')) {
            return null;
        }

        if (!addon_installed('commandr')) {
            return null;
        }
        if (!addon_installed('validation')) {
            return null;
        }

        // Calculate on low priority
        if ($calculate_num_queued === null) {
            $calculate_num_queued = true;
        }

        if ($calculate_num_queued) {
            $query = 'SELECT * FROM ' . get_table_prefix() . 'content_reviews WHERE review_notification_happened=0 AND next_review_time<=' . strval(time());
            $this->pending_content_reviews = $GLOBALS['SITE_DB']->query($query);
            $num_queued = count($this->pending_content_reviews);
        } else {
            $num_queued = null;
        }

        return [
            'label' => 'Send content review notifications',
            'num_queued' => $num_queued,
            'minutes_between_runs' => 60 * 24,
            'enabled_by_default' => true,
        ];
    }

    /**
     * Run function for system scheduler hooks. Searches for things to do. ->info(..., true) must be called before this method.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     */
    public function run(?int $last_run)
    {
        foreach ($this->pending_content_reviews as $pending_content_review) {
            $content_type = $pending_content_review['content_type'];
            $content_id = $pending_content_review['content_id'];

            // Mark as handled
            $GLOBALS['SITE_DB']->query_update('content_reviews', ['review_notification_happened' => 1], ['content_type' => $content_type, 'content_id' => $content_id], '', 1);

            require_code('content');

            require_lang('content_reviews');

            $auto_action = $pending_content_review['auto_action'];

            // Get title / check not deleted, cleanup if is
            list($title, $submitter) = content_get_details($content_type, $content_id);
            if ($title === null) {
                $GLOBALS['SITE_DB']->query_delete('content_reviews', ['content_type' => $content_type, 'content_id' => $content_id], '', 1); // The actual content was deleted, I guess
                continue;
            }

            // Dispatch notification
            if ((!file_exists(get_file_base() . '/sources/hooks/systems/content_meta_aware/' . filter_naughty_harsh($content_type) . '.php')) && (!file_exists(get_file_base() . '/sources_custom/hooks/systems/content_meta_aware/' . filter_naughty_harsh($content_type) . '.php'))) {
                continue; // Weird :S
            }
            require_code('content');
            $object = get_content_object($content_type);
            if ($object === null) {
                continue; // Weird :S
            }
            $info = $object->info();
            if ($info === null) {
                continue; // Weird :S
            }
            $auto_action_str = do_lang('CONTENT_REVIEW_AUTO_ACTION_' . $auto_action);
            list($zone, $attributes,) = page_link_decode($info['edit_page_link_pattern']);
            foreach ($attributes as $key => $val) {
                if ($val == '_WILD') {
                    $attributes[$key] = $content_id;
                }
            }
            $edit_url = build_url($attributes + ['validated' => 1], $zone, [], false, false, true);
            require_code('notifications');
            $subject = do_lang('NOTIFICATION_SUBJECT_CONTENT_REVIEWS' . (($auto_action == 'delete') ? '_delete' : ''), $title, $auto_action_str);
            $message = do_notification_lang('NOTIFICATION_BODY_CONTENT_REVIEWS' . (($auto_action == 'delete') ? '_delete' : ''), $title, $auto_action_str, $edit_url->evaluate());
            dispatch_notification('content_reviews', $content_type, $subject, $message, null, null, ['priority' => 4]);
            if (($submitter !== null) && (!notifications_enabled('content_reviews', $content_type, $submitter))) {
                dispatch_notification('content_reviews__own', $content_type, $subject, $message, [$submitter], null, ['priority' => 4]);
            }

            // Do auto-action
            switch ($auto_action) {
                case 'invalidate':
                    if ($info['validated_field'] !== null) {
                        $info['db']->query_update($info['table'], [$info['validated_field'] => 0], get_content_where_for_str_id($content_id, $info), '', 1);
                    }
                    break;

                case 'delete':
                    require_code('resource_fs');
                    $object_fs = get_resource_commandr_fs_object($content_type);
                    if ($object_fs !== null) {
                        $filename = $object_fs->convert_id_to_filename($content_type, $content_id);
                        if ($filename !== null) {
                            $subpath = $object_fs->search($content_type, $content_id, true);

                            // TODO: We need some sort of privilege checking in case the owner or privileges changed
                            // $privileges = $object_fs->get_resource_privileges(null, $content_type, $content_id);
                            $object_fs->resource_delete($content_type, $filename, dirname($subpath));
                        }
                    }
                    break;

                case 'leave':
                    // Nothing to do
                    break;
            }
        }
    }
}
