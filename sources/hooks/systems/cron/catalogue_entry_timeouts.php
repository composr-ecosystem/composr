<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2023

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    catalogues
 */

/**
 * Hook class.
 */
class Hook_cron_catalogue_entry_timeouts
{
    /**
     * Get info from this hook.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     * @param  ?boolean $calculate_num_queued Calculate the number of items queued, if possible (null: the hook may decide / low priority)
     * @return ?array Return a map of info about the hook (null: disabled)
     */
    public function info(?int $last_run, ?bool $calculate_num_queued) : ?array
    {
        if (!addon_installed('catalogues')) {
            return null;
        }

        // Calculate on low priority
        if ($calculate_num_queued === null) {
            $calculate_num_queued = true;
        }

        if ($calculate_num_queued) {
            $num_queued = 0;

            $catalogue_categories = $GLOBALS['SITE_DB']->query('SELECT id,cc_move_target,cc_move_days_lower,cc_move_days_higher FROM ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_categories WHERE cc_move_target IS NOT NULL');
            foreach ($catalogue_categories as $row) {
                $num_queued += $GLOBALS['SITE_DB']->query_select_value('catalogue_entries', 'COUNT(*)', ['cc_id' => $row['id']]);
            }
        } else {
            $num_queued = null;
        }

        return [
            'label' => 'Catalogue entry expiry',
            'num_queued' => $num_queued,
            'minutes_between_runs' => 6 * 60,
        ];
    }

    /**
     * Run function for system scheduler hooks. Searches for things to do. ->info(..., true) must be called before this method.
     *
     * @param  ?TIME $last_run Last time run (null: never)
     */
    public function run(?int $last_run)
    {
        $time_now = time();

        $catalogue_categories = $GLOBALS['SITE_DB']->query('SELECT id,cc_move_target,cc_move_days_lower,cc_move_days_higher FROM ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_categories WHERE cc_move_target IS NOT NULL');
        foreach ($catalogue_categories as $row) {
            $changed = false;

            $start = 0;
            do {
                $old_limit = cms_set_time_limit(TIME_LIMIT_EXTEND__MODEST);

                $entries = $GLOBALS['SITE_DB']->query_select('catalogue_entries', ['id', 'ce_submitter', 'ce_last_moved'], ['cc_id' => $row['id']], '', 1000, $start);
                foreach ($entries as $entry) {
                    $higher = has_privilege($entry['ce_submitter'], 'high_catalogue_entry_timeout');
                    $time_diff = $time_now - $entry['ce_last_moved'];
                    $move_days = $higher ? $row['cc_move_days_higher'] : $row['cc_move_days_lower'];
                    if ($time_diff / (60 * 60 * 24) > $move_days) {
                        $GLOBALS['SITE_DB']->query_update('catalogue_entries', ['ce_last_moved' => $time_now, 'cc_id' => $row['cc_move_target']], ['id' => $entry['id']], '', 1);
                        $changed = true;
                    }
                }
                $start += 1000;

                cms_set_time_limit($old_limit);
            } while (count($entries) == 1000);

            if ($changed) {
                require_code('catalogues2');
                calculate_category_child_count_cache($row['cc_move_target']);
                calculate_category_child_count_cache($row['id']);
            }
        }
    }
}
