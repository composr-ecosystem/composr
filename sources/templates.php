<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__templates()
{
    global $SKIP_TITLING;
    /** Whether we actually don't want to show screen titles in our output -- put them out as empty.
     *
     * @global boolean $SKIP_TITLING
     */
    $SKIP_TITLING = false;
}

/**
 * Get the Tempcode for a standard box (CSS driven), with the specified content entered. Please rarely use this function; it is not good to assume people want anythings in one of these boxes... use templates instead.
 *
 * @param  Tempcode $content The content being put inside the box, provided in HTML format
 * @param  ?Tempcode $title The title of the standard box, provided in HTML format (null: titleless standard box) (blank: titleless standard box)
 * @param  ID_TEXT $type The type of the box. Refers to a template (STANDARDBOX_type)
 * @param  string $width The CSS width
 * @param  string $options '|' separated list of options (meaning dependant upon templates interpretation)
 * @param  string $meta '|' separated list of meta information (key|value|key|value|...)
 * @param  string $links '|' separated list of link information (linkhtml|...)
 * @param  string $top_links Link to be added to the header of the box
 * @param  string $class CSS class to use
 * @return Tempcode The contents, put inside a standard box, according to the other parameters
 */
function put_in_standard_box(object $content, ?object $title = null, string $type = 'default', string $width = '', string $options = '', string $meta = '', string $links = '', string $top_links = '', string $class = '') : object
{
    if ($title === null) {
        $title = new Tempcode();
    }

    if ($type == '') {
        $type = 'default';
    }

    $_meta = [];
    if ($meta != '') {
        $meta_bits = explode('|', $meta);
        if (count($meta_bits) % 2 == 1) {
            unset($meta_bits[count($meta_bits) - 1]);
        }
        for ($i = 0; $i < count($meta_bits); $i += 2) {
            $_meta[] = ['KEY' => $meta_bits[$i + 0], 'VALUE' => $meta_bits[$i + 1]];
        }
    }

    $_links = [];
    if ($links != '') {
        $_links = explode('|', $links);
        if ($_links[count($_links) - 1] == '') {
            array_pop($_links);
        }
    }

    $_options = explode('|', $options);

    if ($width == 'auto') {
        $width = '';
    }
    if (is_numeric($width)) {
        $width = strval(intval($width)) . 'px';
    }

    if ($class == '') {
        $class = null;
    }

    return do_template('STANDARDBOX_' . filter_naughty($type), ['WIDTH' => $width, 'CONTENT' => $content, 'LINKS' => $_links, 'META' => $_meta, 'OPTIONS' => $_options, 'TITLE' => $title, 'TOP_LINKS' => $top_links, 'CLASS' => $class], null, true);
}

/**
 * Get the Tempcode for a page title. (Ones below the page header, not in the browser title bar).
 *
 * @sets_output_state
 *
 * @param  mixed $title The title to use (usually, a language string codename, see below)
 * @param  boolean $dereference_lang Whether the given title is actually a language string codename, and hence gets dereferenced
 * @param  array $params Parameters sent to the language string
 * @param  ?Tempcode $user_online_title Separate title to put into the 'currently viewing' data (null: use $title)
 * @param  array $awards Awards to say this has won
 * @param  boolean $save_as_metadata Whether to use this as metadata for the screen
 * @param  ?mixed $sub Sub-title (null: none)
 * @return Tempcode The title Tempcode
 */
function get_screen_title($title, bool $dereference_lang = true, array $params = [], ?object $user_online_title = null, array $awards = [], bool $save_as_metadata = true, $sub = null) : object
{
    global $TITLE_CALLED;
    $TITLE_CALLED = true;

    global $SKIP_TITLING;
    if ($SKIP_TITLING) {
        return new Tempcode();
    }

    if (($dereference_lang) && (strpos($title, ' ') !== false)) {
        $dereference_lang = false;
    }

    if ($dereference_lang) {
        $_title = do_lang_tempcode($title, array_shift($params), array_shift($params), $params);
    } else {
        $_title = is_object($title) ? $title : make_string_tempcode(escape_html($title));
    }

    if ((function_exists('get_session_id')) && (get_bot_type() === null) && ((!$GLOBALS['SESSION_IS_NEW']) || (!is_guest()))/*We don't bother tracking 'the_title' for new guest users, due to bot overhead*/) {
        if (get_value('disable_member_tracking') !== '1') {
            if (!$GLOBALS['SITE_DB']->table_is_locked('sessions')) {
                $change_map = [
                    'last_activity_time' => time(),
                    'the_title' => ($user_online_title === null) ? cms_mb_substr($_title->evaluate(), 0, 255) : $user_online_title->evaluate(),
                    'the_zone' => get_zone_name(),
                    'the_page' => cms_mb_substr(get_page_name(), 0, 80),
                    'the_type' => cms_mb_substr(get_param_string('type', '', INPUT_FILTER_GET_COMPLEX), 0, 80),
                    'the_id' => cms_mb_substr(get_param_string('id', '', INPUT_FILTER_GET_COMPLEX), 0, 80),
                ];

                $session_id = get_session_id();
                global $SESSION_CACHE;
                if ((get_value('disable_user_online_counting') !== '1') || (get_option('session_prudence') == '0') || (!isset($SESSION_CACHE[$session_id])) || ($SESSION_CACHE[$session_id]['last_activity_time'] < time() - 60 * 60 * 5)) {
                    $GLOBALS['SITE_DB']->query_update('sessions', $change_map, ['the_session' => $session_id], '', 1, 0, false, true); // Errors suppressed in case DB write access broken

                    if (get_option('session_prudence') == '0' && isset($SESSION_CACHE[$session_id]/*if not logging out?*/)) {
                        $SESSION_CACHE[$session_id] = $change_map + $SESSION_CACHE[$session_id];
                        persistent_cache_set('SESSION_CACHE', $SESSION_CACHE);
                    }
                }
            }
        }
    }

    if ($save_as_metadata) {
        global $DISPLAYED_TITLE;
        $DISPLAYED_TITLE = $_title;
    }

    return do_template('SCREEN_TITLE', ['_GUID' => '847ffbe4823eca6d2d5eac42828ee552', 'AWARDS' => $awards, 'TITLE' => $_title, 'SUB' => $sub]);
}

/**
 * Get the Tempcode for a hyperlink.
 *
 * @param  mixed $url The URL to put in the hyperlink (URLPATH or Tempcode)
 * @param  mixed $caption The hyperlinks caption, format depends on $auto_escape (string or Tempcode)
 * @param  boolean $external Whether the link is an external one (by default, the external template makes it open in a new window)
 * @param  boolean $auto_escape Whether to automatically escape if $caption is plain-text entry so that it cannot contain HTML
 * @param  mixed $title Link title, in plain-text format (string or Tempcode) (blank: none)
 * @param  ?string $accesskey The access key to use (null: none)
 * @param  ?Tempcode $post_data Data to post (null: an ordinary link)
 * @param  ?string $rel Rel (link type) (null: no special type)
 * @param  ?ID_TEXT $overlay Open in overlay with the default link/form target being as follows (e.g. _top or _self) (null: an ordinary link)
 * @return Tempcode The generated hyperlink
 */
function hyperlink($url, $caption, bool $external, bool $auto_escape, $title = '', ?string $accesskey = null, ?object $post_data = null, ?string $rel = null, ?string $overlay = null) : object
{
    if (((is_object($caption)) && ($caption->is_empty())) || ((!is_object($caption)) && ($caption == ''))) {
        $caption = do_lang_tempcode('NA');
    }

    if (($auto_escape) && (!is_object($caption))) {
        $caption = escape_html($caption);
    }

    if ($post_data !== null) {
        $tpl = 'HYPERLINK_BUTTON';
    } else {
        $tpl = 'HYPERLINK';
    }
    return do_template($tpl, ['OVERLAY' => $overlay, 'REL' => $rel, 'POST_DATA' => $post_data, 'ACCESSKEY' => $accesskey, 'NEW_WINDOW' => $external, 'TITLE' => $title, 'URL' => $url, 'CAPTION' => $caption]);
}

/**
 * Get the Tempcode for a div. Similar to paragraph, but may contain more formatting (such as <br />'s).
 *
 * @param  Tempcode $tempcode The Tempcode to put into a div, provided in HTML format (string or Tempcode)
 * @param  string $guid GUID for call
 * @param  ?string $class CSS classname (null: none)
 * @return Tempcode The generated div with contents
 */
function div(object $tempcode, string $guid = '', ?string $class = null) : object
{
    return do_template('DIV', ['_GUID' => $guid, 'TEMPCODE' => $tempcode, 'CLASS' => $class]);
}

/**
 * Get the Tempcode for a span.
 *
 * @param  Tempcode $tempcode The Tempcode to put into a span, provided in HTML format (string or Tempcode)
 * @param  string $guid GUID for call
 * @param  ?string $class CSS classname (null: none)
 * @return Tempcode The generated span with contents
 */
function span(object $tempcode, string $guid = '', ?string $class = null) : object
{
    return do_template('SPAN', ['_GUID' => $guid, 'TEMPCODE' => $tempcode, 'CLASS' => $class]);
}

/**
 * Get the Tempcode for a paragraph. This function should only be used with escaped text strings that need to be put into a paragraph, not with sections of HTML. Remember, paragraphs are literally that, and should only be used with templates that don't assume that they are going to put the given parameters into paragraphs themselves.
 *
 * @param  mixed $text The text to put into the paragraph, provided in HTML format (string or Tempcode)
 * @param  string $guid GUID for call
 * @param  ?string $class CSS classname (null: none)
 * @return Tempcode The generated paragraph
 */
function paragraph($text, string $guid = '', ?string $class = null) : object
{
    return do_template('PARAGRAPH', ['_GUID' => $guid, 'TEXT' => $text, 'CLASS' => $class]);
}

/**
 * Get the Tempcode for an info page.
 *
 * @param  Tempcode $title The title of the info page
 * @param  mixed $text The text to put on the info page, provided in plain-text format or as HTML via do_lang_tempcode/protect_from_escaping (string or Tempcode)
 * @param  boolean $support_match_key_messages Whether match key messages / redirects should be supported
 * @param  ?Tempcode $back_url URL to have back button to (null: none)
 * @param  ?Tempcode $fields Fields to carry with on back button (null: none)
 * @return Tempcode The info page
 */
function inform_screen(object $title, $text, bool $support_match_key_messages = false, ?object $back_url = null, ?object $fields = null) : object
{
    require_code('failure');

    $tmp = _look_for_match_key_message(is_object($text) ? $text->evaluate() : $text, false, !$support_match_key_messages);
    if ($tmp !== null) {
        $text = $tmp;
    }

    return do_template('INFORM_SCREEN', ['_GUID' => '6e0aec9eb8a1daca60f322f213ddd2ee', 'TITLE' => $title, 'TEXT' => $text, 'BACK_URL' => $back_url, 'FIELDS' => $fields]);
}

/**
 * Get the Tempcode for a warn page.
 *
 * @param  Tempcode $title The title of the warn page
 * @param  mixed $text The text to put on the warn page, provided in plain-text format or as HTML via do_lang_tempcode/protect_from_escaping (string or Tempcode)
 * @param  boolean $provide_back Whether to provide a back button
 * @param  boolean $support_match_key_messages Whether match key messages / redirects should be supported
 * @return Tempcode The warn page
 */
function warn_screen(object $title, $text, bool $provide_back = true, bool $support_match_key_messages = false) : object
{
    require_code('failure');
    return _warn_screen($title, $text, $provide_back, $support_match_key_messages);
}

/**
 * Get the Tempcode for a hidden form element.
 *
 * @param  ID_TEXT $name The name which this input field is for
 * @param  mixed $value The value for this input field, provided in plain-text format (string or Tempcode)
 * @return Tempcode The input field
 */
function form_input_hidden(string $name, $value) : object
{
    if (is_object($value)) {
        $value = $value->evaluate();
    }
    return do_template('FORM_SCREEN_INPUT_HIDDEN' . ((strpos($value, "\n") !== false) ? '_2' : ''), ['_GUID' => '1b39e13d1a09573c67522e2f3b7ebf14', 'NAME' => $name, 'VALUE' => $value]);
}

/**
 * Get the Tempcode for a group of list entry. May be attached directly to form_input_list_entry (i.e. this is a group node in a shared tree), and also fed into form_input_list.
 *
 * @param  mixed $title The title for the group
 * @param  Tempcode $entries List entries for group
 * @return Tempcode The group
 */
function form_input_list_group($title, object $entries) : object
{
    if (browser_matches('ios')) { // Workaround to iOS bug
        $entries2 = new Tempcode();
        $entries2->attach(form_input_list_entry('', false, $title, false, true));
        $entries2->attach($entries);
        return $entries2;
    }

    return do_template('FORM_SCREEN_INPUT_LIST_GROUP', ['_GUID' => 'd4df8dba5fd055ec84af7cb6cd95332c', 'TITLE' => $title, 'ENTRIES' => $entries]);
}

/**
 * Get the Tempcode for a list entry. (You would gather together the outputs of several of these functions, then put them in as the $content in a form_input_list function call).
 *
 * @param  string $value The value for this entry
 * @param  boolean $selected Whether this entry is selected by default or not (Note: if nothing else is selected and this is the first, it will be selected by default anyway)
 * @param  mixed $text The text associated with this choice, provided in plain-text format or as HTML via do_lang_tempcode/protect_from_escaping (string or Tempcode) (blank: just use name for text)
 * @param  boolean $red Whether this entry will be put as red (marking it as important somehow)
 * @param  boolean $disabled Whether this list entry is disabled (like a header in a list)
 * @param  string $title The tooltip
 * @return Tempcode The input field
 */
function form_input_list_entry(string $value, bool $selected = false, $text = '', bool $red = false, bool $disabled = false, string $title = '') : object
{
    if ((!is_object($text)) && ($text == '')) {
        $text = $value;
    }

    /* Causes a small performance hit and very unlikely to be needed
    if (function_exists('filter_form_field_default')) { // Don't include just for this (may not be used on a full input form), preserve memory
        $selected = (filter_form_field_default($value, $selected ? '1' : '') == '1');
    }
    */

    return do_template('FORM_SCREEN_INPUT_LIST_ENTRY', [
        '_GUID' => 'dd76a2685d0fba5f819ef160b0816d03',
        'SELECTED' => $selected,
        'DISABLED' => $disabled,
        'CLASS' => $red ? 'criticalfield' : '',
        'NAME' => is_integer($value) ? strval($value) : $value,
        'TEXT' => $text,
        'TITLE' => ($title == '') ? null : $title,
    ]);
}

/**
 * Display some raw text so that it is repeated as raw visually in HTML.
 *
 * @param  mixed $in Input, provided in plain-text format or as HTML via do_lang_tempcode/protect_from_escaping (string or Tempcode)
 * @param  boolean $using_textarea Whether to show using a textarea (more reliable to use clipboard to get from)
 * @param  boolean $using_codetag Whether to use a code tag (for monospaced font); only use if !$using_textarea
 * @return Tempcode Output
 */
function with_whitespace($in, bool $using_textarea = false, bool $using_codetag = false) : object
{
    if (is_object($in)) {
        if ($in->is_empty()) {
            return $in;
        }
    } else {
        if ($in == '') {
            return new Tempcode();
        }
    }
    return do_template('WITH_WHITESPACE', ['_GUID' => 'be3b74901d5522d4e67ff6313ad61643', 'CONTENT' => $in, 'USING_TEXTAREA' => $using_textarea, 'USING_CODETAG' => $using_codetag]);
}

/**
 * Redirect the user - transparently, storing a message that will be shown on their destination page.
 *
 * @param  ?Tempcode $title Title to display on redirect page (null: standard redirection title)
 * @param  mixed $url Destination URL (may be Tempcode)
 * @param  ?mixed $text Message to show (may be Tempcode) (null: standard redirection message)
 * @param  boolean $intermediary_hop For intermediary hops, don't mark so as to read status messages - save them up for the next hop (which will not be intermediary)
 * @param  ID_TEXT $msg_type Code of message type to show
 * @set warn inform fatal
 * @return Tempcode Redirection message (likely to not actually be seen due to instant redirection)
 */
function redirect_screen(?object $title, $url, $text = null, bool $intermediary_hop = false, string $msg_type = 'inform') : object
{
    require_code('templates_redirect_screen');
    return _redirect_screen($title, $url, $text, $intermediary_hop, $msg_type);
}

/**
 * Advanced truncation/tooltip generator.
 * Note we also have the generate_tooltip_by_truncation function, which is good for simple plain-text tooltips.
 *
 * @param  mixed $label Label to truncate (string or Tempcode)
 * @param  string $type The type of truncation to do
 * @set left right spread
 * @param  integer $len The length to truncate at
 * @param  boolean $generate_tooltip Whether to generate a tooltip
 * @param  ?boolean $is_html Whether $label is HTML (null: HTML if $label is Tempcode)
 * @param  boolean $literal_pos Whether to use $len as an HTML actual-text-character length, rather than a simple byte length
 * @param  float $grammar_completeness_tolerance Fractional-deviation-tolerance for grammar-preservation
 * @param  ?mixed $tooltip_if_truncated Tooltip to add on, but only if we end up creating our own tooltip, string or mixed (null: none)
 * @return string The result
 */
function generate_truncation($label, string $type, int $len = 60, bool $generate_tooltip = false, ?bool $is_html = null, bool $literal_pos = false, float $grammar_completeness_tolerance = 0.0, $tooltip_if_truncated = null) : string
{
    $value = '';

    if (is_object($label)) {
        $label = $label->evaluate();
        if ($is_html === null) {
            $is_html = true;
        }
    }

    if ($GLOBALS['XSS_DETECT']) {
        $is_escaped = ocp_is_escaped($label);
    }

    // Optimisation
    if (strlen($label) < $len) {
        if ($is_html) {
            if ($GLOBALS['XSS_DETECT']) {
                if ($is_escaped) {
                    ocp_mark_as_escaped($label);
                }
            }
            return $label;
        } else {
            return escape_html($label);
        }
    }

    if ($is_html) {
        $not_html = strip_html($label); // In case it contains HTML. This is imperfect, but having to cut something up is imperfect from the offset.
        $html = $label;
        if (($html == $not_html) && (strpos($html, '&') === false) && (strpos($html, '<') === false)) {
            $is_html = false; // Conserve memory
        }
    } else {
        $not_html = $label;
        $html = escape_html($label);
    }

    if ((isset($not_html[$len])/*optimisation*/) && ((cms_mb_strlen($not_html) > $len)) || (stripos($html, '<img') !== false)) {
        if ($is_html || $grammar_completeness_tolerance != 0.0) {
            require_code('xhtml');
        }

        $truncated = $not_html;
        switch ($type) {
            case 'left':
                $temp = (($is_html || $grammar_completeness_tolerance != 0.0) ? xhtml_substr($html, 0, max($len - 3, 1), $literal_pos, false, $grammar_completeness_tolerance) : escape_html(cms_mb_substr($not_html, 0, max($len - 3, 1))));
                if ($temp != $html && in_array(substr($temp, -1), ['.', '?', '!'])) {
                    $temp .= '<br class="ellipsis-break" />'; // so the "..." does not go right after the sentence terminator
                }
                $truncated = ($temp == $html) ? $temp : str_replace(['</p>&hellip;', '</div>&hellip;'], ['&hellip;</p>', '&hellip;</div>'], (cms_trim($temp, true) . '&hellip;'));
                break;
            case 'expand':
                $temp = (($is_html || $grammar_completeness_tolerance != 0.0) ? xhtml_substr($html, 0, max($len - 3, 1), $literal_pos, false, $grammar_completeness_tolerance) : escape_html(cms_mb_substr($not_html, 0, max($len - 3, 1))));
                if ($temp != $html && in_array(substr($temp, -1), ['.', '?', '!'])) {
                    $temp .= '<br class="ellipsis-break" />'; // so the "..." does not go right after the sentence terminator
                }
                $_truncated = do_template('COMCODE_HIDE', ['_GUID' => '3ead7fdb5b510930f54310e3c32147c2', 'TEXT' => protect_from_escaping($temp), 'CONTENT' => protect_from_escaping($html)]);
                $truncated = $_truncated->evaluate();
                break;
            case 'right':
                $truncated = str_replace(['</p>&hellip;', '</div>&hellip;'], ['&hellip;</p>', '&hellip;</div>'], ('&hellip;' . ltrim(($is_html || $grammar_completeness_tolerance != 0.0) ? xhtml_substr($html, -max($len - 3, 1), null, $literal_pos, false, $grammar_completeness_tolerance) : escape_html(cms_mb_substr($not_html, -max($len - 3, 1))))));
                break;
            case 'spread':
                $pos = intval(floor(floatval($len) / 2.0)) - 1;
                $truncated = str_replace(['</p>&hellip;', '</div>&hellip;'], ['&hellip;</p>', '&hellip;</div>'], cms_trim((($is_html || $grammar_completeness_tolerance != 0.0) ? xhtml_substr($html, 0, $pos, $literal_pos, false, $grammar_completeness_tolerance) : escape_html(cms_mb_substr($not_html, 0, $pos))) . '&hellip;' . ltrim(($is_html || $grammar_completeness_tolerance != 0.0) ? xhtml_substr($html, -$pos - 1) : escape_html(cms_mb_substr($not_html, -$pos - 1))), true));
                break;
        }

        if (($generate_tooltip) && (preg_replace('#\s+#', ' ', html_entity_decode(strip_tags($truncated), ENT_QUOTES, get_charset()))) != preg_replace('#\s+#', ' ', html_entity_decode(strip_tags($html), ENT_QUOTES, get_charset()))) {
            if ($tooltip_if_truncated !== null) {
                $tif = (is_object($tooltip_if_truncated) ? $tooltip_if_truncated->evaluate() : $tooltip_if_truncated);
                if (strpos($tif, $html) !== false) {
                    $html = $tif;
                } else {
                    $html .= ' &ndash; ' . $tif;
                }
            }
            $tpl = ((strpos($truncated, '<div') !== false || strpos($truncated, '<p') !== false || strpos($truncated, '<table') !== false) ? 'BLOCK_TOOLTIP' : 'INLINE_TOOLTIP');
            $value_tempcode = do_template($tpl, ['_GUID' => '36ae945ed864633cfa0d67e5c3f2d1c8', 'LABEL' => $truncated, 'TOOLTIP' => $html]);
            $value = $value_tempcode->evaluate();
            if ($GLOBALS['XSS_DETECT']) {
                ocp_mark_as_escaped($value);
            }
        } else {
            $value = $truncated;
        }
    } else {
        $value = $html;
    }

    if ($GLOBALS['XSS_DETECT']) {
        if ($is_escaped || !$is_html/*Will have been explicitly escaped by this function*/) {
            ocp_mark_as_escaped($value);
        }
    }

    return $value;
}
