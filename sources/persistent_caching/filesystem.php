<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Cache driver class.
 */
class Persistent_caching_filesystem
{
    /**
     * Constructor.
     */
    public function __construct()
    {
        require_code('files');

        global $PC_FC_CACHE;
        $PC_FC_CACHE = [];
    }

    /**
     * Instruction to load up the objects list.
     *
     * @return array The list of objects
     */
    public function load_objects_list() : array
    {
        /* No concurrency
        if ($this->objects_list === null) {
            $this->objects_list = $this->get('PERSISTENT_CACHE_OBJECTS');
            if ($this->objects_list === null) {
                $this->objects_list = [];
            }
        }
        return $this->objects_list;*/

        $objects_list = $this->get('PERSISTENT_CACHE_OBJECTS');
        if (!is_array($objects_list)) {
            $objects_list = [];
        }
        return $objects_list;
    }

    /**
     * Get data from the persistent cache.
     *
     * @param  string $key Key
     * @param  ?TIME $min_cache_date Minimum timestamp that entries from the cache may hold (null: don't care)
     * @return ?mixed The data (null: not found / null entry)
     */
    public function get(string $key, ?int $min_cache_date = null)
    {
        if ($key != 'PERSISTENT_CACHE_OBJECTS'/*this key is too volatile with concurrency*/) {
            global $PC_FC_CACHE;
            if (isset($PC_FC_CACHE[$key]) && (($min_cache_date === null) || ($PC_FC_CACHE[$key][0] >= $min_cache_date))) {
                return $PC_FC_CACHE[$key][1];
            }
        }

        clearstatcache();

        $path = get_custom_file_base() . '/caches/persistent/' . cms_base64_encode($key, true, true) . '.gcd';
        if (!is_file($path)) {
            return null;
        }
        if ($min_cache_date !== null) { // Code runs here as we know file exists at this point
            if (filemtime($path) < $min_cache_date) {
                return null;
            }
        }
        $contents = @cms_file_get_contents_safe($path);
        if ($contents === false) {
            return null;
        }

        $ret = @unserialize($contents);
        if ($ret === false) {
            $ret = null;
        }

        $PC_FC_CACHE[$key] = [filemtime($path), $ret];

        return $ret;
    }

    /**
     * Put data into the persistent cache.
     *
     * @param  string $key Key
     * @param  mixed $data The data
     * @param  integer $flags Various flags (parameter not used)
     * @param  ?integer $expire_secs The expiration time in seconds (null: no expiry)
     */
    public function set(string $key, $data, int $flags = 0, ?int $expire_secs = null)
    {
        static $scheduled_dumped = false;
        static $scheduled_dump_by_key = [];

        global $PC_FC_CACHE;
        $PC_FC_CACHE[$key] = [time(), $data];

        if ($key !== 'PERSISTENT_CACHE_OBJECTS') {
            // Update list of persistent-objects
            $objects_list = $this->load_objects_list();
            if (!array_key_exists($key, $objects_list)) {
                $objects_list[$key] = true;
                $this->set('PERSISTENT_CACHE_OBJECTS', $objects_list);
            }
        }

        // Optimisation: Defer saving to disk to decrease I/O
        if ($scheduled_dumped === false) {
            // First, try an all-around schedule to save everything in the cache when we shut down
            $scheduled_dumped = cms_register_shutdown_function_if_available(function () {
                global $PC_FC_CACHE;

                require_code('files');

                foreach ($PC_FC_CACHE as $key => $data) {
                    $path = get_custom_file_base() . '/caches/persistent/' . cms_base64_encode($key, true, true) . '.gcd';
                    $to_write = serialize($data[1]);
                    cms_file_put_contents_safe($path, $to_write, FILE_WRITE_FIX_PERMISSIONS);
                }
            });

            // If that did not work, schedule saving the individual key instead (executing immediately if we cannot)
            if (($scheduled_dumped === false) && (!isset($scheduled_dump_by_key[$key]))) {
                $scheduled_dump_by_key[$key] = cms_register_shutdown_function_safe(function () use ($key) {
                    global $PC_FC_CACHE;

                    // It's possible we later deleted this key which wouldn't delete the schedule
                    if (!isset($PC_FC_CACHE[$key])) {
                        return;
                    }

                    require_code('files');

                    $path = get_custom_file_base() . '/caches/persistent/' . cms_base64_encode($key, true, true) . '.gcd';
                    $to_write = serialize($PC_FC_CACHE[$key][1]);
                    cms_file_put_contents_safe($path, $to_write, FILE_WRITE_FIX_PERMISSIONS);
                });

                // If we executed immediately, we must make sure it can execute again if the value changes
                if ($scheduled_dump_by_key[$key] === false) {
                    unset($scheduled_dump_by_key[$key]);
                }
            }
        }
    }

    /**
     * Delete data from the persistent cache.
     *
     * @param  string $key Key
     */
    public function delete(string $key)
    {
        if ($key !== 'PERSISTENT_CACHE_OBJECTS') {
            // Update list of persistent-objects
            $objects_list = $this->load_objects_list();
            unset($objects_list[$key]);
            $this->set('PERSISTENT_CACHE_OBJECTS', $objects_list);
        }

        // Ideally we'd lock while we delete, but it's not stable (and the workaround would be too slow for our efficiency context). So some people reading may get errors while we're clearing the cache. Fortunately this is a rare op to perform.
        @unlink(get_custom_file_base() . '/caches/persistent/' . cms_base64_encode($key, true, true) . '.gcd');

        global $PC_FC_CACHE;
        unset($PC_FC_CACHE[$key]);
    }

    /**
     * Remove all data from the persistent cache.
     */
    public function flush()
    {
        // Update list of persistent-objects
        $objects_list = [];
        $this->set('PERSISTENT_CACHE_OBJECTS', $objects_list);

        $d = opendir(get_custom_file_base() . '/caches/persistent');
        while (($e = readdir($d)) !== false) {
            if (substr($e, -4) == '.gcd') {
                // Ideally we'd lock while we delete, but it's not stable (and the workaround would be too slow for our efficiency context). So some people reading may get errors while we're clearing the cache. Fortunately this is a rare op to perform.
                @unlink(get_custom_file_base() . '/caches/persistent/' . $e);
            }
        }
        closedir($d);

        global $PC_FC_CACHE;
        $PC_FC_CACHE = [];
    }
}
