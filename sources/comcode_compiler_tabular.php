<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_rich_media
 */

/**
 * Parse a Comcode table.
 *
 * @param  string $table_to_parse Table code
 * @param  MEMBER $source_member The member the evaluation is running as. This is a security issue, and you should only run as an administrator if you have considered where the Comcode came from carefully
 * @param  boolean $as_admin Whether to explicitly execute this with admin rights. There are a few rare situations where this should be done, for data you know didn't come from a member, but is being evaluated by one.
 * @param  ?string $pass_id A special identifier that can identify this resource in a sea of our resources of this class; usually this can be ignored, but may be used to provide a binding between JavaScript in evaluated Comcode, and the surrounding environment (null: no explicit binding)
 * @param  ?object $db The database connector to use (null: none; only do this for very simple Comcode)
 * @param  integer $_flags A bitmask of COMCODE_* flags
 * @param  array $highlight_bits A list of words to highlight
 * @param  ?MEMBER $on_behalf_of_member The member we are running on behalf of, with respect to how attachments are handled; we may use this members attachments that are already within this post, and our new attachments will be handed to this member (null: member evaluating)
 * @return Tempcode The rendered table
 */
function _parse_comcode_table(string $table_to_parse, int $source_member, bool $as_admin, ?string $pass_id, ?object $db, int $_flags = 0, array $highlight_bits = [], ?int $on_behalf_of_member = null) : object
{
    $template = 'COMCODE_TABULAR_TABLE';

    $lines = explode("\n", $table_to_parse);

    $tabular_summary = '';

    $tabular_is_wide = false;
    $tabular_class = null;
    $tabular_id = null;
    $tabular_column_sizes = [];

    $tabular_rows = [];

    $current_cell = null;
    $current_cell_header = null;

    $cells = [];

    foreach ($lines as $line) {
        $line = rtrim($line);
        $current_char = ($line == '') ? '' : $line[0];

        if ($line == '|-') {
            // Starting new row (end currently row and reset variables)
            _finish_comcode_table_row($tabular_rows, $cells, $current_cell, $current_cell_header, $tabular_column_sizes, $source_member, $as_admin, $pass_id, $db, $_flags, $highlight_bits, $on_behalf_of_member);
        } elseif (($current_char == '!') || ($current_char == '|')) {
            // Starting new cell / set of cells

            $current_cell_header = ($current_char == '!');
            $_line = ltrim(substr($line, 1));

            $line_cells = preg_split('#(!!|\|\|)#', $_line, -1, PREG_SPLIT_DELIM_CAPTURE);
            foreach ($line_cells as $i => $cell) {
                if ($cell == '!!') {
                    $current_cell_header = true;
                } elseif ($cell == '||') {
                    $current_cell_header = false;
                } else {
                    if ($current_cell !== null) {
                        $cells[] = [$current_cell, $current_cell_header];
                    }
                    $current_cell = $cell;
                }
            }
        } elseif ($current_cell === null) {
            // Not in a cell, so this will go as summary data

            if ($tabular_summary == '') {
                // If this is first line of summary, parse out any metadata in it
                $matches = [];
                $_sizes_regexp = '\d+(\.\d+)?(%|em|px)';
                $sizes_regexp = $_sizes_regexp . '(:' . $_sizes_regexp . ')*';
                $_regexp = '(wide|floats|inline_blocks|flex|fake_table|class=[\w\|]+|id=\w+|' . $sizes_regexp . ')';
                $regexp = '#^\s*(' . $_regexp . '($|\s))+#';
                if (preg_match($regexp, $line, $matches) != 0) {
                    $line = substr($line, strlen($matches[0]));

                    $num_matches = preg_match_all('#(^|\s)' . $_regexp . '#', $matches[0], $matches);
                    for ($i = 0; $i < $num_matches; $i++) {
                        switch ($matches[2][$i]) {
                            case 'wide':
                                $tabular_is_wide = true;
                                break;

                            case 'fake_table':
                                $template = 'COMCODE_TABULAR_FAKE_TABLE';
                                break;
                            case 'floats':
                                $template = 'COMCODE_TABULAR_FLOATS';
                                break;
                            case 'inline_blocks':
                                $template = 'COMCODE_TABULAR_INLINE_BLOCKS';
                                break;
                            case 'flex':
                                $template = 'COMCODE_TABULAR_FLEX';
                                break;

                            default:
                                $matches2 = [];
                                if (preg_match('#^class=(\w+)$#', $matches[2][$i], $matches2) != 0) {
                                    $tabular_class = str_replace('|', ' ', $matches2[1]);
                                } elseif (preg_match('#^id=(\w+)$#', $matches[2][$i], $matches2) != 0) {
                                    $tabular_id = $matches2[1];
                                } elseif (preg_match('#^' . $sizes_regexp . '$#', $matches[2][$i], $matches2) != 0) {
                                    $tabular_column_sizes = [];
                                    foreach (explode(':', $matches2[0]) as $sizing_line) {
                                        $tabular_column_sizes[] = $sizing_line;
                                    }
                                }
                        }
                    }
                }
            } else {
                $tabular_summary .= "\n";
            }
            $tabular_summary .= ltrim($line);
        } elseif ($current_cell !== null) {
            // Part of a multi-line cell
            $current_cell .= "\n";
            $current_cell .= ltrim($line);
        }
    }

    _finish_comcode_table_row($tabular_rows, $cells, $current_cell, $current_cell_header, $tabular_column_sizes, $source_member, $as_admin, $pass_id, $db, $_flags, $highlight_bits, $on_behalf_of_member);

    if (empty($tabular_rows)) {
        return new Tempcode();
    }

    $num_rows = count($tabular_rows);
    $done_first_non_header_row = false;
    foreach ($tabular_rows as $i => &$tabular_row) {
        $tabular_row['FIRST_NON_HEADER_ROW'] = !$tabular_row['IS_HEADER_ROW'] && !$done_first_non_header_row;
        $tabular_row['LAST_NON_HEADER_ROW'] = ($done_first_non_header_row) && ($i == $num_rows - 1);

        if (!$tabular_row['IS_HEADER_ROW']) {
            $done_first_non_header_row = true;
        }
    }

    $tabular_is_columned_table = true;
    foreach ($tabular_rows[0]['CELLS'] as $tabular_row_cell) {
        if (!$tabular_row_cell['IS_HEADER']) {
            $tabular_is_columned_table = false;
            break;
        }
    }

    return do_template($template, [
        'SUMMARY' => $tabular_summary,
        'CLASS' => $tabular_class,
        'IS_COLUMNED_TABLE' => $tabular_is_columned_table,
        'IS_WIDE' => $tabular_is_wide,
        'ID' => $tabular_id,
        'COLUMN_SIZES' => $tabular_column_sizes,
        'ROWS' => $tabular_rows,
    ]);
}

/**
 * Finish off a table cell (if currently open), a table row (if currently open and non-empty) and start a new row.
 *
 * @param  array $tabular_rows Tabular rows (passed by reference)
 * @param  array $cells Cells of current row (passed by reference)
 * @param  ?string $current_cell Current cell contents (passed by reference) (null: no current cell)
 * @param  ?boolean $current_cell_header Whether the current cell is a header cell (passed by reference) (null: no current cell)
 * @param  array $tabular_column_sizes Sizes for the columns of each row (does not need to be all of them)
 * @param  MEMBER $source_member The member the evaluation is running as. This is a security issue, and you should only run as an administrator if you have considered where the Comcode came from carefully
 * @param  boolean $as_admin Whether to explicitly execute this with admin rights. There are a few rare situations where this should be done, for data you know didn't come from a member, but is being evaluated by one.
 * @param  ?string $pass_id A special identifier that can identify this resource in a sea of our resources of this class; usually this can be ignored, but may be used to provide a binding between JavaScript in evaluated Comcode, and the surrounding environment (null: no explicit binding)
 * @param  ?object $db The database connector to use (null: none; only do this for very simple Comcode)
 * @param  integer $_flags A bitmask of COMCODE_* flags
 * @param  array $highlight_bits A list of words to highlight
 * @param  ?MEMBER $on_behalf_of_member The member we are running on behalf of, with respect to how attachments are handled; we may use this members attachments that are already within this post, and our new attachments will be handed to this member (null: member evaluating)
 *
 * @ignore
 */
function _finish_comcode_table_row(array &$tabular_rows, array &$cells, ?string &$current_cell, ?bool &$current_cell_header, array $tabular_column_sizes, int $source_member, bool $as_admin, ?string $pass_id, ?object $db, int $_flags = 0, array $highlight_bits = [], ?int $on_behalf_of_member = null)
{
    if ($current_cell !== null) {
        $cells[] = [$current_cell, $current_cell_header];
    }

    if (!empty($cells)) {
        $is_header_row = true;
        $tabular_row_cells = [];
        foreach ($cells as $i => $cell) {
            if (!$cell[1]) {
                $is_header_row = false;
            }

            $value = comcode_to_tempcode($cell[0], $source_member, $as_admin, $pass_id, $db, $_flags, $highlight_bits, $on_behalf_of_member);

            $tabular_row_cells[] = [
                'IS_HEADER' => $cell[1],
                'FIRST_CELL_ON_ROW' => $i == 0,
                'LAST_CELL_ON_ROW' => $i == count($cells) - 1,
                'WIDTH' => isset($tabular_column_sizes[$i]) ? $tabular_column_sizes[$i] : null,
                'VALUE' => $value,
            ];
        }

        $tabular_rows[] = [
            'IS_HEADER_ROW' => $is_header_row,
            'CELLS' => $tabular_row_cells,

            // Filled later
            'FIRST_NON_HEADER_ROW' => null,
            'LAST_NON_HEADER_ROW' => null,
        ];
    }

    $cells = [];
    $current_cell = null;
    $current_cell_header = null;
}
