<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: xml_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/*
XML or JSON?

We generally prefer JSON when connecting to 3rd party backend services, where no human touches the data transferred.
However in some cases particular standards do require XML, we do use XML for our own AJAX, and we generally tend to prefer XML for user-edited file formats.

To use JSON in the software, use standard PHP functions.
*/

/**
 * Get XML definition of common entities we may use.
 *
 * @return string XML
 */
function get_xml_entities() : string
{
    return '
        <!DOCTYPE xc:content [
        <!ENTITY euro "&#8364;">
        <!ENTITY ldquo "&#8220;">
        <!ENTITY rdquo "&#8221;">
        <!ENTITY lsquo "&#8216;">
        <!ENTITY rsquo "&#8217;">
        <!ENTITY dagger "&#8224;">
        <!ENTITY Dagger "&#8225;">
        <!ENTITY permil "&#8240;">
        <!ENTITY Scaron "&#352;">
        <!ENTITY scaron "&#353;">
        <!ENTITY Yuml "&#376;">
        <!ENTITY ndash "&#8211;">
        <!ENTITY mdash "&#8212;">
        <!ENTITY hellip "&#8230;">
        <!ENTITY copy "&#169;">
        <!ENTITY nbsp " ">
        <!ENTITY fnof "&#402;">
        <!ENTITY reg "&#174;">
        <!ENTITY trade "&#8482;">
        <!ENTITY raquo "&#187;">
        <!ENTITY frac14 "&#188;">
        <!ENTITY frac12 "&#189;">
        <!ENTITY frac34 "&#190;">
        <!ENTITY rarr "&#8594;">
        ]>
    ';
}

/**
 * XML escape the input string.
 *
 * @param  string $string Input string
 * @param  ?string $charset Charset (null: current)
 * @return string Escaped version of input string
 */
function xmlentities(string $string, ?string $charset = null) : string
{
    if ($charset === null) {
        $charset = get_charset();
    }
    if (ENT_SUBSTITUTE == 0 && $charset == 'utf-8') {
        $string = fix_bad_unicode($string);
    }
    $ret = htmlspecialchars($string, ENT_COMPAT | ENT_SUBSTITUTE, $charset); // htmlspecialchars is appropriate, htmlentities uses entities XML does not have
    if (function_exists('ocp_mark_as_escaped')) {
        ocp_mark_as_escaped($ret);
    }
    return $ret;
}

/**
 * Escape an XML CDATA section.
 *
 * @param  string $string Input string
 * @return string Escaped version of input string
 */
function escape_cdata(string $string) : string
{
    $ret = str_replace(']]>', ']]]]><![CDATA[>', $string);
    if (function_exists('ocp_mark_as_escaped')) {
        ocp_mark_as_escaped($ret);
    }
    return $ret;
}

/**
 * Convert HTML entities to plain characters for XML conformance.
 *
 * @param  string $data HTML to convert entities from
 * @param  string $charset The character set we are using for $data (both in and out)
 * @return string Valid XHTML
 */
function convert_bad_entities(string $data, string $charset = 'ISO-8859-1') : string
{
    if ((cms_strtoupper_ascii($charset) != 'ISO-8859-1') && (cms_strtolower_ascii($charset) != 'utf-8')) {
        $charset = 'ISO-8859-1';
    }
    $table = array_flip(get_html_translation_table(HTML_ENTITIES, ENT_COMPAT | ENT_HTML401, $charset));

    unset($table['&amp;']);
    unset($table['&gt;']);
    unset($table['&lt;']);
    unset($table['&quot;']);

    return strtr($data, $table);
}

/**
 * Simple XML reader.
 *
 * @package core
 */
class CMS_simple_xml_reader
{
    // Used during parsing
    public $tag_stack;
    public $attribute_stack;
    public $children_stack;
    public $text_stack;

    public $gleamed;
    public $error;

    /**
     * Constructs the XML reader: parses the given data. Check $gleamed and $error after constructing.
     *
     * @param  string $xml_data The XML data
     */
    public function __construct(string $xml_data)
    {
        $this->gleamed = [];
        $this->error = null;

        $this->tag_stack = [];
        $this->attribute_stack = [];
        $this->children_stack = [];
        $this->text_stack = [];

        if (!function_exists('xml_parser_create')) {
            $this->error = do_lang_tempcode('XML_NEEDED');
            return;
        }

        // Create and setup our parser
        if (function_exists('libxml_disable_entity_loader')) {
            @libxml_disable_entity_loader(); // LEGACY
        }
        $xml_parser = @xml_parser_create_ns();
        if ($xml_parser === false) {
            $this->error = do_lang_tempcode('XML_PARSING_NOT_SUPPORTED');
            return; // PHP 5 default build on windows comes with this function disabled, so we need to be able to escape on error
        }
        xml_set_object($xml_parser, $this);
        @xml_parser_set_option($xml_parser, XML_OPTION_TARGET_ENCODING, get_charset());
        xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, 0); // Preserve element name case
        xml_set_element_handler($xml_parser, [$this, 'startElement'], [$this, 'endElement']);
        xml_set_character_data_handler($xml_parser, [$this, 'startText']);

        if (strpos($xml_data, '<' . '?xml') === false) {
            $xml_data = '<' . '?xml version="1.0" encoding="' . xmlentities(get_charset()) . '"?' . '>' . $xml_data;
        }
        $xml_data = unixify_line_format($xml_data); // Fixes Windows characters

        if (xml_parse($xml_parser, $xml_data, true) == 0) {
            $err_code = xml_get_error_code($xml_parser);
            $err_msg = xml_error_string($err_code) . ' [#' . strval($err_code) . ' @ ' . strval(xml_get_current_line_number($xml_parser)) . ']';
            warn_exit($err_msg, false, true);
        }

        @xml_parser_free($xml_parser);
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  mixed $parser The parser
     * @param  string $name The name of the element found
     * @param  array $attributes Array of attributes of the element
     */
    public function startElement($parser, string $name, array $attributes)
    {
        array_push($this->tag_stack, $name);
        array_push($this->attribute_stack, $attributes);
        array_push($this->children_stack, []);
        array_push($this->text_stack, '');
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  mixed $parser The parser
     */
    public function endElement($parser)
    {
        $this_tag = array_pop($this->tag_stack);
        $this_attributes = array_pop($this->attribute_stack);
        $this_children = array_pop($this->children_stack);
        $this_text = array_pop($this->text_stack);

        if (empty($this->tag_stack)) {
            $this->gleamed = [$this_tag, $this_attributes, $this_text, $this_children];
        } else {
            $next_top_tags_children = array_pop($this->children_stack);
            $next_top_tags_children[] = [$this_tag, $this_attributes, $this_text, $this_children];
            array_push($this->children_stack, $next_top_tags_children);
        }
    }

    /**
     * Standard PHP XML parser function.
     *
     * @param  mixed $parser The parser
     * @param  string $data The text
     */
    public function startText($parser, string $data)
    {
        $next_top_tags_text = array_pop($this->text_stack);
        $next_top_tags_text .= $data;
        array_push($this->text_stack, $next_top_tags_text);

        $next_top_tags_children = array_pop($this->children_stack);
        $next_top_tags_children[] = $data;
        array_push($this->children_stack, $next_top_tags_children);
    }

    /**
     * Pull a portion of an XML tree structure back into textual XML.
     *
     * @param  array $xml_children Level of XML tree
     * @param  array $xml_namespaces XML namespaces [ 'ns-prefix:' => 'http://example.com/namespace-uri' ]
     * @param  array $skip_tags XML tags to skip
     * @param  array $skip_xml_namespaces XML namespaces to skip any attributes or elements of
     * @return string The combined XML
     */
    public function pull_together(array $xml_children, array $xml_namespaces = [], array $skip_tags = [], array $skip_xml_namespaces = []) : string
    {
        $data = '';
        foreach ($xml_children as $_) {
            if (is_array($_)) {
                list($tag, $attributes, , $children) = $_;

                if (in_array($tag, $skip_tags)) {
                    continue;
                }

                foreach ($skip_xml_namespaces as $skip_xml_namespace) {
                    if (substr($tag, 0, strlen($skip_xml_namespace) + 1) == $skip_xml_namespace . ':') {
                        continue 2;
                    }
                }

                $tag = $this->_fix_namespace($tag, $xml_namespaces);
                $drawn = '';
                foreach ($attributes as $key => $val) {
                    foreach ($skip_xml_namespaces as $skip_xml_namespace) {
                        if (substr($key, 0, strlen($skip_xml_namespace) + 1) == $skip_xml_namespace . ':') {
                            continue 2;
                        }
                    }

                    $key = $this->_fix_namespace($key, $xml_namespaces);
                    $drawn .= ' ' . $key . '="' . xmlentities($val) . '"';
                }
                if (!empty($children)) {
                    $data .= '<' . $tag . $drawn . '>' . $this->pull_together($children, $xml_namespaces, $skip_tags, $skip_xml_namespaces) . '</' . $tag . '>';
                } else {
                    // No child nodes, self-close
                    $data .= '<' . $tag . $drawn . '/>';
                }
            } else {
                $data .= xmlentities($_);
            }
        }
        return $data;
    }

    /**
     * Element names and attributes have complete namespace URIs as a prefix for some reason, this fixes that.
     *
     * @param  string $node_name Node name
     * @param  array $xml_namespaces XML namespaces [ 'ns-prefix:' => 'http://example.com/namespace-uri' ]
     * @return string
     */
    protected function _fix_namespace(string $node_name, array $xml_namespaces) : string
    {
        if (strpos($node_name, ':') === false) {
            return $node_name;
        }

        $tmp = explode(':', $node_name);
        $node_name_wo_uri = array_pop($tmp);
        $node_uri = implode(':', $tmp); // Need to do it this way because the URL protocol also has a colon
        $ns_prefix = array_search($node_uri, $xml_namespaces);

        return ($ns_prefix !== false) ? ($ns_prefix . $node_name_wo_uri) : $node_name;
    }
}
