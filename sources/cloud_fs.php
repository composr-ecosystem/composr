<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: stream_wrapper_register*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__cloud_fs()
{
    if (!defined('CMS_CLOUD__LOCAL')) {
        define('CMS_CLOUD__LOCAL', 1);
        define('CMS_CLOUD__PROPAGATED', 2);
        define('CMS_CLOUD__REMOTE', 3);

        define('FILE_BASE__AUTODETECT', 'cmsCloudAutodetect');
        define('FILE_BASE__SHARED', 'cmsCloudShared');
        define('FILE_BASE__CUSTOM', 'cmsCloudCustom');
    }

    define_cloud_fs_bindings();
}

/**
 * Get the patterns defining what files are syndicated in what ways.
 *
 * Regexps specifying where normal Composr file paths will be routed to.
 * Should be in precedence order (for performance reasons).
 * Override this function to change the configuration. Addons can add to this global themselves if needed.
 */
function define_cloud_fs_bindings()
{
    global $CMS_CLOUD_BINDINGS;
    $CMS_CLOUD_BINDINGS = [
        '#^data_custom/errorlog\.php$#' => CMS_CLOUD__LOCAL,
        '#^data_custom/[^/]*\.log$#' => CMS_CLOUD__LOCAL,
        '#^data_custom/modules/admin_backup(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/modules/user_export(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/sitemaps(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/spelling(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/xml_config(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^temp(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^exports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^imports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^lang_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^[^/]*/pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^text_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/css_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/images_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/javascript_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/templates_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^uploads(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^.*$#' => CMS_CLOUD__LOCAL,
    ];
}

/**
 * Enable the cloud file system.
 */
function enable_cloud_fs()
{
    global $FILE_BASE, $CUSTOM_FILE_BASE, $FILE_BASE_LOCAL, $CUSTOM_FILE_BASE_LOCAL;

    stream_wrapper_register(FILE_BASE__AUTODETECT, 'CloudFsStreamWrapper');
    stream_wrapper_register(FILE_BASE__SHARED, 'CloudFsStreamWrapper');
    stream_wrapper_register(FILE_BASE__CUSTOM, 'CloudFsStreamWrapper');

    $FILE_BASE_LOCAL = get_file_base(false, true);
    $CUSTOM_FILE_BASE_LOCAL = get_file_base(true, true);
    $FILE_BASE = FILE_BASE__SHARED . ':/'; // NB: Extra needed "/" will in effect be added by path concatenation anyway
    $CUSTOM_FILE_BASE = FILE_BASE__CUSTOM . ':/'; // "

    if (cloud_mode() != '') {
        $remote_storage_directory = get_remote_storage_directory(get_file_base(false));
        if (!is_dir($remote_storage_directory)) {
            fatal_exit(do_lang_tempcode('DIRECTORY_NOT_FOUND', escape_html($remote_storage_directory))); // We do not try and auto-create, because it could be a configuration error
        }
        if (shared_site_install()) {
            $remote_storage_directory = get_remote_storage_directory(get_file_base(true)());
            if (!is_dir($remote_storage_directory)) {
                require_code('files2');
                make_missing_directory($remote_storage_directory, false);
            }
        }
    }
}

/**
 * Resolve a path to the correct local path and find the storage type.
 *
 * @param  string $path Path
 * @param  boolean $is_create_op Is this an operation to create a new file/directory?
 * @return array A tuple: The storage type relative path (if storage type is CMS_CLOUD__LOCAL then it will be null), The absolute path, The storage type (a CMS_CLOUD__* constant), The file base (if storage type is CMS_CLOUD__LOCAL then it will be null), The file base constant (a FILE_BASE__* constant) (if storage type is CMS_CLOUD__LOCAL then it will be null)
 */
function _make_cms_path_native(string $path, bool $is_create_op = false) : array
{
    global $CMS_CLOUD_BINDINGS, $FILE_BASE_LOCAL, $CUSTOM_FILE_BASE_LOCAL;

    if (substr($path, 0, strlen(FILE_BASE__AUTODETECT . '://')) == FILE_BASE__AUTODETECT . '://') {
        $path_relative = substr($path, strlen(FILE_BASE__AUTODETECT . '://'));

        if (shared_site_install()) {
            if (running_script('upgrader')) {
                $file_base = $FILE_BASE_LOCAL;
            } elseif ($is_create_op) {
                $file_base = $CUSTOM_FILE_BASE_LOCAL;
            } else {
                if (file_exists($CUSTOM_FILE_BASE_LOCAL . '/' . $path_relative)) {
                    $file_base = $CUSTOM_FILE_BASE_LOCAL;
                } elseif (file_exists($FILE_BASE_LOCAL . '/' . $path_relative)) {
                    $file_base = $FILE_BASE_LOCAL;
                } elseif ((strpos($path, '/') !== false) && (file_exists($CUSTOM_FILE_BASE_LOCAL . '/' . dirname($path_relative)))) {
                    $file_base = $CUSTOM_FILE_BASE_LOCAL;
                } elseif ((strpos($path, '/') !== false) && (file_exists($FILE_BASE_LOCAL . '/' . dirname($path_relative)))) {
                    $file_base = $FILE_BASE_LOCAL;
                } else {
                    $file_base = $CUSTOM_FILE_BASE_LOCAL;
                }
            }
        } else {
            $file_base = $FILE_BASE_LOCAL;
        }

        $file_base_constant = FILE_BASE__AUTODETECT;
    } elseif (substr($path, 0, strlen(FILE_BASE__SHARED . '://')) == FILE_BASE__SHARED . '://') {
        $path_relative = substr($path, strlen(FILE_BASE__SHARED . '://'));

        $file_base = get_file_base(false, true);

        $file_base_constant = FILE_BASE__SHARED;
    } elseif (substr($path, 0, strlen(FILE_BASE__CUSTOM . '://')) == FILE_BASE__CUSTOM . '://') {
        $path_relative = substr($path, strlen(FILE_BASE__CUSTOM . '://'));

        $file_base = get_file_base(true, true);

        $file_base_constant = FILE_BASE__CUSTOM;
    } else {
        return [null, $path, CMS_CLOUD__LOCAL, null, null];
    }

    $root = (($path == '') || ($path == '/'));

    $storage_type = CMS_CLOUD__LOCAL;
    if ((!$root) && (cloud_mode() != '')) {
        foreach ($CMS_CLOUD_BINDINGS as $regexp => $_storage_type) {
            if (preg_match($regexp, $path) != 0) {
                $storage_type = $_storage_type;
                break;
            }
        }
    }

    switch ($storage_type) {
        case CMS_CLOUD__PROPAGATED:
        case CMS_CLOUD__LOCAL:
            if ($root) {
                $path_absolute = $file_base;
            } else {
                $path_absolute = $file_base . '/' . $path_relative;
            }
            break;

        case CMS_CLOUD__REMOTE:
            $remote_storage_directory = get_remote_storage_directory($file_base);
            $path_absolute = $remote_storage_directory . '/' . $path_relative;
            break;
    }

    return [$path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant];
}

/**
 * Find an absolute remote storage path given a particular file base.
 * Considers whether the path is absolute or relative to a file base.
 * A relative path is needed for shared-code installs and/as we must have a remote_storage_directory for each individual site.
 *
 * @param  PATH $file_base File base
 * @return PATH Absolute path
 */
function get_remote_storage_directory(string $file_base) : string
{
    global $SITE_INFO;
    if (empty($SITE_INFO['remote_storage_directory'])) {
        $remote_storage_directory = dirname($file_base) . '/shared_storage';
    } else {
        $_remote_storage_directory = $SITE_INFO['remote_storage_directory'];
        $is_absolute = (substr($_remote_storage_directory, 0, 1) == '/') || ((strpos(PHP_OS, 'WIN') !== false) && (substr($_remote_storage_directory, 1, 2) == ':/'));
        if ($is_absolute) {
            $remote_storage_directory = $_remote_storage_directory;
        } else {
            $remote_storage_directory = $file_base . '/' . $_remote_storage_directory;
        }
    }

    return $remote_storage_directory;
}

/**
 * Detail a directory for propagation across all servers.
 *
 * @param  string $file_base_constant A FILE_BASE__* constant
 * @param  string $op_type Operation type
 * @set create touch move delete
 * @param  PATH $path_relative The base-relative path
 * @param  ?integer $perms The Unix file permissions (null: N/A)
 * @param  string $data The property value
 */
function inject_propagation_dir(string $file_base_constant, string $op_type, string $path_relative, ?int $perms = null, string $data = '')
{
    if (cloud_mode() == '') {
        return;
    }

    // Clean up any contradictions/prior-bloat first
    if ($op_type != 'move') {
        $GLOBALS['SITE_DB']->query_delete('cloud_propagation_dirs', [
            'op_type' => $op_type,
            'dir_file_base_constant' => $file_base_constant,
            'dir_path' => $path_relative,
        ]);
    }

    $GLOBALS['SITE_DB']->query_insert('cloud_propagation_dirs', [
        'op_type' => $op_type,
        'op_timestamp' => time(),
        'dir_file_base_constant' => $file_base_constant,
        'dir_path' => $path_relative,
        'dir_perms' => $perms,
        'op_data' => $data,
        'op_originating_host' => gethostname(),
    ]);
}

/**
 * Ping a file as having been changed, so the cloud can be updated.
 * This would be called if an operation happened outside of PHP (i.e. on native paths).
 *
 * @param  PATH $path The absolute path
 * @param  string $file_base_constant A FILE_BASE_* constant
 */
function cloudfs_ping_file_changed(string $path, string $file_base_constant)
{
    $_path = substr($path, strlen($file_base_constant));
    inject_propagation_file($file_base_constant, 'create', $_path, time(), fileperms($path), base64_encode(file_get_contents($path)));
}

/**
 * Detail a file for propagation across all servers.
 *
 * @param  string $file_base_constant A FILE_BASE__* constant
 * @param  string $op_type Operation type
 * @set create touch move delete
 * @param  PATH $path_relative The base-relative path
 * @param  ?TIME $mtime The modification time (null: N/A)
 * @param  ?integer $perms The Unix file permissions (null: N/A)
 * @param  string $data The base64-encoded file contents / property value
 */
function inject_propagation_file(string $file_base_constant, string $op_type, string $path_relative, ?int $mtime = null, ?int $perms = null, string $data = '')
{
    if (cloud_mode() == '') {
        return;
    }

    // Clean up any contradictions/prior-bloat first
    if ($op_type != 'move') {
        $GLOBALS['SITE_DB']->query_delete('cloud_propagation_files', [
            'op_type' => $op_type,
            'file_file_base_constant' => $file_base_constant,
            'dir_path' => $path_relative,
        ]);
    }

    $GLOBALS['SITE_DB']->query_insert('cloud_propagation_files', [
        'op_type' => $op_type,
        'op_timestamp' => time(),
        'file_file_base_constant' => $file_base_constant,
        'file_path' => $path_relative,
        'file_mtime' => $mtime,
        'file_perms' => $perms,
        'op_data' => $data,
        'op_originating_host' => gethostname(),
    ]);
}

/**
 * A filesystem wrapper that adds some additional restrictions,
 * so that this runs as a common denominator of any file system's limitations.
 * Useful if developing on Mac/Windows with an SSD!
 *
 * @package core
 */
class CloudFsStreamWrapper
{
    public $context = null;

    /**
     * Construct our wrapper.
     */
    public function __construct()
    {
    }

    /**
     * Deconstruct our wrapper.
     */
    public function __destruct()
    {
    }

    /* Directory operations */

    protected $directory_handle = false;

    /**
     * Open a directory for analysis.
     *
     * @param  PATH $path The path to the directory to open
     * @param  integer $options Bitmask options
     * @return boolean Success status
     */
    public function dir_opendir(string $path, int $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        if ($file_base_constant == FILE_BASE__AUTODETECT) {
            global $FILE_BASE_LOCAL, $CUSTOM_FILE_BASE_LOCAL;

            $this->directory_handle = [];
            $found_dir = false;
            foreach ([$CUSTOM_FILE_BASE_LOCAL, $FILE_BASE_LOCAL] as $_file_base) {
                if (is_dir($_file_base . '/' . $path_relative)) {
                    if ($this->context === null) { // Weird PHP bug
                        $dh = @opendir($_file_base . '/' . $path_relative);
                    } else {
                        $dh = @opendir($_file_base . '/' . $path_relative, $this->context);
                    }
                    if (is_resource($dh)) {
                        while (($f = readdir($dh)) !== false) {
                            $this->directory_handle[$f] = true;
                        }
                        closedir($dh);
                    }
                    $found_dir = true;
                }
            }

            if (!$found_dir) {
                return false;
            }

            reset($this->directory_handle);

            return true;
        }

        if ($this->context === null) { // Weird PHP bug
            $this->directory_handle = opendir($path_absolute);
        } else {
            $this->directory_handle = opendir($path_absolute, $this->context);
        }
        return ($this->directory_handle !== false);
    }

    /**
     * Read entry from directory handle.
     *
     * @return ~string Next filename (false: error)
     */
    public function dir_readdir()
    {
        if (is_array($this->directory_handle)) {
            if (empty($this->directory_handle)) {
                return false;
            }
            $ret = key($this->directory_handle);
            array_shift($this->directory_handle);
            return $ret;
        }

        if ($this->directory_handle === false) {
            return false;
        }

        return readdir($this->directory_handle);
    }

    /**
     * Rewind directory handle.
     *
     * @return boolean Success status
     */
    public function dir_rewinddir() : bool
    {
        if (is_array($this->directory_handle)) {
            reset($this->directory_handle);
            return true;
        }

        if ($this->directory_handle === false) {
            return false;
        }

        rewinddir($this->directory_handle);
        return true;
    }

    /**
     * Close directory handle.
     *
     * @return boolean Success status
     */
    public function dir_closedir() : bool
    {
        if (is_array($this->directory_handle)) {
            $this->directory_handle = null;
            return true;
        }

        if ($this->directory_handle === false) {
            return false;
        }

        closedir($this->directory_handle);
        $this->directory_handle = false;
        return true;
    }

    /**
     * Makes a directory. {{creates-file}}
     *
     * @param  PATH $path The path to the directory to make
     * @param  integer $mode The mode (e.g. 0777)
     * @param  integer $options Bitmask options
     * @return boolean Success status
     */
    public function mkdir(string $path, int $mode, int $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path, true);

        $ret = mkdir($path_absolute, $mode, ($options & STREAM_MKDIR_RECURSIVE) != 0, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_dir($file_base_constant, 'create', $path_relative, $mode);
        }

        return $ret;
    }

    /**
     * Removes directory.
     *
     * @param  PATH $path Directory path
     * @param  integer $options Bitmask options
     * @return boolean Success status
     */
    public function rmdir(string $path, int $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = rmdir($path_absolute, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_dir($file_base_constant, 'delete', $path_relative);
        }

        return $ret;
    }

    /* File operations */

    /**
     * Deletes a file.
     *
     * @param  PATH $path The file path
     * @return boolean Success status
     */
    public function unlink(string $path) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = unlink($path_absolute, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_file($file_base_constant, 'delete', $path_relative);
        }

        return $ret;
    }

    /**
     * Gets information about a file.
     *
     * @param  PATH $path File path
     * @param  integer $flags Bitmask options
     * @return ~array Map of status information (false: error)
     */
    public function url_stat(string $path, int $flags)
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        return @stat($path_absolute); // We need an @, because url_stat is called for things like is_file
    }

    protected $file_path_relative = null;
    protected $file_path_absolute = null;
    protected $file_storage_type = null;
    protected $file_file_base = null;
    protected $file_file_base_constant = null;
    protected $file_is_new = null;
    protected $file_handle = false;

    /**
     * Opens file or URL. {{creates-file}}
     *
     * @param  PATH $path Filename
     * @param  string $mode Mode (e.g. at)
     * @param  integer $options Bitmask options
     * @param  ?string $opened_path The real path will be written into here, if requested (null: not requested)
     * @return boolean Success status
     */
    public function stream_open(string $path, string $mode, int $options, ?string &$opened_path) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path, preg_match('#[cwx]#', $mode) != 0);

        $this->file_path_relative = $path_relative;
        $this->file_path_absolute = $path_absolute;
        $this->file_storage_type = $storage_type;
        $this->file_file_base = $file_base;
        $this->file_file_base_constant = $file_base_constant;
        $this->file_is_new = !is_file($path_absolute);
        $this->file_handle = fopen($path_absolute, $mode, false, $this->context);

        return ($this->file_handle !== false);
    }

    /**
     * Binary-safe file read.
     *
     * @param  integer $count Maximum length to read
     * @return ~string The read data (false: error)
     */
    public function stream_read(int $count)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fread($this->file_handle, $count);
    }

    /**
     * Binary-safe file write.
     *
     * @param  string $data The string to write to the file
     * @return ~integer The number of bytes written (false: error)
     */
    public function stream_write(string $data)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fwrite($this->file_handle, $data);
    }

    /**
     * Truncates a file to a given length.
     *
     * @param  integer $new_size Cut off size
     * @return boolean Success status
     */
    public function stream_truncate(int $new_size) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftruncate($this->file_handle, $new_size);
    }

    /**
     * Seeks on a file pointer.
     *
     * @param  integer $offset The offset (meaning depends on whence)
     * @param  integer $whence SEEK_SET, SEEK_CUR or SEEK_END
     * @return boolean Success status
     */
    public function stream_seek(int $offset, int $whence = 0/*SEEK_SET*/) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return (fseek($this->file_handle, $offset, $whence) == 0);
    }

    /**
     * Gets file pointer read/write position.
     *
     * @return ~integer The offset (false: error)
     */
    public function stream_tell()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftell($this->file_handle);
    }

    /**
     * Tests for end-of-file on a file pointer.
     *
     * @return boolean Whether the end of the file has been reached
     */
    public function stream_eof() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return feof($this->file_handle);
    }

    /**
     * Flushes the output to a file.
     *
     * @return boolean Success status
     */
    public function stream_flush() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fflush($this->file_handle);
    }

    /**
     * Portable advisory file locking.
     *
     * @param  integer $operation Operation (LOCK_SH, LOCK_EX, LOCK_UN)
     * @return boolean Success status
     */
    public function stream_lock(int $operation) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return flock($this->file_handle, $operation);
    }

    /**
     * Change stream options.
     *
     * @param  integer $option Option being set
     * @param  integer $arg1 1st argument
     * @param  integer $arg2 2nd argument
     * @return boolean Success status
     */
    public function stream_set_option(int $option, int $arg1, int $arg2) : bool
    {
        return false;
    }

    /**
     * Gets information about a file using an open file pointer.
     *
     * @return ~array Map of status information (false: error)
     */
    public function stream_stat()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fstat($this->file_handle);
    }

    /**
     * Closes an open file pointer.
     *
     * @return boolean Success status
     */
    public function stream_close() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        $ret = fclose($this->file_handle);
        $this->file_handle = false;

        if (($ret) && ($this->file_storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_file($this->file_file_base_constant, 'create', $this->file_path_relative, time(), fileperms($this->file_path_absolute), base64_encode(file_get_contents($this->file_path_absolute)));
        }

        return $ret;
    }

    /* File and Directory operations */

    /**
     * Renames a file.
     *
     * @param  PATH $path_from Old name
     * @param  PATH $path_to New name
     * @return boolean Success status
     */
    public function rename(string $path_from, string $path_to) : bool
    {
        list($path_relative_from, $path_absolute_from, $storage_type_from, $file_base_from, $file_base_constant_from) = _make_cms_path_native($path_from);
        list($path_relative_to, $path_absolute_to, $storage_type_to, $file_base_to, $file_base_constant_to) = _make_cms_path_native($path_to, true);

        $ret = rename($path_absolute_from, $path_absolute_to);

        if ($ret) {
            if (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant_to, 'move', $path_relative_from, null, $path_relative_to);
                } else {
                    inject_propagation_file($file_base_constant_to, 'move', $path_relative_from, null, $path_relative_to);
                }
            } elseif (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to != CMS_CLOUD__PROPAGATED)) {
                // Will now be already there (would need to come in via Git if $storage_type_to == CMS_CLOUD__LOCAL), so we just delete where it's from
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant_from, 'delete', $path_relative_from);
                } else {
                    inject_propagation_file($file_base_constant_from, 'delete', $path_relative_from);
                }
            } elseif (($storage_type_from != CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant_to, 'create', $path_relative_to, fileperms($path_absolute_to));
                } else {
                    inject_propagation_file($file_base_constant_to, 'create', $path_relative_to, filemtime($path_absolute_to), fileperms($path_absolute_to), base64_encode(file_get_contents($path_absolute_to)));
                }
            }
        }

        return $ret;
    }

    /**
     * Set metadata on a file.
     *
     * @param  PATH $path Path
     * @param  integer $option What to set on
     * @param  mixed $value Value to set
     * @return boolean Success status
     */
    public function stream_metadata(string $path, int $option, $value) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = false;
        switch ($option) {
            case STREAM_META_TOUCH:
                $ret = touch($path_absolute, $value);
                return $ret;

            case STREAM_META_OWNER_NAME:
            case STREAM_META_OWNER:
                if (php_function_allowed('chown')) {
                    $ret = chown($path_absolute, $value);
                }
                break;

            case STREAM_META_GROUP_NAME:
            case STREAM_META_GROUP:
                if (php_function_allowed('chgrp')) {
                    $ret = chgrp($path_absolute, $value);
                }
                break;

            case STREAM_META_ACCESS:
                $ret = chmod($path_absolute, $value);
                break;
        }

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            if (is_dir($path_absolute)) {
                inject_propagation_dir($file_base_constant, 'touch', $path_relative, fileperms($path_absolute));
            } else {
                inject_propagation_file($file_base_constant, 'touch', $path_relative, filemtime($path_absolute), fileperms($path_absolute));
            }
        }

        return $ret;
    }
}
