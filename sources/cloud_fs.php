<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2021

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */


/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__cloud_fs()
{
    define('CMS_CLOUD__LOCAL', 1); // Unchanging file hosted on each machine (may be changed by Git of course).
    define('CMS_CLOUD__PROPAGATED', 2); // Copied to all machines via a sync queue (the propagation_dirs & propagation_files tables). Fast local access, but a delay propagating and more local disk space use.
    define('CMS_CLOUD__REMOTE', 3); // Hosted on e.g. a NAS, via a NFS share. Slower access, but always in sync and better for large amounts of data.

    define('FILE_BASE__SHARED', 'cmsCloudShared');
    define('FILE_BASE__CUSTOM', 'cmsCloudCustom');

    // Regexps specifying where normal Composr file paths will be routed to.
    // Should be in precedence order (for performance reasons).
    // Nothing used in early boot (pre-database connection) should use CMS_CLOUD__REMOTE.
    // Override cloud.php and this data to change the configuration. Addons can add to this global themselves if needed.
    global $CMS_CLOUD_BINDINGS;
    $CMS_CLOUD_BINDINGS = [
        '#^data_custom/errorlog\.php$#' => CMS_CLOUD__LOCAL,
        '#^data_custom/[^/]*\.log$#' => CMS_CLOUD__LOCAL,
        '#^data_custom/modules/admin_backup(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/modules/user_export(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/sitemaps(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/spelling(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^data_custom/xml_config(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^temp(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^exports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^imports(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^lang_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^[^/]*/pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^pages/comcode_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^text_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/css_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/images_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/javascript_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^themes/[^/]*/templates_custom(/.*)?$#' => CMS_CLOUD__PROPAGATED,
        '#^uploads(/.*)?$#' => CMS_CLOUD__REMOTE,
        '#^.*$#' => CMS_CLOUD__LOCAL,
    ];

    global $SITE_INFO;
    if (empty($SITE_INFO['nas_directory'])) {
        $SITE_INFO['nas_directory'] = '../shared_storage';
    }
}

/**
 * Enable the cloud file system.
 */
function enable_cloud_fs()
{
    if (function_exists('stream_wrapper_register')) {
        stream_wrapper_register(FILE_BASE__SHARED, 'CloudFsStreamWrapper');
        stream_wrapper_register(FILE_BASE__CUSTOM, 'CloudFsStreamWrapper');

        global $FILE_BASE, $CUSTOM_FILE_BASE, $FILE_BASE_LOCAL, $CUSTOM_FILE_BASE_LOCAL;
        $FILE_BASE_LOCAL = get_file_base(true);
        $CUSTOM_FILE_BASE_LOCAL = get_custom_file_base(true);
        $FILE_BASE = FILE_BASE__SHARED . ':/'; // NB: Extra needed "/" will in effect be added by path concatenation anyway
        $CUSTOM_FILE_BASE = FILE_BASE__CUSTOM . ':/'; // "
    }
}

/**
 * Resolve a path to the correct local path and find the storage type.
 *
 * @param  string $path Path
 * @return array A tuple: The storage type relative path (if storage type is CMS_CLOUD__LOCAL then it will be null), The absolute path, The storage type (a CMS_CLOUD__* constant), The file base (if storage type is CMS_CLOUD__LOCAL then it will be null), The file base constant (a FILE_BASE__* constant) (if storage type is CMS_CLOUD__LOCAL then it will be null)
 */
function _make_cms_path_native(string $path) : array
{
    global $CMS_CLOUD_BINDINGS, $SITE_INFO;

    if (substr($path, 0, strlen(FILE_BASE__SHARED . '://')) == FILE_BASE__SHARED . '://') {
        $file_base = get_file_base(true);
        $file_base_constant = FILE_BASE__SHARED;
        $path_relative = substr($path, strlen(FILE_BASE__SHARED . '://'));
    } elseif (substr($path, 0, strlen(FILE_BASE__CUSTOM . '://')) == FILE_BASE__CUSTOM . '://') {
        $file_base = get_custom_file_base(true);
        $file_base_constant = FILE_BASE__CUSTOM;
        $path_relative = substr($path, strlen(FILE_BASE__CUSTOM . '://'));
    } else {
        return [null, $path, CMS_CLOUD__LOCAL, null, null];
    }

    $root = (($path == '') || ($path == '/'));

    $storage_type = CMS_CLOUD__LOCAL;
    if (!$root) {
        foreach ($CMS_CLOUD_BINDINGS as $regexp => $_storage_type) {
            if (preg_match($regexp, $path) != 0) {
                $storage_type = $_storage_type;
                break;
            }
        }
    }

    switch ($storage_type) {
        case CMS_CLOUD__PROPAGATED:
        case CMS_CLOUD__LOCAL:
            if ($root) {
                $path_absolute = $file_base;
            } else {
                $path_absolute = $file_base . '/' . $path;
            }
            break;

        case CMS_CLOUD__REMOTE:
            $nas_directory = $SITE_INFO['nas_directory'];
            if ((substr($nas_directory, 0, 1) == '/') || ((strpos(PHP_OS, 'WIN') !== false) && (substr($nas_directory, 1, 2) == ':/'))) {
                $path_absolute = $nas_directory . '/' . $path;
            } else {
                $path_absolute = $file_base . '/' . $nas_directory . '/' . $path;
            }
            break;
    }

    return [$path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant];
}

/**
 * Detail a file for propagation across all servers.
 *
 * @param  string $file_base_constant A FILE_BASE__* constant
 * @param  string $op_type Operation type
 * @set create touch move delete
 * @param  PATH $path_relative The base-relative path
 * @param  ?integer $perms The Unix file permissions (null: N/A)
 * @param  string $data The property value
 */
function inject_propagation_dir(string $file_base_constant, string $op_type, string $path_relative, ?int $perms = null, string $data = '')
{
    // Clean up any contradictions/prior-bloat first
    if ($op_type != 'move') {
        $GLOBALS['SITE_DB']->query_delete('cloud_propagation_dirs', [
            'op_type' => $op_type,
            'dir_file_base_constant' => $file_base_constant,
            'dir_path' => $path_relative,
        ]);
    }

    $GLOBALS['SITE_DB']->query_insert('cloud_propagation_dirs', [
        'op_type' => $op_type,
        'op_timestamp' => time(),
        'dir_file_base_constant' => $file_base_constant,
        'dir_path' => $path_relative,
        'dir_perms' => $perms,
        'op_data' => $data,
        'op_originating_host' => gethostname(),
    ]);
}

/**
 * Ping a file as having been changed, so the cloud can be updated.
 * This would be called if an operation happened outside of PHP (i.e. on native paths).
 *
 * @param  PATH $path The absolute path
 * @param  string $file_base_constant A FILE_BASE_* constant
 */
function cloudfs_ping_file_changed(string $path, string $file_base_constant)
{
    $_path = substr($path, strlen($file_base));
    inject_propagation_file($file_base_constant, 'create', $_path, time(), fileperms($path), base64_encode(file_get_contents($path)));
}

/**
 * Detail a file for propagation across all servers.
 *
 * @param  string $file_base_constant A FILE_BASE__* constant
 * @param  string $op_type Operation type
 * @set create touch move delete
 * @param  PATH $path_relative The base-relative path
 * @param  ?TIME $mtime The modification time (null: N/A)
 * @param  ?integer $perms The Unix file permissions (null: N/A)
 * @param  string $data The base64-encoded file contents / property value
 */
function inject_propagation_file(string $file_base_constant, string $op_type, string $path_relative, ?int $mtime = null, ?int $perms = null, string $data = '')
{
    // Clean up any contradictions/prior-bloat first
    if ($op_type != 'move') {
        $GLOBALS['SITE_DB']->query_delete('cloud_propagation_files', [
            'op_type' => $op_type,
            'file_file_base_constant' => $file_base_constant,
            'dir_path' => $path_relative,
        ]);
    }

    $GLOBALS['SITE_DB']->query_insert('cloud_propagation_files', [
        'op_type' => $op_type,
        'op_timestamp' => time(),
        'file_file_base_constant' => $file_base_constant,
        'file_path' => $path_relative,
        'file_mtime' => $mtime,
        'file_perms' => $perms,
        'op_data' => $data,
        'op_originating_host' => gethostname(),
    ]);
}

/**
 * A filesystem wrapper that adds some additional restrictions,
 * so that this runs as a common denominator of any file system's limitations.
 * Useful if developing on Mac/Windows with an SSD!
 *
 * @package core
 */
class CloudFsStreamWrapper
{
    public $context = null;

    /**
     * Construct our wrapper.
     */
    public function __construct()
    {
    }

    /**
     * Deconstruct our wrapper.
     */
    public function __destruct()
    {
    }

    /* Directory operations */

    protected $directory_handle = false;

    /**
     * Open a directory for analysis.
     *
     * @param  PATH $path The path to the directory to open
     * @param  boolean $options Bitmask options
     * @return boolean Success status
     */
    public function dir_opendir(string $path, bool $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $this->directory_handle = opendir($path_absolute, $this->context);
        return ($this->directory_handle !== false);
    }

    /**
     * Read entry from directory handle.
     *
     * @return ~string Next filename (false: error)
     */
    public function dir_readdir()
    {
        if ($this->directory_handle === false) {
            return false;
        }

        return readdir($this->directory_handle);
    }

    /**
     * Rewind directory handle.
     *
     * @return boolean Success status
     */
    public function dir_rewinddir() : bool
    {
        if ($this->directory_handle === false) {
            return false;
        }

        rewinddir($this->directory_handle);
        return true;
    }

    /**
     * Close directory handle.
     *
     * @return boolean Success status
     */
    public function dir_closedir() : bool
    {
        if ($this->directory_handle === false) {
            return false;
        }

        closedir($this->directory_handle);
        $this->directory_handle = false;
        return true;
    }

    /**
     * Makes a directory. {{creates-file}}
     *
     * @param  PATH $path The path to the directory to make
     * @param  integer $mode The mode (e.g. 0777)
     * @param  integer $options Bitmask options
     * @return boolean Success status
     */
    public function mkdir(string $path, int $mode, int $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = mkdir($path_absolute, $mode, ($options & STREAM_MKDIR_RECURSIVE) != 0, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_dir($file_base_constant, 'create', $path_relative, $mode);
        }

        return $ret;
    }

    /**
     * Removes directory.
     *
     * @param  PATH $path Directory path
     * @param  boolean $options Bitmask options
     * @return boolean Success status
     */
    public function rmdir(string $path, bool $options) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = rmdir($path_absolute, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_dir($file_base_constant, 'delete', $path_relative);
        }

        return $ret;
    }

    /* File operations */

    /**
     * Deletes a file.
     *
     * @param  PATH $path The file path
     * @return boolean Success status
     */
    public function unlink(string $path) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = unlink($path_absolute, $this->context);

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_file($file_base_constant, 'delete', $path_relative);
        }

        return $ret;
    }

    /**
     * Gets information about a file.
     *
     * @param  PATH $path File path
     * @param  boolean $flags Bitmask options
     * @return ~array Map of status information (false: error)
     */
    public function url_stat(string $path, bool $flags)
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        return stat($path_absolute);
    }

    protected $file_path_relative = null;
    protected $file_path_absolute = null;
    protected $file_storage_type = null;
    protected $file_file_base = null;
    protected $file_file_base_constant = null;
    protected $file_is_new = null;
    protected $file_handle = false;

    /**
     * Opens file or URL. {{creates-file}}
     *
     * @param  PATH $path Filename
     * @param  string $mode Mode (e.g. at)
     * @param  integer $options Bitmask options
     * @param  string $opened_path The real path will be written into here, if requested
     * @return boolean Success status
     */
    public function stream_open(string $path, string $mode, int $options, string &$opened_path) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $this->file_path_relative = $path_relative;
        $this->file_path_absolute = $path_absolute;
        $this->file_storage_type = $storage_type;
        $this->file_file_base = $file_base;
        $this->file_file_base_constant = $file_base_constant;
        $this->file_is_new = !is_file($path_absolute);
        $this->file_handle = fopen($path_absolute, $mode, false, $this->context);

        return ($this->file_handle !== false);
    }

    /**
     * Binary-safe file read.
     *
     * @param  integer $count Maximum length to read
     * @return ~string The read data (false: error)
     */
    public function stream_read(int $count)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fread($this->file_handle, $count);
    }

    /**
     * Binary-safe file write.
     *
     * @param  string $data The string to write to the file
     * @return ~integer The number of bytes written (false: error)
     */
    public function stream_write(string $data)
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fwrite($this->file_handle, $data);
    }

    /**
     * Truncates a file to a given length.
     *
     * @param  integer $new_size Cut off size
     * @return boolean Success status
     */
    public function stream_truncate(int $new_size) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftruncate($this->file_handle, $new_size);
    }

    /**
     * Seeks on a file pointer.
     *
     * @param  integer $offset The offset (meaning depends on whence)
     * @param  integer $whence SEEK_SET, SEEK_CUR or SEEK_END
     * @return boolean Success status
     */
    public function stream_seek(int $offset, int $whence = 0/*SEEK_SET*/) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return (fseek($this->file_handle, $offset, $whence) == 0);
    }

    /**
     * Gets file pointer read/write position.
     *
     * @return ~integer The offset (false: error)
     */
    public function stream_tell()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return ftell($this->file_handle);
    }

    /**
     * Tests for end-of-file on a file pointer.
     *
     * @return boolean Whether the end of the file has been reached
     */
    public function stream_eof() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return feof($this->file_handle);
    }

    /**
     * Flushes the output to a file.
     *
     * @return boolean Success status
     */
    public function stream_flush() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fflush($this->file_handle);
    }

    /**
     * Portable advisory file locking.
     *
     * @param  integer $operation Operation (LOCK_SH, LOCK_EX, LOCK_UN)
     * @return boolean Success status
     */
    public function stream_lock(int $operation) : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        return flock($this->file_handle, $operation);
    }

    /**
     * Change stream options.
     *
     * @param  integer $option Option being set
     * @param  integer $arg1 1st argument
     * @param  integer $arg2 2nd argument
     * @return boolean Success status
     */
    public function stream_set_option(int $option, int $arg1, int $arg2) : bool
    {
        return false;
    }

    /**
     * Gets information about a file using an open file pointer.
     *
     * @return ~array Map of status information (false: error)
     */
    public function stream_stat()
    {
        if ($this->file_handle === false) {
            return false;
        }

        return fstat($this->file_handle);
    }

    /**
     * Closes an open file pointer.
     *
     * @return boolean Success status
     */
    public function stream_close() : bool
    {
        if ($this->file_handle === false) {
            return false;
        }

        $ret = fclose($this->file_handle);
        $this->file_handle = false;

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            inject_propagation_file($file_base_constant, 'create', $this->file_path_relative, time(), fileperms($this->file_path_absolute), base64_encode(file_get_contents($this->file_path_absolute)));
        }

        return $ret;
    }

    /* File and Directory operations */

    /**
     * Renames a file.
     *
     * @param  PATH $path_from Old name
     * @param  PATH $path_to New name
     * @return boolean Success status
     */
    public function rename(string $path_from, string $path_to) : bool
    {
        list($path_relative_from, $path_absolute_from, $storage_type_from, $file_base_from, $file_base_constant_from) = _make_cms_path_native($path);
        list($path_relative_to, $path_absolute_to, $storage_type_to, $file_base_to, $file_base_constant_to) = _make_cms_path_native($path);

        $ret = rename($path_absolute_from, $path_absolute_to);

        if ($ret) {
            if (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant, 'move', $path_relative_from, null, $path_relative_to);
                } else {
                    inject_propagation_file($file_base_constant, 'move', $path_relative_from, null, $path_relative_to);
                }
            } elseif (($storage_type_from == CMS_CLOUD__PROPAGATED) && ($storage_type_to != CMS_CLOUD__PROPAGATED)) {
                // Will now be already there (would need to come in via Git if $storage_type_to == CMS_CLOUD__LOCAL), so we just delete where it's from
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant, 'delete', $path_relative_from);
                } else {
                    inject_propagation_file($file_base_constant, 'delete', $path_relative_from);
                }
            } elseif (($storage_type_from != CMS_CLOUD__PROPAGATED) && ($storage_type_to == CMS_CLOUD__PROPAGATED)) {
                if (is_dir($path_to)) {
                    inject_propagation_dir($file_base_constant, 'create', $path_relative_to, fileperms($path_absolute_to));
                } else {
                    inject_propagation_file($file_base_constant, 'create', $path_relative_to, filemtime($path_absolute_to), fileperms($path_absolute_to), base64_encode(file_get_contents($path_absolute_to)));
                }
            }
        }

        return $ret;
    }

    /**
     * Set metadata on a file.
     *
     * @param  PATH $path Path
     * @param  integer $option What to set on
     * @param  mixed $value Value to set
     * @return boolean Success status
     */
    public function stream_metadata(string $path, int $option, $value) : bool
    {
        list($path_relative, $path_absolute, $storage_type, $file_base, $file_base_constant) = _make_cms_path_native($path);

        $ret = false;
        switch ($option) {
            case STREAM_META_TOUCH:
                $ret = touch($path_absolute, $value);
                return $ret;

            case STREAM_META_OWNER_NAME:
            case STREAM_META_OWNER:
                if (php_function_allowed('chown')) {
                    $ret = chown($path_absolute, $value);
                }
                break;

            case STREAM_META_GROUP_NAME:
            case STREAM_META_GROUP:
                if (php_function_allowed('chgrp')) {
                    $ret = chgrp($path_absolute, $value);
                }
                break;

            case STREAM_META_ACCESS:
                $ret = chmod($path_absolute, $value);
                break;
        }

        if (($ret) && ($storage_type == CMS_CLOUD__PROPAGATED)) {
            if (is_dir(get_file_base(true) . '/' . $path)) {
                inject_propagation_dir($file_base_constant, 'touch', $path_relative, fileperms($path_absolute));
            } else {
                inject_propagation_file($file_base_constant, 'touch', $path_relative, filemtime($path_absolute), fileperms($path_absolute));
            }
        }

        return $ret;
    }
}
