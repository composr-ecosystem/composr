<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    downloads
 */

/**
 * See if a member may access a download category.
 *
 * @param  MEMBER $member_id The member
 * @param  AUTO_LINK $category_id The category
 * @return boolean Whether they can
 */
function may_enter_download_category(int $member_id, int $category_id) : bool
{
    if (get_option('download_cat_access_late') == '1') {
        return true;
    }

    return has_category_access($member_id, 'downloads', strval($category_id));
}

/**
 * Get the URL to purchase access to a download category.
 *
 * @param  AUTO_LINK $category_id The category
 * @return ?Tempcode The purchase URL (null: cannot be purchased)
 */
function get_download_category_purchase_url(int $category_id) : ?object
{
    if (addon_installed('ecommerce')) {
        $product_id = $GLOBALS['SITE_DB']->query_select_value_if_there('ecom_prods_permissions', 'id', ['p_module' => 'downloads', 'p_category' => strval($category_id), 'p_enabled' => 1]);
        if ($product_id !== null) {
            return build_url(['page' => 'purchase', 'type' => 'details', 'type_code' => 'PERMISSION_' . strval($product_id)], get_module_zone('purchase'));
        }
    }
    return null;
}

/**
 * Show a download licence for display.
 */
function download_licence_script()
{
    if (!addon_installed('downloads')) {
        warn_exit(do_lang_tempcode('MISSING_ADDON', escape_html('downloads')));
    }

    $id = get_param_integer('id');

    $rows = $GLOBALS['SITE_DB']->query_select('download_licences', ['*'], ['id' => $id], '', 1);
    if (!array_key_exists(0, $rows)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_licence'));
    }
    $licence_title = $rows[0]['l_title'];
    $licence_text = $rows[0]['l_text'];
    $echo = do_template('STANDALONE_HTML_WRAP', [
        '_GUID' => 'd8f60d5f6f56b08589ed6f4b874dad85',
        'TITLE' => $licence_title,
        'POPUP' => true,
        'NOINDEX' => true,
        'CONTENT' => comcode_to_tempcode($licence_text, $GLOBALS['FORUM_DRIVER']->get_guest_id(), false),
    ]);
    $echo->evaluate_echo();
}

/**
 * Get Tempcode for a download 'feature box' for the given row.
 *
 * @param  array $row The database field row of this download
 * @param  boolean $pic Whether to show a picture
 * @param  boolean $include_breadcrumbs Whether to show breadcrumbs
 * @param  ?ID_TEXT $zone The zone the download module we're using is in (null: find it)
 * @param  ?Tempcode $text_summary Text summary for result (e.g. highlighted portion of actual file from search result) (null: none)
 * @param  boolean $give_context Whether to include context (i.e. say WHAT this is, not just show the actual content)
 * @param  ?AUTO_LINK $root The virtual root (null: read from environment)
 * @param  ID_TEXT $guid Overridden GUID to send to templates (blank: none)
 * @return Tempcode A box for this download, linking to the full download page
 */
function render_download_box(array $row, bool $pic = true, bool $include_breadcrumbs = true, ?string $zone = null, ?object $text_summary = null, bool $give_context = true, ?int $root = null, string $guid = '') : object
{
    if ($row === null) { // Should never happen, but we need to be defensive
        return new Tempcode();
    }

    require_lang('downloads');
    require_css('downloads');
    require_code('files');

    if ($zone === null) {
        $zone = get_module_zone('downloads');
    }

    if (array_key_exists('id', $row)) {
        $just_download_row = db_map_restrict($row, ['id', 'the_description']);
    } else {
        $just_download_row = db_map_restrict($row, ['the_description']);
    }

    // Details
    $file_size = $row['file_size'];
    $file_size = ($file_size > 0) ? clean_file_size($file_size) : do_lang('UNKNOWN');
    $description = (is_string($row['the_description']) && !isset($row['the_description__text_parsed'])) ? comcode_to_tempcode($row['the_description']) : get_translated_tempcode('download_downloads', $just_download_row, 'the_description');
    if (array_key_exists('id', $row)) {
        $map = ['page' => 'downloads', 'type' => 'entry', 'id' => $row['id']];
        if ($root !== null) {
            $map['keep_download_root'] = ($root == db_get_first_id()) ? null : $root;
        }
        $view_url = build_url($map, $zone);
    } else {
        $view_url = new Tempcode();
    }
    $date = get_timezoned_date_tempcode($row['add_date']);
    $date_raw = $row['add_date'];

    $breadcrumbs = $include_breadcrumbs ? breadcrumb_segments_to_tempcode(download_breadcrumbs($row['category_id'], ($root === null) ? get_param_integer('keep_download_root', null) : $root, true, $zone)) : new Tempcode();

    // Download has image?
    $rep_image_url = '';
    if ((addon_installed('galleries')) && ($pic) && (array_key_exists('id', $row))) {
        // Images
        $rows = $GLOBALS['SITE_DB']->query_select('images', ['url', 'id'], ['cat' => 'download_' . strval($row['id'])], '', 1, $row['default_pic'] - 1);
        if (array_key_exists(0, $rows)) {
            $rep_image_url = $rows[0]['url'];
            if (url_is_local($rep_image_url)) {
                $rep_image_url = get_custom_base_url() . '/' . $rep_image_url;
            }
        }
    }

    // Rating
    require_code('feedback');
    $rating = ($row['allow_rating'] == 1 && array_key_exists('id', $row)) ? display_rating($view_url, is_string($row['name']) ? $row['name'] : get_translated_text($row['name']), 'downloads', strval($row['id']), 'RATING_INLINE_STATIC', $row['submitter']) : null;
    if ($rating !== null) {
        if (trim($rating->evaluate()) == '') {
            $rating = null;
        }
    }

    // Licensing
    $licence_title = null;
    $licence_url = null;
    $licence_hyperlink = null;
    $licence = $row['download_licence_id'];
    if ($licence !== null) {
        $licence_title = $GLOBALS['SITE_DB']->query_select_value_if_there('download_licences', 'l_title', ['id' => $licence]);
        if ($licence_title !== null) {
            $keep = symbol_tempcode('KEEP');
            $licence_url = find_script('download_licence') . '?id=' . strval($licence) . $keep->evaluate();
            $licence_hyperlink = do_template('HYPERLINK_OVERLAY', [
                '_GUID' => ($guid != '') ? $guid : '58a9e5c99bd236290009b6eab44dbac3',
                'TITLE' => '',
                'CAPTION' => $licence_title,
                'URL' => $licence_url,
                'WIDTH' => '600',
                'HEIGHT' => '500',
                'REL' => 'license',
            ]);
        } else {
            $licence = null; // Orphaned
        }
    }

    $may_download = has_privilege(get_member(), 'download', 'downloads', ['downloads', strval($row['category_id'])]);

    if (array_key_exists('id', $row)) {
        $download_url = generate_dload_url($row['id'], $row['url_redirect'] != '');
    } else {
        $download_url = new Tempcode();
    }

    // Final template
    return do_template('DOWNLOAD_BOX', [
        '_GUID' => ($guid != '') ? $guid : '7a4737e21bdb4bd15ac5fe8570915d08',
        'ORIGINAL_FILENAME' => $row['original_filename'],
        'GIVE_CONTEXT' => $give_context,
        'TEXT_SUMMARY' => $text_summary,
        'AUTHOR' => $row['author'],
        'ID' => array_key_exists('id', $row) ? strval($row['id']) : '',
        'RATING' => $rating,
        '_VIEWS' => strval($row['download_views']),
        'VIEWS' => integer_format($row['download_views'], 0),
        '_DOWNLOADS' => strval($row['num_downloads']),
        'DOWNLOADS' => integer_format($row['num_downloads'], 0),
        'SUBMITTER' => strval($row['submitter']),
        'DESCRIPTION' => reasonable_html_reduce($description),
        'FILE_SIZE' => $file_size,
        'DATE_RAW' => strval($date_raw),
        'DATE' => $date,
        'EDIT_DATE_RAW' => ($row['edit_date'] === null) ? '' : strval($row['edit_date']),
        'URL' => $view_url,
        'NAME' => is_string($row['name']) ? $row['name'] : get_translated_text($row['name']),
        'BREADCRUMBS' => $breadcrumbs,
        'REP_IMAGE_URL' => $rep_image_url,
        'LICENCE' => ($licence === null) ? null : strval($licence),
        'LICENCE_TITLE' => $licence_title,
        'LICENCE_HYPERLINK' => $licence_hyperlink,
        'MAY_DOWNLOAD' => $may_download,
        'DOWNLOAD_URL' => $download_url,
    ]);
}

/**
 * Get Tempcode for a download category 'feature box' for the given row.
 *
 * @param  array $row The database field row of it
 * @param  ID_TEXT $zone The zone to use
 * @param  boolean $give_context Whether to include context (i.e. say WHAT this is, not just show the actual content)
 * @param  boolean $include_breadcrumbs Whether to include breadcrumbs (if there are any)
 * @param  ?AUTO_LINK $root Virtual root to use (null: none)
 * @param  boolean $attach_to_url_filter Whether to copy through any filter parameters in the URL, under the basis that they are associated with what this box is browsing
 * @param  ID_TEXT $guid Overridden GUID to send to templates (blank: none)
 * @return Tempcode A box for it, linking to the full page
 */
function render_download_category_box(array $row, string $zone = '_SEARCH', bool $give_context = true, bool $include_breadcrumbs = true, ?int $root = null, bool $attach_to_url_filter = false, string $guid = '') : object
{
    if ($row === null) { // Should never happen, but we need to be defensive
        return new Tempcode();
    }

    require_lang('downloads');

    $map = ['page' => 'downloads', 'type' => 'browse', 'id' => ($row['id'] == db_get_first_id()) ? null : $row['id']];
    if ($root !== null) {
        $map['keep_download_root'] = $root;
    }
    if ($attach_to_url_filter) {
        $map += propagate_filtercode();
    }
    $url = build_url($map, $zone);

    $_title = get_translated_text($row['category']);
    $title = $give_context ? do_lang('CONTENT_IS_OF_TYPE', do_lang('DOWNLOAD_CATEGORY'), $_title) : $_title;

    $breadcrumbs = null;
    if ($include_breadcrumbs) {
        $breadcrumbs = breadcrumb_segments_to_tempcode(download_breadcrumbs($row['parent_id'], ($root === null) ? get_param_integer('keep_download_root', null) : $root, true, $zone, $attach_to_url_filter));
    }

    $just_download_category_row = db_map_restrict($row, ['id', 'the_description']);

    $summary = get_translated_tempcode('download_downloads', $just_download_category_row, 'the_description');

    $child_counts = count_download_category_children($row['id']);
    $num_children = $child_counts['num_children_children'];
    $num_entries = $child_counts['num_downloads_children'];
    $entry_details = do_lang_tempcode('CATEGORY_SUBORDINATE', escape_html(integer_format($num_entries, 0)), escape_html(integer_format($num_children, 0)));

    // Image
    $rep_image_url = '';
    if ($row['rep_image'] != '') {
        $rep_image_url = $row['rep_image'];
        if (url_is_local($rep_image_url)) {
            $rep_image_url = get_custom_base_url() . '/' . $rep_image_url;
        }
    }

    return do_template('SIMPLE_PREVIEW_BOX', [
        '_GUID' => ($guid != '') ? $guid : '4074a20248289c28cde8201272627129',
        'ID' => strval($row['id']),
        'BREADCRUMBS' => $breadcrumbs,
        'TITLE' => $title,
        'TITLE_PLAIN' => $_title,
        'SUMMARY' => $summary,
        'REP_IMAGE_URL' => $rep_image_url,
        'ENTRY_DETAILS' => $entry_details,
        'URL' => $url,
        'FRACTIONAL_EDIT_FIELD_NAME' => $give_context ? null : 'category',
        'FRACTIONAL_EDIT_FIELD_URL' => $give_context ? null : ('_SEARCH:cms_downloads:__edit_category:' . strval($row['id'])),
        'RESOURCE_TYPE' => 'download_category',
    ]);
}

/**
 * Get a nice, formatted HTML list of downloads, in download tree structure.
 *
 * @param  ?AUTO_LINK $it The currently selected entry (null: none selected)
 * @param  ?AUTO_LINK $submitter Only show entries submitted by this member (null: no filter)
 * @param  ?AUTO_LINK $shun Download we do not want to show (null: none to not show)
 * @param  boolean $use_compound_list Whether to get a list of child categories (not just direct ones, recursively), instead of just IDs
 * @param  boolean $editable_filter Whether to only show for what may be edited by the current member
 * @return Tempcode The list of entries
 */
function create_selection_list_downloads_tree(?int $it = null, ?int $submitter = null, ?int $shun = null, bool $use_compound_list = false, bool $editable_filter = false) : object
{
    $tree = get_downloads_tree($submitter, null, null, null, $shun, null, $use_compound_list, $editable_filter);
    if ($use_compound_list) {
        $tree = $tree[0];
    }

    $out = '';
    foreach ($tree as $category) {
        foreach ($category['entries'] as $eid => $etitle) {
            $selected = ($eid == $it);
            $line = do_template('DOWNLOAD_LIST_LINE', ['_GUID' => '7bb13e4418b500cb2b330e629710138a', 'BREADCRUMBS' => $category['breadcrumbs'], 'DOWNLOAD' => $etitle]);
            $out .= '<option value="' . (!$use_compound_list ? strval($eid) : $category['compound_list']) . '"' . ($selected ? ' selected="selected"' : '') . '>' . $line->evaluate() . '</option>'; // XHTMLXHTML
        }
    }

    if ($GLOBALS['XSS_DETECT']) {
        ocp_mark_as_escaped($out);
    }

    return make_string_tempcode($out);
}

/**
 * Get a list of maps containing all the downloads, and path information, under the specified category - and those beneath it, recursively.
 *
 * @param  ?MEMBER $submitter Only show images/videos submitted by this member (null: no filter)
 * @param  ?AUTO_LINK $category_id The category being at the root of our recursion (null: true root)
 * @param  ?string $breadcrumbs The breadcrumbs up to this point in the recursion (null: blank, as we are starting the recursion)
 * @param  ?ID_TEXT $title The name of the $category_id we are currently going through (null: look it up). This is here for efficiency reasons, as finding children IDs to recurse to also reveals the child's title
 * @param  ?integer $shun The number of recursive levels to search (null: all)
 * @param  ?AUTO_LINK $levels Download we do not want to show (null: none to not show)
 * @param  boolean $use_compound_list Whether to get a list of child categories (not just direct ones, recursively), instead of just IDs
 * @param  boolean $editable_filter Whether to only show for what may be edited by the current member
 * @param  boolean $tar_filter Whether to only show entries that are TAR files (addons)
 * @return array A list of maps for all categories. Each map entry containing the fields 'id' (category ID) and 'breadcrumbs' (to the category, including the categories own title), and more. Or if $use_compound_list, the tree structure built with pairs containing the compound list in addition to the child branches
 */
function get_downloads_tree(?int $submitter = null, ?int $category_id = null, ?string $breadcrumbs = null, ?string $title = null, ?int $shun = null, ?int $levels = null, bool $use_compound_list = false, bool $editable_filter = false, bool $tar_filter = false) : array
{
    if ($category_id === null) {
        $category_id = db_get_first_id();
    }

    if (!may_enter_download_category(get_member(), $category_id)) {
        return [];
    }

    if ($breadcrumbs === null) {
        $breadcrumbs = '';
    }

    // Put our title onto our breadcrumbs
    if ($title === null) {
        $title = get_translated_text($GLOBALS['SITE_DB']->query_select_value('download_categories', 'category', ['id' => $category_id]));
    }
    $breadcrumbs .= $title;

    $compound_list = strval($category_id) . ',';

    // We'll be putting all children in this entire tree into a single list
    $children = [];
    $children[0] = [];
    $children[0]['id'] = $category_id;
    $children[0]['title'] = $title;
    $children[0]['breadcrumbs'] = $breadcrumbs;

    // Children of this category
    $rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['id', 'category'], ['parent_id' => $category_id], 'ORDER BY ' . $GLOBALS['SITE_DB']->translate_field_ref('category'), intval(get_option('general_safety_listing_limit'))/*reasonable limit*/);
    if (count($rows) == intval(get_option('general_safety_listing_limit'))) {
        $rows = [];
    }
    $where = ['category_id' => $category_id];
    if ($submitter !== null) {
        $where['submitter'] = $submitter;
    }
    $erows = $GLOBALS['SITE_DB']->query_select('download_downloads', ['id', 'name', 'submitter', 'original_filename', 'add_date'], $where, 'ORDER BY ' . $GLOBALS['SITE_DB']->translate_field_ref('name'), intval(get_option('general_safety_listing_limit'))/*reasonable limit*/);
    if (count($erows) == intval(get_option('general_safety_listing_limit'))) {
        $erows = $GLOBALS['SITE_DB']->query_select('download_downloads', ['id', 'name', 'submitter', 'original_filename', 'add_date'], $where, 'ORDER BY add_date DESC', intval(get_option('general_safety_listing_limit'))/*reasonable limit*/);
    }
    $children[0]['entries'] = [];
    foreach ($erows as $row) {
        if (($tar_filter) && (substr(cms_strtolower_ascii($row['original_filename']), -4) != '.tar')) {
            continue;
        }
        if (($editable_filter) && (!has_edit_permission('mid', get_member(), $row['submitter'], 'cms_downloads', ['downloads', $category_id]))) {
            continue;
        }
        if (($shun !== null) && ($shun == $row['id'])) {
            continue;
        }

        $children[0]['entries'][$row['id']] = get_translated_text($row['name']);
    }
    $children[0]['child_entry_count'] = count($children[0]['entries']);
    if ($levels === 0) { // We throw them away now because they're not on the desired level
        $children[0]['entries'] = [];
    }
    $children[0]['child_count'] = count($rows);
    $breadcrumbs .= ' > ';
    if (($levels !== 0) || ($use_compound_list)) {
        foreach ($rows as $child) {
            $child_id = $child['id'];
            $child_title = get_translated_text($child['category']);
            $child_breadcrumbs = $breadcrumbs;

            $child_children = get_downloads_tree($submitter, $child_id, $child_breadcrumbs, $child_title, $shun, ($levels === null) ? null : max(0, $levels - 1), $use_compound_list, $editable_filter, $tar_filter);
            if ($use_compound_list) {
                list($child_children, $_compound_list) = $child_children;
                $compound_list .= $_compound_list;
            }

            if ($levels !== 0) {
                $children = array_merge($children, $child_children);
            }
        }
    }
    $children[0]['compound_list'] = $compound_list;

    return $use_compound_list ? [$children, $compound_list] : $children;
}

/**
 * Get a nice, formatted HTML list extending from the root, and showing all subcategories, and their subcategories (ad infinitum).
 * The tree bit is because each entry in the list is shown to include the path through the tree that gets to it.
 *
 * @param  ?AUTO_LINK $it The currently selected category (null: none selected)
 * @param  boolean $use_compound_list Whether to make the list elements store comma-separated child lists instead of IDs
 * @param  boolean $addable_filter Whether to only show for what may be added to by the current member
 * @param  ?TIME $updated_since Time from which content must be updated (null: no limit)
 * @return Tempcode The list of categories
 */
function create_selection_list_download_category_tree(?int $it = null, bool $use_compound_list = false, bool $addable_filter = false, ?int $updated_since = null) : object
{
    $tree = get_download_category_tree(null, null, null, $updated_since !== null, $use_compound_list, null, $addable_filter);
    if ($use_compound_list) {
        $tree = $tree[0];
    }

    $out = '';
    foreach ($tree as $category) {
        if (($addable_filter) && (!$category['addable'])) {
            continue;
        }

        if (($updated_since !== null) && (($category['updated_since'] === null) || ($category['updated_since'] < $updated_since))) {
            continue;
        }

        $selected = ($category['id'] == $it);
        $line = do_template('DOWNLOAD_LIST_LINE_2', ['_GUID' => '0ccffeff5b80b1840188b839aee8d9f2', 'BREADCRUMBS' => $category['breadcrumbs'], 'FILECOUNT' => '?']);
        $out .= '<option value="' . (!$use_compound_list ? strval($category['id']) : $category['compound_list']) . '"' . ($selected ? ' selected="selected"' : '') . '>' . $line->evaluate() . '</option>'; // XHTMLXHTML
    }

    if ($GLOBALS['XSS_DETECT']) {
        ocp_mark_as_escaped($out);
    }

    return make_string_tempcode($out);
}

/**
 * Get a list of maps containing all the subcategories, and path information, of the specified download category - and those beneath it, recursively.
 *
 * @param  ?AUTO_LINK $category_id The category being at the root of our recursion (null: true root category)
 * @param  ?string $breadcrumbs The breadcrumbs up to this point in the recursion (null: blank, as we are starting the recursion)
 * @param  ?array $category_info The category row of the $category_id we are currently going through (null: look it up). This is here for efficiency reasons, as finding children IDs to recurse to also reveals the child's details
 * @param  boolean $do_stats Whether to collect download counts with our tree information
 * @param  boolean $use_compound_list Whether to make a compound list (a pair of a comma-separated list of children, and the child array)
 * @param  ?integer $levels The number of recursive levels to search (null: all)
 * @param  boolean $addable_filter Whether to only show for what may be added to by the current member
 * @return array A list of maps for all subcategories, contains more details if stats were requested
 */
function get_download_category_tree(?int $category_id = null, ?string $breadcrumbs = null, ?array $category_info = null, bool $do_stats = false, bool $use_compound_list = false, ?int $levels = null, bool $addable_filter = false) : array
{
    if (!$use_compound_list) {
        if ($levels == -1) {
            return [];
        }
    }

    if ($category_id === null) {
        $category_id = db_get_first_id();
    }
    if ($breadcrumbs === null) {
        $breadcrumbs = '';
    }

    if (!may_enter_download_category(get_member(), $category_id)) {
        return $use_compound_list ? [[], ''] : [];
    }

    if ($category_info === null) {
        $_category_info = $GLOBALS['SITE_DB']->query_select('download_categories', ['*'], ['id' => $category_id], '', 1);
        if (!array_key_exists(0, $_category_info)) {
            warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'download_category'));
        }
        $category_info = $_category_info[0];
    }

    $title = get_translated_text($category_info['category']);
    $breadcrumbs .= $title;

    // We'll be putting all children in this entire tree into a single list
    $children = [];
    $children[0] = [];
    $children[0]['id'] = $category_id;
    $children[0]['title'] = $title;
    $children[0]['breadcrumbs'] = $breadcrumbs;
    $children[0]['compound_list'] = strval($category_id) . ',';
    if ($addable_filter) {
        $children[0]['addable'] = has_submit_permission('mid', get_member(), get_ip_address(), 'cms_downloads', ['downloads', $category_id]);
    }
    if ($do_stats) {
        $stats = $GLOBALS['SITE_DB']->query_select('download_downloads', ['COUNT(*) AS downloads_count', 'MAX(add_date) AS updated_since'], ['category_id' => $category_id]);
        $children[0] += $stats[0];
    }

    // Children of this category
    $rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['id', 'category'], ['parent_id' => $category_id], 'ORDER BY ' . $GLOBALS['SITE_DB']->translate_field_ref('category'), intval(get_option('general_safety_listing_limit'))/*reasonable*/);
    if (count($rows) == intval(get_option('general_safety_listing_limit'))) {
        $rows = [];
    }
    $children[0]['child_count'] = count($rows);
    $child_breadcrumbs = ($breadcrumbs == '') ? '' : ($breadcrumbs . ' > ');
    if (($levels !== 0) || ($use_compound_list)) {
        foreach ($rows as $child) {
            $child_id = $child['id'];

            $child_children = get_download_category_tree($child_id, $child_breadcrumbs, $child, $do_stats, $use_compound_list, ($levels === null) ? null : max(0, $levels - 1), $addable_filter);
            if ($use_compound_list) {
                list($child_children, $_compound_list) = $child_children;
                $children[0]['compound_list'] .= $_compound_list;
            }

            if ($levels !== 0) {
                $children = array_merge($children, $child_children);
            }
        }
    }

    return $use_compound_list ? [$children, $children[0]['compound_list']] : $children;
}

/**
 * Get a nice, formatted HTML list to select a download licence.
 *
 * @param  ?AUTO_LINK $it The currently selected licence (null: none selected)
 * @param  boolean $allow_na Whether to allow an N/A selection
 * @return Tempcode The list of categories
 */
function create_selection_list_download_licences(?int $it = null, bool $allow_na = false) : object
{
    $list = new Tempcode();
    if ($allow_na) {
        $list->attach(form_input_list_entry('-1', false, do_lang_tempcode('NA_EM')));
    }
    $rows = $GLOBALS['SITE_DB']->query_select('download_licences', ['id', 'l_title']);
    foreach ($rows as $row) {
        $list->attach(form_input_list_entry(strval($row['id']), $it == $row['id'], $row['l_title']));
    }
    return $list;
}

/**
 * Get a formatted HTML string of the route back to the specified root, from the specified download category.
 *
 * @param  ?AUTO_LINK $category_id The category we are finding for (null: already ascended too far for anything to be left)
 * @param  ?AUTO_LINK $root The root of the tree (null: the true root)
 * @param  boolean $include_link Whether to include category links at this level (the recursed levels will always contain links - the top level is optional, hence this parameter)
 * @param  ?ID_TEXT $zone The zone the download module we're using is in (null: find it)
 * @param  boolean $attach_to_url_filter Whether to copy through any filter parameters in the URL, under the basis that they are associated with what this box is browsing
 * @return array The breadcrumb segments
 */
function download_breadcrumbs(?int $category_id, ?int $root = null, bool $include_link = false, ?string $zone = null, bool $attach_to_url_filter = false) : array
{
    if ($category_id === null) {
        return [];
    }

    if ($root === null) {
        $root = db_get_first_id();
    }
    if ($zone === null) {
        $zone = get_module_zone('downloads');
    }

    $map = ['page' => 'downloads', 'type' => 'browse', 'id' => ($category_id == db_get_first_id()) ? null : $category_id, 'keep_download_root' => ($root == db_get_first_id()) ? null : $root];
    if (get_page_name() == 'downloads') {
        $map += propagate_filtercode();
    }
    $page_link = build_page_link($map, $zone);

    if (($category_id == $root) || ($category_id == db_get_first_id())) {
        if (!$include_link) {
            return [];
        }
        $_title = $GLOBALS['SITE_DB']->query_select_value_if_there('download_categories', 'category', ['id' => $category_id]);
        $title = ($_title === null) ? do_lang('UNKNOWN') : get_translated_text($_title);
        return [[$page_link, $title]];
    }

    static $pt_pair_cache_d = [];
    if (!array_key_exists($category_id, $pt_pair_cache_d)) {
        $category_rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['parent_id', 'category'], ['id' => $category_id], '', 1);
        if (!array_key_exists(0, $category_rows)) {
            //warn_exit(do_lang_tempcode('CAT_NOT_FOUND', escape_html(strval($category_id)), 'download_category'));
            return [];
        }
        $pt_pair_cache_d[$category_id] = $category_rows[0];
    }

    $title = get_translated_text($pt_pair_cache_d[$category_id]['category']);
    $segments = [];
    if ($include_link) {
        $segments[] = [$page_link, $title];
    }

    if ($pt_pair_cache_d[$category_id]['parent_id'] == $category_id) {
        fatal_exit(do_lang_tempcode('RECURSIVE_TREE_CHAIN', escape_html(strval($category_id)), 'download_category'));
    }

    $below = download_breadcrumbs($pt_pair_cache_d[$category_id]['parent_id'], $root, true, $zone, $attach_to_url_filter);

    return array_merge($below, $segments);
}

/**
 * Count the downloads and subcategories underneath the specified category, recursively.
 *
 * @param  AUTO_LINK $category_id The ID of the category for which count details are collected
 * @return array The number of downloads is returned in $output['num_downloads'], and the number of subcategories is returned in $output['num_children'], and the (possibly recursive) number of downloads is returned in $output['num_downloads_children']
 */
function count_download_category_children(int $category_id) : array
{
    static $total_categories = null;
    if ($total_categories === null) {
        $total_categories = $GLOBALS['SITE_DB']->query_select_value('download_categories', 'COUNT(*)');
    }

    $out = [];
    $out['num_children'] = $GLOBALS['SITE_DB']->query_select_value('download_categories', 'COUNT(*)', ['parent_id' => $category_id]);
    $out['num_downloads'] = $GLOBALS['SITE_DB']->query_select_value('download_downloads', 'COUNT(*)', ['category_id' => $category_id, 'validated' => 1]);

    if ($category_id == db_get_first_id()) {
        $out['num_children_children'] = $GLOBALS['SITE_DB']->query_select_value('download_categories', 'COUNT(*)') - 1;
        $out['num_downloads_children'] = $GLOBALS['SITE_DB']->query_select_value('download_downloads', 'COUNT(*)', ['validated' => 1]);
    } else {
        $out['num_children_children'] = $out['num_children'];
        $out['num_downloads_children'] = $out['num_downloads'];

        if ($total_categories < 200) { // Make sure not too much, performance issue
            $rows = $GLOBALS['SITE_DB']->query_select('download_categories', ['id'], ['parent_id' => $category_id]);
            foreach ($rows as $child) {
                $temp = count_download_category_children($child['id']);
                $out['num_downloads_children'] += $temp['num_downloads_children'];
                $out['num_children_children'] += $temp['num_children_children'];
            }
        }
    }

    return $out;
}

/**
 * Generate a link to a site download.
 *
 * @param  AUTO_LINK $id The ID of the download to be downloaded
 * @param  boolean $use_gateway Whether to use the gateway script
 * @return Tempcode The URL
 */
function generate_dload_url(int $id, bool $use_gateway) : object
{
    if (get_option('immediate_downloads') == '1') {
        $use_gateway = false;
    }

    $keep = symbol_tempcode('KEEP', ['0']);

    if ($use_gateway) {
        $download_url = make_string_tempcode(find_script('download_gateway'));
    } else {
        $download_url = make_string_tempcode(find_script('dload'));
    }

    $download_url->attach('?id=' . strval($id));
    $download_url->attach($keep);

    require_code('anti_leech');
    apply_anti_leech_to_tempcode_url($download_url);

    return $download_url;
}
