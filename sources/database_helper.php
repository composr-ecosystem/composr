<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/* This file exists split from database.php to alleviate PHP memory usage / load time. */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__database_helper()
{
    if (defined('DB_MAX_KEY_SIZE')) {
        return;
    }

    if (!defined('DB_MAX_KEY_SIZE')) {
        // Limits...
        //  We also limit field names to not conflict with keywords (those defined in get_db_keyword) and various other hard-coded restrictions).
        //  These limits are intentionally conservative, sometimes much more than all supported databases. This is in case we hit a future more restrictive system and because we want to encourage good database design.

        define('DB_MAX_IDENTIFIER_LENGTH', 44); // Remember we need some space for long table prefixes, we reserve 19 bytes

        define('DB_MAX_PRIMARY_KEY_SIZE', 328); // 328 is what group_privileges uses
        define('DB_MAX_KEY_SIZE', 1000);
        define('DB_MAX_ROW_SIZE', 24000);

        /*
        Source...

        Limitation                                     Access    MySQL (InnoDB)      MySQL (MyISAM)    PostgreSQL    Oracle    DB2    Firebird    SQLite    CUBRID    Ingres    SQL Anywhere    Informix    FileMaker   SQL Server

        Max table name length                          64        64                  64                63            128       128    63          /         254       256       128             128         100         128
        Max field identifier length                    64        64                  64                63            128       128    63          /         254       256       128             128         100         128
        Max index name length                          64        64                  64                63            128       128    63          /         254       256       128             128         100         128
        Max fields in table                            255       1017                /                 1600          1000      8000   /           2000      /         1024      45000           32768       99          1024
        Max indexes for table (excluding primary key)  32        64                  64                /             /         14900  200         /         /         125       4294967296      /           /           999
        Max fields in index                            10        16                  16                32            32        120    /           2000      /         32        /               16          /           32
        Max key size                                   /         3072                1000              /             /         32767  8000        /         /         /         /               797 (*3)    /           1700 (*4)
        Max key size (primary keys)                    255       3072                1000              /             /         32767  8000        /         /         /         /               797 (*3)    /           1700 (*4)
        Max key size (considering unicode)             /         3072                1000              /             /         32767  8000        /         /         /         /               797 (*3)    /           1700 (*4)
        Max row field size                             /         65535 (*2)          65535             /             /         /      65536       /         /         /         /               32767       /           8060 (*5)
        Best unicode ~varchar length                   4000      16377               65535             65535         65535     4046   32765       /         /         16000     32767           32739       /           4000

        *1 It is 767 in < 5.7, but that's so intolerably low when we consider Unicode that we cannot support it
        *2 ~8000 is defined as a limit but this doesn't count VARCHARs which use most of the space
        *3 This is on the default 4KB key size. It's tolerable on an 8KB page size (1615)
        *4 1700 only because we force non-clustered indexes, otherwise it is an unworkable 900
        *5 Only the first 24 bytes of strings are stored in the main rows, so practically the limit is higher

        Some limits depend on page size, and we are assuming nothing lower than the default one is chosen.

        */
    }
}

/**
 * Check a set of fields aren't going to exceed key limits.
 *
 * @param  ID_TEXT $table_name The table name
 * @param  boolean $primary_key Whether this will be in a primary key
 * @param  array $fields The fields (a map between field name and field type [field type must start '*' if it is to be counted])
 * @param  ID_TEXT $id_name The name of what we are checking (only used to generate clear error messages)
 * @param  boolean $skip_size_check Whether to skip the size check for the table (only do this for addon modules that don't need to support anything other than MySQL)
 * @param  boolean $skip_null_check Whether to skip the check for NULL string fields
 * @param  ?boolean $save_bytes Whether to use lower-byte table storage, with trade-offs of not being able to support all unicode characters; use this if key length is an issue (null: autodetect)
 * @param  boolean $return_on_error Whether to return on errors
 * @return boolean Whether the size limit is not exceeded
 *
 * @ignore
 */
function _check_sizes(string $table_name, bool $primary_key, array $fields, string $id_name, bool $skip_size_check = false, bool $skip_null_check = false, ?bool $save_bytes = false, bool $return_on_error = false) : bool
{
    // Check constraints
    $take_unicode_into_account = $save_bytes ? 3 : 4;
    $data_sizes = [
        // The maximum size fields could be from a database-neutral perspective
        'AUTO' => 4,
        'AUTO_LINK' => 4,
        'INTEGER' => 4,
        'UINTEGER' => 4,
        'REAL' => 4,
        'SHORT_INTEGER' => 2,
        'BINARY' => 1,
        'MEMBER' => 4,
        'GROUP' => 4,
        'TIME' => 4,
        'LONG_TRANS' => 4,
        'SHORT_TRANS' => 4,
        'LONG_TRANS__COMCODE' => 255 + 1,
        'SHORT_TRANS__COMCODE' => 255 + 1,
        'SHORT_TEXT' => 255 + 1,
        'TEXT' => 4000 + 1,
        'LONG_TEXT' => 1,
        'ID_TEXT' => 80 + 1,
        'MINIID_TEXT' => 40 + 1,
        'IP' => 15 + 1,
        'LANGUAGE_NAME' => 5 + 1,
        'URLPATH' => 255 + 1,
        'unicode_SHORT_TEXT' => $take_unicode_into_account * 255 + 1,
        'unicode_LONG_TEXT' => $take_unicode_into_account * 255 + 1,
        'unicode_ID_TEXT' => $take_unicode_into_account * 80 + 1,
        'unicode_IP' => $take_unicode_into_account * 15 + 1,
        'unicode_LANGUAGE_NAME' => $take_unicode_into_account * 5 + 1,
        'unicode_URLPATH' => $take_unicode_into_account * 255 + 1,
        'unicode_MD5' => $take_unicode_into_account * 33 + 1,
    ];
    $keywords = get_db_keywords();
    //if (in_array(cms_strtoupper_ascii($table_name), $keywords)) fatal_exit($table_name . ' is a keyword'); // No point, as we have table prefixes
    $key_size = 0;
    $total_size = 0;
    $key_size_unicode = 0;
    $total_size_unicode = 0;
    foreach ($fields as $name => $field) {
        $key = ($field[0] == '*');
        if ($key) {
            $field = substr($field, 1);
        }
        $full_text = ($field[0] == '#');
        if ($full_text) {
            $field = substr($field, 1);
        }
        $null = ($field[0] == '?');
        if ($null) {
            $field = substr($field, 1);
        }
        $size_restricted = (strpos($name, '(') !== false);
        if ($size_restricted) {
            $name = preg_replace('#\(.*\)$#', '', $name);
        }

        if ($key) {
            $key_size += $data_sizes[$field];
        }
        if (!isset($data_sizes[$field])) {
            $data_sizes[$field] = 10; // 10=arbitrary default
        }
        $total_size += $data_sizes[$field];
        if ($key) {
            $key_size_unicode += $data_sizes[(array_key_exists('unicode_' . $field, $data_sizes) ? 'unicode_' : '') . $field];
        }
        $total_size_unicode += $data_sizes[(array_key_exists('unicode_' . $field, $data_sizes) ? 'unicode_' : '') . $field];

        if (($null) && (!$skip_null_check) && (($field == 'LANGUAGE_NAME') || ($field == 'IP') || ($field == 'URLPATH') || ($field == 'TEXT') || (strpos($field, '_TEXT') !== false))) { // Needed for Oracle, really
            fatal_exit('You may not have a NULL string field');
        }
        /*if (($key) && (substr($id_name, 0, 1) != '#') && (!$size_restricted) && (($field == 'LONG_TEXT'))) {      We now size restrict using "(255)"
            fatal_exit('You may not use a ' . $field . ' field for part of a key');
        }*/
        if (($key) && ($primary_key) && ($null)) {
            fatal_exit('No field that may be NULL may be a part of a primary key');
        }
        if (in_array(cms_strtoupper_ascii($name), $keywords)) {
            fatal_exit($name . ' is a keyword');
        }
        if (preg_match('#^[\w]+$#', $name) == 0) {
            fatal_exit('Inappropriate identifier: ' . $name);
        }
        $name_len = strlen($name);
        if (strpos($field, '_TRANS') !== false) {
            $name_len += 13;
        }
        if ($name_len > DB_MAX_IDENTIFIER_LENGTH) {
            fatal_exit('Inappropriate identifier, too long: ' . $name);
        }
    }
    if ((!$skip_size_check) && (substr($id_name, 0, 1) != '#')) {
        if ($key_size > ($primary_key ? DB_MAX_PRIMARY_KEY_SIZE : DB_MAX_KEY_SIZE)) {
            if ($return_on_error) {
                return false;
            }
            fatal_exit('Key too long at ' . integer_format($key_size) . ' bytes [' . $id_name . ']'); // 252 for firebird
        }
        if (($total_size > DB_MAX_ROW_SIZE) && ($table_name != 'f_member_custom_fields')) {
            if ($return_on_error) {
                return false;
            }
            fatal_exit('Fieldset (row) too long at ' . integer_format($total_size) . ' bytes [' . $id_name . ']');
        }
        if ($key_size_unicode > DB_MAX_KEY_SIZE) {
            if ($return_on_error) {
                return false;
            }
            fatal_exit('Unicode version of key too long at ' . integer_format($key_size_unicode) . ' bytes [' . $id_name . ']'); // 252 for firebird
        }
        if (($total_size_unicode > DB_MAX_ROW_SIZE) && ($table_name != 'f_member_custom_fields')) {
            if ($return_on_error) {
                return false;
            }
            fatal_exit('Unicode version of fieldset (row) too long at ' . integer_format($total_size_unicode) . ' bytes [' . $id_name . ']');
        }
    }
    return true;
}

/**
 * Create a table with the given name and the given array of field name to type mappings.
 * If a field type starts '*', then it is part of that field's key. If it starts '?', then it is an optional field.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  array $fields The fields
 * @param  boolean $skip_size_check Whether to skip the size check for the table (only do this for addon modules that don't need to support anything other than MySQL)
 * @param  boolean $skip_null_check Whether to skip the check for NULL string fields
 * @param  ?boolean $save_bytes Whether to use lower-byte table storage, with trade-offs of not being able to support all unicode characters; use this if key length is an issue (null: auto-detect if needed). Pass as true/false for normal install code to make intentions explicit, maintenance code may use auto-detect.
 * @param  boolean $skip_fulltext_key_check Whether to skip checking if keys are appropriate for any auto-created fulltext indices
 *
 * @ignore
 */
function _helper_create_table(object $this_ref, string $table_name, array $fields, bool $skip_size_check = false, bool $skip_null_check = false, ?bool $save_bytes = false, bool $skip_fulltext_key_check = false)
{
    if (preg_match('#^[\w]+$#', $table_name) == 0) {
        fatal_exit('Inappropriate identifier: ' . $table_name); // (the +7 is for prefix: max length of 7 chars allocated for prefix)
    }
    if (strlen($table_name) + 7 > DB_MAX_IDENTIFIER_LENGTH) {
        fatal_exit('Inappropriate identifier, too long: ' . $table_name); // (the +7 is for prefix: max length of 7 chars allocated for prefix)
    }

    $_save_bytes = _helper_needs_to_save_bytes($table_name, $fields);
    if ($save_bytes === null) {
        $save_bytes = $_save_bytes;
    } else {
        if ($save_bytes != $_save_bytes) {
            warn_exit(protect_from_escaping('<kbd>$save_bytes</kbd> setting was ' . ($save_bytes ? 'not needed' : 'needed') . ' when creating table <kbd>' . escape_html($table_name) . '</kbd>'));
        }
    }

    if (!$skip_size_check) {
        _check_sizes($table_name, true, $fields, $table_name, false, false, $save_bytes);
    }

    // Note that interbase has a 31000byte limit on LONG_TEXT/LONG_TRANS, because we can't use blobs on it (those have too many restraints)

    $ins_m_table = [];
    $ins_m_name = [];
    $ins_m_type = [];
    $fields_copy = $fields;
    foreach ($fields_copy as $name => $type) {
        if (($type == 'AUTO') || ($type == '?AUTO')) {
            fatal_exit('AUTO fields must always be a key');
        }

        if ((strpos($type, '?') !== false) && (strpos($type, '*') !== false)) {
            fatal_exit('Fields cannot be both null and part of keys');
        }

        if (($type == '*AUTO') && ($name != 'id')) {
            fatal_exit('AUTO columns must always have a field name of \'id\''); // This is so the FUDGE done for sqlserver to switch identity columns can work
        }

        if (($table_name != 'db_meta') && ($table_name != 'db_meta_indices')) {
            $ins_m_table[] = $table_name;
            $ins_m_name[] = $name;
            $ins_m_type[] = $type;
        }

        if (!multi_lang_content()) {
            if (strpos($type, '_TRANS') !== false) {
                if (strpos($type, '__COMCODE') !== false) {
                    $fields[$name . '__text_parsed'] = 'LONG_TEXT';
                    $fields[$name . '__source_user'] = 'MEMBER';
                }

                $fields[$name] = 'LONG_TEXT'; // In the DB layer, it must now save as such
            }
        }
    }

    $this_ref->query_insert('db_meta', ['m_table' => $ins_m_table, 'm_name' => $ins_m_name, 'm_type' => $ins_m_type], false, true); // Allow errors because sometimes bugs when developing can call for this happening twice

    $this_ref->ensure_connected();

    $queries = $this_ref->driver->create_table__sql($this_ref->table_prefix . $table_name, $fields, $this_ref->connection_write, $table_name, $save_bytes);
    foreach ($queries as $sql) {
        $this_ref->query($sql);
    }

    // Considering tables in a DB reference may be in multiple (if they point to same actual DB's), make sure all our DB objects have their cache cleared
    if (isset($GLOBALS['SITE_DB'])) {
        unset($GLOBALS['SITE_DB']->table_exists_cache[$table_name]);
        unset($GLOBALS['SITE_DB']->table_exists_real_cache[$table_name]);
    }
    if (isset($GLOBALS['FORUM_DB'])) {
        unset($GLOBALS['FORUM_DB']->table_exists_cache[$table_name]);
        unset($GLOBALS['FORUM_DB']->table_exists_real_cache[$table_name]);
    }
    // Then safely update our own
    $this_ref->table_exists_cache[$table_name] = true;
    $this_ref->table_exists_real_cache[$table_name] = true;

    if (!multi_lang_content()) {
        foreach ($fields_copy as $name => $type) {
            if (strpos($type, '_TRANS') !== false) {
                $GLOBALS['SITE_DB']->create_index($table_name, '#' . $name, [$name], null, $skip_fulltext_key_check);
            }
        }
    }

    reload_lang_fields(false, $table_name, $fields);
}

/**
 * Add an index to a table without disturbing the contents, after the table has been created.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $index_name The index name
 * @param  array $fields The fields
 * @param  ?string $unique_key_fields Comma-separated names of the unique key field for the table (null: lookup)
 * @param  boolean $skip_fulltext_key_check Whether to skip checking if keys are appropriate for any auto-created fulltext indices
 *
 * @ignore
 */
function _helper_create_index(object $this_ref, string $table_name, string $index_name, array $fields, ?string $unique_key_fields = null, bool $skip_fulltext_key_check = false)
{
    $fields_with_types = [];
    if ($table_name != 'db_meta') {
        $db_types = collapse_2d_complexity('m_name', 'm_type', $this_ref->query_select('db_meta', ['m_name', 'm_type'], ['m_table' => $table_name]));

        $sized = false;
        foreach ($fields as $field_name) {
            if (strpos($field_name, '(') !== false) {
                $sized = true;
            }
            $_field_name = preg_replace('#\(.*\)$#', '', $field_name);

            $db_type = isset($db_types[$_field_name]) ? $db_types[$_field_name] : null;
            if ($db_type === null) {
                $db_type = 'INTEGER';
                if (running_script('install')) {
                    fatal_exit('It seems we are creating an index on a table & field combo that is not yet created (' . $table_name  . ' & ' . $_field_name . ').');
                }
            }
            if (substr($db_type, 0, 1) != '*') {
                $db_type = '*' . $db_type;
            }

            $fields_with_types[$field_name] = $db_type;
        }
        if (!$sized) {
            _check_sizes($table_name, false, $fields_with_types, $index_name, false, true, true/*indexes don't use so many bytes as keys somehow*/);
        }
    } else {
        $db_types = null;

        foreach ($fields as $field_name) {
            $fields_with_types[$field_name] = null;
        }
    }

    $keywords = get_db_keywords();
    if (in_array(cms_strtoupper_ascii(str_replace('#', '', $index_name)), $keywords)) {
        fatal_exit($index_name . ' is a keyword');
    }
    if (preg_match('#^[\#\w]+$#', $index_name) == 0) {
        fatal_exit('Inappropriate identifier: ' . $index_name);
    }
    if (strlen($index_name) + 7 > DB_MAX_IDENTIFIER_LENGTH) {
        fatal_exit('Inappropriate identifier, too long: ' . $index_name);
    }

    $ok_to_create = true;

    $is_full_text = ($index_name[0] == '#');

    $_fields = _helper_generate_index_fields($table_name, $fields_with_types, $is_full_text);

    $insert_map = ['i_table' => $table_name, 'i_name' => $index_name, 'i_fields' => implode(',', $fields)];
    $test = $this_ref->query_select('db_meta_indices', ['*'], $insert_map);
    if (!empty($test)) { // Already exists, so we'll do nothing (if you want to fix inconsistencies use the database repair tool)
        return;
    }
    $this_ref->query_insert('db_meta_indices', $insert_map);

    if ($_fields !== null) {
        $this_ref->ensure_connected();

        if ($unique_key_fields === null) {
            $unique_key_fields = implode(',', _helper_get_table_key_fields($table_name, $db_types));
        }

        // Check if it's a fulltext index that we do not have multiple
        if (($is_full_text) && (!$skip_fulltext_key_check) && (strpos($unique_key_fields, ',') !== false)) {
            fatal_exit('Fulltext indexes should only be on tables with a single key field');
        }

        $queries = $this_ref->driver->create_index__sql($this_ref->table_prefix . $table_name, $index_name, $_fields, $this_ref->connection_read, $table_name, $unique_key_fields, $this_ref->table_prefix);
        foreach ($queries as $i => $sql) {
            $this_ref->query($sql, null, 0, (strpos(get_db_type(), 'mysql') === false) && $is_full_text/*May fail on database backends that don't cleanup full-text well when dropping tables*/);
        }
    }
}

/**
 * Get the key tables for a table.
 *
 * @param  ID_TEXT $table_name Table name
 * @param  ?array $db_types Database types for whole table from meta registry (null: lookup as needed)
 * @return array List of key fields
 *
 * @ignore
 */
function _helper_get_table_key_fields(string $table_name, ?array $db_types = null) : array
{
    if ($db_types !== null) {
        $ret = [];
        foreach ($db_types as $key => $val) {
            if (substr($val, 0, 1) == '*') {
                $ret[] = $key;
            }
        }
        return $ret;
    }

    return collapse_1d_complexity('m_name', $GLOBALS['SITE_DB']->query_select('db_meta', ['m_name'], ['m_table' => $table_name], ' AND m_type LIKE \'' . db_encode_like('*%') . '\''));
}

/**
 * Generate an index field SQL snippet.
 *
 * @param  string $table_name The table name
 * @param  array $fields List of fields for the index
 * @param  boolean $is_full_text Whether the index is a full-text index
 * @return ?string The SQL (null: won't create index)
 *
 * @ignore
 */
function _helper_generate_index_fields(string $table_name, array $fields, bool $is_full_text) : ?string
{
    $_fields = '';
    foreach ($fields as $field_name => $db_type) {
        if ($_fields != '') {
            $_fields .= ',';
        }
        $_fields .= $field_name;

        if ($db_type !== null) {
            if (($is_full_text) && (multi_lang_content()) && (strpos($db_type, '_TRANS') !== false)) {
                return null; // We don't create a full-text index on *_TRANS fields if we are directing through the translate table
            }

            if ((strpos($field_name, '(') === false) && (!$is_full_text) && ((!multi_lang_content()) || (strpos($db_type, '_TRANS') === false))) {
                if (strpos($field_name, '(') === false) {
                    if ((strpos($db_type, 'TEXT') === 0) || (strpos($db_type, 'SHORT_TEXT') !== false) || (strpos($db_type, 'SHORT_TRANS') !== false) || (strpos($db_type, 'LONG_TEXT') !== false) || (strpos($db_type, 'LONG_TRANS') !== false) || (strpos($db_type, 'URLPATH') !== false)) {
                        $_fields .= '(250)'; // 255 would be too much with MySQL's UTF. Only MySQL supports index lengths, but the other drivers will strip them back out again.
                    }
                }
            }
        }
    }

    return $_fields;
}

/**
 * Delete an index from a table.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $index_name The index name
 *
 * @ignore
 */
function _helper_delete_index_if_exists(object $this_ref, string $table_name, string $index_name)
{
    $full_index_name = $index_name;
    if ($index_name[0] == '#') {
        $index_name = substr($index_name, 1);
    }

    $possible_final_index_names = [
        $index_name,

        // Some DB drivers have to make it globally unique via using table name in name
        $index_name . '__' . $table_name,
        $index_name . '__' . $this_ref->table_prefix . $table_name,
    ];

    foreach ($possible_final_index_names as $_index_name) {
        $query = $this_ref->driver->drop_index__sql($this_ref->table_prefix . $table_name, $_index_name);
        if ($query !== null) {
            $this_ref->query($query, null, 0, true); // Suppress errors in case does not exist
        }
    }

    $this_ref->query_delete('db_meta_indices', ['i_table' => $table_name, 'i_name' => $full_index_name]);
}

/**
 * Drop the given table, or if it doesn't exist, silently return.
 *
 * @param  object $this_ref Link to the real database object
 * @param  mixed $table The table name(s)
 *
 * @ignore
 */
function _helper_drop_table_if_exists(object $this_ref, $table)
{
    if (!is_array($table)) {
        $table = [$table];
    }

    $_tables = [];
    foreach ($table as $t) {
        if (($t != 'db_meta') && ($t != 'db_meta_indices')) {
            if ((!running_script('install')) && (multi_lang_content())) {
                require_code('lang3');
                $attrs = $this_ref->query_select('db_meta', ['m_name', 'm_type'], ['m_table' => $t]);
                $_attrs = [];
                foreach ($attrs as $attr) {
                    if (in_array(preg_replace('#[^\w]#', '', $attr['m_type']), ['SHORT_TRANS', 'LONG_TRANS', 'SHORT_TRANS__COMCODE', 'LONG_TRANS__COMCODE'])) {
                        $_attrs[] = $attr['m_name'];
                    }
                }
                mass_delete_lang($t, $_attrs, $this_ref);
            }

            // In case DB needs pre-cleanup for full-text indexes if they get left behind (for example)
            if (strpos(get_db_type(), 'mysql') === false) {
                $indices = $this_ref->query_select('db_meta_indices', ['*'], ['i_table' => $t]);
                foreach ($indices as $index) {
                    $this_ref->delete_index_if_exists($t, $index['i_name']);
                }
            }

            $this_ref->query_delete('db_meta', ['m_table' => $t]);
            $this_ref->query_delete('db_meta_indices', ['i_table' => $t]);
        }

        $this_ref->ensure_connected();

        unset($this_ref->table_exists_cache[$t]);
        unset($this_ref->table_exists_real_cache[$t]);

        $_tables[] = $this_ref->table_prefix . $t;
    }

    $queries = $this_ref->driver->drop_table_if_exists__sql($_tables);
    foreach ($queries as $sql) {
        $this_ref->query($sql, null, 0, true); // Might already exist so suppress errors
    }

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }
}

/**
 * Whether byte saving is needed for a particular table's fields.
 *
 * @param  ID_TEXT $table_name The table name
 * @param  array $fields Map of field names to types
 * @return boolean Whether byte saving is needed
 *
 * @ignore
 */
function _helper_needs_to_save_bytes(string $table_name, array $fields) : bool
{
    $save_bytes = false;
    if (!_check_sizes($table_name, true, $fields, $table_name, false, false, $save_bytes, true)) {
        $save_bytes = true;
    }
    return $save_bytes;
}

/**
 * Rename the given table.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $old The old table name
 * @param  ID_TEXT $new The new table name
 *
 * @ignore
 */
function _helper_rename_table(object $this_ref, string $old, string $new)
{
    $query = $this_ref->driver->rename_table__sql($this_ref->table_prefix . $old, $this_ref->table_prefix . $new);
    $this_ref->query($query);

    $this_ref->query_update('db_meta', ['m_table' => $new], ['m_table' => $old]);
    $this_ref->query_update('db_meta_indices', ['i_table' => $new], ['i_table' => $old]);

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }
}

/**
 * Adds a field to an existing table.
 * Note: this function cannot add a new AUTO key, use add_auto_key for that.
 * Note: this function cannot change the keys in the database on its own (use change_primary_key for that), although you should include * if something will be a key.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $name The field name
 * @param  ID_TEXT $type The field type
 * @param  ?mixed $default The default value; for a translatable field should still be a string value (null: null default / default default)
 * @ignore
 */
function _helper_add_table_field(object $this_ref, string $table_name, string $name, string $type, $default = null)
{
    if ($type == '*AUTO') {
        fatal_exit('Cannot add a new AUTO field to an existing table using add_table_field, use add_auto_key');
    }

    if (($type == 'AUTO') || ($type == '?AUTO')) {
        fatal_exit('AUTO fields must always be a key');
    }

    if ((strpos($type, '?') !== false) && (strpos($type, '*') !== false)) {
        fatal_exit('Fields cannot be both null and part of keys');
    }

    if (($type == '*AUTO') && ($name != 'id')) {
        fatal_exit('AUTO columns must always have a field name of \'id\'');
    }

    if (($default === null) && (substr($type, 0, 1) != '?')) {
        $default = $this_ref->driver->get_implicit_field_default($type);
    }

    $query = $this_ref->driver->add_table_field__sql($this_ref->table_prefix . $table_name, $name, $type, $default);
    $this_ref->query($query);

    // If adding a translatable field to a multi-lang-content site we need to populate blank strings into the translate table for each field instance
    if ((multi_lang_content()) && ($default !== null) && (strpos($type, '_TRANS') !== false)) {
        $lang_level = 3;

        $key_sql = 'SELECT m_name FROM ' . $this_ref->table_prefix . 'db_meta WHERE m_type LIKE \'*%\' AND ' . db_string_equal_to('m_table', $table_name);
        $key_fields = $this_ref->query($key_sql);
        $key_select = collapse_1d_complexity('m_name', $key_fields);

        $start = 0;
        do {
            $rows = $this_ref->_query('SELECT ' . implode(',', $key_select) . ' FROM ' . $this_ref->table_prefix . $table_name, 1000, $start);
            if ($rows === null) {
                break; // Issue inside upgrader
            }
            foreach ($rows as $row) {
                $this_ref->query_update($table_name, insert_lang($name, $default, $lang_level), $row);
            }
            $start += 1000;
        } while (!empty($rows));
    }

    // Insert into meta-database
    $this_ref->query_insert('db_meta', ['m_table' => $table_name, 'm_name' => $name, 'm_type' => $type]);
    reload_lang_fields(false, $table_name);

    // Add full-text search for any translatable field
    if (strpos($type, '_TRANS') !== false) {
        $GLOBALS['SITE_DB']->create_index($table_name, '#' . $name, [$name]);
    }

    // For Comcode fields on non-multi-lang-content sites we need to add some additional fields
    if ((!multi_lang_content()) && (strpos($type, '__COMCODE') !== false)) {
        foreach (['text_parsed' => 'LONG_TEXT', 'source_user' => 'MEMBER'] as $_sub_name => $sub_type) {
            $sub_name = $name . '__' . $_sub_name;

            $sub_default = mixed();
            if ($sub_type == 'LONG_TEXT') {
                $sub_default = '';
            } else {
                $sub_default = db_get_first_id();
            }

            $query = $this_ref->driver->add_table_field__sql($this_ref->table_prefix . $table_name, $sub_name, $sub_type, $sub_default);
            $this_ref->query($query);
        }
    }

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }
}

/**
 * Change the type of a DB field in a table.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $name The field name
 * @param  ID_TEXT $type The new field type
 * @param  ?ID_TEXT $new_name The new field name (null: leave name)
 * @return boolean Whether we failed to set an auto-increment
 * @ignore
 */
function _helper_alter_table_field(object $this_ref, string $table_name, string $name, string $type, ?string $new_name = null) : bool
{
    if (($type == 'AUTO') || ($type == '?AUTO')) {
        fatal_exit('AUTO fields must always be a key');
    }

    if ((strpos($type, '?') !== false) && (strpos($type, '*') !== false)) {
        fatal_exit('Fields cannot be both null and part of keys');
    }

    if (($type == '*AUTO') && ($name != 'id')) {
        fatal_exit('AUTO columns must always have a field name of \'id\'');
    }

    $type_remap = $this_ref->driver->get_type_remap(true);

    // Handle renaming of special Comcode fields on non-multi-lang-content sites
    if ((strpos($type, '__COMCODE') !== false) && ($new_name != $name) && (!multi_lang_content())) {
        foreach (['text_parsed' => 'LONG_TEXT', 'source_user' => 'MEMBER'] as $sub_name => $sub_type) {
            $sub_old_name = $name . '__' . $sub_name;
            $sub_new_name = $new_name . '__' . $sub_name;

            $db_type = $type_remap[$sub_type];

            $is_autoincrement = false;
            $queries = $this_ref->driver->alter_table_field__sql($this_ref->table_prefix . $table_name, $sub_old_name, $db_type, false, $is_autoincrement, $sub_new_name);
            foreach ($queries as $query) {
                $this_ref->_query($query);
            }
        }
    }

    // Work out field type
    $_type = $type;
    if ((strpos($type, '_TRANS') !== false) && (!multi_lang_content())) {
        $_type = 'LONG_TEXT'; // In the DB layer, it must now save as such
    }
    $__type = str_replace(['*', '?'], ['', ''], $_type);
    $db_type = $type_remap[$__type];

    // Work out and run SQL
    $is_autoincrement = ($_type == '*AUTO');
    $queries = $this_ref->driver->alter_table_field__sql($this_ref->table_prefix . $table_name, $name, $db_type, $_type[0] == '?', $is_autoincrement, ($new_name === null) ? $name : $new_name);
    foreach ($queries as $query) {
        $this_ref->_query($query);
    }

    // Adjust meta database
    $update_map = ['m_type' => $type];
    if ($new_name !== null) {
        $update_map['m_name'] = $new_name;
    }
    $this_ref->query_update('db_meta', $update_map, ['m_table' => $table_name, 'm_name' => $name]);

    // Adjust indices in meta database
    if ($new_name !== null) {
        $indices = $this_ref->query_select('db_meta_indices', ['*'], ['i_table' => $table_name]);
        foreach ($indices as $index) {
            $changed_index = false;
            $fields = explode(',', $index['i_fields']);
            foreach ($fields as &$field) {
                if ($field == $name) {
                    $field = $new_name;
                    $changed_index = true;
                }
            }
            if ($changed_index) {
                $this_ref->query_update('db_meta_indices', ['i_fields' => implode(',', $fields)], ['i_table' => $table_name, 'i_name' => $index['i_name']]);
            }
        }
    }

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }

    return ($is_autoincrement === null);
}

/**
 * Change the primary key of a table.
 * Note: this function cannot initialise a new AUTO key, use add_auto_key for that.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The name of the table to create the index on
 * @param  array $new_key A list of fields to put in the new key
 *
 * @ignore
 */
function _helper_change_primary_key(object $this_ref, string $table_name, array $new_key)
{
    $this_ref->ensure_connected();

    $this_ref->query('UPDATE ' . $this_ref->table_prefix . 'db_meta SET m_type=' . db_function('REPLACE', ['m_type', '\'*\'', '\'\'']) . ' WHERE ' . db_string_equal_to('m_table', $table_name));
    foreach ($new_key as $_new_key) {
        $this_ref->query('UPDATE ' . $this_ref->table_prefix . 'db_meta SET m_type=' . db_function('CONCAT', ['\'*\'', 'm_type']) . ' WHERE ' . db_string_equal_to('m_table', $table_name) . ' AND ' . db_string_equal_to('m_name', $_new_key) . ' AND m_type NOT LIKE \'' . db_encode_like('*%') . '\'');
    }

    $queries = $this_ref->driver->change_primary_key__sql($this_ref->table_prefix, $table_name, $new_key);
    foreach ($queries as $sql) {
        $this_ref->query($sql);
    }
}

/**
 * Use an *AUTO key for a table that had some other key before.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name Table name
 * @param  ID_TEXT $field_name Field name for new key, must always be 'id'
 *
 * @ignore
 */
function _helper_add_auto_key(object $this_ref, string $table_name, string $field_name)
{
    push_query_limiting(false);

    if ($field_name != 'id') {
        fatal_exit('AUTO columns must always have a field name of \'id\'');
    }

    // Current key fields
    $key_sql = 'SELECT m_name FROM ' . $this_ref->table_prefix . 'db_meta WHERE m_type LIKE \'*%\' AND ' . db_string_equal_to('m_table', $table_name);
    $key_fields = $this_ref->query($key_sql);
    $key_select = collapse_1d_complexity('m_name', $key_fields);

    // Add integer field, as it is a safe op (auto_increment must be part of active key, and we already have a key)
    $this_ref->add_table_field($table_name, $field_name, 'INTEGER');

    // But it does need to be unique
    $start = 0;
    $i = db_get_first_id();
    do {
        $rows = $this_ref->query_select($table_name, empty($key_select) ? ['*'] : $key_select, [], '', 100, $start);
        foreach ($rows as $row) {
            $this_ref->query_update($table_name, [$field_name => $i], $row, '', 1);
            $i++;
        }
        $start += 100;
    } while (!empty($rows));

    // Set the new key
    $this_ref->change_primary_key($table_name, [$field_name]);

    // Switch to auto_increment in DB, and update meta DB
    $failed_autoincrement = $this_ref->alter_table_field($table_name, $field_name, '*AUTO');

    // Rebuild whole table?
    if ($failed_autoincrement) {
        rebuild_table_from_meta_database($this_ref, $table_name);
    }
}

/**
 * Rebuild a table from the metadata in the meta database.
 *
 * @param  object $db Link to the real database object
 * @param  ID_TEXT $table_name The table name
 */
function rebuild_table_from_meta_database(object $db, string $table_name)
{
    $fields = $db->query_select('db_meta', ['*'], ['m_table' => $table_name]);
    $indexes = $db->query_select('db_meta_indices', ['*'], ['i_table' => $table_name]);

    $table_name_old = $table_name . '__old';

    $db->rename_table($table_name, $table_name_old);

    $db->create_table($table_name, collapse_2d_complexity('m_name', 'm_type', $fields));

    $start = 0;
    $max = 50;
    do {
        $rows = $db->query_select($table_name, ['*'], [], '', $max, $start);
        foreach ($rows as $row) {
            $db->query_insert($table_name_old, $row);
        }
        $start += $max;
    } while (count($rows) == $max);

    foreach ($indexes as $index) {
        $fields = explode(',', $index['i_fields']);
        $GLOBALS['SITE_DB']->create_index($index['i_table'], $index['i_name'], $fields);
    }

    $db->drop_table_if_exists($table_name_old);
}

/**
 * If a text field has picked up Comcode support, we will need to run this.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $name The field name
 * @param  ID_TEXT $key The tables key field name
 * @param  integer $level The translation level to use
 * @set 1 2 3 4
 * @param  boolean $in_assembly Whether our data is already stored in Tempcode assembly format
 *
 * @ignore
 */
function _helper_promote_text_field_to_comcode(object $this_ref, string $table_name, string $name, string $key = 'id', int $level = 2, bool $in_assembly = false)
{
    $rows = $this_ref->query_select($table_name, [$name, $key]);
    if ($rows === null) {
        return; // Issue in upgrader
    }
    $this_ref->delete_table_field($table_name, $name);
    $this_ref->add_table_field($table_name, $name, 'SHORT_TRANS__COMCODE');
    foreach ($rows as $row) {
        if ($in_assembly) {
            $map = insert_lang($name, '', $level, $this_ref, true, null, null, false, null, $row[$name]);
        } else {
            $map = insert_lang($name, $row[$name], $level, $this_ref);
        }
        $this_ref->query_update($table_name, $map, [$key => $row[$key]]);
    }

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }
}

/**
 * Delete the specified field from the specified table.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $table_name The table name
 * @param  ID_TEXT $name The field name
 *
 * @ignore
 */
function _helper_delete_table_field(object $this_ref, string $table_name, string $name)
{
    $type = $this_ref->query_select_value_if_there('db_meta', 'm_type', ['m_table' => $table_name, 'm_name' => $name]);
    if ($type === null) {
        $type = 'SHORT_TEXT';
    }

    if ((strpos($type, '_TRANS') !== false) && (multi_lang_content())) {
        require_code('lang3');
        mass_delete_lang($table_name, [$name], $this_ref);
    }

    $fields_to_delete = [$name];
    if (strpos($type, '_TRANS__COMCODE') !== false) {
        if (!multi_lang_content()) {
            $fields_to_delete[] = $name . '__text_parsed';
            $fields_to_delete[] = $name . '__source_user';
        }
    }

    foreach ($fields_to_delete as $_name) {
        $query = $this_ref->driver->alter_delete_table_field__sql($this_ref->table_prefix . $table_name, $_name);
        $this_ref->query($query);
    }

    $this_ref->query_delete('db_meta', ['m_table' => $table_name, 'm_name' => $name]);
    $this_ref->query_delete('db_meta_indices', ['i_table' => $table_name, 'i_fields' => $name]);

    if (function_exists('persistent_cache_delete')) {
        persistent_cache_delete('TABLE_LANG_FIELDS_CACHE');
    }
}

/**
 * If we've changed what $type is stored as, this function will need to be called to change the typing in the DB.
 *
 * @param  object $this_ref Link to the real database object
 * @param  ID_TEXT $type The field type
 *
 * @ignore
 */
function _helper_refresh_field_definition(object $this_ref, string $type)
{
    $do = [];
    $rows = $this_ref->query_select('db_meta', ['*'], ['m_type' => $type]);
    foreach ($rows as $row) {
        $do[] = [$row['m_table'], $row['m_name']];
    }

    foreach ($do as $it) {
        $this_ref->alter_table_field($it[0], $it[1], $type);
    }
}

/**
 * Returns a list of keywords for all databases we might some day support.
 *
 * @return array List of pairs
 */
function get_db_keywords() : array
{
    $words = [
        'ABSOLUTE', 'ACCESS', 'ACCESSIBLE', 'ACTION', 'ACTIVE', 'ADA', 'ADD', 'ADMIN',
        'AFTER', 'ALIAS', 'ALL', 'ALLOCATE', 'ALLOW', 'ALPHANUMERIC', 'ALTER', 'ANALYSE',
        'ANALYZE', 'AND', 'ANY', 'APPLICATION', 'ARE', 'ARITH_OVERFLOW', 'ARRAY', 'AS',
        'ASC', 'ASCENDING', 'ASENSITIVE', 'ASSERTION', 'ASSISTANT', 'ASSOCIATE', 'ASUTIME', 'ASYMMETRIC',
        'ASYNC', 'AT', 'ATOMIC', 'AUDIT', 'AUTHORIZATION', 'AUTO', 'AUTODDL', 'AUTOINCREMENT',
        'AUX', 'AUXILIARY', 'AVG', 'BACKUP', 'BASED', 'BASENAME', 'BASE_NAME', 'BEFORE',
        'BEGIN', 'BETWEEN', 'BIGINT', 'BINARY', 'BIT', 'BIT_LENGTH', 'BLOB', 'BLOBEDIT',
        'BOOLEAN', 'BOTH', 'BOTTOM', 'BREADTH', 'BREAK', 'BROWSE', 'BUFFER', 'BUFFERPOOL',
        'BULK', 'BY', 'BYTE', 'CACHE', 'CALL', 'CALLED', 'CAPABILITY', 'CAPTURE',
        'CASCADE', 'CASCADED', 'CASE', 'CAST', 'CATALOG', 'CCSID', 'CHANGE', 'CHAR',
        'CHARACTER', 'CHARACTER_LENGTH', 'CHAR_CONVERT', 'CHAR_LENGTH', 'CHECK', 'CHECKPOINT', 'CHECK_POINT_LEN', 'CHECK_POINT_LENGTH',
        'CLOB', 'CLOSE', 'CLUSTER', 'CLUSTERED', 'COALESCE', 'COLLATE', 'COLLATION', 'COLLECTION',
        'COLLID', 'COLUMN', 'COLUMNS', 'COMMENT', 'COMMIT', 'COMMITTED', 'COMPACTDATABASE', 'COMPILETIME',
        'COMPLETION', 'COMPRESS', 'COMPUTE', 'COMPUTED', 'CONCAT', 'CONDITION', 'CONDITIONAL', 'CONFIRM',
        'CONFLICT', 'CONNECT', 'CONNECTION', 'CONSTRAINT', 'CONSTRAINTS', 'CONSTRUCTOR', 'CONTAINER', 'CONTAINING',
        'CONTAINS', 'CONTAINSTABLE', 'CONTINUE', 'CONTROLROW', 'CONVERT', 'CORRESPONDING', 'COUNT', 'COUNTER',
        'CREATE', 'CREATEDATABASE', 'CREATEFIELD', 'CREATEGROUP', 'CREATEINDEX', 'CREATEOBJECT', 'CREATEPROPERTY', 'CREATERELATION',
        'CREATETABLEDEF', 'CREATEUSER', 'CREATEWORKSPACE', 'CROSS', 'CSTRING', 'CUBE', 'CURRENCY', 'CURRENT',
        'CURRENTUSER', 'CURRENT_DATE', 'CURRENT_DEFAULT_TRANSFORM_GROUP', 'CURRENT_LC_CTYPE', 'CURRENT_PATH', 'CURRENT_ROLE', 'CURRENT_TIME', 'CURRENT_TIMESTAMP',
        'CURRENT_TRANSFORM_GROUP_FOR_TYPE', 'CURRENT_USER', 'CURSOR', 'CYCLE', 'DATA', 'DATABASE', 'DATABASES', 'DATA_PGS',
        'DATE', 'DATETIME', 'DAY',/*'DAYS',*/
        'DAY_HOUR', 'DAY_MICROSECOND', 'DAY_MINUTE', 'DAY_SECOND',
        'DB2SQL', 'DBCC', 'DBINFO', 'DBSPACE', 'DB_KEY', 'DEALLOCATE', 'DEBUG', 'DEC',
        'DECIMAL', 'DECLARE', 'DEFAULT', 'DEFERRABLE', 'DEFERRED', 'DELAYED', 'DELETE', 'DELETING',
        'DENY', 'DEPTH', 'DEREF', 'DESC', 'DESCENDING', 'DESCRIBE',/*'DESCRIPTION',*/
        'DESCRIPTOR',
        'DETERMINISTIC', 'DIAGNOSTICS', 'DICTIONARY', 'DISALLOW', 'DISCONNECT', 'DISK', 'DISPLAY', 'DISTINCT',
        'DISTINCTROW', 'DISTRIBUTED', 'DIV', 'DO', 'DOCUMENT', 'DOMAIN', 'DOUBLE', 'DROP',
        'DSNHATTR', 'DSSIZE', 'DUAL', 'DUMMY', 'DUMP', 'DYNAMIC', 'EACH', 'ECHO',
        'EDIT', 'EDITPROC', 'ELEMENT', 'ELSE', 'ELSEIF', 'ENCLOSED', 'ENCODING', 'ENCRYPTED',
        'ENCRYPTION', 'END', 'END-EXEC', 'ENDIF', 'ENDING', 'ENDTRAN', 'ENTRY_POINT', 'EQUALS',
        'EQV', 'ERASE', 'ERRLVL', 'ERROR', 'ERROREXIT', 'ESCAPE', 'ESCAPED', 'EVENT',
        'EXCEPT', 'EXCEPTION', 'EXCLUSIVE', 'EXEC', 'EXECUTE', 'EXISTING', 'EXISTS', 'EXIT',
        'EXPLAIN', 'EXTERN', 'EXTERNAL', 'EXTERNLOGIN', 'EXTRACT', 'FALSE', 'FENCED', 'FETCH',
        'FIELD', 'FIELDPROC', 'FIELDS', 'FILE', 'FILLCACHE', 'FILLFACTOR', 'FILTER', 'FINAL',
        'FIRST', 'FLOAT', 'FLOAT4', 'FLOAT8', 'FLOPPY', 'FOR', 'FORCE', 'FOREIGN',
        'FORM', 'FORMS', 'FORTRAN', 'FORWARD', 'FOUND', 'FREE', 'FREETEXT', 'FREETEXTTABLE',
        'FREEZE', 'FREE_IT', 'FROM', 'FULL', 'FULLTEXT', 'FUNCTION', 'GDSCODE', 'GENERAL',
        'GENERATED', 'GENERATOR', 'GEN_ID',/*'GET',*/
        'GETOBJECT', 'GETOPTION', 'GLOB', 'GLOBAL',
        'GO', 'GOTO', 'GOTOPAGE', 'GRANT', 'GROUP', 'GROUPING', 'GROUP_COMMIT_WAIT', 'GROUP_COMMIT_WAIT_TIME',
        'GUID', 'HANDLER', 'HAVING', 'HELP', 'HIGH_PRIORITY', 'HOLD', 'HOLDLOCK', 'HOUR',
        'HOURS', 'HOUR_MICROSECOND', 'HOUR_MINUTE', 'HOUR_SECOND', 'IDENTIFIED', 'IDENTITY', 'IDENTITYCOL', 'IDENTITY_INSERT',
        'IDLE', 'IEEEDOUBLE', 'IEEESINGLE', 'IF', 'IGNORE', 'ILIKE', 'IMMEDIATE', 'IMP',
        'IN', 'INACTIVE', 'INCLUDE', 'INCLUSIVE', 'INCREMENT', 'INDEX', 'INDEXES', 'INDEX_LPAREN',
        'INDICATOR', 'INFILE', 'INHERIT', 'INIT', 'INITIAL', 'INITIALLY', 'INNER', 'INOUT',
        'INPUT', 'INPUT_TYPE', 'INSENSITIVE', 'INSERT', 'INSERTING', 'INSERTTEXT', 'INSTALL', 'INSTEAD',
        'INT', 'INT1', 'INT2', 'INT3', 'INT4', 'INT8', 'INTEGER', 'INTEGER1',
        'INTEGER2', 'INTEGER4', 'INTEGRATED', 'INTERSECT', 'INTERVAL', 'INTO', 'IQ', 'IS',
        'ISNULL', 'ISOBID', 'ISOLATION', 'ISQL', 'ITERATE', 'JAR', 'JAVA', 'JOIN',
        'KEY', 'KEYS', 'KILL', 'LABEL',/*'LANGUAGE',*/
        'LARGE', 'LAST', 'LASTMODIFIED',
        'LATERAL', 'LC_CTYPE', 'LC_MESSAGES', 'LC_TYPE', 'LEADING', 'LEAVE', 'LEFT', 'LENGTH',
        'LESS', 'LEV', 'LEVEL', 'LIKE', 'LIMIT', 'LINEAR', 'LINENO', 'LINES',
        'LOAD', 'LOCAL', 'LOCALE', 'LOCALTIME', 'LOCALTIMESTAMP', 'LOCATOR', 'LOCATORS', 'LOCK',
        'LOCKMAX', 'LOCKSIZE', 'LOGFILE', 'LOGICAL', 'LOGICAL1', 'LOGIN', 'LOG_BUFFER_SIZE', 'LOG_BUF_SIZE',
        'LONG', 'LONGBINARY', 'LONGBLOB', 'LONGTEXT', 'LOOP', 'LOWER', 'LOW_PRIORITY', 'MACRO',
        'MAINTAINED', 'MANUAL', 'MAP', 'MATCH', 'MATERIALIZED', 'MAX', 'MAXEXTENTS', 'MAXIMUM',
        'MAXIMUM_SEGMENT', 'MAX_SEGMENT', 'MEDIUMBLOB', 'MEDIUMINT', 'MEDIUMTEXT', 'MEMBER', 'MEMBERSHIP', 'MEMO',
        'MERGE', 'MESSAGE', 'METHOD', 'MICROSECOND', 'MICROSECONDS', 'MIDDLEINT', 'MIN', 'MINIMUM',
        'MINUS', 'MINUTE', 'MINUTES', 'MINUTE_MICROSECOND', 'MINUTE_SECOND', 'MIRROR', 'MIRROREXIT', 'MLSLABEL',
        'MOD', 'MODE', 'MODIFIES', 'MODIFY', 'MODULE', 'MODULE_NAME', 'MONEY', 'MONTH',
        'MONTHS', 'MOVE', 'MULTISET',/*'NAME',*/
        'NAMES', 'NATIONAL', 'NATURAL', 'NCHAR',
        'NCLOB', 'NEW', 'NEWPASSWORD', 'NEXT', 'NEXTVAL', 'NO', 'NOAUDIT', 'NOAUTO',
        'NOCHECK', 'NOCOMPRESS', 'NOHOLDLOCK', 'NONCLUSTERED', 'NONE', 'NOT', 'NOTIFY', 'NOTNULL',
        'NOWAIT', 'NO_WRITE_TO_BINLOG', 'NULL', 'NULLIF', 'NULLS', 'NUMBER', 'NUMERIC', 'NUMERIC_TRUNCATION',
        'NUMPARTS', 'NUM_LOG_BUFFERS', 'NUM_LOG_BUFS', 'OBID', 'OBJECT', 'OCTET_LENGTH', 'OF', 'OFF',
        'OFFLINE', 'OFFSET', 'OFFSETS', 'OID', 'OLD', 'OLEOBJECT', 'ON', 'ONCE',
        'ONLINE', 'ONLY', 'OPEN', 'OPENDATASOURCE', 'OPENQUERY', 'OPENRECORDSET', 'OPENROWSET', 'OPENXML',
        'OPERATION', 'OPERATORS', 'OPTIMIZATION', 'OPTIMIZE', 'OPTION', 'OPTIONALLY', 'OPTIONS', 'OR',
        'ORDER', 'ORDINALITY', 'OTHERS', 'OUT', 'OUTER', 'OUTFILE', 'OUTPUT', 'OUTPUT_TYPE',
        'OVER', 'OVERFLOW', 'OVERLAPS', 'OWNERACCESS', 'PACKAGE', 'PAD', 'PADDED', 'PAGE',
        'PAGELENGTH',/*'PAGES',*/
        'PAGE_SIZE', 'PARAMETER', 'PARAMETERS', 'PART', 'PARTIAL', 'PARTITION',
        'PARTITIONED', 'PARTITIONING', 'PASCAL', 'PASSTHROUGH', 'PASSWORD',/*'PATH',*/
        'PCTFREE', 'PENDANT',
        'PERCENT', 'PERM', 'PERMANENT', 'PIECESIZE', 'PIPE', 'PIVOT', 'PLACING', 'PLAN',
        'POSITION', 'POST_EVENT', 'PRECISION', 'PREORDER', 'PREPARE', 'PRESERVE', 'PREVVAL', 'PRIMARY',
        'PRINT', 'PRIOR', 'PRIQTY', 'PRIVATE', 'PRIVILEGES', 'PROC', 'PROCEDURE', 'PROCESSEXIT',
        'PROGRAM', 'PROPERTY', 'PROTECTED', 'PSID', 'PUBLIC', 'PUBLICATION', 'PURGE', 'QUERIES',
        'QUERY', 'QUERYNO', 'QUIT', 'RAID0', 'RAISERROR', 'RANGE', 'RAW', 'RAW_PARTITIONS',
        'READ', 'READS', 'READTEXT', 'READ_ONLY', 'READ_WRITE', 'REAL', 'RECALC', 'RECONFIGURE',
        'RECORDSET', 'RECORD_VERSION', 'RECURSIVE', 'REF', 'REFERENCE', 'REFERENCES', 'REFERENCING', 'REFRESH',
        'REFRESHLINK', 'REGEXP', 'REGISTERDATABASE', 'RELATION', 'RELATIVE', 'RELEASE', 'REMOTE', 'REMOVE',
        'RENAME', 'REORGANIZE', 'REPAINT', 'REPAIRDATABASE', 'REPEAT', 'REPEATABLE', 'REPLACE', 'REPLICATION',
        'REPORT', 'REPORTS', 'REQUERY', 'REQUIRE', 'RESERV', 'RESERVED_PGS', 'RESERVING', 'RESIGNAL',
        'RESOURCE', 'RESTORE', 'RESTRICT', 'RESULT', 'RESULT_SET_LOCATOR', 'RETAIN', 'RETURN', 'RETURNING_VALUES',
        'RETURNS', 'REVOKE', 'RIGHT', 'RLIKE', 'ROLE', 'ROLLBACK', 'ROLLUP', 'ROUTINE',
        'ROW', 'ROWCNT', 'ROWCOUNT', 'ROWGUIDCOL', 'ROWID', 'ROWLABEL', 'ROWNUM', 'ROWS',
        'ROWSET', 'RULE', 'RUN', 'RUNTIME', 'SAVE', 'SAVEPOINT', 'SCHEMA', 'SCHEMAS',
        'SCOPE', 'SCRATCHPAD', 'SCREEN', 'SCROLL', 'SEARCH', 'SECOND', 'SECONDS', 'SECOND_MICROSECOND',
        'SECQTY',/*'SECTION',*/
        'SECURITY', 'SELECT', 'SENSITIVE', 'SEPARATOR', 'SEQUENCE', 'SERIALIZABLE',
        'SESSION', 'SESSION_USER', 'SET', 'SETFOCUS', 'SETOPTION', 'SETS', 'SETUSER', 'SHADOW',
        'SHARE', 'SHARED', 'SHELL', 'SHORT', 'SHOW', 'SHUTDOWN', 'SIGNAL', 'SIMILAR',
        'SIMPLE', 'SINGLE', 'SINGULAR', 'SIZE', 'SMALLINT', 'SNAPSHOT', 'SOME', 'SONAME',
        'SORT', 'SOURCE', 'SPACE', 'SPATIAL', 'SPECIFIC', 'SPECIFICTYPE', 'SQL', 'SQLCA',
        'SQLCODE', 'SQLERROR', 'SQLEXCEPTION', 'SQLSTATE', 'SQLWARNING', 'SQL_BIG_RESULT', 'SQL_CALC_FOUND_ROWS', 'SQL_SMALL_RESULT',
        'SSL', 'STABILITY', 'STANDARD', 'START', 'STARTING', 'STARTS', 'STATE', 'STATEMENT',
        'STATIC', 'STATISTICS', 'STAY', 'STDEV', 'STDEVP', 'STOGROUP', 'STOP', 'STORES',
        'STRAIGHT_JOIN', 'STRING', 'STRIPE', 'STRUCTURE', 'STYLE', 'SUBMULTISET', 'SUBPAGES', 'SUBSTRING',
        'SUBTRANS', 'SUBTRANSACTION', 'SUB_TYPE', 'SUCCESSFUL', 'SUM', 'SUMMARY', 'SUSPEND', 'SYB_IDENTITY',
        'SYB_RESTREE', 'SYMMETRIC', 'SYNCHRONIZE', 'SYNONYM', 'SYNTAX_ERROR', 'SYSDATE', 'SYSFUN', 'SYSIBM',
        'SYSPROC', 'SYSTEM', 'SYSTEM_USER', 'TABLE', 'TABLEDEF', 'TABLEDEFS', 'TABLEID', 'TABLES',
        'TABLESAMPLE', 'TABLESPACE', 'TAPE', 'TEMP', 'TEMPORARY', 'TERMINATED', 'TERMINATOR', 'TEST',
        'TEXT', 'TEXTSIZE', 'THEN', 'THERE', 'TIME', 'TIMESTAMP', 'TIMEZONE_HOUR', 'TIMEZONE_MINUTE',
        'TINYBLOB', 'TINYINT', 'TINYTEXT', 'TO', 'TOP', 'TRAILING', 'TRAN', 'TRANSACTION',
        'TRANSFORM', 'TRANSLATE', 'TRANSLATION', 'TREAT', 'TRIGGER', 'TRIM', 'TRUE', 'TRUNCATE',
        'TSEQUAL', 'TYPE', 'UID', 'UNBOUNDED', 'UNCOMMITTED', 'UNDER', 'UNDO', 'UNION',
        'UNIQUE', 'UNIQUEIDENTIFIER', 'UNKNOWN', 'UNLOCK', 'UNNEST', 'UNSIGNED', 'UNTIL', 'UPDATE',
        'UPDATETEXT', 'UPDATING', 'UPGRADE', 'UPPER', 'USAGE', 'USE', 'USED_PGS', 'USER',
        'USER_OPTION', 'USING', 'UTC_DATE', 'UTC_TIME', 'UTC_TIMESTAMP', 'VALIDATE', 'VALIDPROC', 'VALUE',
        'VALUES', 'VAR', 'VARBINARY', 'VARCHAR', 'VARCHAR2', 'VARCHARACTER', 'VARIABLE', 'VARIANT',
        'VARP', 'VARYING', 'VCAT', 'VERBOSE', 'VERSION', 'VIEW', 'VIRTUAL', 'VISIBLE',
        'VOLATILE', 'VOLUMES', 'WAIT', 'WAITFOR', 'WEEKDAY', 'WHEN', 'WHENEVER', 'WHERE',
        'WHILE', 'WINDOW', 'WITH', 'WITHIN', 'WITHOUT', 'WITH_CUBE', 'WITH_LPAREN', 'WITH_ROLLUP',
        'WLM', 'WORK', 'WORKSPACE', 'WRITE', 'WRITETEXT', 'X509', 'XMLELEMENT', 'XOR',
        'YEAR', 'YEARDAY', 'YEARS', 'YEAR_MONTH', 'YES', 'YESNO', 'ZEROFILL', 'ZONE', 'GET',

        // Added in MySQL 5.7
        'ACCOUNT', 'ALWAYS', 'CHANNEL', 'COMPRESSION', 'ENCRYPTION', 'FILE_BLOCK_SIZE', 'FILTER', 'FOLLOWS', 'GENERATED',
        'GROUP_REPLICATION', 'INSTANCE', 'JSON', 'MASTER_TLS_VERSION', 'MAX_STATEMENT_TIME', 'NEVER', 'OPTIMIZER_COSTS',
        'PARSE_GCOL_EXPR', 'PRECEDES', 'REPLICATE_DO_DB', 'REPLICATE_DO_TABLE', 'REPLICATE_IGNORE_DB', 'REPLICATE_IGNORE_TABLE',
        'REPLICATE_REWRITE_DB', 'REPLICATE_WILD_DO_TABLE', 'REPLICATE_WILD_IGNORE_TABLE', 'ROTATE', 'STORED', 'VALIDATION',
        'VIRTUAL', 'WITHOUT', 'XID',

        // Added in MySQL 8.0
        'ARRAY', 'CUME_DIST', 'DENSE_RANK', 'EMPTY', 'FIRST_VALUE', 'GET_MASTER_PUBLIC_KEY;', 'GROUPING', 'GROUPS',
        'JSON_TABLE', 'LAG', 'LAST_VALUE', 'LATERAL', 'LEAD', 'MEMBER', 'NTH_VALUE', 'NTILE', 'OF', 'OVER', 'PERCENT_RANK',
        'PERSIST_ONLY;', 'RANK', 'RECURSIVE', 'ROW_NUMBER', 'SYSTEM', 'WINDOW', 'ACTIVE;', 'BUCKETS;', 'CLONE;', 'DEFINITION;',
        'DESCRIPTION;', 'ENFORCED;', 'EXCLUDE;', 'FOLLOWING;', 'GEOMCOLLECTION;', 'HISTOGRAM;', 'HISTORY;', 'INACTIVE;',
        'LOCKED;', 'MASTER_COMPRESSION_ALGORITHMS;', 'MASTER_PUBLIC_KEY_PATH;', 'MASTER_ZSTD_COMPRESSION_LEVEL;', 'NESTED;',
        'NETWORK_NAMESPACE;', 'NOWAIT;', 'NULLS;', 'OJ;', 'OLD;', 'OPTIONAL;', 'ORDINALITY;', 'ORGANIZATION;', 'OTHERS;',
        'PATH;', 'PRECEDING;', 'PROCESS;', 'REFERENCE;', 'RESOURCE;', 'RESPECT;', 'RESTART;', 'RETAIN;', 'REUSE;',
        'SECONDARY;', 'SECONDARY_ENGINE;', 'SECONDARY_LOAD;', 'SECONDARY_UNLOAD;', 'SKIP;', 'SRID;', 'THREAD_PRIORITY;',
        'TIES;', 'UNBOUNDED;', 'VCPU;',

        // Added in MariaDB 10.0
        'RETURNING',
    ];
    return $words;
}
