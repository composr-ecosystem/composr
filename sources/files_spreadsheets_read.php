<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2020

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Find whether a file is a readable spreadsheet.
 *
 * @param  string $filename Filename
 * @return boolean Whether it is
 */
function is_spreadsheet_readable($filename)
{
    $ext = get_file_extension($filename);
    return in_array($ext, explode(',', spreadsheet_read_file_types()));
}

/**
 * Find supported spreadsheet file types for reading.
 *
 * @return string A comma-separated list of supported file types
 */
function spreadsheet_read_file_types()
{
    return 'csv,txt';
}

/**
 * Open spreadsheet for reading.
 *
 * @param  PATH $path File path
 * @param  ?string $filename Filename (null: derive from $path)
 * @param  integer $algorithm An ALGORITHM_* constant
 * @param  boolean $trim Whether to trim each cell
 * @param  ?string $default_charset The default character set to assume if none is specified in the file (null: website character set) (blank: smart detection)
 * @return object A subclass of CMS_Spreadsheet_Reader
 */
function spreadsheet_open_read($path, $filename = null, $algorithm = 3, $trim = true, $default_charset = '')
{
    if ($filename === null) {
        $filename = basename($path);
    }

    $ext = get_file_extension($filename);
    switch ($ext) {
        case 'csv':
        case 'txt':
            return new CMS_CSV_Reader($path, $filename, $algorithm, $trim, $default_charset);
    }

    warn_exit(do_lang_tempcode('UNKNOWN_FORMAT', escape_html($ext)));
}

/**
 * Spreadsheet reader.
 *
 * @package core
 */
abstract class CMS_Spreadsheet_Reader
{
    const ALGORITHM_RAW = 1;
    const ALGORITHM_UNNAMED_FIELDS = 2;
    const ALGORITHM_NAMED_FIELDS = 3;

    protected $algorithm = 3;
    protected $trim = true;
    protected $fields = null;

    /**
     * Constructor. Opens spreadsheet for reading.
     *
     * @param  PATH $path File path
     * @param  string $filename Filename
     * @param  integer $algorithm An ALGORITHM_* constant
     * @param  boolean $trim Whether to trim each cell
     * @param  ?string $default_charset The default character set to assume if none is specified in the file (null: website character set) (blank: smart detection)
     */
    public function __construct($path, $filename, $algorithm = 3, $trim = true, $default_charset = '')
    {
        $this->algorithm = $algorithm;
        $this->trim = $trim;

        if ($algorithm == self::ALGORITHM_RAW) {
            $this->fields = null;
        } else {
            $row = $this->read_row();
            if ($row === false) {
                $row = [];
            }
            $this->fields = $row;
        }
    }

    /**
     * Rewind to return first record again.
     */
    abstract public function rewind();

    /**
     * Read spreadsheet row.
     *
     * @return ~array Row (false: error)
     */
    public function read_row()
    {
        $row = $this->_read_row();

        if ($row === false) {
            return false;
        }

        if ($this->trim) {
            foreach ($row as &$v) {
                $v = trim($v);
            }
        }

        if (array_unique($row) == ['']) { // Skip to next for any blank row
            return $this->read_row();
        }

        if ($this->fields === null) {
            $_row = $row;

            $this->fields = $row; // So can pad out consistently for following rows
        } else {
            switch ($this->algorithm) {
                case self::ALGORITHM_RAW:
                case self::ALGORITHM_UNNAMED_FIELDS:
                    $_row = $row;
                    for ($i = count($_row); $i < count($this->fields); $i++) {
                        $_row[] = '';
                    }
                    break;

                case self::ALGORITHM_NAMED_FIELDS:
                    $_row = [];
                    foreach ($this->fields as $i => $f) {
                        $_row[$f] = (array_key_exists($i, $row) ? $row[$i] : '');
                    }
                    break;
            }
        }

        return $_row;
    }

    /**
     * Read spreadsheet row.
     *
     * @return ~array Row (false: error)
     */
    abstract protected function _read_row();

    /**
     * Close down the spreadsheet file handle, for when we're done.
     */
    abstract public function close();
}

/**
 * CSV spreadsheet file reader.
 *
 * @package core
 */
class CMS_CSV_Reader extends CMS_Spreadsheet_Reader
{
    const FORMAT_CSV = 1; // Comma
    const FORMAT_TSV = 2; // Tab
    const FORMAT_SCSV = 3; // Semicolon

    protected $tmp_path = null;
    protected $handle = null;
    protected $charset = null;
    protected $format = 1;
    protected $start_pos = 0;

    /**
     * Constructor. Opens spreadsheet for reading.
     *
     * @param  PATH $path File path
     * @param  string $filename Filename
     * @param  integer $algorithm An ALGORITHM_* constant
     * @param  boolean $trim Whether to trim each cell
     * @param  ?string $default_charset The default character set to assume if none is specified in the file (null: website character set) (blank: smart detection)
     * @param  ?integer $format A FORMAT_* constant (null: autodetect)
     */
    public function __construct($path, $filename, $algorithm = 3, $trim = true, $default_charset = '', $format = null)
    {
        require_code('files');

        // First we need to fix line endings, as there's a chance of Classic Mac line endings due to Microsoft Excel Mac's behaviour, and cms_fgets cannot cope with that
        if ($GLOBALS['IN_MINIKERNEL_VERSION']) {
            $open_path = $path;
        } else {
            $this->tmp_path = cms_tempnam();
            cms_file_put_contents_safe($this->tmp_path, cms_file_get_contents_safe($path, FILE_READ_UNIXIFIED_TEXT | FILE_READ_LOCK), 0);
            $open_path = $this->tmp_path;
        }

        $this->handle = cms_fopen_text_read($open_path, $this->charset, false/*no lock needed on our temp file*/, 'rb', $default_charset);

        if ($format === null) {
            // Detect format...

            $pos = ftell($this->handle);
            $first_line = fgets($this->handle);
            fseek($this->handle, $pos, SEEK_SET);

            $this->format = (strpos($first_line, "\t") !== false) ? self::FORMAT_TSV : ((substr_count($first_line, ',') >= substr_count($first_line, ';')) ? self::FORMAT_CSV : self::FORMAT_SCSV);
        } else {
            $this->format = $format;
        }

        parent::__construct($path, $filename, $algorithm, $trim, $default_charset);

        $this->start_pos = ftell($this->handle);
    }

    /**
     * Rewind to return first record again.
     */
    public function rewind()
    {
        if ($this->handle === null) {
            fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));
        }

        fseek($this->start_pos, SEEK_SET);
    }

    /**
     * Read spreadsheet row.
     *
     * @return ~array Row (false: error)
     */
    protected function _read_row()
    {
        if ($this->handle === null) {
            fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));
        }

        switch ($this->format) {
            case self::FORMAT_CSV:
                $delimiter = ',';
                break;
            case self::FORMAT_TSV:
                $delimiter = "\t";
                break;
            case self::FORMAT_SCSV:
                $delimiter = ';';
                break;
            default:
                fatal_exit(do_lang_tempcode('INTERNAL_ERROR'));
        }

        $line = cms_fgets($this->handle, $this->charset);
        if ($line === false) {
            return false;
        }

        return str_getcsv($line, $delimiter, '"', (version_compare(PHP_VERSION, '7.4.0') >= 0) ? '' : '\\'/*LEGACY*/);
    }

    /**
     * Standard destructor.
     */
    public function __destruct()
    {
        $this->close();
    }

    /**
     * Close down the spreadsheet file handle, for when we're done.
     */
    public function close()
    {
        if ($this->handle !== null) {
            fclose($this->handle);
            $this->handle = null;
            if ($this->tmp_path !== null) {
                unlink($this->tmp_path);
                $this->tmp_path = null;
            }
        }
    }
}
