<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*EXTRA FUNCTIONS: ILess_Autoloader|ILess_Parser|ILess_Cache_FileSystem|less_proxy_compile|proc_.*|stream_get_contents*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__tempcode_compiler()
{
    if (!defined('PARSE_NO_MANS_LAND')) {
        define('PARSE_NO_MANS_LAND', 0);
        define('PARSE_DIRECTIVE', 1);
        define('PARSE_SYMBOL', 2);
        define('PARSE_LANGUAGE_REFERENCE', 3);
        define('PARSE_PARAMETER', 4);
        define('PARSE_DIRECTIVE_INNER', 5);
    }

    global $DIRECTIVES_NEEDING_VARS;
    $DIRECTIVES_NEEDING_VARS = ['IF_PASSED_AND_TRUE' => true, 'IF_NON_PASSED_OR_FALSE' => true, 'PARAM_INFO' => true, 'IF_NOT_IN_ARRAY' => true, 'IF_IN_ARRAY' => true, 'IMPLODE' => true, 'COUNT' => true, 'IF_ARRAY_EMPTY' => true, 'IF_ARRAY_NON_EMPTY' => true, 'OF' => true, 'INCLUDE' => true, 'LOOP' => true, 'SET_NOPREEVAL' => true, 'PARAMS_JSON' => true];

    // Work out what symbols may be compiled out (look at patterns at top of caches3.php if changing this)...

    if (!defined('SYMBOL_COMPILE_STATIC_SAFE')) {
        define('SYMBOL_COMPILE_STATIC_SAFE', 0);
        define('SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE', 1);
        define('SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS', 2);
        define('SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_JAVASCRIPT', 4);
        define('SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_KEEP', 8);
    }

    global $COMPILABLE_SYMBOLS;
    $COMPILABLE_SYMBOLS = [
        '' => SYMBOL_COMPILE_STATIC_SAFE, // A Tempcode comment
        'PAGE_LINK' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE | SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_KEEP,
        'TERNARY' => SYMBOL_COMPILE_STATIC_SAFE,
        'IMG' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS,
        'IMG_MTIME' => SYMBOL_COMPILE_STATIC_SAFE,
        'IMG_WIDTH' => SYMBOL_COMPILE_STATIC_SAFE,
        'IMG_HEIGHT' => SYMBOL_COMPILE_STATIC_SAFE,
        'STRIP_TAGS' => SYMBOL_COMPILE_STATIC_SAFE,
        'TRUNCATE_LEFT' => SYMBOL_COMPILE_STATIC_SAFE,
        'TRUNCATE_SPREAD' => SYMBOL_COMPILE_STATIC_SAFE,
        'PARAGRAPH' => SYMBOL_COMPILE_STATIC_SAFE,
        'IS_EMPTY' => SYMBOL_COMPILE_STATIC_SAFE,
        'IS_NON_EMPTY' => SYMBOL_COMPILE_STATIC_SAFE,
        'CDN_FILTER' => SYMBOL_COMPILE_STATIC_SAFE,
        'LOGO_URL' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS,
        'TRIM' => SYMBOL_COMPILE_STATIC_SAFE,
        'MEMBER_PROFILE_URL' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'PHOTO' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'AVATAR' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'USERNAME' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'DISPLAYED_USERNAME' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'THUMBNAIL' => SYMBOL_COMPILE_STATIC_SAFE,
        'URL_FOR_GET_FORM' => SYMBOL_COMPILE_STATIC_SAFE,
        'HIDDENS_FOR_GET_FORM' => SYMBOL_COMPILE_STATIC_SAFE,
        'FIND_SCRIPT_NOHTTP' => SYMBOL_COMPILE_STATIC_SAFE,
        'FIND_SCRIPT' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS | SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_KEEP,
        'PREG_REPLACE' => SYMBOL_COMPILE_STATIC_SAFE,
        'MAX' => SYMBOL_COMPILE_STATIC_SAFE,
        'MIN' => SYMBOL_COMPILE_STATIC_SAFE,
        'DIV_FLOAT' => SYMBOL_COMPILE_STATIC_SAFE,
        'DIV' => SYMBOL_COMPILE_STATIC_SAFE,
        'LCASE' => SYMBOL_COMPILE_STATIC_SAFE,
        'REPLACE' => SYMBOL_COMPILE_STATIC_SAFE,
        'IN_STR' => SYMBOL_COMPILE_STATIC_SAFE,
        'SUBSTR_COUNT' => SYMBOL_COMPILE_STATIC_SAFE,
        'SUBSTR' => SYMBOL_COMPILE_STATIC_SAFE,
        'ALTERNATOR_TRUNCATED' => SYMBOL_COMPILE_STATIC_SAFE,
        'EQ' => SYMBOL_COMPILE_STATIC_SAFE,
        'NEQ' => SYMBOL_COMPILE_STATIC_SAFE,
        'NOT' => SYMBOL_COMPILE_STATIC_SAFE,
        'OR' => SYMBOL_COMPILE_STATIC_SAFE,
        'AND' => SYMBOL_COMPILE_STATIC_SAFE,
        'NOR' => SYMBOL_COMPILE_STATIC_SAFE,
        'NAND' => SYMBOL_COMPILE_STATIC_SAFE,
        'GT' => SYMBOL_COMPILE_STATIC_SAFE,
        'EXTEND_URL' => SYMBOL_COMPILE_STATIC_SAFE,
        'MAKE_URL_ABSOLUTE' => SYMBOL_COMPILE_STATIC_SAFE,
        'LANG' => SYMBOL_COMPILE_STATIC_SAFE,
        'THEME' => SYMBOL_COMPILE_STATIC_SAFE,
        'VERSION_NUMBER' => SYMBOL_COMPILE_STATIC_SAFE,
        'SITE_NAME' => SYMBOL_COMPILE_STATIC_SAFE,
        'CHARSET' => SYMBOL_COMPILE_STATIC_SAFE,
        'ADDON_INSTALLED' => SYMBOL_COMPILE_STATIC_SAFE,
        'CONFIG_OPTION' => SYMBOL_COMPILE_STATIC_SAFE,
        'VALUE_OPTION' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'COPYRIGHT' => SYMBOL_COMPILE_STATIC_SAFE,
        'BRAND_NAME' => SYMBOL_COMPILE_STATIC_SAFE,
        'BRAND_BASE_URL' => SYMBOL_COMPILE_STATIC_SAFE,
        'CUSTOM_BASE_URL' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS,
        'BASE_URL_NOHTTP' => SYMBOL_COMPILE_STATIC_SAFE,
        'CUSTOM_BASE_URL_NOHTTP' => SYMBOL_COMPILE_STATIC_SAFE,
        'BASE_URL' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS,
        'CNS' => SYMBOL_COMPILE_STATIC_SAFE,
        'VALID_FILE_TYPES' => SYMBOL_COMPILE_STATIC_SAFE,
        'COOKIE_PATH' => SYMBOL_COMPILE_STATIC_SAFE,
        'COOKIE_DOMAIN' => SYMBOL_COMPILE_STATIC_SAFE,
        'SESSION_COOKIE_NAME' => SYMBOL_COMPILE_STATIC_SAFE,
        'MAILTO' => SYMBOL_COMPILE_STATIC_SAFE,
        'INLINE_STATS' => SYMBOL_COMPILE_STATIC_SAFE,
        'IMG_INLINE' => SYMBOL_COMPILE_STATIC_SAFE,
        'ADD' => SYMBOL_COMPILE_STATIC_SAFE,
        'ANCHOR' => SYMBOL_COMPILE_STATIC_SAFE,
        'AT' => SYMBOL_COMPILE_STATIC_SAFE,
        'URLDECODE' => SYMBOL_COMPILE_STATIC_SAFE,
        'CLEAN_FILE_SIZE' => SYMBOL_COMPILE_STATIC_SAFE,
        'COPPA_ON' => SYMBOL_COMPILE_STATIC_SAFE,
        'CSS_DIMENSION_REDUCE' => SYMBOL_COMPILE_STATIC_SAFE,
        'DIV_CEIL' => SYMBOL_COMPILE_STATIC_SAFE,
        'DOMAIN' => SYMBOL_COMPILE_STATIC_SAFE,
        'ENTITY_DECODE' => SYMBOL_COMPILE_STATIC_SAFE,
        'ESCAPE' => SYMBOL_COMPILE_STATIC_SAFE,
        'FIND_GUID_VIA_ID' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_ID_VIA_GUID' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_ID_VIA_LABEL' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_ID_VIA_COMMANDR_FS_FILENAME' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_ID_VIA_URL_MONIKER' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_LABEL_VIA_ID' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_COMMANDR_FS_FILENAME_VIA_ID' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FIND_URL_MONIKER_VIA_ID' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'FLOAT_FORMAT' => SYMBOL_COMPILE_STATIC_SAFE,
        'FORUM_BASE_URL' => SYMBOL_COMPILE_STATIC_SAFE,
        'HAS_FORUM' => SYMBOL_COMPILE_STATIC_SAFE,
        'LENGTH' => SYMBOL_COMPILE_STATIC_SAFE,
        'LT' => SYMBOL_COMPILE_STATIC_SAFE,
        'MOD' => SYMBOL_COMPILE_STATIC_SAFE,
        'MULT' => SYMBOL_COMPILE_STATIC_SAFE,
        'NEGATE' => SYMBOL_COMPILE_STATIC_SAFE,
        'STRIP_HTML' => SYMBOL_COMPILE_STATIC_SAFE,
        'NUMBER_FORMAT' => SYMBOL_COMPILE_STATIC_SAFE,
        'OBFUSCATE' => SYMBOL_COMPILE_STATIC_SAFE,
        'CNS_MEMBER_HTML' => SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE,
        'PAD_LEFT' => SYMBOL_COMPILE_STATIC_SAFE,
        'PAD_RIGHT' => SYMBOL_COMPILE_STATIC_SAFE,
        'PREG_MATCH' => SYMBOL_COMPILE_STATIC_SAFE,
        'REM' => SYMBOL_COMPILE_STATIC_SAFE,
        'ROUND' => SYMBOL_COMPILE_STATIC_SAFE,
        'SECONDS_PERIOD' => SYMBOL_COMPILE_STATIC_SAFE,
        'SHOW_DOCS' => SYMBOL_COMPILE_STATIC_SAFE,
        'SITE_SCOPE' => SYMBOL_COMPILE_STATIC_SAFE,
        'SSW' => SYMBOL_COMPILE_STATIC_SAFE,
        'STAFF_ADDRESS' => SYMBOL_COMPILE_STATIC_SAFE,
        'STAFF_ADDRESS_PURE' => SYMBOL_COMPILE_STATIC_SAFE,
        'STRPOS' => SYMBOL_COMPILE_STATIC_SAFE,
        'STARTS_WITH' => SYMBOL_COMPILE_STATIC_SAFE,
        'ENDS_WITH' => SYMBOL_COMPILE_STATIC_SAFE,
        'SUBTRACT' => SYMBOL_COMPILE_STATIC_SAFE,
        'TIME_PERIOD' => SYMBOL_COMPILE_STATIC_SAFE,
        'TO_TIMESTAMP' => SYMBOL_COMPILE_STATIC_SAFE,
        'TRUNCATE_EXPAND' => SYMBOL_COMPILE_STATIC_SAFE,
        'TRUNCATE_RIGHT' => SYMBOL_COMPILE_STATIC_SAFE,
        'TUTORIAL_URL' => SYMBOL_COMPILE_STATIC_SAFE,
        'UCASE' => SYMBOL_COMPILE_STATIC_SAFE,
        'VERSION' => SYMBOL_COMPILE_STATIC_SAFE,
        'WCASE' => SYMBOL_COMPILE_STATIC_SAFE,
        'WORDWRAP' => SYMBOL_COMPILE_STATIC_SAFE,
        'XOR' => SYMBOL_COMPILE_STATIC_SAFE,
        'ZONE_HEADER_TEXT' => SYMBOL_COMPILE_STATIC_SAFE,
        'KEEP' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_KEEP,
        'JS_ON' => SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_JAVASCRIPT,
    ];
}

/**
 * Helper function or use getting line numbers.
 *
 * @param  array $bits Compiler tokens
 * @param  integer $i How far we are through the token list
 * @return integer The sum length of tokens passed
 *
 * @ignore
 */
function _length_so_far($bits, $i)
{
    $len = 0;
    foreach ($bits as $_i => $x) {
        if ($_i === $i) {
            break;
        }
        $len += strlen($x);
    }
    return $len;
}

/**
 * Take some Tempcode and pre-process it for Tempcode portions encapsulated within comments (or similar).
 * This is done so syntax-highlighters don't break, and WYSIWYG-editors don't corrupt the Tempcode.
 *
 * @param  string $data Input Tempcode
 * @return string Output Tempcode
 */
function substitute_comment_encapsulated_tempcode($data)
{
    // HTML comment
    $data = cms_preg_replace_safe('#<!--\s*\{(((?!-->).)*)\}\s*-->#', '{${1}}', $data);

    // HTML attribute
    $data = preg_replace('#\sx-tempcode(-\w+)?="\{([^"]*)\}"#', '{${2}}', $data);

    // CSS/JS comment
    $data = cms_preg_replace_safe('#/\*\s*\{([^a-z0-9])(((?!\*/).)*)\}\s*\*/#', '{${1}${2}}', $data);

    return $data;
}

/**
 * Compile a template into a list of appendable outputs, for the closure-style Tempcode implementation.
 *
 * @param  string $data The template file contents
 * @param  ID_TEXT $template_name The name of the template
 * @param  ID_TEXT $theme The name of the theme
 * @param  ID_TEXT $lang The language it is for
 * @param  boolean $tolerate_errors Whether to tolerate errors
 * @param  ?array $parameters Parameters to hard-code in during compilation (null: no hard-coding)
 * @param  ?array $parameters_used Parameters used in final Tempcode will be written into here (null: don't)
 * @return array A pair: array Compiled result structure, array preprocessable bits (special stuff needing attention that is referenced within the template)
 */
function compile_template($data, $template_name, $theme, $lang, $tolerate_errors = false, &$parameters = null, &$parameters_used = null)
{
    if (strpos($data, '/*{$,parser hint: pure}*/') !== false) {
        return [['"' . php_addslashes(preg_replace('#\{\$,.*\}#U', '', str_replace('/*{$,parser hint: pure}*/', '/*no minify*/', $data))) . '"'], []];
    }

    if ($parameters !== null) {
        $parameter = null;
        foreach ($parameters as $key => $parameter) {
            if (is_bool($parameter)) {
                $parameters[$key] = $parameter ? '1' : '0';
            } elseif ($parameter === null) {
                unset($parameters[$key]);
            } elseif (isset($parameter->is_all_static)) {
                $parameters[$key] = $parameters[$key]->evaluate();
            }
        }
    }

    $data = substitute_comment_encapsulated_tempcode($data);

    $data = preg_replace('#<\?php(.*)\?' . '>#sU', '{+START,PHP}${1}{+END}', $data);

    global $STUCK_ABORT_SIGNAL;

    $sas_bak = $STUCK_ABORT_SIGNAL;
    require_code('lang');
    require_code('urls');
    $cl = fallback_lang();
    $bits = array_values(preg_split('#(?<!\\\\)(\{(?![A-Z][a-z])(?=[\dA-Z\$\+\!_]+[\.`%\*=\;\#\-~\^\|\'!&/@+]*))|((?<!\\\\),)|((?<!\\\\)\})#', $data, -1, PREG_SPLIT_DELIM_CAPTURE));  // One error mail showed on a server it had weird indexes, somehow. Hence the array_values call to reindex it
    $count = count($bits);
    $stack = [];
    $current_level_mode = PARSE_NO_MANS_LAND;
    $current_level_data = [];
    $current_level_params = [];
    $preprocessable_bits = [];
    $num_preprocessable_bits = 0;
    $preprocessable_bits_stack = [];
    for ($i = 0; $i < $count; $i++) {
        $next_token = $bits[$i];
        if ($next_token === '') {
            continue;
        }
        if (($i !== $count - 1) && ($next_token === '{') && (preg_match('#^[\dA-Z\$\+\!_]#', $bits[$i + 1]) === 0)) {
            $current_level_data[] = '"{}"';
            continue;
        }

        switch ($next_token) {
            case '{':
                // Open a new level
                $stack[] = [$current_level_mode, $current_level_data, $current_level_params, null, null, null, count($preprocessable_bits)];
                ++$i;
                $next_token = isset($bits[$i]) ? $bits[$i] : null;
                if ($next_token === null) {
                    if ($tolerate_errors) {
                        continue 2;
                    }
                    warn_exit(do_lang_tempcode('ABRUPTED_DIRECTIVE_OR_BRACE', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
                }
                $current_level_data = [];
                switch (isset($next_token[0]) ? $next_token[0] : '') {
                    case '$':
                        $current_level_mode = PARSE_SYMBOL;
                        $current_level_data[] = '"' . php_addslashes(($next_token === '$') ? '' : substr($next_token, 1)) . '"';
                        break;

                    case '+':
                        $current_level_mode = PARSE_DIRECTIVE;
                        $current_level_data[] = '"' . php_addslashes(($next_token === '+') ? '' : substr($next_token, 1)) . '"';
                        break;

                    case '!':
                        $current_level_mode = PARSE_LANGUAGE_REFERENCE;
                        $current_level_data[] = '"' . php_addslashes(($next_token === '!') ? '' : substr($next_token, 1)) . '"';
                        break;

                    default:
                        $current_level_mode = PARSE_PARAMETER;
                        $current_level_data[] = '"' . php_addslashes($next_token) . '"';
                        break;
                }
                $current_level_params = [];
                break;

            case '}':
                if ((empty($stack)) || ($current_level_mode === PARSE_DIRECTIVE_INNER)) {
                    $literal = php_addslashes($next_token);
                    if ($GLOBALS['XSS_DETECT']) {
                        ocp_mark_as_escaped($literal);
                    }

                    $current_level_data[] = '"' . $literal . '"';
                    break;
                }

                $opener_params = array_merge($current_level_params, [$current_level_data]);
                $__first_param = array_shift($opener_params);
                if (count($__first_param) !== 1) {
                    warn_exit(do_lang_tempcode('COMPLEX_FIRST_PARAMETER'), false, true);
                }
                $_first_param = $__first_param[0];

                if (($bits[$i - 1] === '') && (count($current_level_data) === 0)) {
                    $current_level_data[] = '""';
                }

                // Return to the previous level
                $past_level_data = $current_level_data;
                $past_level_params = $current_level_params;
                $past_level_mode = $current_level_mode;
                if (empty($stack)) {
                    if (!$tolerate_errors) {
                        warn_exit(do_lang_tempcode('TEMPCODE_TOO_MANY_CLOSES', escape_html($template_name), escape_html(integer_format(1 + _length_so_far($bits, $i)))), false, true);
                    }
                } else {
                    list($current_level_mode, $current_level_data, $current_level_params, , , , $num_preprocessable_bits) = array_pop($stack);
                }

                // Handle the level we just closed
                $_escaped = str_split(preg_replace('#[^:\.`%\*=\;\#\-~\^\|\'&/@+]:?#', '', $_first_param)); // :? is so that the ":" in language string codenames does not get considered an escape
                $escaped = [];
                foreach ($_escaped as $e) {
                    switch ($e) {
                        case '`':
                            $escaped[] = NULL_ESCAPED;
                            break;
                        case '%':
                            $escaped[] = NAUGHTY_ESCAPED;
                            break;
                        case '*':
                            $escaped[] = ENTITY_ESCAPED;
                            break;
                        case '=':
                            $escaped[] = FORCIBLY_ENTITY_ESCAPED;
                            break;
                        case ';':
                            $escaped[] = SQ_ESCAPED;
                            break;
                        case '#':
                            $escaped[] = DQ_ESCAPED;
                            break;
                        case '~': // New lines disappear
                            $escaped[] = NL_ESCAPED;
                            break;
                        case '^':
                            $escaped[] = NL2_ESCAPED; // New lines go to \n
                            break;
                        case '|':
                            $escaped[] = ID_ESCAPED;
                            break;
                        case '\'':
                            $escaped[] = CSS_ESCAPED;
                            break;
                        case '!': // If & is not wanted as WYSIWYG editor may break it
                        case '&':
                            $escaped[] = UL_ESCAPED;
                            break;
                        case '.':
                            $escaped[] = UL2_ESCAPED;
                            break;
                        case '/':
                            $escaped[] = JSHTML_ESCAPED;
                            break;
                        case '@':
                            $escaped[] = CC_ESCAPED;
                            break;
                        case '+':
                            $escaped[] = PURE_STRING; // A performance marker
                            break;

                        // This is used as a hint to not preprocess
                        case '-':
                            // NB: we're out of ASCII symbols now. We want to avoid []()<>" brackets, whitespace characters, and control codes, and others are used for Tempcode grammar or are valid identifier characters.
                            //  Actually +/$/! can be used at the end (+ and ! is already taken, and $ messes with Tempcode compilation)
                    }
                }
                $_opener_params = '';
                foreach ($opener_params as $oi => &$oparam) {
                    if (empty($oparam)) {
                        $oparam = ['""'];
                        if (!isset($opener_params[$oi + 1])) {
                            unset($opener_params[$oi]);
                            break;
                        }
                    }

                    if ($_opener_params !== '') {
                        $_opener_params .= ',';
                    }
                    $_opener_params .= implode('.', $oparam);
                }

                $first_param = preg_replace('#[`%*=;\#\-~\^|\'!&./@+]+(")?$#', '$1', $_first_param);
                switch ($past_level_mode) {
                    case PARSE_SYMBOL:
                        // Pre-processing
                        $no_preprocess = in_array('-', $_escaped);
                        if (!$no_preprocess) {
                            switch ($first_param) { // These need preprocessing
                                case '""':
                                    array_splice($preprocessable_bits, $num_preprocessable_bits); // Remove anything preprocessable marked inside the comment
                                    break;

                                case '"REQUIRE_CSS"':
                                case '"REQUIRE_JAVASCRIPT"':
                                case '"JS_TEMPCODE"':
                                case '"CSS_TEMPCODE"':
                                case '"SET"':
                                case '"BLOCK"':
                                case '"LOAD_PAGE"':
                                case '"LOAD_PANEL"':
                                case '"CATALOGUE_ENTRY_FOR"':
                                case '"METADATA"':
                                case '"METADATA_IMAGE_EXTRACT"':
                                    foreach ($stack as $level_test) { // Make sure if it's a LOOP then we evaluate the parameters early, as these have extra bindings we don't know about
                                        if (($level_test[3] === PARSE_DIRECTIVE) && (isset($level_test[5][1], $level_test[5][1][0])) && ($level_test[5][1][0] === '"LOOP"')) { // For a loop, we need to do full evaluation of symbol parameters as it may be bound to a loop variable
                                            $eval_openers = tc_eval_opener_params($_opener_params);
                                            if (is_array($eval_openers)) {
                                                $pp_bit = [[], TC_SYMBOL, str_replace('"', '', $first_param), $eval_openers];
                                                $preprocessable_bits[] = $pp_bit;
                                            }
                                            break 2;
                                        }
                                    }

                                    $symbol_params = [];
                                    foreach ($opener_params as $param) {
                                        $myfunc = 'tcpfunc_' . fast_uniqid();
                                        $funcdef = build_closure_function($myfunc, $param);
                                        $symbol_params[] = new Tempcode([[$myfunc => $funcdef], [[[$myfunc, [/* Is currently unbound */], TC_KNOWN, '', '']]]]); // Parameters will be bound in later.
                                    }

                                    $pp_bit = [[], TC_SYMBOL, str_replace('"', '', $first_param), $symbol_params];

                                    $preprocessable_bits[] = $pp_bit;
                                    break;
                            }
                        }

                        // Special case: Needed to ensure correct binding
                        if ((($first_param === '"IMG"') || ($first_param === '"IMG_INLINE"')) && (strpos($_opener_params, ',') === false)) { // Needed to ensure correct binding
                            $_opener_params .= ',"0","' . php_addslashes($theme) . '"';
                        }

                        // Optimise simple PHP-compatible operators
                        foreach (['EQ' => '==', 'NEQ' => '!='] as $symbol_op => $php_op) {
                            if (($first_param === '"' . $symbol_op . '"') && (count($opener_params) === 2)) {
                                $current_level_data[] = '(((' . implode('.', $opener_params[0]) . ')' . $php_op . '(' . implode('.', $opener_params[1]) . '))?"1":"0")';
                                break 2;
                            }
                        }
                        foreach (['AND' => '&&', 'OR' => '||'] as $symbol_op => $php_op) {
                            if (($first_param === '"' . $symbol_op . '"') && (count($opener_params) === 2)) {
                                $current_level_data[] = '(((' . implode('.', $opener_params[0]) . ')=="1")' . $php_op . '(' . implode('.', $opener_params[1]) . '=="1")?"1":"0")';
                                break 2;
                            }
                        }
                        if (($first_param === '"?"') && (count($opener_params) === 3) && (count($escaped) === 0)) {
                            $current_level_data[] = '(((' . implode('.', $opener_params[0]) . ')=="1")?(' . implode('.', $opener_params[1]) . '):(' . implode('.', $opener_params[2]) . '))';
                            break 2;
                        }

                        // Okay, a fully dynamic symbol
                        $name = preg_replace('#(^")|("$)#', '', $first_param);
                        if ($name === '?') {
                            $name = 'TERNARY';
                        }
                        if (function_exists('ecv_' . $name)) {
                            $new_line = 'ecv_' . $name . '($cl,[' . implode(',', array_map('strval', $escaped)) . '],[' . $_opener_params . '])';
                        } else {
                            $new_line = 'ecv($cl,[' . implode(',', array_map('strval', $escaped)) . '],' . strval(TC_SYMBOL) . ',' . $first_param . ',[' . $_opener_params . '])';
                        }
                        if ((may_optimise_out_symbol(trim($first_param, '"'))) && (tc_is_all_static($_opener_params))) { // Can optimise out?
                            $tpl_funcs = [];
                            $eval = tempcode_compiler_eval('return ' . $new_line . ';', $tpl_funcs, [], $cl);

                            $new_line = '"' . php_addslashes($eval) . '"';
                        } else {
                            // We want the benefit's of keep_ variables but not with having to do lots of individual URL moniker lookup queries - so use a static URL and KEEP_ symbol combination
                            if (($GLOBALS['OUTPUT_STREAMING']) && ($first_param === '"PAGE_LINK"') && (count($opener_params) === 1) && (tc_is_all_static($_opener_params)) && (function_exists('has_submit_permission')/*needed for moniker hooks to load up*/)) {
                                $tmp = $_GET;
                                foreach (array_keys($_GET) as $key) {
                                    if (substr($key, 0, 5) === 'keep_') {
                                        unset($_GET[$key]);
                                    }
                                }
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $new_line . ';', $tpl_funcs, [], $cl);
                                $new_line = '"' . php_addslashes($eval) . '"';
                                $_GET = $tmp;
                                $current_level_data[] = $new_line;
                                $current_level_data[] = 'ecv_KEEP($cl,[' . implode(',', array_map('strval', $escaped)) . '],["' . ((strpos($new_line, '?') === false) ? '1' : '0') . '"])';
                                $GLOBALS['HAS_KEEP_IN_URL_CACHE'] = null; // The temporary $_GET change can cause this to go wrong
                                break;
                            }
                        }
                        $current_level_data[] = $new_line;
                        break;

                    case PARSE_LANGUAGE_REFERENCE:
                        $new_line = 'ecv($cl,[' . implode(',', array_map('strval', $escaped)) . '],' . strval(TC_LANGUAGE_REFERENCE) . ',' . $first_param . ',[' . $_opener_params . '])';
                        if (tc_is_all_static($_opener_params)) { // Optimise out for simple case?
                            $tpl_funcs = [];
                            $looked_up = tempcode_compiler_eval('return ' . $new_line . ';', $tpl_funcs, [], $cl);
                            if (!cms_empty_safe($looked_up)) {
                                $new_line = '"' . php_addslashes($looked_up) . '"';
                            }
                        }
                        $current_level_data[] = $new_line;
                        break;

                    case PARSE_PARAMETER:
                        $parameter = trim($first_param, '"\'');

                        if ($parameters_used !== null) {
                            $parameters_used[$parameter] = true;
                        }

                        // Optimise out as parameter is known
                        if ((isset($parameters[$parameter])) && (is_string($parameters[$parameter]))) {
                            $current_level_data[] = '"' . php_addslashes(apply_tempcode_escaping_inline($escaped, $parameters[$parameter])) . '"';
                            break;
                        }

                        $parameter = preg_replace('#[^\w]#', '', $parameter); // security to stop PHP injection
                        if (is_numeric($parameter)) {
                            $current_level_data[] = '\'{' . php_addslashes($parameter) . '}\'';
                        } elseif ($escaped === [PURE_STRING]) {
                            $current_level_data[] = '$bound_' . php_addslashes($parameter);
                        } else {
                            $temp = 'otp(isset($bound_' . php_addslashes($parameter) . ')?$bound_' . php_addslashes($parameter) . ':null';
                            if ((!function_exists('get_value')) || (get_value('shortened_tempcode') !== '1')) {
                                $temp .= ',"' . php_addslashes($template_name . ':' . $parameter) . '"';
                            }
                            $temp .= ')';

                            if (empty($escaped)) {
                                $current_level_data[] = $temp;
                            } else {
                                $s_escaped = '';
                                foreach ($escaped as $esc) {
                                    if ($s_escaped !== '') {
                                        $s_escaped .= ',';
                                    }
                                    $s_escaped .= strval($esc);
                                }
                                if (($s_escaped === strval(ENTITY_ESCAPED)) && (!$GLOBALS['XSS_DETECT'])) {
                                    $current_level_data[] = '(empty($bound_' . $parameter . '->pure_lang)?@htmlspecialchars(' . $temp . ',ENT_QUOTES | ENT_SUBSTITUTE,get_charset()):' . $temp . ')';
                                } else {
                                    if ($s_escaped === strval(ENTITY_ESCAPED)) {
                                        $current_level_data[] = '(empty($bound_' . $parameter . '->pure_lang)?apply_tempcode_escaping_inline([' . $s_escaped . '],' . $temp . '):' . $temp . ')';
                                    } else {
                                        $current_level_data[] = 'apply_tempcode_escaping_inline([' . $s_escaped . '],' . $temp . ')';
                                    }
                                }
                            }
                        }
                        break;
                }

                // Handle directive nesting
                if ($past_level_mode === PARSE_DIRECTIVE) {
                    $tpl_funcs = [];
                    $eval = tempcode_compiler_eval('return ' . $first_param . ';', $tpl_funcs, [], $cl);
                    if (!is_string($eval)) {
                        $eval = '';
                    }
                    if ($eval === 'START') { // START
                        // Open a new directive level
                        $stack[] = [$current_level_mode, $current_level_data, $current_level_params, $past_level_mode, $past_level_data, $past_level_params, count($preprocessable_bits)];
                        $current_level_data = [];
                        $current_level_params = [];
                        $current_level_mode = PARSE_DIRECTIVE_INNER;
                        if ($opener_params === [['"NO_PREPROCESSING"']]) {
                            array_push($preprocessable_bits_stack, $preprocessable_bits); // So anything inside will end up being thrown away when we pop back to what we had before in $preprocessable_bits
                        }
                    } elseif ($eval === 'END') { // END
                        // Test that the top stack does represent a started directive, and close directive level
                        $past_level_data = $current_level_data;
                        if (empty($past_level_data)) {
                            $past_level_data = ['""'];
                        }
                        $past_level_params = $current_level_params;
                        $past_level_mode = $current_level_mode;
                        if (empty($stack)) {
                            if ($tolerate_errors) {
                                continue 2;
                            }
                            warn_exit(do_lang_tempcode('TEMPCODE_TOO_MANY_CLOSES', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
                        }
                        list($current_level_mode, $current_level_data, $current_level_params, $directive_level_mode, $directive_level_data, $directive_level_params, $num_preprocessable_bits) = array_pop($stack);
                        if (!is_array($directive_level_params)) {
                            if ($tolerate_errors) {
                                continue 2;
                            }
                            warn_exit(do_lang_tempcode('UNCLOSED_DIRECTIVE_OR_BRACE', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
                        }
                        $directive_opener_params = array_merge($directive_level_params, [$directive_level_data]);
                        if (($directive_level_mode !== PARSE_DIRECTIVE) || ($directive_opener_params[0][0] !== '"START"')) {
                            if ($tolerate_errors) {
                                continue 2;
                            }
                            warn_exit(do_lang_tempcode('TEMPCODE_TOO_MANY_CLOSES', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
                        }

                        if (count($directive_opener_params) === 1) {
                            if ($tolerate_errors) {
                                continue 2;
                            }
                            warn_exit(do_lang_tempcode('NO_DIRECTIVE_TYPE', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
                        }

                        // Work out parameters
                        $directive_params = '';
                        $first_directive_param = '""';
                        if (empty($directive_opener_params[1])) {
                            $directive_opener_params[1] = ['""'];
                        }
                        $count_directive_opener_params = count($directive_opener_params);
                        for ($j = 2; $j < $count_directive_opener_params; $j++) {
                            if (empty($directive_opener_params[$j])) {
                                $directive_opener_params[$j] = ['""'];
                            }

                            if ($directive_params !== '') {
                                $directive_params .= ',';
                            }
                            $directive_params .= implode('.', $directive_opener_params[$j]);

                            if ($j === 2) {
                                $first_directive_param = implode('.', $directive_opener_params[$j]);
                            }
                        }
                        $directive_internal = implode('.', $past_level_data);
                        $directive_params_with_internal = $directive_params;
                        if ($directive_params_with_internal !== '') {
                            $directive_params_with_internal .= ',';
                        }
                        $directive_params_with_internal .= $directive_internal;
                        $directive_params_with_internal_with_faux = $directive_params;
                        if ($directive_params_with_internal_with_faux !== '') {
                            $directive_params_with_internal_with_faux .= ',';
                        }
                        $directive_params_with_internal_with_faux .= '"xxx"';

                        // Work out name
                        $tpl_funcs = [];
                        $eval = tempcode_compiler_eval('return ' . implode('.', $directive_opener_params[1]) . ';', $tpl_funcs, [], $cl);
                        if (!is_string($eval)) {
                            $eval = '';
                        }
                        $directive_name = $eval;

                        // Special case: Some nested pre-processables
                        $added_preprocessable_bits = false;
                        switch ($directive_name) {
                            case 'INCLUDE':
                            case 'FRACTIONAL_EDITABLE':
                                $eval = tc_eval_opener_params($directive_params);
                                if (is_array($eval)) {
                                    $pp_bit = [[], TC_DIRECTIVE, str_replace('"', '', $directive_name), $eval];
                                    $preprocessable_bits[] = $pp_bit;
                                    $added_preprocessable_bits = true;
                                }
                                break;
                        }

                        // Special case: Needs to be dynamic as NO_PREPROCESSING also implies avoid internal caching
                        if ($directive_name === 'SET_NOPREEVAL') {
                            $myfunc = 'do_runtime_' . uniqid('', true)/*fast_uniqid()*/;
                            $_past_level_data = $directive_internal;
                            if (strpos($_past_level_data, 'isset($bound') !== false) { // Horrible but efficient code needed to allow IF_PASSED/IF_NON_PASSED to keep working when templates are put adjacent to each other, where some have it, and don't. This is needed as eval does not set a scope block.
                                $reset_code = "eval(\\\$FULL_RESET_VAR_CODE); ";
                            } elseif (strpos($_past_level_data, '$bound') !== false) {
                                $reset_code = "eval(\\\$RESET_VAR_CODE); ";
                            } else {
                                $reset_code = '';
                            }
                            $funcdef = /*if (!isset(\$tpl_funcs['$myfunc']))\n\t*/"\$tpl_funcs['$myfunc']=\"{$reset_code}echo " . php_addslashes($_past_level_data) . ";\";\n";
                            $past_level_data = ['new Tempcode([[\'' . $myfunc . '\'=>"' . php_addslashes($funcdef) . '"],[[["' . $myfunc . '",[],' . strval(TC_KNOWN) . ',\'\',\'\']]]])'];
                        }

                        // Generate standard PHP code for directive
                        if (isset($GLOBALS['DIRECTIVES_NEEDING_VARS'][$directive_name])) {
                            $regular_code = 'ecv($cl,[],' . strval(TC_DIRECTIVE) . ',' . implode('.', $directive_opener_params[1]) . ',[' . $directive_params_with_internal . ',\'vars\'=>$parameters])';
                        } else {
                            $regular_code = 'ecv($cl,[],' . strval(TC_DIRECTIVE) . ',' . implode('.', $directive_opener_params[1]) . ',[' . $directive_params_with_internal . '])';
                        }
                        if (isset($GLOBALS['DIRECTIVES_NEEDING_VARS'][$directive_name])) {
                            $regular_code_with_faux = 'ecv($cl,[],' . strval(TC_DIRECTIVE) . ',' . implode('.', $directive_opener_params[1]) . ',[' . $directive_params_with_internal_with_faux . ',\'vars\'=>$parameters])';
                        } else {
                            $regular_code_with_faux = 'ecv($cl,[],' . strval(TC_DIRECTIVE) . ',' . implode('.', $directive_opener_params[1]) . ',[' . $directive_params_with_internal_with_faux . '])';
                        }

                        // See if we can completely optimise out a directive
                        if (tc_is_all_static($directive_params)) {
                            switch ($directive_name) {
                                case 'IF':
                                case 'IF_EMPTY':
                                case 'IF_NON_EMPTY':
                                case 'BOX':
                                    $tpl_funcs = [];
                                    $eval = tempcode_compiler_eval('return ' . $regular_code_with_faux . ';', $tpl_funcs, [], $cl);

                                    if ($eval !== '') {
                                        $current_level_data[] = $directive_internal;
                                    } else {
                                        // Nothing will render from under here, so wipe out preprocessable bits that were under there
                                        $preprocessable_bits = [];
                                    }

                                    break 2;
                            }
                        }

                        // Code generation, with some smart PHP-equivalent substitutions
                        switch ($directive_name) {
                            case 'COMMENT':
                                break;

                            case 'NO_PREPROCESSING':
                                $current_level_data[] = $directive_internal;
                                $preprocessable_bits = array_pop($preprocessable_bits_stack);
                                $num_preprocessable_bits = count($preprocessable_bits);
                                break;

                            case 'IF':
                                // Optimise simple expressions to PHP
                                $matches = [];
                                if (preg_match('#^\((\(\([^()]+\)(==|!=)\([^()]+\))\)\?"1":"0"\)\)$#', $first_directive_param, $matches) !== 0) {
                                    $current_level_data[] = '(' . $matches[1] . '?(' . $directive_internal . '):\'\')';
                                    break;
                                }

                                // Normal IF then (actually it's implemented as ternary un PHP)
                                $current_level_data[] = '((' . $first_directive_param . '=="1")?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_EMPTY':
                                $current_level_data[] = '((' . $first_directive_param . '==\'\')?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_NON_EMPTY':
                                $current_level_data[] = '((' . $first_directive_param . '!=\'\')?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_PASSED':
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($eval)) {
                                    $eval = '';
                                }
                                $current_level_data[] = '(isset($bound_' . preg_replace('#[^\w]#', '', $eval) . ')?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_NON_PASSED':
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($eval)) {
                                    $eval = '';
                                }
                                $current_level_data[] = '(!isset($bound_' . preg_replace('#[^\w]#', '', $eval) . ')?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_PASSED_AND_TRUE':
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($eval)) {
                                    $eval = '';
                                }
                                $current_level_data[] = '((isset($bound_' . preg_replace('#[^\w]#', '', $eval) . ') && (otp($bound_' . preg_replace('#[^\w]#', '', $eval) . ')=="1"))?(' . $directive_internal . '):\'\')';
                                break;

                            case 'IF_NON_PASSED_OR_FALSE':
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($eval)) {
                                    $eval = '';
                                }
                                $current_level_data[] = '((!isset($bound_' . preg_replace('#[^\w]#', '', $eval) . ') || (otp($bound_' . preg_replace('#[^\w]#', '', $eval) . ')!="1"))?(' . $directive_internal . '):\'\')';
                                break;

                            case 'WHILE':
                                $current_level_data[] = 'closure_while_loop([$parameters,$cl],' . "\n" . 'recall_named_function(\'' . uniqid('', true) . '\',\'$parameters,$cl\',"extract(\$parameters,EXTR_PREFIX_ALL,\'bound\'); return (' . php_addslashes($first_directive_param) . ')==\"1\";"),' . "\n" . 'recall_named_function(\'' . uniqid('', true) . '\',\'$parameters,$cl\',"extract(\$parameters,EXTR_PREFIX_ALL,\'bound\'); return ' . php_addslashes($directive_internal) . ';"))';
                                break;

                            case 'LOOP':
                                $current_level_data[] = 'closure_loop([' . $directive_params . ',\'vars\'=>$parameters],[$parameters,$cl],' . "\n" . 'recall_named_function(\'' . uniqid('', true) . '\',\'$parameters,$cl\',"extract(\$parameters,EXTR_PREFIX_ALL,\'bound\'); return ' . php_addslashes($directive_internal) . ';"))';

                                $parameter = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($parameter)) {
                                    $parameter = '';
                                }
                                if ($parameters_used !== null) {
                                    $parameters_used[$parameter] = true;
                                }

                                break;

                            case 'PHP':
                                $current_level_data[] = 'closure_eval(' . $directive_internal . ',$parameters)';
                                break;

                            case 'PARAMS_JSON':
                                $current_level_data[] = 'closure_params_json([' . $directive_params . ',\'vars\'=>$parameters],[$parameters,$cl],' . "\n" . 'recall_named_function(\'' . uniqid('', true) . '\',\'$parameters,$cl\',"extract(\$parameters,EXTR_PREFIX_ALL,\'bound\'); return ' . php_addslashes($directive_internal) . ';"))';
                                break;

                            case 'INCLUDE':
                                global $FILE_ARRAY;
                                $tpl_funcs = [];
                                $eval = tempcode_compiler_eval('return ' . $first_directive_param . ';', $tpl_funcs, [], $cl);
                                if (!is_string($eval)) {
                                    $eval = '';
                                }
                                if (($template_name === $eval) || ($past_level_data === ['""']) && (!isset($FILE_ARRAY))) { // Simple case where no separate binding context of variables needed
                                    $_ex = isset($directive_opener_params[1 + 1 + 2]) ? tempcode_compiler_eval('return ' . implode('.', $directive_opener_params[1 + 2]) . ';', $tpl_funcs, [], $cl) : '';
                                    if (!is_string($_ex)) {
                                        $_ex = '';
                                    }
                                    if ($_ex == '') {
                                        $_ex = '.tpl';
                                    }
                                    $_td = isset($directive_opener_params[1 + 2 + 2]) ? tempcode_compiler_eval('return ' . implode('.', $directive_opener_params[2 + 2]) . ';', $tpl_funcs, [], $cl) : '';
                                    if (!is_string($_td)) {
                                        $_td = '';
                                    }
                                    if ($_td == '') {
                                        $_td = 'templates';
                                    }
                                    $_theme = isset($directive_opener_params[1 + 3 + 2]) ? tempcode_compiler_eval('return ' . implode('.', $directive_opener_params[3 + 2]) . ';', $tpl_funcs, [], $cl) : '';
                                    if (!is_string($_theme)) {
                                        $_theme = '';
                                    }
                                    if ($_theme == '') {
                                        $_theme = $theme;
                                    }
                                    $_force_original = isset($directive_opener_params[1 + 4 + 2]) ? tempcode_compiler_eval('return ' . implode('.', $directive_opener_params[4 + 2]) . ';', $tpl_funcs, [], $cl) : '';
                                    if (!is_string($_force_original)) {
                                        $_force_original = '';
                                    }
                                    if ($_force_original != '1') {
                                        $_force_original = '0';
                                    }

                                    $found = find_template_place($eval, '', $_theme, $_ex, $_td, ($template_name === $eval) || ($_force_original == '1'));

                                    if (($found !== null) && ($found[1] !== null)) {
                                        $_theme = $found[0];

                                        $full_path = get_custom_file_base() . '/themes/' . $_theme . $found[1] . $eval . $found[2];
                                        if (!is_file($full_path)) {
                                            $full_path = get_file_base() . '/themes/' . $_theme . $found[1] . $eval . $found[2];
                                        }
                                        if (is_file($full_path)) {
                                            $file_contents = cms_file_get_contents_safe($full_path, FILE_READ_LOCK | FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM);
                                        } else {
                                            $file_contents = '';
                                        }

                                        list($_current_level_data, $_preprocessable_bits) = compile_template($file_contents, $eval, $theme, $lang, $tolerate_errors, $parameters, $parameters_used);
                                        $current_level_data = array_merge($current_level_data, $_current_level_data);
                                        if ($added_preprocessable_bits) {
                                            array_pop($preprocessable_bits);
                                        }
                                        $preprocessable_bits = array_merge($preprocessable_bits, $_preprocessable_bits);
                                        break;
                                    }
                                } else {
                                    $parameters_used = null; // We don't know what the INCLUDE directive may need
                                }
                                // no break

                            default:
                                $current_level_data[] = $regular_code;
                                break;
                        }
                    } else {
                        $tpl_funcs = [];
                        $eval = tempcode_compiler_eval('return ' . $first_param . ';', $tpl_funcs, [], $cl);
                        if (!is_string($eval)) {
                            $eval = '';
                        }
                        $directive_name = $eval;
                        if (isset($GLOBALS['DIRECTIVES_NEEDING_VARS'][$directive_name])) {
                            $current_level_data[] = 'ecv($cl,[' . implode(',', array_map('strval', $escaped)) . '],' . strval(TC_DIRECTIVE) . ',' . $first_param . ',[' . $_opener_params . ',\'vars\'=>$parameters])';
                        } else {
                            $current_level_data[] = 'ecv($cl,[' . implode(',', array_map('strval', $escaped)) . '],' . strval(TC_DIRECTIVE) . ',' . $first_param . ',[' . $_opener_params . '])';
                        }
                    }
                }
                break;

            case ',': // NB: Escaping via "\," was handled in our regexp split
                switch ($current_level_mode) {
                    case PARSE_NO_MANS_LAND:
                    case PARSE_DIRECTIVE_INNER:
                        $current_level_data[] = '","';
                        break;
                    default:
                        $current_level_params[] = $current_level_data;
                        $current_level_data = [];
                        break;
                }
                break;

            default:
                $literal = php_addslashes(str_replace(['\,', '\}', '\{'], [',', '}', '{'], $next_token));
                if ($GLOBALS['XSS_DETECT']) {
                    ocp_mark_as_escaped($literal);
                }

                $current_level_data[] = '"' . $literal . '"';
                break;
        }
    }
    require_code('comcode');
    if (!peek_lax_comcode()) {
        if (!empty($stack)) {
            if (!$tolerate_errors) {
                warn_exit(do_lang_tempcode('UNCLOSED_DIRECTIVE_OR_BRACE', escape_html($template_name), escape_html(integer_format(1 + substr_count(substr($data, 0, _length_so_far($bits, $i)), "\n")))), false, true);
            }
        }
    }

    if ($current_level_data === ['']) {
        $current_level_data = ['""'];
    }

    // Some optimisations
    $merged = [];
    $just_done_string = false;
    foreach ($current_level_data as $c) {
        // Try and replace some unnecessary string appending which may have happened when experiencing possible (but not) control characters
        $c = preg_replace('#([^\\\\])' . preg_quote('"."', '#') . '#', '$1', $c);

        // Try and merge some strings that don't need to be in separate seq_parts
        $c_stripped_down = str_replace(['\\\\', '\\"'], ['', ''], $c); // Remove literal slashes and literal quotes so we can do an accurate scan to ensure it is all one string
        if (($c_stripped_down[0] === '"') && (strpos($c_stripped_down, '"', 1) === strlen($c_stripped_down) - 1)) {
            if ($just_done_string) {
                $pi = count($merged) - 1;
                $merged[$pi] = substr($merged[$pi], 0, strlen($merged[$pi]) - 1) . substr($c, 1, strlen($c) - 1);
            } else {
                $merged[] = $c;
            }
            $just_done_string = true;
        } else {
            $just_done_string = false;
            $merged[] = $c;
        }
    }
    $current_level_data = $merged;

    $STUCK_ABORT_SIGNAL = $sas_bak;

    return [$current_level_data, $preprocessable_bits];
}

/**
 * Find some opening params as a PHP array, for temporary use within the compiler logic.
 *
 * @param  string $_opener_params The parameters in PHP code format
 * @return ?array Parameters (null: could not evaluate, probably due to dynamism)
 */
function tc_eval_opener_params($_opener_params)
{
    $cl = fallback_lang();

    $tpl_funcs = [];
    return tempcode_compiler_eval('return [' . $_opener_params . '];', $tpl_funcs, [], $cl);
}

/**
 * Find if some opening parameters are definitely static.
 *
 * @param  string $_opener_params The parameters in PHP code format
 * @return boolean Is static
 */
function tc_is_all_static($_opener_params)
{
    if (strpos($_opener_params, '$bound_') !== false) {
        return false;
    }

    if (strpos($_opener_params, 'ecv_') !== false) {
        return false;
    }

    if (strpos($_opener_params, 'ecv2_') !== false) {
        return false;
    }

    return true;
}

/**
 * Find whether the symbol may be optimised out.
 *
 * @param  string $symbol The symbol
 * @return boolean May optimise
 */
function may_optimise_out_symbol($symbol)
{
    global $COMPILABLE_SYMBOLS, $SITE_INFO;

    if (!isset($COMPILABLE_SYMBOLS[$symbol])) {
        return false;
    }

    $v = $COMPILABLE_SYMBOLS[$symbol];

    if (($v & SYMBOL_COMPILE_STATIC_IF_AGGRESSIVE) !== 0) {
        if ((!function_exists('get_value')) || (get_value('aggressive_tempcode_compilation') !== '1')) {
            return false;
        }
    }

    if (($v & SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_KEEP) !== 0) {
        if ((!isset($SITE_INFO['no_keep_params'])) || ($SITE_INFO['no_keep_params'] === '0')) {
            return false;
        }
    }

    if (($v & SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_BASE_URLS) !== 0) {
        if ($GLOBALS['DEV_MODE']) {
            return false; // May be experimenting with different base URLs, e.g. both http and https
        }

        if (addon_installed('ssl')) {
            return false;
        }

        foreach (array_keys($SITE_INFO) as $key) {
            if (substr($key, 0, 13) === 'ZONE_MAPPING_') {
                return false;
            }
        }
    }

    if (($v & SYMBOL_COMPILE_STATIC_SAFE_SIMPLE_JAVASCRIPT) !== 0) {
        if ((!function_exists('get_option')) || (get_option('detect_javascript') === '1')) {
            return false;
        }
    }

    return true;
}

/**
 * A template has not been structurally cached, so compile it and store in the cache.
 *
 * @param  ID_TEXT $theme The theme the template is in the context of
 * @param  string $directory Subdirectory type to look in. Surrounded by '/', unlike with $directory parameters to most other functions (performance reasons)
 * @param  ID_TEXT $codename The codename of the template (e.g. foo)
 * @param  ID_TEXT $_codename The actual codename to use for the template (e.g. foo_mobile)
 * @param  LANGUAGE_NAME $lang The language the template is in the context of
 * @param  string $suffix File type suffix of template file (e.g. .tpl)
 * @param  ?ID_TEXT $theme_orig The theme to cache in (null: main theme)
 * @param  ?array $parameters Parameters to hard-code in during compilation (null: no hard-coding)
 * @return Tempcode The compiled Tempcode
 *
 * @ignore
 */
function _do_template($theme, $directory, $codename, $_codename, $lang, $suffix, $theme_orig = null, &$parameters = null)
{
    if ($theme_orig === null) {
        $theme_orig = $theme;
    }

    $base_dir = get_custom_file_base() . '/themes/';
    if (!is_file($base_dir . $theme . $directory . $codename . $suffix)) {
        $base_dir = get_file_base() . '/themes/';
    }

    global $CACHE_TEMPLATES, $FILE_ARRAY, $IS_TEMPLATE_PREVIEW_OP_CACHE, $SITE_INFO;
    if ($IS_TEMPLATE_PREVIEW_OP_CACHE === null) {
        fill_template_preview_op_cache();
    }

    // Load file
    if (isset($FILE_ARRAY)) {
        $template_contents = unixify_line_format(handle_string_bom(file_array_get('themes/' . $theme . $directory . $codename . $suffix)));
    } else {
        $_path = $base_dir . filter_naughty($theme . $directory . $codename) . $suffix;
        $template_contents = cms_file_get_contents_safe($_path, FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM);
    }

    //$final_css_path = null;

    // Special case: LESS support
    if ((addon_installed('less')) && ($suffix === '.less')) {
        // Up our resources
        $old_limit = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLOW);
        disable_php_memory_limit();

        // Stop parallel compilation of the same file by a little hack; without this it could knock out a server
        /*$final_css_path = get_custom_file_base() . '/themes/' . $theme . '/templates_cached/' . $lang . '/' . $codename . '.css'; Actually this is architecturally messy, just let it happen - it's not as slow as it was
        if ((is_file($final_css_path)) && (cms_file_get_contents_safe($final_css_path, FILE_READ_LOCK) === 'GENERATING')) {
            header('Content-Type: text/plain; charset=' . get_charset());
            exit('We are doing a code update. Please refresh in around 2 minutes.');
        }
        require_code('files');
        cms_file_put_contents_safe($final_css_path, 'GENERATING', FILE_WRITE_FIX_PERMISSIONS);
        */

        if (!empty($SITE_INFO['nodejs_binary_path'])) {
            $less_path = get_custom_file_base() . '/node_modules/less/bin/lessc';

            if (!file_exists($less_path)) {
                fatal_exit('Unable to find the less NPM module. Please `cd` to your Composr directory and run `npm install less` to install it.');
            }

            $cmd = sprintf('%s %s --no-color %s', $SITE_INFO['nodejs_binary_path'], cms_escapeshellarg($less_path), cms_escapeshellarg($_path));
            $descriptorspec = [
                0 => ['pipe', 'r'], // stdin
                1 => ['pipe', 'w'], // stdout
                2 => ['pipe', 'w'], // stderr
            ];
            $pipes = [];
            $process = proc_open($cmd, $descriptorspec, $pipes);

            if ($process === false) {
                fatal_exit('Unable to execute the Node.js binary, please make sure it exists and proper permissions are set.');
            }

            $stdout = stream_get_contents($pipes[1]);
            fclose($pipes[1]);

            $stderr = stream_get_contents($pipes[2]);
            fclose($pipes[2]);

            $return_code = proc_close($process);

            if ($return_code !== 0) {
                fatal_exit('.less problem: ' . $stderr);
            }

            $template_contents = $stdout;
        } else {
            // Heavy-weight, newer (iLess)
            require_code('ILess/Autoloader');
            ILess_Autoloader::register();
            $less = new ILess_Parser(
                [
                    'import_dirs' => [dirname($_path)],
                ],
                new ILess_Cache_FileSystem([
                    'cache_dir' => get_custom_file_base() . '/themes/' . $theme . '/templates_cached/' . $lang,
                ])
            );
            try {
                $less->parseString($template_contents);
                $template_contents = $less->getCSS();
            } catch (Exception $ex) {
                fatal_exit('.less problem: ' . $ex->getMessage());
            }
        }

        cms_set_time_limit($old_limit);
    }


    // Special case: HTML template file
    $matches = [];
    if (!$GLOBALS['IN_MINIKERNEL_VERSION'] && ($GLOBALS['SEMI_DEV_MODE']) && ($suffix === '.tpl') && (preg_match('#<script[^>]*>.*<\/script>#is', $template_contents, $matches) > 0)) {
        if (strpos($matches[0], 'CSP_NONCE_HTML') === false) {
            attach_message(do_lang_tempcode('DO_NOT_USE_INLINE_SCRIPT_TAGS', escape_html($codename)), 'warn', false, true);
        }
    }

    // Strip off trailing final lines from single lines templates. Editors often put these in, and it causes annoying "visible space" issues
    if ((substr($template_contents, -1, 1) === "\n") && (substr_count($template_contents, "\n") === 1)) {
        $template_contents = substr($template_contents, 0, strlen($template_contents) - 1);
    }

    // Special case: Template previews
    if ($IS_TEMPLATE_PREVIEW_OP_CACHE) {
        $_template_file = str_replace('_custom', '', trim($directory, '/')) . '/' . $codename . $suffix;
        $preview_post_param_key = 'e_' . get_dynamic_file_parameter($_template_file);
        $test = post_param_string($preview_post_param_key, null);
        if ($test !== null) {
            $template_contents = $test;
        }
    }

    // Do compilation
    cms_profile_start_for('_do_template');
    $result = template_to_tempcode($template_contents, 0, false, $codename, $theme_orig, $lang, false, $parameters);
    cms_profile_end_for('_do_template', $codename . $suffix);

    // Save into cache
    if (($CACHE_TEMPLATES) && ($parameters === null) && (!$IS_TEMPLATE_PREVIEW_OP_CACHE)) {
        $path2 = get_custom_file_base() . '/themes/' . $theme_orig . '/templates_cached/' . filter_naughty($lang);
        $_path2 = $path2 . '/' . filter_naughty($_codename) . $suffix . '.tcp';

        require_code('files');
        $data_to_write = '<' . '?php' . "\n" . $result->to_assembly($lang) . "\n";
        cms_file_put_contents_safe($_path2, $data_to_write, FILE_WRITE_FAILURE_SOFT | FILE_WRITE_FIX_PERMISSIONS);
    }

    return $result;
}

/**
 * Convert template text into Tempcode format.
 *
 * @param  string $text The template text
 * @param  integer $symbol_pos The position we are looking at in the text
 * @param  boolean $inside_directive Whether this text is in fact a directive, about to be put in the context of a wider template
 * @param  ID_TEXT $codename The codename of the template (e.g. foo)
 * @param  ?ID_TEXT $theme The theme it is for (null: current theme)
 * @param  ?ID_TEXT $lang The language it is for (null: current language)
 * @param  boolean $tolerate_errors Whether to tolerate errors
 * @param  ?array $parameters Parameters to hard-code in during compilation (null: no hard-coding)
 * @return mixed The converted/compiled template as Tempcode, OR if a directive, encoded directive information
 */
function template_to_tempcode($text, $symbol_pos = 0, $inside_directive = false, $codename = '', $theme = null, $lang = null, $tolerate_errors = false, &$parameters = null)
{
    if ($theme === null) {
        $theme = isset($GLOBALS['FORUM_DRIVER']) ? $GLOBALS['FORUM_DRIVER']->get_theme() : 'default';
    }
    if ($lang === null) {
        $lang = user_lang();
    }

    $parameters_used = null;
    if ($parameters !== null) {
        $parameters_used = [];
    }
    list($parts, $preprocessable_bits) = compile_template(substr($text, $symbol_pos), $codename, $theme, $lang, $tolerate_errors, $parameters, $parameters_used);

    if (($parameters !== null) && ($parameters_used !== null)) {
        foreach ($parameters as $key => $parameter) {
            if (!isset($parameters_used[$key])) {
                unset($parameters[$key]);
            }
        }
    }

    if (count($parts) === 0) {
        return new Tempcode();
    }

    $output_streaming = (function_exists('get_option')) && (get_option('output_streaming') === '1');

    $is_all_static = true;

    $parts_groups = [];
    $parts_group = [];
    foreach ($parts as $part) {
        if (($output_streaming) && (strpos($part, '$bound_') !== false)) { // Start a new seq_part, so output streaming can break at this parameter reference
            if ($parts_group !== []) {
                $parts_groups[] = $parts_group;
            }
            $parts_group = [];
        }
        $parts_group[] = $part;

        if (!tc_is_all_static($part)) {
            $is_all_static = false;
        }
    }
    if ($parts_group !== []) {
        $parts_groups[] = $parts_group;
    }

    $funcdefs = [];
    $seq_parts = [];
    foreach ($parts_groups as $parts_group) {
        $myfunc = 'tcpfunc_' . fast_uniqid() . '_' . strval(count($seq_parts) + 1);
        $funcdef = build_closure_function($myfunc, $parts_group);
        $funcdefs[$myfunc] = $funcdef;
        $seq_parts[] = [[$myfunc, [/* Is currently unbound */], TC_KNOWN, '', '']];
    }

    $ret = new Tempcode([$funcdefs, $seq_parts]); // Parameters will be bound in later.
    if (!empty($preprocessable_bits)) {
        if (!isset($ret->preprocessable_bits)) {
            $ret->preprocessable_bits = [];
        }
        $ret->preprocessable_bits = array_merge($ret->preprocessable_bits, $preprocessable_bits);
    }
    $ret->codename = $codename;
    if ($is_all_static) {
        if ($parameters !== null) {
            foreach ($parameters as $parameter) {
                if (is_object($parameter) && !isset($parameter->is_all_static)) {
                    $is_all_static = false;
                }
            }
        }

        if ($is_all_static) {
            $ret->is_all_static = true;
        }
    }
    return $ret;
}

/**
 * Build a closure function for a compiled template.
 *
 * @param  string $myfunc The function name
 * @param  array $parts An array of lines to be output, each one in PHP format
 * @return string Finished PHP code
 */
function build_closure_function($myfunc, $parts)
{
    if (empty($parts)) {
        $parts = ['""'];
    }
    $code = '';
    foreach ($parts as $part) {
        if ($code !== '') {
            $code .= ",\n\t";
        }
        $code .= $part;
    }

    if (strpos($code, '$bound') === false) {
        $funcdef = "\$tpl_funcs['$myfunc']=\$KEEP_TPL_FUNCS['$myfunc']=recall_named_function('" . uniqid('', true) . "','\$parameters,\$cl',\"echo " . php_addslashes($code) . ";\");";
    } else {
        $funcdef = "\$tpl_funcs['$myfunc']=\$KEEP_TPL_FUNCS['$myfunc']=recall_named_function('" . uniqid('', true) . "','\$parameters,\$cl',\"extract(\\\$parameters,EXTR_PREFIX_ALL,'bound'); echo " . php_addslashes($code) . ";\");";
    }

    //   Eval version also works. Easier to debug. Less performant due to re-parse requirement each time it is called
    if ($GLOBALS['DEV_MODE']) {
        if (strpos($code, 'isset($bound') !== false) { // Horrible but efficient code needed to allow IF_PASSED/IF_NON_PASSED to keep working when templates are put adjacent to each other, where some have it, and don't. This is needed as eval does not set a scope block.
            $reset_code = "eval(\\\$FULL_RESET_VAR_CODE); ";
        } elseif (strpos($code, '$bound') !== false) {
            $reset_code = "eval(\\\$RESET_VAR_CODE); ";
        } else {
            $reset_code = '';
        }
        $funcdef = "\$tpl_funcs['$myfunc']=\"{$reset_code}echo " . php_addslashes($code) . ";\";";
    }

    return $funcdef;
}

/**
 * Evaluate some Tempcode PHP, with ability to better debug.
 *
 * @param  ?string $code Code to evaluate (null: code not found)
 * @param  ?array $tpl_funcs Evaluation code context (null: N/A)
 * @param  ?array $parameters Evaluation parameters (null: N/A)
 * @param  ?ID_TEXT $cl Language (null: N/A)
 * @return mixed Result
 *
 * @ignore
 */
function tempcode_compiler_eval($code, &$tpl_funcs = null, $parameters = null, $cl = null)
{
    global $NO_EVAL_CACHE, $XSS_DETECT, $KEEP_TPL_FUNCS, $FULL_RESET_VAR_CODE, $RESET_VAR_CODE;

    if ($code === '') {
        return '';
    }

    $result = @eval($code); // Simple error suppressing because we totally expect this to sometimes fail. We can't always set the full Tempcode context correctly.

    return $result;
}
