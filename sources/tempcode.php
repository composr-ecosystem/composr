<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__tempcode()
{
    if (defined('ENTITY_ESCAPED')) {
        return;
    }

    if (!defined('ENTITY_ESCAPED')) {
        define('ENTITY_ESCAPED', 1); // HTML entities
        define('SQ_ESCAPED', 2); // Single quotes
        define('DQ_ESCAPED', 3); // Double quotes
        define('NL_ESCAPED', 4); // New lines disappear
        define('CC_ESCAPED', 5); // Comcode
        define('UL_ESCAPED', 6); // URL
        define('JSHTML_ESCAPED', 7); // JavaScript </ -> <\/
        define('NL2_ESCAPED', 8); // New lines go to \n
        define('ID_ESCAPED', 9); // Strings to to usable IDs
        define('NAUGHTY_ESCAPED', 10); // Used as a JavaScript variable name, for example... to prevent code injection
        define('NULL_ESCAPED', 11); // This is useful to mark something that takes strings but does not need escaping (usually because it is escaped further down the line)
        define('FORCIBLY_ENTITY_ESCAPED', 12); // To force a language string to be escaped
        define('CSS_ESCAPED', 13); // To stop CSS injection
        define('UL2_ESCAPED', 14); // rawurlencode
        define('PURE_STRING', 16); // Used to indicating we just put something directly into the output. Works with __toString or normal strings. Does no escaping.
        define('NO_OUTPUT', 17); // Process but do not output

        define('TC_SYMBOL', 0);
        define('TC_KNOWN', 1); // Either string or Tempcode
        define('TC_LANGUAGE_REFERENCE', 2);
        define('TC_PARAMETER', 3); // A late parameter for a compiled template
        define('TC_DIRECTIVE', 4);
    }

    global $XHTML_SPIT_OUT, $NO_EVAL_CACHE, $MEMORY_OVER_SPEED, $TEMPLATE_DISK_ORIGIN_CACHE, $REQUEST_BLOCK_NEST_LEVEL, $LOADED_TPL_CACHE, $KEEP_TPL_FUNCS;
    $XHTML_SPIT_OUT = null;
    $NO_EVAL_CACHE = false;
    $MEMORY_OVER_SPEED = (get_param_integer('keep_memory_over_speed', 0) === 1);
    $TEMPLATE_DISK_ORIGIN_CACHE = [];
    $REQUEST_BLOCK_NEST_LEVEL = 0;
    $LOADED_TPL_CACHE = [];
    $KEEP_TPL_FUNCS = [];

    global $RECORD_TEMPLATES_USED, $RECORDED_TEMPLATES_USED, $INJECT_HIDDEN_TEMPLATE_NAMES, $POSSIBLY_IN_SAFE_MODE_CACHE, $SCREEN_TEMPLATE_CALLED, $TITLE_CALLED;
    $RECORD_TEMPLATES_USED = false;
    $RECORDED_TEMPLATES_USED = [];
    $INJECT_HIDDEN_TEMPLATE_NAMES = (get_param_integer('keep_template_magic_markers', 0) === 1);
    /** The name of a template that was called to render the current screen (null: not rendering a screen), auto-populated within the template system. This is tracked during dev mode to confirm that each screen really does wrap itself in a proper screen template.
     *
     * @global ?ID_TEXT $SCREEN_TEMPLATE_CALLED
     */
    $SCREEN_TEMPLATE_CALLED = null;
    /** Whether a title has been called.
     *
     * @global boolean $TITLE_CALLED
     */
    $TITLE_CALLED = false;
    $POSSIBLY_IN_SAFE_MODE_CACHE = (get_param_integer('keep_safe_mode', 0) === 1);

    global $SIMPLE_ESCAPED, $XSS_DETECT;
    $SIMPLE_ESCAPED = [ENTITY_ESCAPED];
    if ($XSS_DETECT) {
        $SIMPLE_ESCAPED = [12345]; // Don't allow $SIMPLE_ESCAPED to work, as we need to work through full manual escaping
    }

    require_code('symbols');

    global $FULL_RESET_VAR_CODE, $RESET_VAR_CODE;
    // && substr($x, 0, 6) === \'bound_\' removed from the below for performance, not really needed
    $FULL_RESET_VAR_CODE = 'foreach(get_defined_vars() as $x => $_) { if ($x[0]==\'b\' && $x[1]==\'o\') unset($$x); } extract($parameters,EXTR_PREFIX_ALL,\'bound\');';
    $RESET_VAR_CODE = 'extract($parameters,EXTR_PREFIX_ALL,\'bound\');';

    global $IS_TEMPLATE_PREVIEW_OP_CACHE;
    $IS_TEMPLATE_PREVIEW_OP_CACHE = null;

    global $STOP_IF_STUCK, $STUCK_ABORT_SIGNAL, $TEMPCODE_OUTPUT_STARTED, $CSS_OUTPUT_STARTED, $JS_OUTPUT_STARTED, $TEMPCODE_CURRENT_PAGE_OUTPUTTING;
    $STOP_IF_STUCK = false;
    $STUCK_ABORT_SIGNAL = false;
    $TEMPCODE_OUTPUT_STARTED = false;
    $CSS_OUTPUT_STARTED = false;
    $JS_OUTPUT_STARTED = false;
    $TEMPCODE_CURRENT_PAGE_OUTPUTTING = null;

    global $TEMPCODE_PARAMETER_INLINING_MODE;
    $TEMPCODE_PARAMETER_INLINING_MODE = [false];
}

/**
 * Set the Tempcode parameter inlining mode.
 *
 * @param  boolean $m The current Tempcode parameter inlining mode
 */
function push_tempcode_parameter_inlining_mode(bool $m)
{
    global $TEMPCODE_PARAMETER_INLINING_MODE;
    array_push($TEMPCODE_PARAMETER_INLINING_MODE, $m);
}

/**
 * Restore the Tempcode parameter inlining mode.
 */
function pop_tempcode_parameter_inlining_mode()
{
    global $TEMPCODE_PARAMETER_INLINING_MODE;
    array_pop($TEMPCODE_PARAMETER_INLINING_MODE);
}

/**
 * Simple function to evaluate some Tempcode. Very rarely to be used, only if you can't call a method (e.g. you are copying direct into an array, such as in block caching).
 *
 * @param  Tempcode $ob Tempcode object
 * @return string Evaluated string
 */
function static_evaluate_tempcode(object $ob) : string
{
    return $ob->evaluate();
}

/**
 * Escape a string to fit within PHP double quotes TWICE. Needed sometimes when generating code. This function exists for performance reasons.
 *
 * @param  string $in String in
 * @return string Resultant string
 */
function php_addslashes_twice(string $in) : string
{
    global $PHP_REP_FROM, $PHP_REP_TO_TWICE;
    return str_replace($PHP_REP_FROM, $PHP_REP_TO_TWICE, $in);
}

/**
 * Create a unique identifier.
 *
 * @return string Unique Identifier
 */
function fast_uniqid() : string
{
    return uniqid('', true);
}

/**
 * Get a string (natural for Tempcode's stream-based processing-model) representation of a bound Tempcode construct.
 *
 * @param  mixed $var Construct (or null if not set)
 * @param  ID_TEXT $origin Where this parameter is referenced, in a compressed reference form
 * @return string Value
 */
function otp($var, string $origin = '') : string
{
    switch (gettype($var)) {
        case 'NULL':
            if ($GLOBALS['STOP_IF_STUCK']) {
                $GLOBALS['STUCK_ABORT_SIGNAL'] = true;
                return '';
            }
            return missing_template_parameter($origin);
        case 'string':
            return $var;
        case 'object':
            return $var->evaluate();
        case 'boolean':
            return $var ? '1' : '0';
        case 'array':
            $cnt = count($var);
            return ($cnt === 0) ? '' : strval($cnt);
    }
    return '';
}

/**
 * Give an error about a missing template parameter.
 *
 * @param  ID_TEXT $origin Where this parameter is referenced, in a slash-combined reference form
 * @return string Always ""
 */
function missing_template_parameter(string $origin) : string
{
    if ((error_reporting() & E_WARNING) === 0) { // Errors disabled via @ most likely, probably we're doing a test in tempcode_compiler.php
        return '';
    }
    if (strpos($origin, ':') === false) {
        return '';
    }
    list($template_name, $parameter) = ($origin === '') ? [do_lang('UNKNOWN'), do_lang('UNKNOWN')] : explode(':', $origin, 2);
    if (cms_strtolower_ascii($template_name) !== $template_name && (!is_file(get_file_base() . '/themes/default/templates/' . $template_name . '.tpl'))) {
        return ''; // Some kind of custom template, will be error prone
    }
    trigger_error(do_lang('MISSING_TEMPLATE_PARAMETER', $parameter, ($template_name === '') ? '???' : $template_name), E_USER_NOTICE);
    return '';
}

/**
 * Build a conventional Tempcode object.
 *
 * @param  integer $type The type of symbol this is (TC_SYMBOL, TC_LANGUAGE_REFERENCE)
 * @set 0 2
 * @param  ID_TEXT $name The name of the symbol
 * @param  array $parameters Parameters to the symbol. In same format as expected by ecv.
 * @param  array $escaping Escaping for the symbol
 * @return Tempcode Tempcode object
 */
function build_closure_tempcode(int $type, string $name, array $parameters, array $escaping = []) : object
{
    if ($escaping === null) {
        $_escaping = '[]';
    } else {
        $_escaping = '[' . @implode(',', $escaping) . ']';
    }

    $_type = strval($type);

    if (preg_match('#^[\w\-]*$#', $name) === 0) {
        $_name = php_addslashes_twice($name);
    } else {
        $_name = $name;
    }

    static $generator_base = null;
    static $generator_num = 0;
    if ($generator_base === null) {
        $generator_base = uniqid('', true);
    }
    $generator_num++;

    $has_tempcode = false;
    foreach ($parameters as $parameter) {
        if (isset($parameter->codename)/*faster than is_object*/) {
            $has_tempcode = true;
        }
    }

    $myfunc = 'do_runtime_' . $generator_base . '_' . strval($generator_num)/*We'll inline it actually rather than calling, for performance   fast_uniqid()*/;
    if ($name === '?' && $type === TC_SYMBOL) {
        $name = 'TERNARY';
    }

    if ($has_tempcode) {
        $funcdef = "\$tpl_funcs['$myfunc']=\"foreach (\\\$parameters as \\\$i=>\\\$p) { if (is_object(\\\$p)) \\\$parameters[\\\$i]=\\\$p->evaluate(); } echo ";
        if (($type === TC_SYMBOL) && (function_exists('ecv_' . $name))) {
            $funcdef .= "ecv_" . $name . "(\\\$cl," . ($_escaping) . ",\\\$parameters);\";\n";
        } else {
            $funcdef .= "ecv(\\\$cl," . ($_escaping) . "," . ($_type) . ",\\\"" . ($_name) . "\\\",\\\$parameters);\";\n";
        }
    } else {
        $_parameters = '';
        foreach ($parameters as $parameter) {
            if ($_parameters !== '') {
                $_parameters .= ',';
            }
            if (is_bool($parameter)) {
                $_parameters .= "\\\"" . ($parameter ? '1' : '0') . "\\\"";
            } else {
                $_parameters .= "\\\"" . php_addslashes_twice($parameter) . "\\\"";
            }
        }

        $funcdef = "\$tpl_funcs['$myfunc']=\"echo ";
        if (($type === TC_SYMBOL) && (function_exists('ecv_' . $name))) {
            $funcdef .= "ecv_" . $name . "(\\\$cl," . ($_escaping) . ",[" . $_parameters . "]);\";\n";
        } else {
            $funcdef .= "ecv(\\\$cl," . ($_escaping) . "," . ($_type) . ",\\\"" . ($_name) . "\\\",[" . $_parameters . "]);\";\n";
        }

        switch ($_name) {
            // Needs parameters for preprocessing, so we won't throw them out
            case 'REQUIRE_CSS':
            case 'REQUIRE_JAVASCRIPT':
            case 'FACILITATE_AJAX_BLOCK_CALL':
            case 'JS_TEMPCODE':
            case 'CSS_TEMPCODE':
            case 'SET':
            case 'SET_TITLE':
            case 'BLOCK':
            case 'PAGE_LINK':
            case 'LOAD_PAGE':
            case 'LOAD_PANEL':
            case 'CATALOGUE_ENTRY_FOR':
            case 'METADATA':
            case 'METADATA_IMAGE_EXTRACT':
            case 'CANONICAL_URL':
            case 'INSERT_SPAMMER_BLACKHOLE':
                break;

            default:
                $parameters = [];
                break;
        }
    }

    $ret = new Tempcode([[$myfunc => $funcdef], [[[$myfunc, $parameters, $type, $name, '']]]]);
    if ($type === TC_LANGUAGE_REFERENCE) {
        $ret->pure_lang = true;
    }
    return $ret;
}

/**
 * This will create a new Tempcode object that is containing a single specified symbol.
 *
 * @param  ID_TEXT $symbol The ID of the symbol to use
 * @param  array $parameters Symbol parameters
 * @param  array $escape Escaping
 * @return Tempcode A symbol Tempcode object
 */
function symbol_tempcode(string $symbol, array $parameters = [], array $escape = []) : object
{
    return build_closure_tempcode(TC_SYMBOL, $symbol, $parameters, $escape);
}

/**
 * This will create a new Tempcode object that is containing a single specified directive.
 *
 * @param  ID_TEXT $directive The ID of the directive to use
 * @param  mixed $content The contents (string or Tempcode); no special escaping is performed for you
 * @param  array $parameters Directive parameters
 * @return Tempcode A directive Tempcode object
 */
function directive_tempcode(string $directive, $content, array $parameters = []) : object
{
    $parameters[] = $content;

    return build_closure_tempcode(TC_DIRECTIVE, $directive, $parameters);
}

/**
 * Perform a simple while loop, that can be inlined in an expression.
 *
 * @param  array $args The template bound parameters
 * @param  mixed $control_function The loop control function
 * @param  mixed $main_function The loop execution function
 * @return string Result
 */
function closure_while_loop(array $args, callable $control_function, callable $main_function) : string
{
    $out = '';
    while (call_user_func_array($control_function, $args)) {
        $out .= call_user_func_array($main_function, $args);
    }
    return $out;
}

/**
 * Evaluate some PHP code to put the result into an expression (code is allowed to have side effects).
 *
 * @param  string $code The code
 * @param  array $parameters Template parameters
 * @return string Result
 */
function closure_eval(string $code, array $parameters) : string
{
    if (get_value('allow_php_in_templates') !== '1') {
        return do_lang('NO_PHP_IN_TEMPLATES');
    }

    try {
        $ret = eval($code);
    } catch (Error $e) {
        tempcode_error($e, $code);
    }
    if (!is_string($ret)) {
        $ret = @strval($ret);
    }
    return $ret;
}

/**
 * Perform a simple loop, that can be inlined in an expression.
 *
 * @param  array $param The template bound parameters
 * @param  array $args The loop directive parameters
 * @param  mixed $main_function The loop execution function
 * @return string Result
 */
function closure_loop(array $param, array $args, callable $main_function) : string
{
    $value = '';
    if (isset($param[0])) {
        $array_key = $param[0];
        if ((is_numeric($array_key)) || (strpos($array_key, ',') !== false) || (strpos($array_key, '=') !== false)) {
            $array = comma_list_str_to_arr($array_key);
        } else {
            $array = isset($param['vars'][$array_key]) ? $param['vars'][$array_key] : [];
        }
        if (!is_array($array)) {
            return do_lang('TEMPCODE_NOT_ARRAY'); // Must have this, otherwise will loop over the Tempcode object
        }
        if (isset($param[1 + 1])) { /* NB: +1 is due to there being a non-numeric index here too */
            $columns = intval($param[1]);
            if ($columns === 0) {
                $columns = 1;
            }
            $row_starter = isset($param[2 + 1]) ? $param[2] : '<tr>';
            $row_terminator = isset($param[3 + 1]) ? $param[3] : '</tr>';
            if (!empty($array)) {
                $value .= $row_starter;
            }

            // Sorting
            if (isset($param[4 + 1])) {
                $sort_key = $param[4];

                $rev = ((isset($param[5 + 1])) && ($param[5] === 'DESC'));
                if ($sort_key !== '') {
                    sort_maps_by($array, $sort_key);
                }
                if ($rev) {
                    $array = array_reverse($array);
                }
            }
        }
        $col = 0;

        $first = true;
        $max_index = count($array) - 1;
        foreach ($array as $go_key => $go) {
            if (!is_array($go)) {
                $go = ['_loop_var' => $go];
            } else {
                $go['_loop_var'] = '(array)'; // In case it's not a list of maps, but just a list
            }

            if ((isset($param[2])) && ($col % $columns === 0) && ($col !== 0)) {
                $value .= $row_starter;
            }

            $ps = $go + ['_loop_key' => is_integer($go_key) ? strval($go_key) : $go_key, '_i' => strval($col), '_first' => $first, '_last' => $col === $max_index];
            $args[0] = $ps + $args[0];
            $args[0]['vars'] = $args[0];
            $value .= call_user_func_array($main_function, $args);

            ++$col;
            if ((isset($param[3])) && ($col % $columns === 0)) {
                $value .= $row_terminator;
            }
            $first = false;
        }
        if ((isset($param[2])) && ($col % $columns !== 0)) {
            $value .= $row_terminator;
        }
    }

    return $value;
}

/**
 * Serialize the passed parameter names as JSON.
 *
 * @param  array $param The template bound parameters
 * @param  array $args The loop directive parameters
 * @param  mixed $main_function The loop execution function
 * @return string Result
 */
function closure_params_json(array $param, array $args, callable $main_function) : string
{
    global $TEMPCODE_SETGET;

    $output = [];
    $template_params = $param['vars'];
    unset($param['vars']);

    foreach ($param as $param_name) {
        $param_name = is_object($param_name) ? $param_name->evaluate() : strval($param_name);

        if ($param_name === '') {
            continue;
        }

        if (array_key_exists($param_name, $template_params)) {
            $output[$param_name] = $template_params[$param_name];
        } elseif (array_key_exists($param_name, $TEMPCODE_SETGET)) {
            $output[$param_name] = $TEMPCODE_SETGET[$param_name];
        }
    }

    $output = evaluate_tempcode_elements($output);
    $output = camel_case_array_keys($output);
    $_output = json_encode($output, JSON_UNESCAPED_SLASHES | JSON_NUMERIC_CHECK);

    $ps = ['_' => $_output]; // "{_}" parameter inside the directive block represents the JSON output
    $args[0] = $ps + $args[0]; // Combine arrays
    $args[0]['vars'] = $args[0];
    $value = call_user_func_array($main_function, $args);

    return $value;
}

/**
 * Recursively evaluate all Tempcode in a map.
 *
 * @param  array $arr Template map
 * @return array Adjusted map
 */
function evaluate_tempcode_elements(array $arr) : array
{
    foreach ($arr as $k => $v) {
        if (is_array($v)) {
            $arr[$k] = evaluate_tempcode_elements($v);
            continue;
        }

        if (is_object($v)) {
            $arr[$k] = $v->evaluate();
        }
    }

    return $arr;
}

/**
 * Make all array keys camel case.
 *
 * @param  array $arr Template map
 * @return array Adjusted map
 */
function camel_case_array_keys(array $arr) : array
{
    $new_arr = [];

    foreach ($arr as $k => $v) {
        if (is_integer($k)) {
            $k = strval($k);
        }

        $leading_underscore = $k[0] === '_';
        $k = cms_lcfirst_ascii(str_replace(' ', '', cms_ucwords_ascii(str_replace('_', ' ', cms_strtolower_ascii($k))))); // camelCase the key

        if ($leading_underscore) {
            $k = '_' . $k;
        }

        if (is_array($v)) {
            $v = camel_case_array_keys($v);
        }

        $new_arr[$k] = $v;
    }

    return $new_arr;
}

/**
 * Convert a string to Tempcode.
 *
 * @param  string $string String
 * @return Tempcode Tempcode
 */
function make_string_tempcode(string $string) : object
{
    static $generator_base = null;
    static $generator_num = 0;
    if ($generator_base === null) {
        $generator_base = uniqid('', true);
    }
    $generator_num++;

    $myfunc = 'string_attach_' . $generator_base . '_' . strval($generator_num)/*We'll inline it actually rather than calling, for performance   fast_uniqid()*/;
    $code_to_preexecute = [$myfunc => "\$tpl_funcs['$myfunc']=\"echo \\\"" . php_addslashes_twice($string) . "\\\";\";\n"];
    $seq_parts = [[[$myfunc, [], TC_KNOWN, '', '']]];
    $ret = new Tempcode([$code_to_preexecute, $seq_parts]);
    $ret->is_all_static = true;
    return $ret;
}

/**
 * Escape certain special characters in the provided string/Tempcode, so that it can be embedded as text within HTML.
 *
 * @param  mixed $data Plain-text string
 * @return Tempcode HTML string
 */
function escape_html_tempcode($data) : object
{
    // This is a bit of a hack, but it works. We don't want to have to have a route for altering Tempcode structure (because that has a performance hit, so we piggy-back on recursing through a null language string and add escaping when we do it)
    return build_closure_tempcode(TC_LANGUAGE_REFERENCE, 'dont_escape_trick', [$data], [FORCIBLY_ENTITY_ESCAPED]);
}

/**
 * Apply whatever escaping is requested to the given value (by reference).
 *
 * @param  array $escaped A list of escaping to do
 * @param  string $value The string to apply the escapings to
 * @return string Output string (you do not need to collect this, as $value is pass-by-reference -- but this is useful for chaining)
 */
function apply_tempcode_escaping(array $escaped, string &$value) : string
{
    static $charset = null;
    if ($charset === null) {
        $charset = get_charset();
    }

    global $ESCAPE_HTML_OUTPUT;
    foreach ($escaped as $escape) {
        if ($escape === ENTITY_ESCAPED) {
            if ((!isset($ESCAPE_HTML_OUTPUT[$value])/*not already auto-escaped once*/) || (!function_exists('has_solemnly_declared')) || (has_solemnly_declared(I_UNDERSTAND_XSS)/*no auto-escape*/)) {
                $value = @htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
            }
        } elseif ($escape === FORCIBLY_ENTITY_ESCAPED) {
            $value = @htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
        } elseif ($escape === SQ_ESCAPED) {
            $value = str_replace('\'', '\\\'', str_replace('\\', '\\\\', $value));
        } elseif ($escape === DQ_ESCAPED) {
            $value = str_replace('"', '\\"', str_replace('\\', '\\\\', $value));
        } elseif ($escape === NL_ESCAPED) {
            $value = str_replace(["\r", "\n"], ['', ''], $value);
        } elseif ($escape === NL2_ESCAPED) {
            $value = str_replace(["\r", "\n"], ['', '\n'], $value);
        } elseif ($escape === CC_ESCAPED) {
            $value = str_replace('[', '\\[', str_replace('\\', '\\\\', $value));
        } elseif ($escape === UL_ESCAPED) {
            $value = cms_urlencode($value);
        } elseif ($escape === UL2_ESCAPED) {
            $value = rawurlencode($value);
        } elseif ($escape === JSHTML_ESCAPED) {
            $value = str_replace(']]>', ']]\'+\'>', str_replace('</', '<\/', $value));
        } elseif ($escape === ID_ESCAPED) {
            $value = fix_id($value);
        } elseif ($escape === CSS_ESCAPED) {
            $value = preg_replace('#[^\w\#\.\-\%]#', '_', $value);
        } elseif ($escape === NAUGHTY_ESCAPED) {
            $value = filter_naughty_harsh($value, true);
        } elseif ($escape === NO_OUTPUT) {
            $value = '';
        }
    }
    if (($GLOBALS['XSS_DETECT']) && (!empty($escaped))) {
        ocp_mark_as_escaped($value);
    }

    return $value;
}

/**
 * Apply whatever escaping is requested to the given value (by return).
 *
 * @param  array $escaped A list of escaping to do
 * @param  string $value The string to apply the escapings to
 * @return string Output string
 */
function apply_tempcode_escaping_inline(array $escaped, string $value) : string
{
    static $charset = null;
    if ($charset === null) {
        $charset = get_charset();
    }

    global $ESCAPE_HTML_OUTPUT;
    foreach ($escaped as $escape) {
        if ($escape === ENTITY_ESCAPED) {
            if ((!isset($ESCAPE_HTML_OUTPUT[$value])/*not already auto-escaped once*/) || (!function_exists('has_solemnly_declared')) || (has_solemnly_declared(I_UNDERSTAND_XSS)/*no auto-escape*/)) {
                $value = @htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
            }
        } elseif ($escape === FORCIBLY_ENTITY_ESCAPED) {
            $value = @htmlspecialchars($value, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
        } elseif ($escape === SQ_ESCAPED) {
            $value = str_replace('\'', '\\\'', str_replace('\\', '\\\\', $value));
        } elseif ($escape === DQ_ESCAPED) {
            $value = str_replace('"', '\\"', str_replace('\\', '\\\\', $value));
        } elseif ($escape === NL_ESCAPED) {
            $value = str_replace(["\r", "\n"], ['', ''], $value);
        } elseif ($escape === NL2_ESCAPED) {
            $value = str_replace(["\r", "\n"], ['', '\n'], $value);
        } elseif ($escape === CC_ESCAPED) {
            $value = str_replace('[', '\\[', str_replace('\\', '\\\\', $value));
        } elseif ($escape === UL_ESCAPED) {
            $value = cms_urlencode($value);
        } elseif ($escape === UL2_ESCAPED) {
            $value = rawurlencode($value);
        } elseif ($escape === JSHTML_ESCAPED) {
            $value = str_replace(']]>', ']]\'+\'>', str_replace('</', '<\/', $value));
        } elseif ($escape === ID_ESCAPED) {
            $value = fix_id($value);
        } elseif ($escape === CSS_ESCAPED) {
            $value = preg_replace('#[^\w\#\.\-\%]#', '_', $value);
        } elseif ($escape === NAUGHTY_ESCAPED) {
            $value = filter_naughty_harsh($value, true);
        } elseif ($escape === NO_OUTPUT) {
            $value = '';
        }
    }
    if (($GLOBALS['XSS_DETECT']) && (!empty($escaped))) {
        ocp_mark_as_escaped($value);
    }

    return $value;
}

/**
 * This will create a new Tempcode object that is containing a single specified language string codename.
 * See do_lang for more documentation.
 *
 * @param  ID_TEXT $lang_string The codename of the language string to use
 * @param  ?mixed $parameter1 The first parameter [string or Tempcode, make sure escaped] (replaces {1}) (null: none)
 * @param  ?mixed $parameter2 The second parameter [string or Tempcode, make sure escaped] (replaces {2}) (null: none)
 * @param  ?mixed $parameter3 The third parameter (replaces {3}). May be an array of [of string or Tempcode, make sure escaped], to allow any number of additional args (null: none)
 * @return Tempcode A language Tempcode object
 */
function do_lang_tempcode(string $lang_string, $parameter1 = null, $parameter2 = null, $parameter3 = null) : object
{
    $parameters = [];
    if (isset($parameter1)) {
        $parameters[] = $parameter1;
    }
    if (isset($parameter2)) {
        $parameters[] = $parameter2;
    }
    if (isset($parameter3)) {
        if (!is_array($parameter3)) {
            $parameters[] = $parameter3;
        } else {
            $parameters = array_merge($parameters, $parameter3);
        }
    }

    return build_closure_tempcode(TC_LANGUAGE_REFERENCE, $lang_string, $parameters);
}

/**
 * Provide automatic escaping for a template call.
 *
 * @param  array $parameters Template parameters
 */
function kid_gloves_html_escaping(array &$parameters)
{
    if (get_value('disable_kid_gloves_html') === '1') {
        return;
    }

    global $KNOWN_TRUE_HTML;

    $param = mixed();
    foreach ($parameters as &$param) {
        if (is_string($param)) {
            if ((strpos($param, "'") !== false) || (strpos($param, '"') !== false) || (strpos($param, '<') !== false) || (strpos($param, '>') !== false)) {
                if (!isset($KNOWN_TRUE_HTML[$param])) {
                    $param = escape_html($param);
                }
            }
        } elseif (is_array($param)) {
            kid_gloves_html_escaping($param);
        }
    }
}

/**
 * Provide automatic escaping for a particular parameter.
 *
 * @param  string $param Parameter
 */
function kid_gloves_html_escaping_singular(string &$param)
{
    if (get_value('disable_kid_gloves_html') === '1') {
        return;
    }

    global $KNOWN_TRUE_HTML;

    if ((strpos($param, "'") !== false) || (strpos($param, '"') !== false) || (strpos($param, '<') !== false) || (strpos($param, '>') !== false)) {
        if (!isset($KNOWN_TRUE_HTML[$param])) {
            $param = escape_html($param);
        }
    }
}

/**
 * Work out if we're doing a template preview op.
 */
function fill_template_preview_op_cache()
{
    global $IS_TEMPLATE_PREVIEW_OP_CACHE;
    $IS_TEMPLATE_PREVIEW_OP_CACHE = isset($_POST['template_preview_op']) && ($_POST['template_preview_op'] === '1') && ((get_page_name() !== 'admin_themes') || (get_param_string('type', '') === 'screen_preview'));
}

/**
 * Get a Tempcoded version of a software template. It is perhaps the most common function to load up templates using do_template, and then attach them together either as parameters to each other, or via the Tempcode attach method.
 *
 * @param  ID_TEXT $codename The codename of the template being loaded
 * @param  array $parameters A map of parameters for the template (key to value); you can have any number of parameters of any name, there is no set standard; having a _GUID parameter of random value is a convention
 * @param  ?LANGUAGE_NAME $lang The language to load the template in (templates can embed language references) (null: users own language)
 * @param  boolean $light_error Whether to not produce a stack trace if the template is missing
 * @param  ?ID_TEXT $fallback Alternate template to use if the primary one does not exist (null: none)
 * @param  string $suffix File type suffix of template file (e.g. .tpl)
 * @set .tpl .js .xml .txt .css
 * @param  string $directory Subdirectory type to look in
 * @set templates javascript xml text css
 * @param  ?ID_TEXT $theme Theme to use (null: current theme)
 * @param  boolean $non_custom_only Whether to only search in the default templates
 * @return Tempcode The Tempcode for this template
 */
function do_template(string $codename, array $parameters = [], ?string $lang = null, bool $light_error = false, ?string $fallback = null, string $suffix = '.tpl', string $directory = 'templates', ?string $theme = null, bool $non_custom_only = false) : object
{
    if (empty($lang)) {
        global $USER_LANG_CACHED;
        $lang = isset($USER_LANG_CACHED) ? $USER_LANG_CACHED : (function_exists('user_lang') ? user_lang() : 'EN');
    }

    if ($GLOBALS['SEMI_DEV_MODE']) {
        if (($codename === cms_strtolower_ascii($codename)) && ($directory === 'templates')) {
            fatal_exit('Template names should be in upper case, and the files should be stored in upper case (' . $codename . ').');
        }

        if ($codename !== 'MENU_BRANCH_dropdown'/*optimisation*/) {
            if ((substr($codename, -7) === '_SCREEN') || (substr($codename, -8) === '_OVERLAY') || ($codename === 'POOR_XHTML_WRAPPER')) {
                $GLOBALS['SCREEN_TEMPLATE_CALLED'] = $codename;
            }
        }
    }

    if ((function_exists('has_solemnly_declared')) && (!has_solemnly_declared(I_UNDERSTAND_XSS))) {
        kid_gloves_html_escaping($parameters);
    }

    global $IS_TEMPLATE_PREVIEW_OP_CACHE, $RECORD_TEMPLATES_USED, $RECORDED_TEMPLATES_USED, $RECORD_LANG_STRINGS, $FILE_ARRAY, $KEEP_MARKERS, $SHOW_EDIT_LINKS, $XHTML_SPIT_OUT, $CACHE_TEMPLATES, $FORUM_DRIVER, $POSSIBLY_IN_SAFE_MODE_CACHE, $USER_THEME_CACHE, $TEMPLATE_DISK_ORIGIN_CACHE, $LOADED_TPL_CACHE, $TEMPCODE_PARAMETER_INLINING_MODE;

    if ($IS_TEMPLATE_PREVIEW_OP_CACHE === null) {
        fill_template_preview_op_cache();
    }

    $special_treatment = ((($KEEP_MARKERS) || ($SHOW_EDIT_LINKS)) && ($XHTML_SPIT_OUT === null));

    if ($RECORD_TEMPLATES_USED) {
        record_template_used($directory . '/' . $codename . $suffix);
    }

    $inlining_mode = end($TEMPCODE_PARAMETER_INLINING_MODE);

    // Variables we'll need
    if (!isset($theme)) {
        $theme = isset($USER_THEME_CACHE) ? $USER_THEME_CACHE : (((isset($FORUM_DRIVER)) && (is_object($FORUM_DRIVER)) && (method_exists($FORUM_DRIVER, 'get_theme'))) ? filter_naughty($FORUM_DRIVER->get_theme()) : 'default');
    }
    $prefix_default = get_file_base() . '/themes/';
    $prefix = get_custom_file_base() . '/themes/';

    // Is it structurally cached on disk yet?
    $_data = mixed();
    $_data = false;
    $loaded_this_once = isset($TEMPLATE_DISK_ORIGIN_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only]);

    // Load from run-time cache?
    if (isset($LOADED_TPL_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only])) {
        // We have run-time caching
        $_data = $LOADED_TPL_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only];
    }

    // Find where template is on disk
    $found = null;
    $may_use_template_cache =
        ($CACHE_TEMPLATES) &&
        (has_caching_for('template', $codename)) &&
        (!$IS_TEMPLATE_PREVIEW_OP_CACHE) &&
        ((!$POSSIBLY_IN_SAFE_MODE_CACHE) || (isset($GLOBALS['SITE_INFO']['safe_mode'])) || (!in_safe_mode())) &&
        (!$RECORD_LANG_STRINGS/*Tempcode compilation embeds lang strings*/) &&
        !$inlining_mode;
    if (!$loaded_this_once) {
        $found = find_template_place($codename, $theme, $suffix, $directory, $non_custom_only);
        $TEMPLATE_DISK_ORIGIN_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only] = $found;
    } else {
        $found = $TEMPLATE_DISK_ORIGIN_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only];
    }

    // Load from template cache?
    if ($may_use_template_cache) {
        if ($found !== null) {
            $tcp_path_prefix = $prefix . $theme . '/templates_cached/' . $lang . '/';
            $tcp_path_suffix = $found[2] . '.tcp';
            $tcp_path = $tcp_path_prefix . $codename . ($non_custom_only ? '_non_custom_only' : '') . $tcp_path_suffix;

            if ($loaded_this_once) {
                $may_use_cache = true;
            } else {
                // We need to support smart-decaching
                global $SITE_INFO;
                $support_smart_decaching = support_smart_decaching();
                $found_disk_file = false;
                if ($support_smart_decaching) {
                    if (get_custom_file_base() !== get_file_base()) {
                        $file_path = get_custom_file_base() . '/themes/' . $found[0] . $found[1] . $codename . $found[2];
                        if (is_file($file_path)) {
                            $found_disk_file = true;
                        } else {
                            $file_path = get_file_base() . '/themes/' . $found[0] . $found[1] . $codename . $found[2];
                            if (is_file($file_path)) {
                                $found_disk_file = true;
                            }
                        }
                    } else {
                        $file_path = get_custom_file_base() . '/themes/' . $found[0] . $found[1] . $codename . $found[2];
                        if (is_file($file_path)) {
                            $found_disk_file = true;
                        }
                    }
                    if (GOOGLE_APPENGINE) {
                        gae_optimistic_cache(true);
                    }
                    $tcp_time = is_file($tcp_path) ? @filemtime($tcp_path) : false;
                    if (GOOGLE_APPENGINE) {
                        gae_optimistic_cache(false);
                    }
                }

                $may_use_cache = false;
                if ((!$support_smart_decaching) || (($tcp_time !== false) && ($found_disk_file))/*if in install can be found yet no file at path due to running from data.cms*/ && ($found !== null)) {
                    if ((!$support_smart_decaching) || ((is_file($file_path)) && (filemtime($file_path) < $tcp_time) && (dependencies_are_good($codename, $suffix, $directory, $found[0], $tcp_time)))) {
                        $may_use_cache = true;
                    }
                }
            }

            if ($may_use_cache) {
                $_data = new Tempcode();
                $test = $_data->from_assembly_executed($tcp_path, [$codename, $codename, $lang, $theme, $suffix, $directory, $fallback]);
                if (!$test) {
                    $_data = false; // failed
                }
            }
        }
    }

    // Compile?
    if ($_data === false) { // No, it's not
        if ($found === null) {
            if ($fallback === null) {
                if ($light_error) {
                    return paragraph(do_lang_tempcode('MISSING_TEMPLATE_FILE', escape_html($directory . '/' . $codename . $suffix)), '5bi5yne9a1trw48se2psx1bbfagkahcy', 'nothing-here');
                }
                fatal_exit(do_lang_tempcode('MISSING_TEMPLATE_FILE', escape_html($directory . '/' . $codename . $suffix)));
            } else {
                $result = do_template($fallback, $parameters, $lang, $light_error, null, $suffix, $directory, $theme);
                return $result;
            }
        } else {
            require_code('tempcode_compiler');
            if ($inlining_mode) {
                $_data = _do_template($found[0], $found[1], $codename, $codename, $lang, $found[2], $theme, $parameters, $non_custom_only);
            } else {
                $_parameters = null;
                $_data = _do_template($found[0], $found[1], $codename, $codename, $lang, $found[2], $theme, $_parameters, $non_custom_only);
            }
        }
    }

    if ((($loaded_this_once) || (($suffix == '.tpl') && (substr($codename, -7) !== '_SCREEN'))) && (!isset($LOADED_TPL_CACHE[$codename][$theme])) && (!$inlining_mode)) { // On 3rd load (and onwards) it will be fully cached
        // Set run-time cache
        $LOADED_TPL_CACHE[$codename][$lang][$theme][$suffix][$directory][$non_custom_only] = $_data;
    }

    // Optimisation
    if (empty($parameters) && !$GLOBALS['INJECT_HIDDEN_TEMPLATE_NAMES']) { // Streamlined if no parameters involved
        $out = new Tempcode();

        $out->codename = $codename;

        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            $out->metadata = create_template_tree_metadata(TEMPLATE_TREE_NODE__TEMPLATE_INSTANCE, $directory . '/' . $codename . $suffix, isset($_data->metadata) ? $_data->metadata['children'] : []);
        }

        $out->code_to_preexecute = $_data->code_to_preexecute;

        if (!empty($_data->preprocessable_bits)) {
            $out->preprocessable_bits = $_data->preprocessable_bits;
        }

        $out->seq_parts = $_data->seq_parts;
        foreach ($out->seq_parts as &$seq_parts_group) {
            foreach ($seq_parts_group as &$seq_part) {
                if ($seq_part[1] !== []) {
                    $seq_part[1] = [];
                }
            }
        }

        return $out;
    }

    // Bind parameters
    $ret = $_data->bind($parameters, $codename);
    if ($GLOBALS['RECORD_TEMPLATES_USED']) {
        $ret->metadata = create_template_tree_metadata(TEMPLATE_TREE_NODE__TEMPLATE_INSTANCE, $directory . '/' . $codename . $suffix, isset($ret->metadata) ? $ret->metadata['children'] : []);
        if ($special_treatment) {
            $ret->metadata['type'] = TEMPLATE_TREE_NODE__UNKNOWN; // Stop optimisation that assumes the codename represents the sole content of it
        }
    }

    // Special rendering modes
    if ($special_treatment) {
        if ($KEEP_MARKERS) {
            $__data = new Tempcode();
            $__data->attach('<!-- START-TEMPLATE=' . escape_html($codename) . ' -->');
            $__data->attach($ret);
            $__data->attach('<!-- END-TEMPLATE=' . escape_html($codename) . ' -->');
            $ret = $__data;
        }
        if (($SHOW_EDIT_LINKS) && ($codename !== 'PARAM_INFO') && ($codename !== 'TEMPLATE_EDIT_LINK')) {
            $edit_url = build_url(['page' => 'admin_themes', 'type' => 'edit_templates', 'theme' => $theme, 'f0file' => $directory . '/' . $codename . $suffix], get_module_zone('admin_themes'));

            $parameters2 = [];
            foreach ($parameters as $k => $v) {
                if (is_array($v)) {
                    $parameters2[$k] = '(array)';
                } elseif (!is_object($v)) {
                    $parameters2[$k] = $v;
                } else {
                    $parameters2[$k] = $v->evaluate();
                    if (strlen($parameters2[$k]) > 100) {
                        $parameters2[$k] = substr($parameters2[$k], 0, 100) . '...';
                    }
                }
            }
            $param_info = do_template('PARAM_INFO', ['_GUID' => '0070acad5e82e0877ad49e25283d342e', 'MAP' => $parameters2]);

            $ret = do_template('TEMPLATE_EDIT_LINK', ['_GUID' => '511ae911d31a5b237a4371ff22fc78fd', 'PARAM_INFO' => $param_info, 'CONTENTS' => $ret, 'CODENAME' => $codename, 'EDIT_URL' => $edit_url]);
        }
    }

    if ($GLOBALS['INJECT_HIDDEN_TEMPLATE_NAMES'] && $directory === 'templates' && (running_script('index') || running_script('iframe')) && $codename !== 'GLOBAL_HTML_WRAP'/*don't want junk at start*/ && $codename !== 'FORM_SCREEN_INPUT_HIDDEN' && $codename !== 'FORM_SCREEN_INPUT_HIDDEN_2') {
        $ret2 = new Tempcode();
        $ret2->attach(invisible_output_encode('<' . $directory . '/' . $codename . $suffix . '>'));
        $ret2->attach($ret);
        $ret2->attach(invisible_output_encode('</' . $directory . '/' . $codename . $suffix . '>'));
        return $ret2;
    }

    return $ret;
}

/**
 * Prepare some invisible text to annotate the HTML output stream.
 * It works using invisible unicode characters.
 * It's a bit like having hidden messages in the “umm”s and “err”s in speech. If I said “it’s lovely err err umm outside, want to umm err err umm go for a walk”, it can be a hidden code.
 * Also implemented in JavaScript (core_themeing.js), function invisible_output_encode(string).
 *
 * @param  string $string Input
 * @return string Output
 */
function invisible_output_encode(string $string) : string
{
    $ret = '';

    $utf8 = (get_charset() === 'utf-8');

    $len = strlen($string);
    for ($i = 0; $i < $len; $i++) {
        $char = ord($string[$i]);

        for ($_bit = 7; $_bit >= 0; $_bit--) {
            $_bitmask = '1' . str_repeat('0', $_bit);
            $bitmask = bindec($_bitmask);
            $bit = ($char & $bitmask) !== 0;
            if ($utf8) {
                if ($bit) {
                    $ret .= chr(0xE2) . chr(0x80) . chr(0x8B); // http://www.fileformat.info/info/unicode/char/200B/index.htm (ZERO WIDTH SPACE)
                } else {
                    $ret .= chr(0xEF) . chr(0xBB) . chr(0xBF); // http://www.fileformat.info/info/unicode/char/feff/index.htm (ZERO WIDTH NO-BREAK SPACE)
                }
            } else {
                $ret .= $bit ? '&#x200b;' : '&#xfeff;';
            }
        }
    }

    if ($GLOBALS['XSS_DETECT']) {
        ocp_mark_as_escaped($ret);
    }

    // Possible for future...
    //  http://www.fileformat.info/info/unicode/char/fffe/index.htm (Unicode Noncharacter)
    //  http://www.unicode.org/faq/private_use.html
    //  https://en.wikipedia.org/wiki/Unicode_control_characters
    //  https://en.wikipedia.org/wiki/Control_character
    //  https://en.wikipedia.org/wiki/Whitespace_character#Unicode
    //  These all seem to have problems though. They're either explicitly visible spaces, show as unicode boxes (i.e. the no-font-character box), throw off lexical analysis, or at least they trigger non-empty element rules in CSS etc.
    //   Null byte (0x00) seems okay, but it's likely browsers may remove it entirely.

    return $ret;
}

/**
 * Strip out the invisible_output_encode encoding.
 *
 * @param  string $string Input
 * @return string Output
 */
function strip_invisible_output_encoding(string $string) : string
{
    if ($GLOBALS['XSS_DETECT']) {
        $is_escaped = ocp_is_escaped($string);
    }

    if (get_charset() === 'utf-8') {
        $string = str_replace([chr(0xE2) . chr(0x80) . chr(0x8B), chr(0xEF) . chr(0xBB) . chr(0xBF)], ['', ''], $string);
    } else {
        $string = str_replace(['&#x200b;', '&#xfeff;'], ['', ''], $string);
    }

    if ($GLOBALS['XSS_DETECT']) {
        if ($is_escaped) {
            ocp_mark_as_escaped($string);
        }
    }

    return $string;
}

/**
 * Do a smart decache dependency check for the case of multiple files.
 *
 * @param  string $codename Dependency codename
 * @param  string $suffix File type suffix of template file (e.g. .tpl)
 * @set .tpl .js .xml .txt .css
 * @param  string $directory Subdirectory type to look in
 * @set templates javascript xml text css
 * @param  ID_TEXT $theme Theme to use
 * @param  TIME $tcp_time Time of cache file
 * @return boolean Whether decache is NOT needed
 */
function dependencies_are_good(string $codename, string $suffix, string $directory, string $theme, int $tcp_time) : bool
{
    $key = 'dependency__' . $directory . '__' . $codename;

    global $SITE_INFO;
    if (empty($SITE_INFO[$key])) {
        if (!$GLOBALS['DEV_MODE']) {
            return true;
        }

        switch ($key) {
            case 'dependency__templates__STANDALONE_HTML_WRAP':
                $SITE_INFO[$key] = 'HTML_HEAD';
                break;

            case 'dependency__templates__GLOBAL_HTML_WRAP':
                $SITE_INFO[$key] = 'HTML_HEAD';
                break;

            case 'dependency__templates__HTML_HEAD':
                $SITE_INFO[$key] = 'HTML_HEAD_POLYFILLS';
                break;

            case 'dependency__css__global':
                $SITE_INFO[$key] = 'toastify,' . get_theme_option('globally_included_css_files');
                break;

            case 'dependency__javascript__global':
                $SITE_INFO[$key] = '_json5,_util,_dom,_cms,_cms_form,_cms_ui,_cms_templates,_cms_views,_cms_behaviors,toastify,' . get_theme_option('globally_included_js_files');
                break;

            case 'dependency__javascript__editing':
                $SITE_INFO[$key] = '_wysiwyg_settings';
                break;

            case 'dependency__javascript__posting':
                $SITE_INFO[$key] = '_attachment_ui_defaults';
                break;

            default:
                return true;
        }
    }

    $dep = explode(',', $SITE_INFO[$key]);

    foreach ($dep as $d) {
        $d = trim($d);
        if ($d == '') {
            continue;
        }

        $found = find_template_place($d, $theme, $suffix, $directory);
        $full_path = get_custom_file_base() . '/themes/' . $found[0] . $found[1] . $d . $found[2];
        if (!is_file($full_path)) {
            $full_path = get_file_base() . '/themes/' . $found[0] . $found[1] . $d . $found[2];
        }

        $mtime = @filemtime($full_path);
        if (($mtime !== false) && ($mtime > $tcp_time)) {
            return false;
        }
    }
    return true;
}

/**
 * Certain symbols need preprocessing, before the output stream is made.
 *
 * @param  array $seq_part Symbol details
 * @param  array $children Where we store children stuff
 * @param  ID_TEXT $template_name The name of the template this came from (blank: not from a file / unknown); only passed for directives to avoid infinite loops with INCLUDE
 */
function handle_symbol_preprocessing(array $seq_part, array &$children, string $template_name = '')
{
    switch ($seq_part[2]) {
        case 'PAGE_LINK':
            $param = $seq_part[3];

            if (isset($param[0])) {
                if (isset($param[0]->codename/*faster than is_object*/)) {
                    $param[0] = $param[0]->evaluate();
                }

                list(, $url_parts,) = page_link_decode($param[0]);

                if ((!isset($url_parts['id'])) && (!array_key_exists('id', $url_parts))) {
                    return;
                }
                if ((!isset($url_parts['type'])) && (!array_key_exists('type', $url_parts))) {
                    $url_parts['type'] = 'browse';
                }
                if ($url_parts['type'] === null) {
                    $url_parts['type'] = 'browse'; // null means "do not take from environment"; so we default it to 'browse' (even though it might actually be left out when URL Schemes are off, we know it cannot be for URL Schemes)
                }
                if (!array_key_exists('page', $url_parts)) {
                    return;
                }
                if ($url_parts['id'] === null) {
                    if (($url_parts['page'] == 'members') && ($url_parts['type'] == 'view')) {
                        $url_parts['id'] = strval(get_member()); // FUDGE
                    } else {
                        $url_parts['id'] = strval(db_get_first_id());
                    }
                }

                // Does this URL arrangement support monikers?
                global $LOADED_MONIKERS_CACHE;
                if (!isset($LOADED_MONIKERS_CACHE[$url_parts['type']][$url_parts['page']][$url_parts['id']])) {
                    global $CONTENT_OBS;
                    load_moniker_hooks();
                    $found = false;
                    $looking_for = '_SEARCH:' . $url_parts['page'] . ':' . $url_parts['type'] . ':_WILD';

                    $ob_info = isset($CONTENT_OBS[$looking_for]) ? $CONTENT_OBS[$looking_for] : null;
                    if ($ob_info !== null) {
                        $LOADED_MONIKERS_CACHE[$url_parts['type']][$url_parts['page']][$url_parts['id']] = true; // Indicator to preload this
                    }
                }
            }
            return;

        case 'INCLUDE':
            if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                $param = $seq_part[3];

                $_template_name = is_object($param[0]) ? $param[0]->evaluate() : $param[0];
                $ex = isset($param[2]) ? (is_object($param[1]) ? $param[1]->evaluate() : '') : '';
                if ($ex == '') {
                    $ex = '.tpl';
                }
                $td = isset($param[3]) ? (is_object($param[2]) ? $param[2]->evaluate() : '') : '';
                if ($td == '') {
                    $td = 'templates';
                }
                $theme = isset($param[4]) ? (is_object($param[3]) ? $param[3]->evaluate() : '') : '';
                if ($theme == '') {
                    $theme = null;
                }
                $force_original = isset($param[4]) ? (is_object($param[4]) ? $param[4]->evaluate() : '') : '';
                if ($force_original != '1') {
                    $force_original = '0';
                }

                $tpl_path_descrip = $td . '/' . $_template_name . $ex;

                record_template_used($tpl_path_descrip);

                $temp = @do_template($_template_name, [], null, true, null, $ex, $td, $theme, ($template_name == $_template_name) || ($force_original == '1'));

                require_code('themes_meta_tree');
                $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__INCLUDE, $tpl_path_descrip, $temp);
            }
            return;

        case 'SET_TITLE':
            $param = $seq_part[3];

            if (array_key_exists(0, $param)) {
                get_screen_title(is_object($param[0]) ? $param[0]->evaluate() : $param[0], false);
            }
            return;

        case 'SET':
            $param = $seq_part[3];

            if (isset($param[1])) {
                global $TEMPCODE_SETGET;
                if (count($param) == 2) {
                    $TEMPCODE_SETGET[isset($param[0]->codename/*faster than is_object*/) ? $param[0]->evaluate() : $param[0]] = $param[1];
                } else {
                    $param_copy = [];
                    foreach ($param as $i => $x) {
                        if ($i !== 0) {
                            $param_copy[] = isset($x->codename/*faster than is_object*/) ? $x->evaluate() : $x;
                        }
                    }
                    $TEMPCODE_SETGET[isset($param[0]->codename/*faster than is_object*/) ? $param[0]->evaluate() : $param[0]] = implode(',', $param_copy);
                }

                if (($GLOBALS['RECORD_TEMPLATES_USED']) && (is_object($param[1]))) {
                    require_code('themes_meta_tree');
                    $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__SET, is_object($param[0]) ? $param[0]->evaluate() : $param[0]);
                }
            }
            return;

        case 'BLOCK':
            $param = $seq_part[3];

            foreach ($param as $i => $p) {
                if (isset($p->codename/*faster than is_object*/)) {
                    $param[$i] = $p->evaluate();
                }
            }

            if ((count($param) === 1) && (strpos($param[0], ',') !== false)) { // NB: This code is also in symbols.php
                $param = comma_list_str_to_arr($param[0], true);
            }

            if ((in_array('defer=1', $param)) && (!running_script('comcode_convert'))) {
                // Nothing has to be done here, except preparing for AJAX
            } else {
                global $REQUEST_BLOCK_NEST_LEVEL;

                global $BLOCKS_CACHE;
                if (isset($BLOCKS_CACHE[serialize($param)])) {
                    $REQUEST_BLOCK_NEST_LEVEL--;
                    return;
                }

                $REQUEST_BLOCK_NEST_LEVEL++;
                if ($REQUEST_BLOCK_NEST_LEVEL > 40) { // 100 caused xdebug error, but the software will have some overhead in both error handler and other code to get to here. We want xdebug error to not show, but of course to provide the same benefits as that error.
                    $REQUEST_BLOCK_NEST_LEVEL = 0;
                    $BLOCKS_CACHE[serialize($param)] = do_lang_tempcode('INTERNAL_ERROR', escape_html('367033934c586f56e84baf2ef4028a97'));
                    attach_message(do_lang_tempcode('STOPPED_RECURSIVE_RESOURCE_INCLUDE', escape_html(is_string($param[0]) ? $param[0] : 'block'), escape_html(do_lang('BLOCK'))), 'warn', false, true);
                    return;
                }

                $block_parms = [];
                foreach ($param as &$_param) {
                    $block_parts = explode('=', $_param, 2);
                    if (!isset($block_parts[1])) {
                        $BLOCKS_CACHE[serialize($param)] = make_string_tempcode(do_lang('INTERNAL_ERROR', comcode_escape('30eb7286ffef52298b48c89a440c5535')) . ' (bad block parameter: ' . escape_html($_param) . ')');
                        return;
                    }
                    list($key, $val) = $block_parts;
                    $block_parms[$key] = $val;
                }

                if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                    require_code('files');
                    $before = memory_get_usage();
                }
                if (isset($block_parms['block'])) {
                    if ($GLOBALS['IN_MINIKERNEL_VERSION']) {
                        $b_value = new Tempcode();
                    } else {
                        $b_value = do_block($block_parms['block'], $block_parms);
                    }

                    if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                        if (function_exists('attach_message')) {
                            attach_message('block: ' . $block_parms['block'] . ' (' . clean_file_size(memory_get_usage() - $before) . ' used, now at ' . integer_format(memory_get_usage()) . ')', 'inform');
                        } else {
                            @ob_end_flush();
                            @ob_end_flush();
                            @ob_end_flush();
                            print('<!-- block: ' . htmlentities($block_parms['block']) . ' (' . htmlentities(clean_file_size(memory_get_usage() - $before)) . ' used, now at ' . htmlentities(integer_format(memory_get_usage())) . ') -->' . "\n");
                            cms_flush_safe();
                        }
                    }

                    $b_value->handle_symbol_preprocessing();

                    if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                        require_code('themes_meta_tree');

                        $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__BLOCK, $block_parms['block'], $b_value);
                    }

                    $BLOCKS_CACHE[serialize($param)] = $b_value;
                }

                $REQUEST_BLOCK_NEST_LEVEL--;
            }

            return;

        case 'REQUIRE_JAVASCRIPT':
            if (isset($param[0])) {
                $param = $seq_part[3];
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = $p->evaluate();
                    }
                }

                require_javascript($param[0]);
            }
            return;

        case 'FACILITATE_AJAX_BLOCK_CALL':
            return;

        case 'REQUIRE_CSS':
            if (isset($param[0])) {
                $param = $seq_part[3];
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = $p->evaluate();
                    }
                }

                require_css($param[0]);
            }
            return;

        case 'TRIM':
        case 'PARAGRAPH':
            $param = $seq_part[3];
            if ((isset($param[0])) && (is_object($param[0]))) {
                if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                    require_code('themes_meta_tree');
                    $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__TRIM, '', $param[0]);
                }
            }
            break;

        case 'LOAD_PANEL':
            $param = $seq_part[3];
            foreach ($param as $i => $p) {
                if (is_object($p)) {
                    $param[$i] = $p->evaluate();
                }
            }

            global $PANELS_CACHE;
            if (isset($PANELS_CACHE[serialize($param)])) {
                return;
            }

            if (array_key_exists(0, $param)) {
                if (substr(get_page_name(), 0, 6) !== 'panel_') {
                    if (strpos($param[0], ':') !== false) {
                        $param = array_reverse(explode(':', $param[0], 2));
                    }
                    if (substr($param[0], 0, 6) === 'panel_') {
                        $param[0] = substr($param[0], 6);
                    }

                    global $ZONE;
                    $wide_high = is_wide_high();
                    $wide = is_wide();
                    if ((($wide === 0) || (($wide_high === 0) && (($param[0] === 'bottom') || ($param[0] === 'top')))) && ((get_option('site_closed') === '0') || ($GLOBALS['IS_ACTUALLY_ADMIN']) || (has_privilege(get_member(), 'access_closed_site')))) {
                        if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                            require_code('files');
                            $before = memory_get_usage();
                        }
                        $tp_value = request_page('panel_' . $param[0], false, array_key_exists(1, $param) ? $param[1] : null, null);
                        if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                            if (function_exists('attach_message')) {
                                attach_message('panel: ' . 'panel_' . $param[0] . ' (' . clean_file_size(memory_get_usage() - $before) . ' bytes used, now at ' . clean_file_size(memory_get_usage()) . ')', 'inform');
                            } else {
                                @ob_end_flush();
                                @ob_end_flush();
                                @ob_end_flush();
                                print('<!-- panel: ' . htmlentities('panel_' . $param[0]) . ' (' . htmlentities(clean_file_size(memory_get_usage() - $before)) . ' bytes used, now at ' . htmlentities(clean_file_size(memory_get_usage())) . ') -->' . "\n");
                                cms_flush_safe();
                            }
                        }

                        $tp_value->handle_symbol_preprocessing();

                        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                            require_code('themes_meta_tree');
                            $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__PANEL, (array_key_exists(1, $param) ? $param[1] : get_zone_name()) . ':panel_' . $param[0], $tp_value);
                        }

                        $value = $tp_value->evaluate();
                    } else {
                        $value = '';
                    }
                } else {
                    $value = '';
                }
            } else {
                $value = '';
            }

            $PANELS_CACHE[serialize($param)] = $value;

            return;

        case 'JS_TEMPCODE':
            if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                $param = $seq_part[3];
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = $p->evaluate();
                    }
                }

                $temp = javascript_tempcode();

                require_code('themes_meta_tree');
                $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__JS_TEMPCODE, isset($param[0]) ? $param[0] : '', $temp);
            }
            return;

        case 'CSS_TEMPCODE':
            if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                $param = $seq_part[3];

                $temp = css_tempcode();

                require_code('themes_meta_tree');
                $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__CSS_TEMPCODE, '', $temp);
            }
            return;

        case 'LOAD_PAGE':
            $param = $seq_part[3];
            foreach ($param as $i => $p) {
                if (is_object($p)) {
                    $param[$i] = $p->evaluate();
                }
            }

            global $PAGES_CACHE;
            if (array_key_exists(serialize($param), $PAGES_CACHE)) {
                return;
            }

            if ((array_key_exists(0, $param)) && ($param[0] !== '')) {
                if (strpos($param[0], ':') !== false) {
                    $param = array_reverse(explode(':', $param[0], 2));
                }

                $being_included = (!array_key_exists(2, $param)) || ($param[2] === '1');
                $virtual_state = (array_key_exists(3, $param)) && ($param[3] === '1');

                if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                    require_code('files');
                    $before = memory_get_usage();
                }

                $page = $param[0];
                $zone = array_key_exists(1, $param) ? $param[1] : get_comcode_zone($param[0], false);

                if ($virtual_state) {
                    // Virtualised state, so that any nested main_comcode_page_children blocks execute correctly
                    require_code('urls2');
                    list($old_get, $old_zone, $old_current_script) = set_execution_context(
                        ['page' => $page],
                        $zone
                    );
                }

                $tp_value = request_page($page, false, $zone, null, $being_included);

                if ($virtual_state) {
                    $tp_value = make_string_tempcode(($tp_value === null) ? '' : $tp_value->evaluate());

                    // Get things back to prior state
                    set_execution_context(
                        $old_get,
                        $old_zone,
                        $old_current_script,
                        false
                    );
                }

                if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] === '1')) {
                    if (function_exists('attach_message')) {
                        attach_message('page: ' . $param[0] . ' (' . clean_file_size(memory_get_usage() - $before) . ' bytes used, now at ' . clean_file_size(memory_get_usage()) . ')', 'inform');
                    } else {
                        @ob_end_flush();
                        @ob_end_flush();
                        @ob_end_flush();
                        print('<!-- page: ' . htmlentities($param[0]) . ' (' . htmlentities(clean_file_size(memory_get_usage() - $before)) . ' bytes used, now at ' . htmlentities(clean_file_size(memory_get_usage())) . ') -->' . "\n");
                        cms_flush_safe();
                    }
                }

                if ($GLOBALS['RECORD_TEMPLATES_USED']) {
                    require_code('themes_meta_tree');
                    $children[] = create_template_tree_metadata(TEMPLATE_TREE_NODE__PAGE, $zone . ':' . $page, $tp_value);
                }
            } else {
                $tp_value = new Tempcode();
            }

            $PAGES_CACHE[serialize($param)] = $tp_value;

            return;

        case 'FRACTIONAL_EDITABLE':
            require_javascript('fractional_edit');
            return;

        case 'CATALOGUE_ENTRY_FOR':
            $param = $seq_part[3];
            if (isset($param[1])) {
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = @$p->evaluate(); // The "@" is in case something is not passed
                    }
                }

                if ((!empty($param[0])) && (!@cms_empty_safe($param[1])) && (addon_installed('catalogues'))) {
                    require_code('fields');
                    $entry_id = get_bound_content_entry($param[0], $param[1]);
                    if ($entry_id !== null) {
                        // This will do necessary pre-processing on all the fields (it also has internal caching deep down, so no serious performance issue)
                        require_code('catalogues');
                        get_catalogue_entry_field_values('_' . $param[0], $entry_id);
                    }
                }
            }
            return;

        case 'METADATA':
            // We need to allow setting operations to be preprocessed
            $param = $seq_part[3];
            if (isset($param[1])) {
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = $p->evaluate();
                    }
                }

                ecv_METADATA(user_lang(), [], $param);
            }
            return;

        case 'METADATA_IMAGE_EXTRACT':
            // We need to allow setting operations to be preprocessed
            $param = $seq_part[3];
            if (isset($param[0])) {
                foreach ($param as $i => $p) {
                    if (is_object($p)) {
                        $param[$i] = $p->evaluate();
                    }
                }

                ecv_METADATA_IMAGE_EXTRACT(user_lang(), [], $param);
            }
            return;

        case 'CANONICAL_URL':
            $param = $seq_part[3];
            if (!empty($param[0])) {
                global $CANONICAL_URL;
                $CANONICAL_URL = $param[0]->evaluate();
            }
            return;

        case 'INSERT_SPAMMER_BLACKHOLE':
            if (get_bot_type() === null) {
                $GLOBALS['STATIC_CACHE_ENABLED'] = false;
            }
            return;
    }
}

/**
 * Tempcode (compiled implementation).
 *
 * @package core
 */
class Tempcode
{
    public $code_to_preexecute;
    public $seq_parts; // List of list of closure pairs: (0) function name, and (1) parameters, (2) type, (3) name         We use a 2D list to make attach ops very fast

    public $codename; // The name of the template it came from

    public $is_all_static; // Whether this Tempcode is entirely static content
    public $metadata; // Map of Tempcode metadata
    public $preprocessable_bits;
    public $pure_lang;
    public $preprocessed;
    private $is_empty; // Whether this Tempcode has no content
    private $cached_output;
    private $evaluate_echo_offset_group;
    private $evaluate_echo_offset_inner;
    /**
     * @var true
     */

    /**
     * Constructor of Tempcode.
     *
     * @param  ?array $details Pair: Code to pre-execute, Initialisation seq-parts (null: start as empty)
     */
    public function __construct(?array $details = null)
    {
        $this->codename = ':container';

        if (!isset($details)) {
            $this->seq_parts = [];
            $this->code_to_preexecute = [];

            $this->is_all_static = true;
        } else {
            $this->code_to_preexecute = $details[0];
            $this->seq_parts = $details[1];

            $pp_bits = [];

            foreach ($this->seq_parts as $seq_parts_group) {
                foreach ($seq_parts_group as $seq_part) {
                    if ($seq_part[2] === TC_SYMBOL) {
                        switch ($seq_part[3]) {
                            case 'REQUIRE_CSS':
                            case 'REQUIRE_JAVASCRIPT':
                            case 'FACILITATE_AJAX_BLOCK_CALL':
                            case 'JS_TEMPCODE':
                            case 'CSS_TEMPCODE':
                            case 'SET':
                            case 'SET_TITLE':
                            case 'BLOCK':
                            case 'PAGE_LINK':
                            case 'LOAD_PAGE':
                            case 'LOAD_PANEL':
                            case 'METADATA':
                            case 'CANONICAL_URL':
                            case 'INSERT_SPAMMER_BLACKHOLE':
                                $pp_bits[] = [[], TC_SYMBOL, $seq_part[3], $seq_part[1]];
                                break;
                        }
                    } elseif ($seq_part[2] === TC_DIRECTIVE) {
                        switch ($seq_part[3]) {
                            case 'INCLUDE':
                            case 'FRACTIONAL_EDITABLE':
                                $pp_bits[] = [[], TC_DIRECTIVE, $seq_part[3], $seq_part[1]];
                                break;
                        }
                    }
                    foreach ($seq_part[1] as $param) {
                        if (!empty($param->preprocessable_bits)) { // If is a Tempcode object
                            foreach ($param->preprocessable_bits as $b) {
                                $pp_bits[] = $b;
                            }
                        }
                    }
                }
            }

            if (!empty($pp_bits)) {
                $this->preprocessable_bits = $pp_bits;
            }
        }

        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            require_code('themes_meta_tree');
            $this->metadata = create_template_tree_metadata();
        }
    }

    /**
     * Find if this Tempcode object uses less memory (very roughly!) than the given number of bytes.
     *
     * @param  integer $bytes_available The number of bytes passed by reference
     * @return boolean Whether it is
     */
    public function is_smaller_than(int &$bytes_available) : bool
    {
        foreach ($this->code_to_preexecute as $part) {
            $bytes_available -= strlen($part);
        }
        if ($bytes_available < 0) {
            return false;
        }
        foreach ($this->seq_parts as $seq_parts_group) {
            foreach ($seq_parts_group as $seq_part) {
                $bytes_available -= strlen($seq_part[0]) + 1 + strlen($seq_part[3]);
                foreach ($seq_part[1] as $param) {
                    if (is_string($param)) {
                        $bytes_available -= strlen($param);
                    } elseif (is_object($param)) {
                        $param->is_smaller_than($bytes_available); // Recurse
                    }
                    if ($bytes_available < 0) {
                        return false;
                    }
                }
            }
        }

        return ($bytes_available > 0);
    }

    /**
     * PHP magic function to handle serialisation.
     *
     * @return array What is to be serialised
     */
    public function __sleep() : array
    {
        $ret = ['code_to_preexecute', 'seq_parts', 'codename'];
        if (isset($this->preprocessable_bits)) {
            $ret[] = 'preprocessable_bits';
        }
        if (isset($this->pure_lang)) {
            $ret[] = 'pure_lang';
        }
        return $ret;
    }

    /**
     * Remove any internal evaluation cachings within the object.
     */
    public function decache()
    {
        foreach ($this->seq_parts as &$seq_parts_group) {
            foreach ($seq_parts_group as &$seq_part) {
                foreach ($seq_part[1] as $val) {
                    if (isset($val->codename/*faster than is_object*/)) {
                        $val->decache();
                    }
                }
            }
        }
        unset($this->cached_output);
    }

    /**
     * Parse a single symbol from an input stream and append it.
     *
     * @param  string $code Code string (input stream)
     * @param  integer $pos Start position of input string
     * @param  integer $len End position of input string
     */
    public function parse_from(string &$code, int &$pos, int &$len)
    {
        unset($this->cached_output);
        require_code('tempcode_compiler');
        $temp = template_to_tempcode(substr($code, $pos, $len - $pos), 0, false, '');
        $this->code_to_preexecute = $temp->code_to_preexecute;
        $this->seq_parts = $temp->seq_parts;
        if (!empty($temp->preprocessable_bits)) {
            $this->preprocessable_bits = $temp->preprocessable_bits;
        }
        if (!isset($temp->is_all_static)) {
            unset($this->is_all_static);
        }
    }

    /**
     * Attach the specified Tempcode to the right of the current Tempcode object.
     *
     * @param  mixed $attach The Tempcode/string to attach; no special escaping is performed for you
     * @param  boolean $enable_child_merge If we've already merged the children from what we're attaching into the child tree (at bind stage) then pass as false
     */
    public function attach($attach, bool $enable_child_merge = true)
    {
        if ($attach === '') {
            return;
        }

        unset($this->is_empty);

        unset($this->cached_output);

        global $TEMPCODE_PARAMETER_INLINING_MODE;
        $inlining_mode = end($TEMPCODE_PARAMETER_INLINING_MODE)/*in inlining mode*/;

        if (isset($attach->is_all_static) && $inlining_mode) { // Can flatten to a string?
            $attach = $attach->evaluate();
        }

        if (isset($attach->codename)/*faster than is_object*/) { // Consider it another piece of Tempcode
            if (!isset($attach->is_all_static)) {
                unset($this->is_all_static);
            }

            foreach ($attach->seq_parts as $seq_part_group) {
                $this->seq_parts[] = $seq_part_group;
            }

            $this->code_to_preexecute += $attach->code_to_preexecute;

            if (!empty($attach->preprocessable_bits)) {
                foreach ($attach->preprocessable_bits as $b) {
                    $this->preprocessable_bits[] = $b;
                }
            }

            if (($enable_child_merge) && ($GLOBALS['RECORD_TEMPLATES_USED']) && (isset($attach->metadata))) {
                if (!isset($this->metadata)) {
                    require_code('themes_meta_tree');
                    $this->metadata = create_template_tree_metadata();
                }
                $this->metadata['children'][] = create_template_tree_metadata(TEMPLATE_TREE_NODE__ATTACHED, '', $attach);
            }
        } else { // Consider it a string
            if (end($this->seq_parts) !== false) { // If not currently empty
                $end = &$this->seq_parts[key($this->seq_parts)];
                if ($inlining_mode && end($end) !== false) {
                    $_end = &$end[key($end)];
                    if (($_end[2] === TC_KNOWN) && (empty($_end[1]))) { // Optimisation to save memory/storage-space/evaluation-time -- we can just append text
                        $myfunc = $_end[0];
                        if (isset($this->code_to_preexecute[$myfunc])) {
                            $code = $this->code_to_preexecute[$myfunc];
                            $pos2 = strpos($code, '\\";";');
                            if (($pos2 !== false) && (strpos($code, '\\\\"') === false)) {
                                $code = substr($code, 0, $pos2) . php_addslashes_twice($attach) . substr($code, $pos2);
                                $this->code_to_preexecute[$myfunc] = $code;
                                return;
                            }
                        }
                    }
                }
            } else {
                $this->seq_parts[] = []; // Currently empty. We need a stub to append to
                $end = &$this->seq_parts[0];
            }

            static $generator_base = null;
            static $generator_num = 0;
            if ($generator_base === null) {
                $generator_base = uniqid('', true);
            }
            $generator_num++;

            $myfunc = 'string_attach_' . $generator_base . '_' . strval($generator_num);/*We'll inline it actually rather than calling, for performance   fast_uniqid()*/
            $funcdef = "\$tpl_funcs['$myfunc']=\"echo \\\"" . php_addslashes_twice($attach) . "\\\";\";\n";
            $this->code_to_preexecute[$myfunc] = $funcdef;
            $end[] = [$myfunc, [], TC_KNOWN, '', ''];
        }
    }

    /**
     * Assemble the current Tempcode object into a single serialised (compiled) Tempcode storage representation (parameters and certain symbols and not evaluated). The output of the function is language-tied.
     *
     * @return string The assembly result
     */
    public function to_assembly() : string
    {
        require_code('tempcode_optimiser');
        optimise_tempcode($this);

        return 'return unserialize("' . php_addslashes(serialize([$this->seq_parts, isset($this->preprocessable_bits) ? $this->preprocessable_bits : [], $this->codename, !empty($this->pure_lang), $this->code_to_preexecute])) . '");' . "\n";
    }

    /**
     * The opposite of to_assembly - it decodes a Tempcode storage representation and turns it into a proper Tempcode object. This version handles the result of evaled code.
     *
     * @param  PATH $file The file to load
     * @param  array $forced_reload_details List of parameters for a forced reload if required
     * @return boolean Success status (it can fail, if the compiled cache file is corrupt)
     */
    public function from_assembly_executed(string $file, array $forced_reload_details) : bool
    {
        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            require_code('themes_meta_tree');
            $this->metadata = create_template_tree_metadata();
        }

        $result = tempcode_include($file); // We don't eval on this because we want it to potentially be op-code cached by e.g. Zend Accelerator
        if (!is_array($result)) {
            return false; // May never get here, as PHP fatal errors can't be suppressed or skipped over
        }

        unset($this->cached_output);

        $this->seq_parts = $result[0];
        if (!empty($result[1])) {
            $this->preprocessable_bits = $result[1];
        }
        $this->codename = $result[2];
        if ($result[3]) {
            $this->pure_lang = $result[3];
        }
        $this->code_to_preexecute = $result[4];

        if ($forced_reload_details[6] === null) {
            $forced_reload_details[6] = '';
        }
        if ((count($this->code_to_preexecute) > 10) && ($GLOBALS['CACHE_TEMPLATES'])) {
            // We don't actually use $code_to_preexecute, because it uses too much RAM and DB space throwing full templates into the caching. Instead we rewrite to custom load it whenever it's needed. This isn't inefficient due to normal opcode caching and optimizer opcode caching, and because we cache Tempcode object's evaluations at runtime so it can only happen once per screen view.
            $_file = (strpos($file, '\'') === false) ? $file : php_addslashes($file);
            $this->code_to_preexecute[] = '
                if (($result=tempcode_include(\'' . $_file . '\'))===false) {
                    $tmp=do_template(\'' . php_addslashes($forced_reload_details[0]) . '\',null,\'' . ((strpos($forced_reload_details[2], '\'') === false) ? $forced_reload_details[2] : php_addslashes($forced_reload_details[2])) . '\',false,\'' . (($forced_reload_details[6] === '') ? '' : ((strpos($forced_reload_details[6], '\'') === false) ? $forced_reload_details[6] : php_addslashes($forced_reload_details[6]))) . '\',\'' . ($forced_reload_details[4]) . '\',\'' . ($forced_reload_details[5]) . '\');
                    clearstatcache();
                    $tmp2=$GLOBALS[\'CACHE_TEMPLATES\'];
                    if (!@is_file(\'' . $_file . '\')) {
                        $GLOBALS[\'CACHE_TEMPLATES\']=false;
                    }
                    try {
                        eval($tmp->code_to_preexecute);
                    }
                    catch (Error $e) {
                        tempcode_error($e, $tmp->code_to_preexecute);
                    }
                    $GLOBALS[\'CACHE_TEMPLATES\']=$tmp2;
                    unset($tmp);
                } else {
                    try {
                        eval($result[4]);
                    }
                    catch (Error $e) {
                        tempcode_error($e, $result[4]);
                    }
                    unset($result);
                }
            ';
            // NB: $GLOBALS[\'CACHE_TEMPLATES\']=false; is in case the template cache has been detected as broken, it prevents this branch running as it would fail again
        }

        if ($GLOBALS['XSS_DETECT']) {
            //$this->_mark_all_as_escaped();
        }

        return true;
    }

    /**
     * Recursively mark all parameters in this Tempcode as escaped. This is needed when loading from cache, as escape tainting data would have been lost.
     *
     * @param  boolean $top_level Whether this is the top-level call
     */
    protected function _mark_all_as_escaped(bool $top_level = true)
    {
        static $done = [];

        foreach ($this->seq_parts as &$seq_parts_group) {
            foreach ($seq_parts_group as &$seq_part) {
                if (!isset($seq_part[1]['_escaped'])) {
                    foreach ($seq_part[1] as &$val) {
                        if (is_string($val)) {
                            ocp_mark_as_escaped($val);
                        } elseif (is_object($val)) {
                            $val->_mark_all_as_escaped(false);
                        }
                    }
                    if (!isset($seq_part[1][0])) { // Only if it's a parameter map, not a parameter list
                        $seq_part[1]['_escaped'] = true; // Temporarily mark as escaped. Many seq_parts share a referenced list of parameters, and its naive/slow to re-mark for each
                    }
                    $done[] = &$seq_part[1];
                }
            }
        }

        if ($top_level) {
            // Remove the escaping markers, as the escaping marking does not persist with serialisation
            foreach ($done as $d) {
                unset($d['_escaped']);
            }
            $done = [];
        }
    }

    /**
     * The opposite of to_assembly - it decodes a Tempcode storage representation and turns it into a proper Tempcode object.
     *
     * @param  string $raw_data The assembled Tempcode
     * @param  boolean $allow_failure Return error code on failure, rather than exiting
     * @return boolean Success status (it can fail, if the compiled cache file is corrupt)
     */
    public function from_assembly(string &$raw_data, bool $allow_failure = false) : bool
    {
        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            require_code('themes_meta_tree');
            $this->metadata = create_template_tree_metadata();
        }

        try {
            $result = eval($raw_data);
        } catch (Error $e) {
            tempcode_error($e, $raw_data);
        }
        if ($result === false) {
            if ($allow_failure) {
                return false;
            }
            fatal_exit(cms_error_get_last());
        }

        unset($this->cached_output);

        $this->seq_parts = $result[0];
        if (!empty($result[1])) {
            $this->preprocessable_bits = $result[1];
        }
        $this->codename = $result[2];
        if ($result[3]) {
            $this->pure_lang = $result[3];
        }
        $this->code_to_preexecute = $result[4];

        if ($GLOBALS['XSS_DETECT']) {
            $this->_mark_all_as_escaped();
        }

        return true;
    }

    /**
     * Find whether a construct within this Tempcode is parameterless.
     *
     * @param  integer $at Offset to the construct
     * @return boolean Whether it is parameterless
     */
    public function parameterless(int $at) : bool
    {
        $i = 0;
        foreach ($this->seq_parts as $seq_parts_group) {
            foreach ($seq_parts_group as $seq_part) {
                if ($i === $at) {
                    return empty($seq_part[1]);
                }
                $i++;
            }
        }
        return false;
    }

    /**
     * Bind the parameter bits, or recursively bind children (doesn't change self, returns a bound Tempcode object).
     *
     * @param  array $parameters Map of parameters to bind parameter bits to
     * @param  ID_TEXT $codename The codename of the template this Tempcode is from
     * @return Tempcode The new bound Tempcode object
     */
    public function bind(array &$parameters, string $codename) : object
    {
        if (!isset($parameters['_GUID'])) {
            $parameters['_GUID'] = '';

            $trace = debug_backtrace();
            $parameters['_GUID'] = isset($trace[3]) ? ($trace[3]['function'] . '/' . $trace[2]['function']) : (isset($trace[2]) ? $trace[2]['function'] : $trace[1]['function']);
        }
        $is_all_static = isset($this->is_all_static);

        $out = new Tempcode();
        $out->codename = $codename;
        $out->code_to_preexecute = $this->code_to_preexecute;
        if (!empty($this->preprocessable_bits)) {
            foreach ($this->preprocessable_bits as $preprocessable_bit) {
                foreach ($preprocessable_bit[3] as $i => $param) {
                    if ((($preprocessable_bit[2] !== 'SET') || (($i >= 1))) && (isset($param->codename/*faster than is_object*/))) {
                        $preprocessable_bit[3][$i] = $param->bind($parameters, '<' . $codename . '>');
                    }
                }
                $out->preprocessable_bits[] = $preprocessable_bit;
            }
        }

        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            require_code('themes_meta_tree');
            $out->metadata = isset($this->metadata) ? $this->metadata : create_template_tree_metadata();
            foreach ($parameters as $key => $parameter) {
                if (is_object($parameter)) {
                    if (!empty($parameter->preprocessable_bits)) {
                        $parameter->handle_symbol_preprocessing(); // Needed to force children to be populated. Otherwise it is possible but not definite that evaluation will result in children being pushed down.
                    }
                    $out->metadata['children'][] = create_template_tree_metadata(TEMPLATE_TREE_NODE__TEMPLATE_PARAMETER, $key, $parameter);
                } else {
                    if ((is_string($parameter)) && ($key === '_GUID')) {
                        $out->metadata['children'][] = create_template_tree_metadata(TEMPLATE_TREE_NODE__TEMPLATE_GUID, $parameter);
                    }
                }
            }
        }

        foreach ($parameters as $key => $parameter) {
            $p_type = gettype($parameter);
            if ($p_type === 'string') {
                // Performance, this is most likely
            } elseif ($p_type === 'object') {
                if (!isset($parameter->is_all_static)) {
                    $is_all_static = false;
                }

                if (!empty($parameter->preprocessable_bits)) {
                    foreach ($parameter->preprocessable_bits as $b) {
                        $out->preprocessable_bits[] = $b;
                    }
                } elseif ($parameter->is_empty_shell()) {
                    $parameters[$key] = ''; // Little optimisation to save memory
                }
            } elseif ($p_type === 'boolean') {
                $parameters[$key] = $parameter ? '1' : '0';
            } elseif (($p_type !== 'array') && ($p_type !== 'NULL')) {
                trigger_error(do_lang('NO_INTEGERS_TEMPLATE', escape_html($key)), E_USER_NOTICE);
                $parameters[$key] = @strval($parameter);
            }
        }

        $out->seq_parts[0] = [];
        foreach ($this->seq_parts as $seq_parts_group) {
            foreach ($seq_parts_group as $seq_part) {
                if ((($seq_part[0][0] !== 's') || (substr($seq_part[0], 0, 14) !== 'string_attach_')) && ($seq_part[2] !== TC_LANGUAGE_REFERENCE)) {
                    $seq_part[1] = &$parameters; // & is to preserve memory
                }
                $out->seq_parts[0][] = $seq_part;
            }
        }

        if (!$is_all_static) {
            unset($out->is_all_static);
        }

        return $out;
    }

    /**
     * Replace the named parameter with a specific value. Hardly used, but still important. Note that this will bind to all kinds of things that might not normally take named parameters, like symbols; this should not cause problems though.
     *
     * @param  string $key Named parameter
     * @param  mixed $value Specific value
     */
    public function singular_bind(string $key, $value)
    {
        unset($this->cached_output);

        if ($GLOBALS['RECORD_TEMPLATES_USED']) {
            if (is_object($value)) {
                require_code('themes_meta_tree');

                if (!isset($this->metadata)) {
                    $this->metadata = create_template_tree_metadata();
                }

                if (!empty($value->preprocessable_bits)) {
                    $value->handle_symbol_preprocessing(); // Needed to force children to be populated. Otherwise it is possible but not definite that evaluation will result in children being pushed down.
                }
                $this->metadata['children'][] = create_template_tree_metadata(TEMPLATE_TREE_NODE__TEMPLATE_PARAMETER, $key, $value);
            }
        }

        if (empty($this->seq_parts)) {
            return;
        }

        foreach ($this->seq_parts as &$seq_parts_group) {
            foreach ($seq_parts_group as &$seq_part) {
                if ((($seq_part[0][0] !== 's') || (substr($seq_part[0], 0, 14) !== 'string_attach_')) && ($seq_part[2] !== TC_LANGUAGE_REFERENCE)) {
                    $seq_part[1][$key] = $value;
                }
            }
        }

        if (!empty($value->preprocessable_bits)) { // Is Tempcode
            foreach ($value->preprocessable_bits as $b) {
                $this->preprocessable_bits[] = $b;
            }
        }

        if (!isset($value->is_all_static)) {
            unset($this->is_all_static);
        }
    }

    /**
     * Scan this Tempcode for anything that needs to be symbol-preprocessed.
     */
    public function handle_symbol_preprocessing()
    {
        if (!empty($this->preprocessed)) {
            return;
        }

        $children = [];

        if (!empty($this->preprocessable_bits)) {
            foreach ($this->preprocessable_bits as $seq_part) {
                handle_symbol_preprocessing($seq_part, $children, $this->codename);
            }
        }

        if (($GLOBALS['RECORD_TEMPLATES_USED']) && (isset($this->metadata['children']))) {
            $this->metadata['children'] = array_merge($this->metadata['children'], $children);
        }

        $this->preprocessed = true;
    }

    /**
     * Find whether the Tempcode object entirely empty (devoid of anything evaluable), not just evaluates as empty. This is also useful if you want to avoid early evaluation, which will mess up GET/SET flow.
     * Does not perform an evaluation, so will not trigger any early pre-processing or out-of-order evaluation.
     *
     * @return boolean Whether it is entirely empty
     */
    public function is_empty_shell() : bool
    {
        foreach ($this->seq_parts as $seq_parts_group) {
            if (isset($seq_parts_group[0])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Find whether the Tempcode object is blank or not.
     *
     * @return boolean Whether the Tempcode object is empty
     */
    public function is_empty() : bool
    {
        if (isset($this->cached_output)) {
            return strlen($this->cached_output) === 0;
        }
        if (isset($this->is_empty)) {
            return $this->is_empty;
        }

        if ($this->is_empty_shell()) { // Optimisation: empty
            $this->is_empty = true;
            return true;
        }

        ob_start();

        global $NO_EVAL_CACHE, $XSS_DETECT, $USER_LANG_CACHED, $KEEP_TPL_FUNCS, $MEMORY_OVER_SPEED, $FULL_RESET_VAR_CODE, $RESET_VAR_CODE, $DEV_MODE;

        if ($XSS_DETECT) {
            $before = ini_get('ocproducts.xss_detect');
            cms_ini_set('ocproducts.xss_detect', '0');
        }

        $no_eval_cache_before = $NO_EVAL_CACHE;

        if (isset($USER_LANG_CACHED)) {
            $current_lang = $USER_LANG_CACHED;
        } else {
            if (!function_exists('user_lang')) {
                require_code('lang');
            }
            $current_lang = user_lang();
        }
        $cl = $current_lang;

        $first_of_long = isset($this->seq_parts[0][3]) || isset($this->seq_parts[3]); // We set this to know not to dig right through to determine emptiness, as this wastes cache memory (it's a trade-off)
        $tpl_funcs = $KEEP_TPL_FUNCS;

        $codename = $this->codename;

        foreach ($this->seq_parts as $seq_parts_group) {
            foreach ($seq_parts_group as $seq_part) {
                $seq_part_0 = $seq_part[0];
                if (!isset($tpl_funcs[$seq_part_0])) {
                    try {
                        eval($this->code_to_preexecute[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $this->code_to_preexecute[$seq_part_0]);
                    }
                }
                if (is_callable($tpl_funcs[$seq_part_0])) {
                    call_user_func($tpl_funcs[$seq_part_0], $seq_part[1], $current_lang, $seq_part[4]);
                } else {
                    $parameters = $seq_part[1];
                    try {
                        eval($tpl_funcs[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $tpl_funcs[$seq_part_0]);
                    }
                }

                if ((($first_of_long) || ($MEMORY_OVER_SPEED)) && (ob_get_length() > 0)) { // We only quick exit on the first iteration, as we know we likely didn't spend much time getting to it- anything more and we finish so that we can cache for later use by evaluate/evaluate_echo
                    ob_end_clean();
                    if (!$no_eval_cache_before) {
                        $NO_EVAL_CACHE = $no_eval_cache_before;
                    }
                    if (($XSS_DETECT) && ($before !== false)) {
                        cms_ini_set('ocproducts.xss_detect', $before);
                    }
                    $this->is_empty = false;
                    return false;
                }

                $first_of_long = false;
            }
        }

        $tmp = ob_get_clean();
        if ((!$MEMORY_OVER_SPEED) && (!$NO_EVAL_CACHE) && (!$GLOBALS['STUCK_ABORT_SIGNAL'])) {
            $this->cached_output = $tmp; // Optimisation to store it in here. We don't do the same for evaluate_echo as that's a final use case and hence it would be unnecessarily inefficient to store the result

            global $DECLARATIONS_STATE, $KNOWN_TRUE_HTML;
            if (defined('I_UNDERSTAND_XSS') && !$DECLARATIONS_STATE[I_UNDERSTAND_XSS]) {
                $KNOWN_TRUE_HTML[$tmp] = true;
            }
        }
        if (!$no_eval_cache_before) {
            $NO_EVAL_CACHE = $no_eval_cache_before;
        }
        if (($XSS_DETECT) && ($before !== false)) {
            cms_ini_set('ocproducts.xss_detect', $before);
        }
        $ret = ($tmp === '');
        $this->is_empty = $ret;
        return $ret;
    }

    /**
     * Convert the object into a string, using ->evaluate().
     * This is implemented for newbie coders. Don't rely on this as it leads to ambiguous code.
     *
     * @return string The evaluated thing
     */
    public function __toString() : string
    {
        return $this->evaluate();
    }

    /**
     * Parses the current Tempcode object, then return the parsed string.
     *
     * @param  ?LANGUAGE_NAME $current_lang The language to evaluate with (null: current user's language)
     * @return string The evaluated thing. Voila, it's all over!
     */
    public function evaluate(?string $current_lang = null) : string
    {
        if (isset($this->cached_output)) {
            return $this->cached_output;
        }
        if ($this->is_empty_shell()) { // Optimisation: empty
            $this->cached_output = '';
            return '';
        }

        global $NO_EVAL_CACHE, $MEMORY_OVER_SPEED, $USER_LANG_CACHED, $XSS_DETECT, $KEEP_TPL_FUNCS, $FULL_RESET_VAR_CODE, $RESET_VAR_CODE, $DEV_MODE, $KNOWN_TRUE_HTML, $DECLARATIONS_STATE;

        ob_start();

        if ($XSS_DETECT) {
            $before = ini_get('ocproducts.xss_detect');
            cms_ini_set('ocproducts.xss_detect', '0');
        }

        if ($current_lang === null) {
            if (isset($USER_LANG_CACHED)) {
                $current_lang = $USER_LANG_CACHED;
            } else {
                if (!function_exists('user_lang')) {
                    require_code('lang');
                }
                $current_lang = user_lang();
            }
        }
        $cl = $current_lang;

        $codename = $this->codename;

        $tpl_funcs = $KEEP_TPL_FUNCS;
        $no_eval_cache_before = $NO_EVAL_CACHE;
        foreach ($this->seq_parts as $seq_parts_group) {
            foreach ($seq_parts_group as $seq_part) {
                $seq_part_0 = $seq_part[0];
                if (!isset($tpl_funcs[$seq_part_0])) {
                    try {
                        eval($this->code_to_preexecute[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $this->code_to_preexecute[$seq_part_0]);
                    }
                }
                if (is_callable($tpl_funcs[$seq_part_0])) {
                    call_user_func($tpl_funcs[$seq_part_0], $seq_part[1], $current_lang, $seq_part[4]);
                } else {
                    $parameters = $seq_part[1];
                    try {
                        eval($tpl_funcs[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $tpl_funcs[$seq_part_0]);
                    }
                }
            }
        }

        if (($XSS_DETECT) && ($before !== false)) {
            cms_ini_set('ocproducts.xss_detect', $before);
        }

        $ret = ob_get_clean();

        if ((!$MEMORY_OVER_SPEED) && (!$NO_EVAL_CACHE) && (!$GLOBALS['STUCK_ABORT_SIGNAL'])) {
            $this->cached_output = $ret; // Optimisation to store it in here. We don't do the same for evaluate_echo as that's a final use case and hence it would be unnecessarily inefficient to store the result
        }

        if (!$no_eval_cache_before) {
            $NO_EVAL_CACHE = $no_eval_cache_before;
        }

        if (defined('I_UNDERSTAND_XSS') && !$DECLARATIONS_STATE[I_UNDERSTAND_XSS]) {
            $KNOWN_TRUE_HTML[$ret] = true;
        }

        return $ret;
    }

    /**
     * Parse the current Tempcode object, then echo it to the browser.
     *
     * @param  ?LANGUAGE_NAME $current_lang The language to evaluate with (null: current user's language)
     * @return string Blank string. Allows chaining within echo statements
     */
    public function evaluate_echo(?string $current_lang = null) : string
    {
        if ($_SERVER['REQUEST_METHOD'] === 'HEAD') {
            return '';
        }

        if (isset($this->cached_output)) {
            echo $this->cached_output;
            unset($this->cached_output); // Won't be needed again
            return '';
        }
        if ($this->is_empty_shell()) { // Optimisation: empty
            $this->cached_output = '';
            return '';
        }

        $cl = $current_lang;
        if ($cl === null) {
            $cl = user_lang();
        }

        $codename = $this->codename;

        global $KEEP_TPL_FUNCS, $FULL_RESET_VAR_CODE, $RESET_VAR_CODE, $STUCK_ABORT_SIGNAL, $DEV_MODE, $TEMPCODE_OUTPUT_STARTED;
        $TEMPCODE_OUTPUT_STARTED = true;
        $tpl_funcs = $KEEP_TPL_FUNCS;
        $seq_parts_group_cnt = count($this->seq_parts);
        if (!isset($this->evaluate_echo_offset_group)) {
            $this->evaluate_echo_offset_group = 0;
            $this->evaluate_echo_offset_inner = 0;
        }
        $i = &$this->evaluate_echo_offset_group; // A reference, so evaluate_echo_offset_group will go up naturally via looping of $i
        $first_i = true;
        for (; $i < $seq_parts_group_cnt; $i++) {
            $seq_parts_group = $this->seq_parts[$i];

            $seq_parts_cnt = count($seq_parts_group);
            if ($first_i) {
                $j = &$this->evaluate_echo_offset_inner;
                $first_i = false;
            } else {
                $j = 0;
            }
            for (; $j < $seq_parts_cnt; $j++) {
                $seq_part = $seq_parts_group[$j];

                $seq_part_0 = $seq_part[0];
                if (!isset($tpl_funcs[$seq_part_0])) {
                    try {
                        eval($this->code_to_preexecute[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $this->code_to_preexecute[$seq_part_0]);
                    }
                }
                if (is_callable($tpl_funcs[$seq_part_0])) {
                    call_user_func($tpl_funcs[$seq_part_0], $seq_part[1], $current_lang, $seq_part[4]);
                } else {
                    $parameters = $seq_part[1];
                    try {
                        eval($tpl_funcs[$seq_part_0]);
                    } catch (Error $e) {
                        tempcode_error($e, $tpl_funcs[$seq_part_0]);
                    }
                }
            }
        }

        cms_flush_safe();

        return '';
    }
}

/**
 * Get a closure for a particular call, with caching support via a named map (as many things may end up adopting this closure).
 *
 * @param  string $id A randomised unique ID
 * @param  string $parameters Parameters
 * @param  string $code Function code
 * @return mixed The function reference
 *
 * @ignore
 */
function recall_named_function(string $id, string $parameters, string $code)
{
    $k = 'TEMPCODE_FUNCTION__' . $id;
    if (!isset($GLOBALS[$k])) {
        $code = 'return function (' . $parameters . ') { $cl = user_lang(); ' . $code . ' };';
        try {
            $GLOBALS[$k] = eval($code);
        } catch (Error $e) {
            tempcode_error($e, $code);
        }
    }
    return $GLOBALS[$k];
}

/**
 * Include and evaluate the specified Tempcode file.
 *
 * @param  PATH $filepath The filename of the file to include
 * @return mixed Success status or returned value
 *
 * @ignore
 */
function tempcode_include(string $filepath)
{
    // NB: We suppress errors because the file may be missing, especially due to race conditions. If we fail we return false, and an alternative Tempcode technique is used

    if (GOOGLE_APPENGINE) {
        gae_optimistic_cache(true);
        $ret = @include($filepath);
        gae_optimistic_cache(false);
    } else {
        $ret = is_file($filepath) ? include($filepath) : false;
    }

    return $ret;
}

/**
 * Record that a template has been loaded up. Tallies are kept.
 *
 * @param  string $tpl_path_descrip Template that's getting loaded
 */
function record_template_used(string $tpl_path_descrip)
{
    static $called_once = false;

    global $RECORDED_TEMPLATES_USED;

    if (!isset($RECORDED_TEMPLATES_USED[$tpl_path_descrip])) {
        $RECORDED_TEMPLATES_USED[$tpl_path_descrip] = 0;
    }
    $RECORDED_TEMPLATES_USED[$tpl_path_descrip]++;

    if (!$called_once || !function_exists('register_shutdown_function')) {
        if (running_script('index')) {
            require_code('themes_meta_tree');
            cms_register_shutdown_function_safe(function () {
                // Save into the database...

                if (strpos($_SERVER['SCRIPT_NAME'], '/_tests/') !== false) {
                    return;
                }

                if (get_option('grow_template_meta_tree') == '0') {
                    return;
                }

                global $RECORDED_TEMPLATES_USED;
                $templates_used = array_keys($RECORDED_TEMPLATES_USED);
                sort($templates_used);

                foreach ($templates_used as $i => $rel_a) {
                    $has_currently = collapse_1d_complexity('rel_b', $GLOBALS['SITE_DB']->query_select('theme_template_relations', ['rel_b'], [
                        'rel_a' => $rel_a,
                    ]));
                    sort($has_currently);
                    $has_currently_flipped = array_flip($has_currently);

                    $templates_used_copy = $templates_used;
                    unset($templates_used_copy[$i]);

                    if ($has_currently != $templates_used_copy) {
                        foreach ($templates_used_copy as $rel_b) {
                            if (!isset($has_currently_flipped[$rel_b])) {
                                $insert_map = [
                                    'rel_a' => $rel_a,
                                    'rel_b' => $rel_b,
                                ];
                                $GLOBALS['SITE_DB']->query_insert('theme_template_relations', $insert_map, false, true); // errors suppressed in case of race condition
                            }
                        }

                        $meta_tree_builder = new Meta_tree_builder();
                        $meta_tree_builder->refresh(dirname($rel_a) . '-related', basename($rel_a));
                    }
                }
            });
        }
    }

    $called_once = true;
}

/**
 * Simplify some Tempcode-within-Comcode for use in WYSIWYG and e-mails.
 *
 * @param  string $text Comcode
 * @return string Simplified Comcode
 */
function simplify_static_tempcode(string $text) : string
{
    push_no_keep_context();

    $symbols = [
        'PAGE_LINK',
        'BASE_URL',
        'IMG',
    ];

    foreach ($symbols as $symbol) {
        $new_text = '';

        $matches = [];
        $regexp = '#\{\$' . preg_quote($symbol, '#') . '[\.`%\*=\;\#\-~\^\|\'&/@+]*(,[^{}]+)?\}#';
        $num_matches = preg_match_all($regexp, $text, $matches, PREG_SET_ORDER | PREG_OFFSET_CAPTURE);
        $last_offset = 0;
        for ($i = 0; $i < $num_matches; $i++) {
            $new_offset = $matches[$i][0][1];
            $tempcode_portion = $matches[$i][0][0];
            $len = strlen($tempcode_portion);

            $new_text .= substr($text, $last_offset, $new_offset - $last_offset);

            require_code('tempcode_compiler');
            $temp = template_to_tempcode(substr($text, $new_offset, $len), 0, false, '');
            $new_text .= $temp->evaluate();

            $last_offset = $new_offset + $len;
        }

        $new_text .= substr($text, $last_offset);

        $text = $new_text;
    }

    pop_no_keep_context();

    return $text;
}

/**
 * Make edited Comcode more portable between sites by putting the base URL symbol back in.
 *
 * @param  string $text Comcode
 * @return string Tempcode-enhanced Comcode
 */
function reinstate_static_tempcode(string $text) : string
{
    $_base_url = str_replace(['http\://', 'https\://'], ['https?\://', 'https?\://'], preg_quote(escape_html(get_base_url() . '/'), '#'));

    // Recognise what should be a page-link
    $matches = [];
    $num_matches = preg_match_all('#\shref="(' . $_base_url . '[^"\#]*)["\#]#', $text, $matches);
    for ($i = 0; $i < $num_matches; $i++) {
        $url_escaped = $matches[1][$i];
        $page_link = url_to_page_link(html_entity_decode($url_escaped, ENT_QUOTES));
        if ($page_link != '') {
            $text = str_replace($url_escaped, '{$PAGE_LINK*,' . $page_link . '}', $text);
        }
    }

    // Replace both http and https variants of base URL
    $text = preg_replace('#(<[^<>]*)' . $_base_url . '([^<>]*>)#', '$1{$BASE_URL*}/$2', $text);

    // Simple base URL substitution
    $text = str_replace(get_base_url() . '/', '{$BASE_URL*}/', $text);

    return $text;
}

/**
 * Log an error in failed Tempcode evaluation, and give a generic failure message.
 *
 * @param  object $e Error object
 * @param  string $code Eval'd code
 */
function tempcode_error(object $e, string $code)
{
    $error_message = $e->getMessage();

    $error_label = $error_message . ' - ' . $code;

    if ((function_exists('syslog')) && (GOOGLE_APPENGINE)) {
        syslog(LOG_ERR, $error_label);
    }
    if (php_function_allowed('error_log')) {
        @error_log(brand_name() . ' Tempcode: ERROR ' . $error_label, 0);
    }

    fatal_exit($error_message);
}

/**
 * Reduce down a template parameter to a maximum reasonable length, to avoid too much data being stuck in Tempcode trees.
 *
 * @param  Tempcode $text Text, provided in HTML format
 * @param  integer $max_length Maximum length
 * @return Tempcode Reduced length version of $text if required
 */
function reasonable_html_reduce(object $text, int $max_length = 1000) : object
{
    $text_flat = $text->evaluate();
    if (strlen($text_flat) > $max_length) {
        $text = make_string_tempcode(generate_truncation($text_flat, 'left', $max_length, false, true));
    }
    return $text;
}

/**
 * Parse Tempcode include code, for variables and substitutions.
 *
 * @param  string $var_data Text
 * @param  array $tpl_params Template parameters (added to by reference)
 * @return array Substitutions
 */
function parse_tempcode_include(string $var_data, array &$tpl_params) : array
{
    $substitutions = [];

    $explode = explode("\n", $var_data);
    foreach ($explode as $val) {
        $sub_matches = [];
        if (preg_match('#^\s*(\w+):\s*(.*?)\s*(~~>\s*(.*)\s*)?$#', $val, $sub_matches) != 0) {
            $substitutions[] = [$sub_matches[1], $sub_matches[2], isset($sub_matches[4]) ? $sub_matches[4] : ''];
        } else {
            $bits = explode('=', $val, 2);
            if (count($bits) == 2) {
                $save_as = ltrim($bits[0]);
                $tpl_params[$save_as] = str_replace('\n', "\n", $bits[1]);

                if ($GLOBALS['XSS_DETECT'] && ocp_is_escaped($var_data)) {
                    ocp_mark_as_escaped($tpl_params[$save_as]);
                }
            }
        }
    }

    return $substitutions;
}

/**
 * Execute Tempcode include substitution code.
 *
 * @param  string $value The evaluated Tempcode
 * @param  array $substitutions Substitutions to make (from parse_tempcode_include)
 */
function apply_tempcode_substitutions(string &$value, array $substitutions)
{
    if ($GLOBALS['XSS_DETECT']) {
        $escaped_before = ocp_is_escaped($value);
    }

    // Do substitutions
    foreach ($substitutions as $substitution) {
        switch ($substitution[0]) {
            case 'INSERT_AFTER':
                $value = str_replace($substitution[1], $substitution[1] . $substitution[2], $value);
                break;
            case 'INSERT_BEFORE':
                $value = str_replace($substitution[1], $substitution[2] . $substitution[1], $value);
                break;
            case 'STR_STRIP':
                $value = str_replace($substitution[1], '', $value);
                break;
            case 'STR_REPLACE':
                $value = str_replace($substitution[1], $substitution[2], $value);
                break;
            case 'PREG_STRIP':
                $value = @preg_replace($substitution[1], '', $value);
                break;
            case 'PREG_REPLACE':
                $value = @preg_replace($substitution[1], $substitution[2], $value);
                break;
            case 'REMOVE_SELECTOR':
                $value = preg_replace('#(^|\}|/)\s*' . preg_quote($substitution[1], '#') . '\s*\{.*\}#Us', '$1', $value);
                break;
            case 'REMOVE_SELECTOR_PROPERTY':
                $value = preg_replace('#((^|\}|/)\s*' . preg_quote($substitution[1], '#') . '\s*\{.*\s)' . preg_quote($substitution[2], '#') . ':[^;]*;(.*\})#Us', '$1$3', $value);
                break;
        }
    }

    if ($GLOBALS['XSS_DETECT']) {
        if ($escaped_before) {
            ocp_mark_as_escaped($value);
        }
    }
}
