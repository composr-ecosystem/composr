<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__files2()
{
    require_code('files');
}

/**
 * Make a missing required directory, or exit with an error if we cannot (unless error suppression is on).
 *
 * @param  PATH $dir Path to create
 * @param  boolean $make_index_file Whether to make an empty index file, to prevent browsing
 * @return boolean Success status
 */
function make_missing_directory(string $dir, bool $make_index_file = true) : bool
{
    if (@mkdir($dir, 0777, true) === false) {
        if ((error_reporting() & E_WARNING) === 0) { // Errors disabled via @ most likely
            return false;
        }
        if (function_exists('do_lang_tempcode')) {
            warn_exit(do_lang_tempcode('WRITE_ERROR_DIRECTORY_REPAIR', escape_html($dir)), false, true);
        } else {
            warn_exit('Could not auto-create missing directory ' . htmlentities($dir), false, true);
        }
    }
    fix_permissions($dir);
    sync_file($dir);

    cms_file_put_contents_safe($dir . '/index.html', '');

    return true;
}

/**
 * Discern the cause of a file-write error, and show an appropriate error message.
 *
 * @param  PATH $path File path that could not be written (full path, not relative)
 * @ignore
 */
function _intelligent_write_error(string $path)
{
    if (error_reporting() == 0) {
        return;
    }

    if (!function_exists('do_lang_tempcode')) {
        warn_exit('Could not write to ' . htmlentities($path));
    }

    if (file_exists($path)) {
        if (filesize($path) == 0) {
            return; // Probably was OR'd where 0 casted to false
        }

        warn_exit(do_lang_tempcode('WRITE_ERROR', escape_html($path)), false, true);
    } elseif (file_exists(dirname($path))) {
        if (strpos($path, '/templates_cached/') !== false) {
            critical_error('PASSON', do_lang('WRITE_ERROR_CREATE', escape_html($path), escape_html(dirname($path))));
        }
        warn_exit(do_lang_tempcode('WRITE_ERROR_CREATE', escape_html($path), escape_html(dirname($path))), false, true);
    } else {
        warn_exit(do_lang_tempcode('WRITE_ERROR_MISSING_DIRECTORY', escape_html(dirname($path)), escape_html(dirname($path, 2))), false, true);
    }
}

/**
 * Discern the cause of a file-write error, and return an appropriate error message.
 *
 * @param  PATH $path File path that could not be written
 * @param  boolean $force_hardcoded Whether to force a hard-coded error message, useful if we have not finished bootstrapping
 * @return mixed Message (string or Tempcode)
 *
 * @ignore
 */
function _intelligent_write_error_inline(string $path, bool $force_hardcoded = false)
{
    static $looping = false;
    if ($force_hardcoded || $looping/* Bail out hard if would cause a loop */ || !function_exists('do_lang_tempcode')/* In case do_lang_tempcode below spawns a recursive failure, due to the file being the language cache itself */) {
        if (file_exists($path)) {
            $ret = 'Cannot write to <kbd>' . escape_html($path) . '</kbd>. File permissions for it (or the directory it is in) may have not been set correctly.';
        } elseif (file_exists(dirname($path))) {
            $ret = 'Cannot create a <kbd>' . escape_html($path) . '</kbd> file. File permissions for the <kbd>' . escape_html(dirname($path)) . '</kbd> directory likely have not been set correctly.';
        } else {
            $ret = 'An expected directory, <kbd>' . escape_html($path) . '</kbd>, is missing.';
        }
        return $ret;
    }
    $looping = true;

    if (file_exists($path)) {
        $tret = do_lang_tempcode('WRITE_ERROR', escape_html($path));
    } elseif (file_exists(dirname($path))) {
        $tret = do_lang_tempcode('WRITE_ERROR_CREATE', escape_html($path), escape_html(dirname($path)));
    } else {
        $tret = do_lang_tempcode('WRITE_ERROR_MISSING_DIRECTORY', escape_html(dirname($path)), escape_html(dirname($path, 2)));
    }

    $looping = false;

    return $tret;
}

/**
 * Find details of where we can save temporary files, taking into account PHP's platform-dependent difficulties.
 *
 * @return array A tuple: preferred temporary path to save to, whether there's an identified problem saving in the system path, the system path to save to, the local path to save to
 */
function cms_get_temp_dir() : array
{
    $local_path = get_custom_file_base() . '/temp';
    if (!file_exists($local_path)) {
        make_missing_directory($local_path);
    }
    $server_path = rtrim(sys_get_temp_dir(), '/\\');
    $identified_problem_saving = ((get_option('force_local_temp_dir') == '1') || ((ini_get('open_basedir') != '') && (preg_match('#(^|:|;)' . preg_quote($server_path, '#') . '($|:|;|/)#', ini_get('open_basedir')) == 0)));
    $path = ($identified_problem_saving ? $local_path : $server_path);
    return [$path, $identified_problem_saving, $server_path, $local_path];
}

/**
 * Create file with unique file name, but works around compatibility issues between servers. Note that the file is NOT automatically deleted. You should also delete it using "@unlink", as some servers have problems with permissions.
 *
 * @param  string $prefix The prefix of the temporary file name
 * @return ~string The name of the temporary file (false: error)
 *
 * @ignore
 */
function _cms_tempnam(string $prefix = '')
{
    list($tmp_path, $identified_problem_saving, $server_path, $local_path) = cms_get_temp_dir();
    if (php_function_allowed('tempnam')) {
        // Create a real temporary file
        //  We have to use "@" in case of "file created in the system's temporary directory" notice
        $tempnam = @tempnam($tmp_path, 'tmpfile__' . $prefix);

        $seemed_to_save_okay = (($tempnam !== false) && ($tempnam != ''/*Should not be blank, but seen in the wild*/));

        if ($seemed_to_save_okay && !cms_is_writable($tempnam)/*Windows maybe created a file but not a writable one!*/) {
            @unlink($tempnam);
            $seemed_to_save_okay = false;
        }

        if ((!$seemed_to_save_okay) && ($tmp_path != $local_path)) {
            $tempnam = @tempnam($local_path, 'tmpfile__' . $prefix); // Try saving in local path even if we didn't think there'd be a problem saving into the system path
        }
    } else {
        // A fake temporary file, as true ones have been disabled on PHP
        require_code('crypt');
        $tempnam = $local_path . '/' . 'tmpfile__' . $prefix . get_secure_random_string();
        $myfile = fopen($tempnam, 'wb');
        fclose($myfile);
        fix_permissions($tempnam);
    }
    return $tempnam;
}

/**
 * Find if a file is a temporary file.
 *
 * @param  PATH $path File path
 * @return boolean Whether it is
 */
function is_temp_file(string $path) : bool
{
    $path = realpath($path);

    $_temp_dir = cms_get_temp_dir();
    $temp_dirs = [
        realpath($_temp_dir[0]),
        realpath(get_custom_file_base() . '/temp'),
    ];

    foreach ($temp_dirs as $temp_dir) {
        if (substr($path, 0, strlen($temp_dir) + 1) == $temp_dir . '/') { // Unix
            return true;
        }
        if (substr($path, 0, strlen($temp_dir) + 1) == $temp_dir . '\\') { // Windows
            return true;
        }
    }

    return false;
}

/**
 * Delete any attachment files from disk that were created as temporary files.
 * We cannot do this after calls to the dispatch_mail function because the mail queue will need them - it has to be once the mail is finished with.
 *
 * @param  ?array $attachments A list of attachments (each attachment being a map, absolute path=>filename) (null: none)
 */
function clean_temporary_mail_attachments(?array $attachments)
{
    if ($attachments !== null) {
        foreach (array_keys($attachments) as $path) {
            if (is_temp_file($path)) {
                unlink($path);
            }
        }
    }
}

/**
 * Provides a hook for file synchronisation between mirrored servers. Called after any file creation, deletion or edit.
 *
 * @param  PATH $filename File/directory name to sync on (full path)
 * @ignore
 */
function _sync_file(string $filename)
{
    global $FILE_BASE, $_MODIFIED_FILES, $_CREATED_FILES;
    if (substr($filename, 0, strlen($FILE_BASE) + 1) == $FILE_BASE . '/') {
        $filename = substr($filename, strlen($FILE_BASE) + 1);
    }
    static $has_sync_script = null;
    if ($has_sync_script === null) {
        $has_sync_script = is_file($FILE_BASE . '/data_custom/sync_script.php');
    }
    if ($has_sync_script) {
        require_once $FILE_BASE . '/data_custom/sync_script.php';
        if (function_exists('master__sync_file')) {
            master__sync_file($filename);
        }
    }
    if (isset($_MODIFIED_FILES)) {
        foreach ($_MODIFIED_FILES as $i => $x) {
            if (($x == $FILE_BASE . '/' . $filename) || ($x == $filename)) {
                unset($_MODIFIED_FILES[$i]);
            }
        }
    }
    if (isset($_CREATED_FILES)) {
        foreach ($_CREATED_FILES as $i => $x) {
            if (($x == $FILE_BASE . '/' . $filename) || ($x == $filename)) {
                unset($_CREATED_FILES[$i]);
            }
        }
    }
}

/**
 * Provides a hook for file-move synchronisation between mirrored servers. Called after any rename or move action.
 *
 * @param  PATH $old File/directory name to move from (may be full or relative path)
 * @param  PATH $new File/directory name to move to (may be full or relative path)
 * @ignore
 */
function _sync_file_move(string $old, string $new)
{
    global $FILE_BASE;
    if (is_file($FILE_BASE . '/data_custom/sync_script.php')) {
        require_once $FILE_BASE . '/data_custom/sync_script.php';
        if (substr($old, 0, strlen($FILE_BASE)) == $FILE_BASE) {
            $old = substr($old, strlen($FILE_BASE));
        }
        if (substr($new, 0, strlen($FILE_BASE)) == $FILE_BASE) {
            $new = substr($new, strlen($FILE_BASE));
        }
        if (function_exists('master__sync_file_move')) {
            master__sync_file_move($old, $new);
        }
    }
}

/**
 * Delete all the contents of a directory, and any subdirectories of that specified directory (recursively).
 *
 * @param  PATH $dir The pathname to the directory to delete
 * @param  boolean $default_preserve Whether to preserve index.html and .htaccess files (only applies to the lowest level directory)
 * @param  boolean $delete_dir_also Whether to delete the $dir at the end
 * @return boolean Success status
 *
 * @ignore
 */
function _deldir_contents(string $dir, bool $default_preserve = false, bool $delete_dir_also = false) : bool
{
    $success = true;

    $dh = @opendir($dir);

    if ($dh === false) {
        return false;
    }

    while (($file = readdir($dh)) !== false) {
        if (in_array($file, ['.', '..'])) {
            continue;
        }

        if (($default_preserve) && (in_array($file, ['index.html', '.htaccess']))) {
            continue;
        }

        if (is_dir($dir . '/' . $file)) {
            if (!_deldir_contents($dir . '/' . $file, false, true)) {
                $success = false;
            }
        } else {
            $test = @unlink($dir . '/' . $file);
            if ($test === false) {
                $success = false;
                if (function_exists('attach_message')) {
                    attach_message(do_lang_tempcode('WRITE_ERROR', escape_html($dir . '/' . $file)), 'warn', false, true);
                }
            }
        }

        sync_file($dir . '/' . $file);
    }
    closedir($dh);

    if ($delete_dir_also) {
        $test = @rmdir($dir);
        if ($test === false) {
            $success = false;
            if (function_exists('attach_message')) {
                attach_message(do_lang_tempcode('WRITE_ERROR', escape_html($dir)), 'warn', false, true);
            }
        }
    }

    return $success;
}

/**
 * Find path to the PHP executable.
 *
 * @param  boolean $cgi Whether we need a CGI interpreter
 * @return PATH Path to PHP (or just raw php command if cannot find a full path)
 */
function find_php_path(bool $cgi = false) : string
{
    global $SITE_INFO;
    if ((!$cgi) && isset($SITE_INFO['php_path']) && is_file($SITE_INFO['php_path'])) {
        return $SITE_INFO['php_path'];
    }
    if (($cgi) && isset($SITE_INFO['php_cgi_path']) && is_file($SITE_INFO['php_cgi_path'])) {
        return $SITE_INFO['php_cgi_path'];
    }

    if (strpos(PHP_OS, 'WIN') !== false) {
        $search_dirs = [
            'c:\\php*',
            'c:\\progra~1\\php*',
        ];
        $filenames = [
            'php.exe',
            'php-win.exe',
            'php-cli.exe',
            'php-cgi.exe',
        ];
    } elseif (strpos(PHP_OS, 'Darwin') !== false) {
        $search_dirs = [
            '/usr/local/bin',
            '/usr/bin',
            '/bin',
        ];
        $filenames = [
            'php',
            'php.dSYM',
            'php-cli',
            'php-cli.dSYM',
            'php-cgi',
            'php-cgi.dSYM',
        ];
    } else {
        $search_dirs = [
            '/usr/local/bin',
            '/usr/bin',
            '/bin',
        ];
        $filenames = [
            'php',
            'php-cli',
            'php-cgi',
        ];
    }

    $php_path = '';
    foreach ($search_dirs as $dir) {
        foreach ($filenames as $file) {
            if ((!$cgi) || (strpos($file, 'cgi') !== false)) {
                $path = $dir . '/' . $file;
                $_path = @glob($path);
                if (!@empty($_path)) {
                    $php_path = $_path[0];
                    break 2;
                }
            }
        }
    }
    if ($php_path == '') {
        // Make up what we'd expect by default then
        $php_path = $cgi ? 'php-cgi' : 'php';
    }
    return $php_path;
}

/**
 * Get the contents of a directory, recursively. It is assumed that the directory exists.
 * Always uses '/' as the directory separator.
 *
 * @param  PATH $path The path to search
 * @param  PATH $rel_path The path we prepend to everything we find (intended to be used inside the recursion)
 * @param  ?integer $bitmask Bitmask of extra stuff to ignore (see IGNORE_* constants) (null: do not use)
 * @param  boolean $recurse Whether to recurse (if not, will return directories as files)
 * @param  boolean $files_wanted Whether to get files (if not, will return directories instead of files)
 * @param  ?array $file_extensions File extensions to limit to (no dots), if $files_wanted set (null: no limit)
 * @return array The contents of the directory
 */
function get_directory_contents(string $path, string $rel_path = '', ?int $bitmask = IGNORE_ACCESS_CONTROLLERS, bool $recurse = true, bool $files_wanted = true, ?array $file_extensions = null) : array
{
    if (($files_wanted) && ($file_extensions === [])) {
        return []; // Optimisation
    }

    $out = [];

    require_code('files');

    $dh = @opendir($path);
    if ($dh === false) {
        return [];
    }
    while (($file = readdir($dh)) !== false) {
        if ($file == '_meta_tree') { // Very special case, directory can get huge
            continue;
        }

        if ($bitmask !== null) {
            if (should_ignore_file($rel_path . (($rel_path == '') ? '' : '/') . $file, $bitmask)) {
                continue;
            }
        } elseif (($file == '.') || ($file == '..')) {
            continue;
        }

        if (is_file($path . '/' . $file)) {
            if (($files_wanted) && (($file_extensions === null) || (in_array(get_file_extension($file), $file_extensions)))) {
                $out[] = $rel_path . (($rel_path == '') ? '' : '/') . $file;
            }
        } elseif (is_dir($path . '/' . $file)) {
            if (!$files_wanted) {
                $out[] = $rel_path . (($rel_path == '') ? '' : '/') . $file;
            }
            if ($recurse) {
                $out = array_merge($out, get_directory_contents($path . '/' . $file, $rel_path . (($rel_path == '') ? '' : '/') . $file, $bitmask, $recurse, $files_wanted, $file_extensions));
            }
        }
    }
    closedir($dh);

    return $out;
}

/**
 * Get the size in bytes of a directory. It is assumed that the directory exists.
 *
 * @param  PATH $path The path to search
 * @param  boolean $recurse Whether to recurse
 * @return integer The size in bytes
 */
function get_directory_size(string $path, bool $recurse = true) : int
{
    $size = 0;

    $dh = @opendir($path);
    if ($dh === false) {
        return 0;
    }
    while (($e = readdir($dh)) !== false) {
        if (($e == '.') || ($e == '..')) {
            continue;
        }

        if (is_file($path . '/' . $e)) {
            $size += filesize($path . '/' . $e);
        } elseif (is_dir($path . '/' . $e)) {
            if ($recurse) {
                $size += get_directory_size($path . '/' . $e, $recurse);
            }
        }
    }
    closedir($dh);

    return $size;
}

/**
 * Get a message for maximum uploads.
 *
 * @param  float $max Maximum size in MB
 * @return Tempcode The message
 */
function get_maximum_upload_message(float $max) : object
{
    $config_url = get_upload_limit_config_url();
    return paragraph(do_lang_tempcode(($config_url === null) ? 'MAXIMUM_UPLOAD' : 'MAXIMUM_UPLOAD_STAFF', escape_html(($max > 10.0) ? integer_format(intval($max)) : float_format($max)), ($config_url === null) ? '' : escape_html_tempcode($config_url)), '0oa9paovv3xj12dqlny21zwajoh1f90q');
}

/**
 * Get the URL to the config option group for editing limits.
 *
 * @return ?Tempcode The URL to the config option group for editing limits (null: no access)
 */
function get_upload_limit_config_url() : ?object
{
    $config_url = null;
    if (has_actual_page_access(get_member(), 'admin_config')) {
        $config_url = build_url(['page' => 'admin_config', 'type' => 'category', 'id' => 'FEATURE'], get_module_zone('admin_config'), [], false, false, false, 'group-UPLOAD');
    }
    return $config_url;
}

/**
 * Get the maximum allowed upload filesize, as specified in the configuration.
 *
 * @param  ?MEMBER $source_member Member we consider quota for (null: do not consider quota because we are not dealing with attachments)
 * @param  ?object $db Database connector to get quota from (null: site DB)
 * @param  boolean $consider_php_limits Whether to consider limitations in PHP's configuration
 * @return integer The maximum allowed upload filesize, in bytes
 */
function get_max_file_size(?int $source_member = null, ?object $db = null, bool $consider_php_limits = true) : int
{
    $possibilities = [];

    require_code('files');
    $a = php_return_bytes(ini_get('upload_max_filesize'));
    $b = GOOGLE_APPENGINE ? 0 : php_return_bytes(ini_get('post_max_size'));
    $c = intval(get_option('max_download_size')) * 1024;
    if (has_privilege(get_member(), 'exceed_filesize_limit')) {
        $c = 0;
    }

    $d = null;
    if (($source_member !== null) && (!has_privilege(get_member(), 'exceed_filesize_limit'))) { // We'll be considering quota also
        if (get_forum_type() == 'cns') {
            require_code('cns_groups');
            $daily_quota = cns_get_member_best_group_property($source_member, 'max_daily_upload_mb');
        } else {
            $daily_quota = NON_CNS_QUOTA;
        }
        if ($db === null) {
            $db = $GLOBALS['SITE_DB'];
        }
        $_size_uploaded_today = $db->query('SELECT SUM(a_file_size) AS the_answer FROM ' . $db->get_table_prefix() . 'attachments WHERE a_member_id=' . strval($source_member) . ' AND a_add_time>' . strval(time() - 60 * 60 * 24) . ' AND a_add_time<=' . strval(time()));
        $size_uploaded_today = intval($_size_uploaded_today[0]['the_answer']);
        $d = max(0, $daily_quota * 1024 * 1024 - $size_uploaded_today);
    }

    if ($consider_php_limits) {
        if ($a != 0) {
            $possibilities[] = $a;
        }
        if ($b != 0) {
            $possibilities[] = $b;
        }
    }
    if ($c != 0) {
        $possibilities[] = $c;
    }
    if ($d !== null) {
        $possibilities[] = $d;
    }

    return (empty($possibilities)) ? (1024 * 1024 * 1024 * 1024) : min($possibilities);
}

/**
 * Check uploaded file extensions for possible malicious intent, and if some is found, an error is put out, and the hackattack logged.
 *
 * @param  string $path The file path or filename
 * @param  boolean $skip_server_side_security_check Whether to skip the server side security check
 * @param  ?string $file_to_delete Delete this file if we have to exit (null: no file to delete)
 * @param  boolean $accept_errors Whether to allow errors without dying
 * @param  ?MEMBER $member_id Member to check as (null: current member)
 * @return boolean Success status
 */
function check_extension(string &$path, bool $skip_server_side_security_check = false, ?string $file_to_delete = null, bool $accept_errors = false, ?int $member_id = null) : bool
{
    if ($member_id === null) {
        $member_id = get_member();
    }

    $bad_file_extensions = [
        // Also see .htaccess files that use these same lists
        'phtml', 'php', 'php3', 'php4', 'php5', 'phar', 'phps', // PHP
        'py', // Python
        'rhtml', 'rb', // Ruby
        'pl', // Perl
        'jsp', // JavaServer Pages
        'dll', 'aspx', 'ashx', 'asmx', 'asx', 'axd', 'asp', // ASP / .net
        'vbs', // Server-side VBScript
        'cgi', 'fcgi', 'sh', // CGI
    ];

    $filename = basename($path);
    $dir = dirname($path);
    $filename = preg_replace('#\.(' . implode('|', $bad_file_extensions) . ')(?=\.)#', '-$1', $filename);
    if (($dir != '') && ($dir != '.')) {
        $path = $dir . '/' . $filename;
    } else {
        $path = $filename;
    }

    $ext = get_file_extension($filename);

    $_types = get_option('valid_types');
    $types = array_flip(explode(',', $_types));
    ksort($types);
    if (!$skip_server_side_security_check) {
        if (!has_privilege($member_id, 'use_very_dangerous_comcode')) {
            $dangerous_markup_types = [
                'js',
                'json',
                'html',
                'htm',
                'shtml',
                'svg',
                'xml',
                'rss',
                'atom',
                'xsd',
                'xsl',
                'css',
                'woff',
            ];
            foreach ($dangerous_markup_types as $type) {
                unset($types[$type]);
            }
        }
    }
    $types = array_flip($types);

    $_types = '';
    foreach ($types as $val) {
        if ($_types != '') {
            $_types .= ',';
        }
        $_types .= $val;
    }

    if (!$skip_server_side_security_check) {
        if ((in_array($ext, $bad_file_extensions)) || (cms_strtolower_ascii($filename) == '.htaccess')) {
            if ($file_to_delete !== null) {
                unlink($file_to_delete);
            }
            if ($accept_errors) {
                return false;
            }
            log_hack_attack_and_exit('SCRIPT_UPLOAD_HACK');
        }
    }

    if ($_types != '') {
        foreach ($types as $val) {
            if (cms_strtolower_ascii(trim($val)) == $ext) {
                return true;
            }
        }

        if ($file_to_delete !== null) {
            unlink($file_to_delete);
        }
        $message = do_lang_tempcode('INVALID_FILE_TYPE', escape_html($ext), escape_html(str_replace(',', ', ', $_types)));
        if (has_actual_page_access(get_member(), 'admin_config')) {
            $link = build_url(['page' => 'admin_config', 'type' => 'category', 'id' => 'SECURITY'], get_module_zone('admin_config'), [], false, false, false, 'group-UPLOAD');
            $message = do_lang_tempcode('INVALID_FILE_TYPE_ADMIN', escape_html($ext), escape_html(str_replace(',', ', ', $_types)), escape_html_tempcode($link));
        }
        if ($accept_errors) {
            require_code('site');
            attach_message($message, 'warn');
            return false;
        } else {
            warn_exit($message);
        }
    }

    return true;
}

/**
 * Delete an uploaded file from disk, if it's URL has changed (i.e. it's been replaced, leaving a redundant disk file).
 * This MUST be run before the edit/delete operation, as it scans for the existing value to know what is changing.
 *
 * @param  string $upload_path The path to the upload directory
 * @param  ID_TEXT $table The table name
 * @param  ID_TEXT $field The table field name
 * @param  mixed $id_field The table ID field name, or a map array
 * @param  mixed $id The table ID
 * @param  ?string $new_url The new URL to use (null: deleting without replacing: no change check)
 */
function delete_upload(string $upload_path, string $table, string $field, $id_field, $id, ?string $new_url = null)
{
    // Try and delete the file
    if ((has_actual_page_access(get_member(), 'admin_cleanup')) || (get_option('cleanup_files') == '1')) { // This isn't really a permission - more a failsafe in case there is a security hole. Staff can cleanup leftover files from the Cleanup module anyway. NB: Also repeated in cms_galleries.php.
        $where = is_array($id_field) ? $id_field : [$id_field => $id];
        $url = $GLOBALS['SITE_DB']->query_select_value_if_there($table, filter_naughty_harsh($field), $where);
        if (empty($url)) {
            return;
        }

        if (($new_url === null) || ((($url != $new_url) && (rawurldecode($url) != rawurldecode($new_url))) && ($new_url != STRING_MAGIC_NULL))) {
            if ((url_is_local($url)) && (substr($url, 0, strlen($upload_path) + 1) == $upload_path . '/')) {
                $count = $GLOBALS['SITE_DB']->query_select_value($table, 'COUNT(*)', [$field => $url]);

                if ($count <= 1) {
                    @unlink(get_custom_file_base() . '/' . rawurldecode($url));
                    sync_file(rawurldecode($url));
                }
            }
            if ((url_is_local($url)) && (substr($url, 0, strlen('themes/default/images_custom') + 1) == 'themes/default/images_custom/')) {
                require_code('themes2');
                tidy_theme_img_code($new_url, $url, $table, $field, $GLOBALS['SITE_DB']);
            }
        }
    }
}

/**
 * Check bandwidth usage against page view ratio for shared hosting.
 *
 * @param  integer $extra The extra bandwidth requested
 */
function check_shared_bandwidth_usage(int $extra)
{
    global $SITE_INFO;
    if (!empty($SITE_INFO['throttle_bandwidth_registered'])) {
        $views_till_now = intval(get_value('page_views'));
        $bandwidth_allowed = $SITE_INFO['throttle_bandwidth_registered'];
        $total_bandwidth = intval(get_value('download_bandwidth'));
        if ($bandwidth_allowed * 1024 * 1024 >= $total_bandwidth + $extra) {
            return;
        }
    }
    if (!empty($SITE_INFO['throttle_bandwidth_complementary'])) {
        // $timestamp_start = $SITE_INFO['custom_user_'] . current_share_user(); Actually we'll do by views
        // $days_till_now = (time() - $timestamp_start) / (24 * 60 * 60);
        $views_till_now = intval(get_value('page_views'));
        $bandwidth_allowed = $SITE_INFO['throttle_bandwidth_complementary'] + $SITE_INFO['throttle_bandwidth_views_per_meg'] * $views_till_now;
        $total_bandwidth = intval(get_value('download_bandwidth'));
        if ($bandwidth_allowed * 1024 * 1024 < $total_bandwidth + $extra) {
            critical_error('RELAY', 'The hosted user has exceeded their shared-hosting "bandwidth-limit to page-view" ratio. More pages must be viewed before this may be downloaded.');
        }
    }
}

/**
 * Check disk space usage against page view ratio for shared hosting.
 *
 * @param  integer $extra The extra space in bytes requested
 */
function check_shared_space_usage(int $extra)
{
    global $SITE_INFO;
    if (!empty($SITE_INFO['throttle_space_registered'])) {
        $views_till_now = intval(get_value('page_views'));
        $bandwidth_allowed = $SITE_INFO['throttle_space_registered'];
        $total_space = get_directory_size(get_custom_file_base() . '/uploads');
        if ($bandwidth_allowed * 1024 * 1024 >= $total_space + $extra) {
            return;
        }
    }
    if (!empty($SITE_INFO['throttle_space_complementary'])) {
        // $timestamp_start = $SITE_INFO['custom_user_'] . current_share_user(); Actually we'll do by views
        // $days_till_now = (time() - $timestamp_start) / (24 * 60 * 60);
        $views_till_now = intval(get_value('page_views'));
        $space_allowed = $SITE_INFO['throttle_space_complementary'] + $SITE_INFO['throttle_space_views_per_meg'] * $views_till_now;
        $total_space = get_directory_size(get_custom_file_base() . '/uploads');
        if ($space_allowed * 1024 * 1024 < $total_space + $extra) {
            critical_error('RELAY', 'The hosted user has exceeded their shared-hosting "disk-space to page-view" ratio. More pages must be viewed before this may be uploaded.');
        }
    }
}
