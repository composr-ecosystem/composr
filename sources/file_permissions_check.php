<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2020

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*EXTRA FUNCTIONS: shell_exec|escapeshellarg|posix_.*|fileowner|get_current_user*/

// Everything in this file can run without Composr having bootstrapped, although it will run better if it has

/**
 * Execute a shell command, returning full output, with a guaranteed line break if not blank.
 *
 * @param  string $command Command to run
 * @return string Command output
 */
function execute_nicely($command)
{
    $ret = @trim(shell_exec($command . ' 2>&1'));
    if ($ret != '') {
        $ret .= "\n";
    }
    return $ret;
}

/**
 * Scan permissions.
 *
 * @param  boolean $live_output Whether to produce live output of issues
 * @param  boolean $live_commands Whether to run commands live
 * @param  ?string $web_username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
 * @param  ?boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP (null: default / auto-detect if possible)
 * @param  integer $minimum_level Minimum RESULT_TYPE_* level
 * @return array A tuple: Messages to show, Commands to run, Paths with issues, Whether any issues were found
 */
function scan_permissions($live_output = false, $live_commands = false, $web_username = null, $has_ftp_loopback_for_write = null, $minimum_level = 3)
{
    $sensitive_paths = [
        '_config.php',
        'exports/backups/[^/]*\.tar(\.gz)?',
        'exports/file_backups/_config.php\.\d+',
    ];

    $chmod_array = get_chmod_array('**', true);
    $chmod_paths = [];
    foreach ($chmod_array as $chmod) {
        $chmod = preg_quote($chmod, '#');
        $chmod = str_replace('\*\*', '[^/\.]*', $chmod);
        $chmod = str_replace('\*', '[^/]*', $chmod);
        $chmod_paths[] = $chmod;
    }

    if ($has_ftp_loopback_for_write === null) {
        $has_ftp_loopback_for_write = ((function_exists('ftp_ssl_connect')) || (function_exists('ftp_connect'))) && ((!function_exists('get_value')) || (get_value('uses_ftp') !== '0'));
    }

    if (strpos(PHP_OS, 'WIN') !== false) {
        $ob = new CMSPermissionsScannerWindows();
    } else {
        $ob = new CMSPermissionsScannerLinux();
    }

    $ob->set_path_patterns($sensitive_paths, $chmod_paths);

    $ob->set_live_output($live_output);
    $ob->set_live_commands($live_commands);

    if ($web_username !== null) {
        $ob->set_web_username($web_username);
    }

    $ob->set_minimum_level($minimum_level);

    $ob->set_has_ftp_loopback_for_write($has_ftp_loopback_for_write);

    $subdir = '';

    if (function_exists('get_file_base')) {
        $stub = get_file_base() . (($subdir == '') ? '' : '/');
    } else {
        $stub = dirname(__DIR__) . (($subdir == '') ? '' : '/');
    }

    $found_any_issue = false;

    $messages = [];
    $commands = [];
    $_paths = [];

    list($_messages, $_commands) = $ob->process_directory($stub . $subdir, $subdir, null, true, $_paths, $found_any_issue);
    $messages = array_merge($messages, $_messages);
    $commands = array_merge($commands, $_commands);

    if ((function_exists('get_file_base')) && (get_file_base() != get_custom_file_base())) {
        list($_messages, $_commands) = $ob->process_directory(get_custom_file_base() . (($subdir == '') ? '' : '/') . $subdir, $subdir, null, true, $_paths, $found_any_issue);
        $messages = array_merge($messages, $_messages);
        $commands = array_merge($commands, $_commands);
    }

    $paths = array_keys($_paths);

    return [$messages, $commands, $paths, $found_any_issue];
}

/**
 * Get the list of files that need CHmodding for write access.
 *
 * @param  string $lang Language to use, may be whatever wildcard syntax the caller supports
 * @param  boolean $runtime Whether to include wildcards represented runtime-created chmoddable files
 * @return array The list of files
 */
function get_chmod_array($lang = '*', $runtime = false)
{
    $extra_files = [];

    if (function_exists('find_all_hooks')) {
        $hooks = find_all_hooks('systems', 'addon_registry');
        $hook_keys = array_keys($hooks);
        foreach ($hook_keys as $hook) {
            /*require_code('hooks/systems/addon_registry/' . filter_naughty_harsh($hook));
            $object = object_factory('Hook_addon_registry_' . filter_naughty_harsh($hook));
            $extra_files = array_merge($extra_files, $object->get_chmod_array());*/

            // Save memory compared to above commented code...

            $path = get_file_base() . '/sources_custom/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            if (!file_exists($path)) {
                $path = get_file_base() . '/sources/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            }
            $matches = [];
            if (preg_match('#function get_chmod_array\(\)\s*\{([^\}]*)\}#', cms_file_get_contents_safe($path, FILE_READ_LOCK), $matches) != 0) {
                $extra_files = array_merge($extra_files, cms_eval($matches[1], $path));
            }
        }
    }

    if ($runtime) {
        $extra_files = array_merge($extra_files, [
            'adminzone/pages/comcode_custom/*/*.txt',
            'adminzone/pages/html_custom/*/*.htm',
            'cms/pages/comcode_custom/*/*.txt',
            'cms/pages/html_custom/*/*.htm',
            'data_custom/modules/admin_backup/*',
            'data_custom/modules/admin_stats/*',
            'data_custom/modules/chat/*',
            'data_custom/modules/web_notifications/*',
            'data_custom/sitemaps/*',
            'data_custom/spelling/personal_dicts/*',
            'data_custom/xml_config/*.xml',
            'exports/*/*',
            'forum/pages/comcode_custom/*/*.txt',
            'forum/pages/html_custom/*/*.htm',
            'imports/*/*',
            'lang_custom/*/*.ini',
            'pages/comcode_custom/*/*.txt',
            'pages/html_custom/*/*.htm',
            'site/pages/comcode_custom/*/*.txt',
            'site/pages/html_custom/*/*.htm',
            'text_custom/*.txt',
            'text_custom/*/*.txt',
            'themes/*/css_custom/*',
            'themes/*/images_custom/*',
            'themes/*/javascript_custom/*',
            'themes/*/templates_custom/*',
            'themes/*/text_custom/*',
            'themes/*/xml_custom/*',
            'uploads/attachments/*',
            'uploads/attachments_thumbs/*',
            'uploads/auto_thumbs/*',
            'uploads/banners/*',
            'uploads/captcha/*',
            'uploads/catalogues/*',
            'uploads/cns_avatars/*',
            'uploads/cns_cpf_upload/*',
            'uploads/cns_photos/*',
            'uploads/cns_photos_thumbs/*',
            'uploads/downloads/*',
            'uploads/filedump/*',
            'uploads/galleries/*',
            'uploads/galleries_thumbs/*',
            'uploads/personal_sound_effects/*',
            'uploads/repimages/*',
            'uploads/watermarks/*',
            'uploads/website_specific/*',
        ]);
    }

    return array_merge(
        $extra_files,
        [
            'adminzone/pages/comcode_custom/' . $lang,
            'adminzone/pages/html_custom/' . $lang,
            'caches/static',
            'caches/lang',
            'caches/lang/' . $lang,
            'caches/persistent',
            'caches/self_learning',
            'caches/http',
            'cms/pages/comcode_custom/' . $lang,
            'cms/pages/html_custom/' . $lang,
            'data_custom/errorlog.php',
            'data_custom/firewall_rules.txt',
            'data_custom/modules/admin_backup',
            'data_custom/modules/admin_stats',
            'data_custom/modules/chat',
            'data_custom/modules/web_notifications',
            'data_custom/sitemaps',
            'data_custom/spelling/personal_dicts',
            'data_custom/xml_config',
            'data_custom',
            'exports/addons',
            'exports/backups',
            'exports/file_backups',
            'forum/pages/comcode_custom/' . $lang,
            'forum/pages/html_custom/' . $lang,
            'imports/addons',
            'lang_custom',
            'lang_custom/' . $lang,
            'pages/comcode_custom/' . $lang,
            'pages/html_custom/' . $lang,
            'temp',
            'site/pages/comcode_custom/' . $lang,
            'site/pages/html_custom/' . $lang,
            'text_custom',
            'text_custom/' . $lang,
            'themes',
            'themes/admin/css_custom',
            'themes/admin/images_custom',
            'themes/admin/javascript_custom',
            'themes/admin/templates_cached/' . $lang,
            'themes/admin/templates_custom',
            'themes/admin/text_custom',
            'themes/admin/xml_custom',
            'themes/default/css_custom',
            'themes/default/images_custom',
            'themes/default/javascript_custom',
            'themes/default/templates_cached/' . $lang,
            'themes/default/templates_custom',
            'themes/default/text_custom',
            'themes/default/theme.ini',
            'themes/default/xml_custom',
            'themes/map.ini',
            'uploads/attachments',
            'uploads/attachments_thumbs',
            'uploads/auto_thumbs',
            'uploads/banners',
            'uploads/captcha',
            'uploads/catalogues',
            'uploads/cns_avatars',
            'uploads/cns_cpf_upload',
            'uploads/cns_photos',
            'uploads/cns_photos_thumbs',
            'uploads/downloads',
            'uploads/filedump',
            'uploads/galleries',
            'uploads/galleries_thumbs',
            'uploads/incoming',
            'uploads/personal_sound_effects',
            'uploads/repimages',
            'uploads/watermarks',
            'uploads/website_specific',
            '_config.php',
        ]
    );
}

/**
 * Check/fix permissions, base class.
 *
 * @package cms_permissions_scanner
 */
abstract class CMSPermissionsScanner
{
    // Constants...

    const RESULT_TYPE_SUCCESS = 0;
    const RESULT_TYPE_SUGGESTION_EXCESSIVE = 1;
    const RESULT_TYPE_SUGGESTION_MISSING = 2;
    const RESULT_TYPE_ERROR_EXCESSIVE = 3;
    const RESULT_TYPE_ERROR_MISSING = 4;

    // Options...

    protected $sensitive_paths = [];
    protected $chmod_paths = [];
    protected $script_paths = null;

    protected $has_ftp_loopback_for_write = false;

    protected $minimum_level = 1;
    protected $live_output = false;
    protected $live_commands = false;

    // Code...

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    abstract public function set_web_username($username = null);

    /**
     * Set paths patterns.
     *
     * @param  array $sensitive_paths A list of sensitive path regexps that really should have minimal read permission
     * @param  array $chmod_paths A list of path regexps that should be chmodded as writable for non-suEXEC-style servers
     * @param  ?array $script_paths A list of path regexps for scripts that need Unix execute permission (null: .sh files)
     */
    public function set_path_patterns($sensitive_paths = [], $chmod_paths = [], $script_paths = null)
    {
        $this->sensitive_paths = $sensitive_paths;
        $this->chmod_paths = $chmod_paths;
        if ($script_paths === null) {
            $this->script_paths = [
                '.*\.sh',
            ];
        } else {
            $this->script_paths = $script_paths;
        }
    }

    /**
     * Set whether we can 'get' write access via some kind of loopback.
     *
     * @param  boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP
     */
    public function set_has_ftp_loopback_for_write($has_ftp_loopback_for_write)
    {
        $this->has_ftp_loopback_for_write = $has_ftp_loopback_for_write;
    }

    /**
     * Set minimum result level.
     *
     * @param  integer $minimum_level Minimum RESULT_TYPE_* level
     */
    public function set_minimum_level($minimum_level)
    {
        $this->minimum_level = $minimum_level;
    }

    /**
     * Set whether to show live output, rather than just returning at the end.
     *
     * @param  boolean $live_output Whether to output live
     */
    public function set_live_output($live_output)
    {
        $this->live_output = $live_output;
    }

    /**
     * Set whether to run live commands, rather than just returning at the end.
     *
     * @param  boolean $live_commands Whether to run commands
     */
    public function set_live_commands($live_commands)
    {
        $this->live_commands = $live_commands;
    }

    /**
     * Find whether a particular PHP function is allowed.
     *
     * @param  string $function Function name
     * @return boolean Whether it is
     */
    protected function php_function_allowed($function)
    {
        if (!function_exists($function)) {
            return false;
        }
        $disabled_functions = @strtolower(ini_get('disable_functions') . ',' . ini_get('suhosin.executor.func.blacklist') . ',' . ini_get('suhosin.executor.include.blacklist') . ',' . ini_get('suhosin.executor.eval.blacklist'));
        return (@preg_match('#(\s|,|^)' . preg_quote($function, '#') . '(\s|$|,)#', $disabled_functions) == 0);
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    abstract public function process_directory($path, $rel_path = '', $attr = null, $top_level = true, &$paths = [], &$found_any_issue = false);

    /**
     * Create a success message.
     *
     * @param  PATH $path The path the message is about
     * @return string The message
     */
    protected function output_success($path)
    {
        $message = 'Success: ' . $path;

        return $message;
    }
}

/**
 * Check/fix permissions on Linux/MacOS.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScannerLinux extends CMSPermissionsScanner
{
    // Constants...

    const BITMASK_PERMISSIONS_STICKY = 01000;
    const BITMASK_PERMISSIONS_SETGID = 02000;
    const BITMASK_PERMISSIONS_SETUID = 04000;

    const BITMASK_PERMISSIONS_OWNER_EXECUTE = 00100;
    const BITMASK_PERMISSIONS_OWNER_WRITE = 00200;
    const BITMASK_PERMISSIONS_OWNER_READ = 00400;

    const BITMASK_PERMISSIONS_GROUP_EXECUTE = 00010;
    const BITMASK_PERMISSIONS_GROUP_WRITE = 00020;
    const BITMASK_PERMISSIONS_GROUP_READ = 00040;

    const BITMASK_PERMISSIONS_OTHER_EXECUTE = 00001;
    const BITMASK_PERMISSIONS_OTHER_WRITE = 00002;
    const BITMASK_PERMISSIONS_OTHER_READ = 00004;

    // Run-time data...

    protected $has_lsattr;
    protected $web_user;

    // Code...

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->set_web_username();

        $this->set_path_patterns();

        $this->has_lsattr = false;
        if (($this->php_function_allowed('shell_exec')) && ($this->php_function_allowed('escapeshellarg'))) {
            if (preg_match('#lsattr \d#', shell_exec('lsattr -V 2>&1')) != 0) {
                $this->has_lsattr = true;
            }
        }
    }

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username($username = null)
    {
        $this->web_user = null;

        if ($username === null) {
            if ($this->php_function_allowed('posix_getuid')) {
                $this->web_user = posix_getuid();
            }
        } else {
            if (is_numeric($username)) {
                $this->web_user = intval($username);
            } else {
                if ($this->php_function_allowed('posix_getpwnam')) {
                    $details = @posix_getpwnam($username);
                    if ($details === false) {
                        throw new Exception('Cannot find user, ' . $username);
                    }
                    $this->web_user = $details['uid'];
                } else {
                    throw new Exception('Posix extension is needed if passing a username');
                }
            }
        }
    }

    /**
     * Find the extended attributes for a path.
     *
     * @param  PATH $path The absolute path
     * @param  boolean $directory_contents Whether this is a directory to get the contents of
     * @return array A map of file paths to extended attribute strings
     */
    protected function process_lsattr($path, $directory_contents = false)
    {
        $lsattr = [];
        if ($this->has_lsattr) {
            $cmd = 'lsattr';
            if (!$directory_contents) {
                $cmd .= ' -d';
            }
            $cmd .= ' ' . escapeshellarg($path);
            $_lsattr = @strval(shell_exec($cmd . ' 2>&1'));

            $matches = [];
            $num_matches = preg_match_all('#^([A-Za-z\-])\t(.*)$#m', $_lsattr, $matches);
            for ($i = 0; $i < $num_matches; $i++) {
                $lsattr[$matches[2][$i]] = $matches[1][$i];
            }
        }
        return $lsattr;
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory($path, $rel_path = '', $attr = null, $top_level = true, &$paths = [], &$found_any_issue = false)
    {
        $messages = [];
        $commands = [];

        if ($top_level) {
            if ($this->php_function_allowed('shell_exec')) {
                if (strpos(shell_exec('sestatus'), 'enabled') !== false) {
                    if (strpos(shell_exec('ps -eZ'), 'httpd_t') !== false) {
                        $found_selinux_rule = false;

                        $path_up = $path;
                        do {
                            $cmd = 'ls -Zld ' . escapeshellarg($path_up);
                            if (strpos(shell_exec($cmd), 'httpd_sys_rw_content_t') !== false) {
                                $found_selinux_rule = true;
                            }

                            $_path_up = $path_up;
                            $path_up = dirname($path_up);
                        } while (($path_up != '.') && (!empty($path_up)) && ($path_up != $_path_up));

                        if (!$found_selinux_rule) {
                            $message = 'Error: selinux is running and httpd_sys_rw_content_t is not set in the directory tree of ' . $path;
                            $messages[] = $message;
                            if ($this->live_output) {
                                echo $message . "\n";
                            }
                        }
                    }
                }
            }
        }

        if ($attr === null) {
            $lsattr = $this->process_lsattr($path);
            $attr = isset($lsattr[$path]) ? $lsattr[$path] : '';
        }

        $_messages = $this->process_node($path, $rel_path, true, $attr, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $lsattr = $this->process_lsattr($path, true);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, isset($lsattr[$_path]) ? $lsattr[$_path] : '', false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, isset($lsattr[$_path]) ? $lsattr[$_path] : '', $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }

    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  boolean $is_directory Whether this is a directory
     * @param  string $attr A string of extended attributes from lsattr
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node($path, $rel_path, $is_directory, $attr, &$paths = [], &$found_any_issue = false)
    {
        // (We will assume the file owner is not something we want to change, just the permissions to work best with that owner)

        $messages = [];
        $commands = [];

        $file_owner = @fileowner($path);
        $file_perms = @fileperms($path);

        if (($file_owner === false) || ($file_perms === false)) {
            return [[], []]; // Likely as parent directory is missing perms, which will be flagged
        }

        $perms_needed = 0;
        $perms_desired = 0;
        $perms_irrelevant = 0;
        $perms_avoided = 0;
        $perms_dangerous = 0;

        $contains_sensitive = false;
        foreach ($this->sensitive_paths as $sensitive_path) {
            if (preg_match('#^' . $sensitive_path . '$#', $rel_path) != 0) {
                $contains_sensitive = true;
            }
        }

        $is_shell_script = false;
        if (!$is_directory) {
            foreach ($this->script_paths as $script_path) {
                if (preg_match('#^' . $script_path . '$#', $rel_path) != 0) {
                    $is_shell_script = true;
                }
            }
        }

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETGID;
        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETUID;

        if (($this->web_user === null) || ($file_owner == $this->web_user)) {
            // suEXEC style...

            $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;

            if ($is_directory) {
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            } else {
                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            }
        } else {
            // nobody style...

            if ($is_directory) {
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                }
            } else {
                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                }
            }
        }

        $found_issue = false;

        $new_file_perms = $file_perms;

        if ($this->minimum_level <= self::RESULT_TYPE_ERROR_MISSING) {
            // Extended attributes checks
            if (($perms_needed & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $extended_attribute_issues = [];
                $extended_attribute_commands = [];
                if (strpos($attr, 'a') !== false) {
                    $extended_attribute_issues[] = 'remove "a" append-only attribute';
                    $command = 'chattr -a ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (strpos($attr, 'i') !== false) {
                    $extended_attribute_issues[] = 'remove "i" immutable attribute';
                    $command = 'chattr -i ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (!empty($extended_attribute_issues)) {
                    $message = 'Error: extended attributes problem on ' . $path . ' (' . implode(', ', $extended_attribute_issues) . ')';
                    if ($this->live_output) {
                        echo $message . "\n";
                        foreach ($extended_attribute_commands as $command) {
                            echo $command . "\n";
                        }
                    }
                    $found_issue = true;
                    $found_any_issue = true;
                    $paths[$path] = true;
                    $commands = array_merge($commands, $extended_attribute_commands);
                }
            }
        }

        $check_types = [
            [self::RESULT_TYPE_ERROR_MISSING, $perms_needed, '+'],
            [self::RESULT_TYPE_SUGGESTION_MISSING, $perms_desired, '+'],
            [self::RESULT_TYPE_ERROR_EXCESSIVE, $perms_dangerous, '-'],
            [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $perms_avoided, '-'],
        ];
        foreach ($check_types as $check_type) {
            list($check_type_level, $bitmask, $operator) = $check_type;

            if ($this->minimum_level <= $check_type_level) {
                if ($operator == '+') {
                    $ok = ($file_perms & $bitmask) == $perms_needed; // Has all
                } else {
                    $ok = ($file_perms & $bitmask) == 0; // Has none
                }
                if (!$ok) {
                    if ($operator == '+') {
                        $perms_involved_octal = ($file_perms ^ $bitmask) & $bitmask; // What is missing
                    } else {
                        $perms_involved_octal = $file_perms & $bitmask; // What is excessive
                    }
                    list($message, $command) = $this->output_issue($path, $check_type_level, $perms_involved_octal);
                    $messages[] = $message;
                    if ($command !== null) {
                        $commands[] = $command;
                    }
                    $paths[$path] = true;
                    if ($this->live_output) {
                        echo $message . "\n";
                        if ($command !== null) {
                            echo $command . "\n";
                        }
                    }
                    $found_issue = true;
                    $found_any_issue = true;
                    $new_file_perms = $new_file_perms | $perms_needed;
                }
            }
        }

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        if ($this->live_commands) {
            foreach ($commands as $command) {
                if (substr($command, 0, 6) != 'chmod ') {
                    echo execute_nicely($command);
                }
            }
            if ($new_file_perms != $file_perms) {
                chmod($path, $new_file_perms);
            }
        }

        return [$messages, $commands];
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $result_type A RESULT_TYPE_* constant
     * @param  integer $perms_involved_octal The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue($path, $result_type, $perms_involved_octal)
    {
        $perms_involved_written = $this->convert_octal_to_written($perms_involved_octal);

        switch ($result_type) {
            case self::RESULT_TYPE_SUGGESTION_MISSING:
                $message = 'Suggestion: set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '+');
                break;

            case self::RESULT_TYPE_ERROR_MISSING:
                $message = 'Error: set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '+');
                break;

            case self::RESULT_TYPE_SUGGESTION_EXCESSIVE:
                $message = 'Suggestion: remove unnecessary permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '-');
                break;

            case self::RESULT_TYPE_ERROR_EXCESSIVE:
                $message = 'Error: remove dangerous permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '-');
                break;

            default:
                throw new Exception('Internal Error');
        }

        return [$message, $command];
    }

    /**
     * Generate a chmod command from differential octal permissions.
     *
     * @param  PATH $path The path the command is for
     * @param  integer $octal Permissions
     * @param  string $operator Change operator
     * @set - +
     * @return string Chmod command
     */
    protected function generate_chmod_command($path, $octal, $operator)
    {
        $owner_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
            $owner_perms[] = 's';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
            $owner_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
            $owner_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
            $owner_perms[] = 'w';
        }

        $group_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
            $group_perms[] = 's';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
            $group_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
            $group_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
            $group_perms[] = 'w';
        }

        $other_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
            $other_perms[] = 't';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
            $other_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
            $other_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
            $other_perms[] = 'w';
        }

        $chmod = '';
        foreach (['u' => $owner_perms, 'g' => $group_perms, 'o' => $other_perms] as $permission_class => $perms) {
            if (!empty($perms)) {
                if ($chmod != '') {
                    $chmod .= ',';
                }
                $chmod .= $permission_class . $operator . implode('', $perms);
            }
        }
        $command = 'chmod ' . $chmod . ' ' . escapeshellarg($path);

        return $command;
    }

    /**
     * Convert octal permissions to written ones.
     *
     * @param  integer $octal Permissions
     * @return string Written permissions
     */
    protected function convert_octal_to_written($octal)
    {
        $perms = [];

        if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
            $perms[] = 'sticky';
        }
        if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
            $perms[] = 'setgid';
        }
        if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
            $perms[] = 'setuid';
        }

        if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
            $perms[] = 'owner execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
            $perms[] = 'owner read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
            $perms[] = 'owner write';
        }

        if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
            $perms[] = 'group execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
            $perms[] = 'group read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
            $perms[] = 'group write';
        }

        if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
            $perms[] = 'other execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
            $perms[] = 'other read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
            $perms[] = 'other write';
        }

        return implode(', ', $perms);
    }
}

/**
 * Check/fix permissions on Windows.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScannerWindows extends CMSPermissionsScanner
{
    // Constants...

    const BITMASK_PERMISSIONS_READ = 1;
    const BITMASK_PERMISSIONS_WRITE = 2;
    const BITMASK_PERMISSIONS_EXECUTE = 4;

    // Run-time data...

    protected $key_users = [];
    protected $common_users = [];

    // Code...

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->set_web_username();

        $this->set_path_patterns();
    }

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username($username = null)
    {
        // Work out key users...

        $this->key_users = [];

        // Web server user
        if ($username === null) {
            if (is_cli()) {
                if ((strpos(__FILE__, 'htdocs') !== false) || (strpos(__FILE__, 'httpdocs') !== false)) {
                    $this->key_users[] = 'SYSTEM'; // The services user which Apache will use
                } else {
                    $this->key_users[] = 'IUSR';
                    $this->key_users[] = 'IIS_IUSRS'; // This is the usergroup, we'll use it also just to be safe
                }
            } else {
                $this->key_users[] = get_current_user(); // On Windows this returns the user PHP is running as, counter to documentation
            }
        } else {
            $this->key_users[] = $username;
        }

        // File owner
        $path = str_replace('/', DIRECTORY_SEPARATOR, __FILE__);
        if (class_exists('COM')) {
            $su = new COM('ADsSecurityUtility');
            $security_info = $su->GetSecurityDescriptor($path, 1, 1);
            $this->key_users[] = $security_info->owner;
        } else {
            $text = shell_exec('dir /a /q ' . escapeshellarg($path));
            $matches = [];
            if (preg_match('#\d (.*)\s+' . preg_quote(basename($path), '#') . '$#i', $text, $matches) != 0) {
                $this->key_users[] = $matches[1];
            } else {
                $this->key_users[] = 'Creator Owner'; // Fallback for when we do not know
            }
        }

        $this->key_users = array_unique($this->key_users);

        // Work out users to avoid...

        $this->common_users = [];

        $this->common_users[] = 'Everyone';
        $this->common_users[] = 'Users';
        $this->common_users[] = 'Local account';
        $this->common_users[] = 'Authenticated Users';
        $this->common_users[] = 'ANONYMOUS LOGON';
        $this->common_users[] = 'Guest';
        $this->common_users[] = 'Guests';
        $this->common_users[] = 'CONSOLE LOGON';
        $this->common_users[] = 'DIALUP';
        $this->common_users[] = 'NETWORK';
        $this->common_users[] = 'INTERACTIVE';
        $this->common_users[] = 'Domain Users';
        $this->common_users[] = 'Domain Guests';
        $this->common_users[] = 'Domain Computers';
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory($path, $rel_path = '', $attr = null, $top_level = true, &$paths = [], &$found_any_issue = false)
    {
        $messages = [];
        $commands = [];

        $_messages = $this->process_node($path, $rel_path, true, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, '', false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }


    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  boolean $is_directory Whether this is a directory
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node($path, $rel_path, $is_directory, &$paths = [], &$found_any_issue = false)
    {
        $path = str_replace('/', DIRECTORY_SEPARATOR, $path);

        $messages = [];
        $commands = [];

        $acl = $this->find_acl($path);

        if (empty($acl)) {
            return [[], []]; // Likely as parent directory is missing perms, which will be flagged
        }

        $perms_needed_key_users = 0;
        $perms_desired_key_users = 0;
        $perms_irrelevant_key_users = 0;
        $perms_avoided_key_users = 0;
        $perms_dangerous_key_users = 0;

        $perms_needed_common_users = 0;
        $perms_desired_common_users = 0;
        $perms_irrelevant_common_users = 0;
        $perms_avoided_common_users = 0;
        $perms_dangerous_common_users = 0;

        $contains_sensitive = false;
        foreach ($this->sensitive_paths as $sensitive_path) {
            if (preg_match('#^' . $sensitive_path . '$#', $rel_path) != 0) {
                $contains_sensitive = true;
            }
        }

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        // Note the Windows algorithm is very different from Windows in some ways
        //  - We are working against ACLs, not permission masks
        //  - We do not need to worry about chmodding 'others' to have write access and/or relaying through FTP
        //   - Because we can set permissions both for the executing web user and the owner user i.e. it's irrelevant if they are different (the non-suEXEC case)
        //   - ACLs are inherited by default for any new files or folders
        // On how we treat inheritance:
        //  - Note that Windows copies ACLs down the hierarchy for performance, as a caching mechanism.
        //  - Our approach is to never set permissions via inheriting for simplicity and speed.
        //  - However, we respect positive permissions that have been granted by inheriting and don't re-set them.
        //  - If the webmaster wants to use inheriting manually, that's great. We ourselves can't assume we 'own' the whole base directory.
        // On permission complexity:
        //  - Windows has complex overlapping permissions (simple rights, specific rights, generic rights)
        //  - We use the 'simple rights' when setting
        //  - When checking we accept other rights as synonyms

        if ($is_directory) {
            $perms_needed_key_users |= self::BITMASK_PERMISSIONS_EXECUTE;
        } else {
            $perms_irrelevant_key_users |= self::BITMASK_PERMISSIONS_EXECUTE; // Doesn't even exist
        }
        $perms_needed_key_users |= self::BITMASK_PERMISSIONS_READ;
        if ($on_chmod_list) {
            $perms_needed_key_users |= self::BITMASK_PERMISSIONS_WRITE;
        } else {
            $perms_desired_key_users |= self::BITMASK_PERMISSIONS_WRITE;
        }

        if ($is_directory) {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_EXECUTE;
        } else {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_EXECUTE; // Doesn't even exist
        }
        if ($contains_sensitive) {
            $perms_dangerous_common_users |= self::BITMASK_PERMISSIONS_READ;
        } else {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_READ;
        }
        $perms_dangerous_common_users |= self::BITMASK_PERMISSIONS_WRITE;

        $found_issue = false;

        $check_types = [
            [self::RESULT_TYPE_ERROR_MISSING, $this->key_users, $perms_needed_key_users, '+'],
            [self::RESULT_TYPE_SUGGESTION_MISSING, $this->key_users, $perms_desired_key_users, '+'],
            [self::RESULT_TYPE_ERROR_EXCESSIVE, $this->key_users, $perms_dangerous_key_users, '-'],
            [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $this->key_users, $perms_avoided_key_users, '-'],
            [self::RESULT_TYPE_ERROR_MISSING, $this->common_users, $perms_needed_common_users, '+'],
            [self::RESULT_TYPE_SUGGESTION_MISSING, $this->common_users, $perms_desired_common_users, '+'],
            [self::RESULT_TYPE_ERROR_EXCESSIVE, $this->common_users, $perms_dangerous_common_users, '-'],
            [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $this->common_users, $perms_avoided_common_users, '-'],
        ];
        foreach ($check_types as $check_type) {
            list($check_type_level, $users, $perms, $operator) = $check_type;

            if ($this->minimum_level <= $check_type_level) {
                foreach ($users as $sid) {
                    if ($operator == '+') {
                        list($perms_involved, $perms_involved_to_remove) = $this->find_missing_file_perms($sid, $acl, $perms);

                        // Special case of having to get rid of particularly troublesome overrides
                        if (!empty($perms_involved_to_remove)) {
                            list($message, $command) = $this->output_issue($path, self::RESULT_TYPE_ERROR_EXCESSIVE, $sid, $perms_involved_to_remove); // TODO: This is wrong, it would just do a /deny rather than revoking a deny
                            $messages[] = $message;
                            if ($command !== null) {
                                $commands[] = $command;
                            }
                            $paths[$path] = true;
                            if ($this->live_output) {
                                echo $message . "\n";
                                if ($command !== null) {
                                    echo $command . "\n";
                                }
                            }
                            $found_issue = true;
                            $found_any_issue = true;
                        }
                    } else {
                        $perms_involved = $this->find_excessive_file_perms($sid, $acl, $perms);
                    }

                    if (!empty($perms_involved)) {
                        list($message, $command) = $this->output_issue($path, $check_type_level, $sid, $perms_involved);
                        $messages[] = $message;
                        if ($command !== null) {
                            $commands[] = $command;
                        }
                        $paths[$path] = true;
                        if ($this->live_output) {
                            echo $message . "\n";
                            if ($command !== null) {
                                echo $command . "\n";
                            }
                        }
                        $found_issue = true;
                        $found_any_issue = true;
                    }
                }
            }
        }

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        if ($this->live_commands) {
            foreach ($commands as $command) {
                echo execute_nicely($command);
            }
        }

        return [$messages, $commands];
    }

    /**
     * Find the access control list for a path.
     *
     * @param  PATH $path The path
     * @return array ACL
     */
    public function find_acl($path)
    {
        $acl = [];

        $result = shell_exec('icacls ' . escapeshellarg($path));
        $lines = explode("\n", $result);
        foreach ($lines as $line) {
            if (substr($line, 0, strlen($path) + 1) == $path . ' ') {
                $line = substr($line, strlen($path));
            }

            $matches = [];
            if (preg_match('#^\s*(.*):(\([A-Z]+\)+)#', $matches) != 0) {
                $sid = $matches[1];
                $permissions_negative = [];
                $permissions_positive = [];
                $permissions_negative_inherited = [];
                $permissions_positive_inherited = [];
                $inherits_from_parent = false;
                $operator = '+';

                $statements = $matches[2];
                $matches_2 = [];
                $num_matches_2 = preg_match_all('#\(([A-Z]+)\)#', $statements, $matches_2);
                for ($i = 0; $i < $num_matches_2; $i++) {
                    $statement = $statements[1][$i];
                    if ($statement == 'DENY') {
                        $operator = '-';
                    } elseif ($statement == 'I') {
                        $inherits_from_parent = true;
                    } elseif (!in_array($statement, ['OI', 'CI', 'IO', 'NP'])) {
                        if (($operator == '-') && (!$inherits_from_parent)) {
                            $permissions_negative[$statement] = true;
                        } elseif (($operator == '+') && (!$inherits_from_parent)) {
                            $permissions_positive[$statement] = true;
                        } elseif (($operator == '-') && ($inherits_from_parent)) {
                            $permissions_negative_inherited[$statement] = true;
                        } else {
                            $permissions_positive_inherited[$statement] = true;
                        }
                    }
                }

                if (array_key_exists($sid, $acl)) {
                    $acl[$sid][0] = array_merge($acl[$sid][0], $permissions_negative);
                    $acl[$sid][1] = array_merge($acl[$sid][1], $permissions_positive);
                    $acl[$sid][2] = array_merge($acl[$sid][2], $permissions_negative_inherited);
                    $acl[$sid][3] = array_merge($acl[$sid][3], $permissions_positive_inherited);
                    if ($inherits_from_parent) {
                        $acl[$sid][1] = true;
                    }
                } else {
                    $acl[$sid] = [$permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited, $inherits_from_parent/*if at least one rule is inherited from a parent*/];
                }
            }
        }

        return $acl;
    }

    /**
     * Find missing file permissions.
     *
     * @param  string $sid The user to check for
     * @param  array $acl The ACL for the file
     * @param  string $perms A bitmask of permissions that could be missing
     * @return array A pair: A list of missing permissions (or one's currently negated that will be flipped to be positive), A list of negative permissions to take out
     */
    protected function find_missing_file_perms($sid, $acl, $perms)
    {
        if (array_key_exists($sid, $acl)) {
            list($permissions_negative, $permissions_positive, $permissions_negative_inherited, ) = $acl[$sid];
        } else {
            $permissions_negative = [];
            $permissions_positive = [];
            $permissions_negative_inherited = [];
        }
        $_permissions_negative = array_merge($permissions_negative, $permissions_negative_inherited);

        $missing = [];

        // There are many ways to approach this, due to the complexity of having multiple levels of both positive and negative permissions, and multiple ways of defining the same access.
        //  We'll avoid being clever by undoing negative permissions individually. If we see negativity, we'll just hammer on the maximum positivity that we can.
        //  Otherwise our algorithm would be incredibly complicated.

        if (($perms & self::BITMASK_PERMISSIONS_READ) != 0) {
            if (!$this->has_read_access($sid, $acl)) {
                $complete_hammer = ['GR', 'R', 'RD', 'RA', 'REA', 'RC'];
                if (!empty(array_intersect(array_keys($_permissions_negative), $complete_hammer))) {
                    $missing = array_merge($missing, array_diff($complete_hammer, array_diff(array_keys($permissions_positive), array_keys($permissions_negative)))); // We have negatives, so we hammer in all positives
                } else {
                    $missing[] = 'R'; // Simple
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            if (!$this->has_write_access($sid, $acl)) {
                $complete_hammer = ['GW', 'W', 'WD', 'WA', 'WEA', 'AD', 'D', 'DC'];
                if (!empty(array_intersect(array_keys($_permissions_negative), $complete_hammer))) {
                    $missing = array_merge($missing, array_diff($complete_hammer, array_diff(array_keys($permissions_positive), array_keys($permissions_negative)))); // We have negatives, so we hammer in all positives
                } else {
                    $missing[] = 'W'; // Simple
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            if (!$this->has_execute_access($sid, $acl)) {
                $complete_hammer = ['GE', 'RX', 'X'];
                if (!empty(array_intersect(array_keys($_permissions_negative), $complete_hammer))) {
                    $missing = array_merge($missing, array_diff($complete_hammer, array_diff(array_keys($permissions_positive), array_keys($permissions_negative)))); // We have negatives, so we hammer in all positives
                } else {
                    $missing[] = 'X'; // Simple
                }
            }
        }

        // We sometimes can't handle these with the hammer because they cross categories
        if (isset($_permissions_negative['A'])) {
            if ((($perms & self::BITMASK_PERMISSIONS_READ) != 0) && (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) && (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0)) {
                $missing[] = 'A';
            } else {
                $negative_remove[] = 'A';
            }
        }
        if (isset($_permissions_negative['M'])) {
            if ((($perms & self::BITMASK_PERMISSIONS_READ) != 0) && (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) && (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0)) {
                $missing[] = 'M';
            } else {
                $negative_remove[] = 'M';
            }
        }

        return [$missing, $negative_remove];
    }

    /**
     * Find excessive file permissions.
     *
     * @param  string $sid The user to check for
     * @param  array $acl The ACL for the file
     * @param  string $perms A bitmask of permissions that would exceesive
     * @return array A list of excessive permissions
     */
    protected function find_excessive_file_perms($sid, $acl, $perms)
    {
        $excessive = [];

        if (($perms & self::BITMASK_PERMISSIONS_READ) != 0) {
            if ($this->has_read_access($sid, $acl, $permissions_involved, true)) {
                $excessive = array_merge($excessive, $permissions_involved);
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            if ($this->has_write_access($sid, $acl, $permissions_involved, true)) {
                $excessive = array_merge($excessive, $permissions_involved);
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            if ($this->has_execute_access($sid, $acl, $permissions_involved, true)) {
                $excessive = array_merge($excessive, $permissions_involved);
            }
        }

        return $excessive;
    }

    /**
     * Find if read access is set for the given ACL for the given user.
     *
     * @param  string $sid The user to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $partial_access_check Whether to check for partial access
     * @return boolean Whether it is
     */
    protected function has_read_access($sid, $acl, &$permissions_involved = [], $partial_access_check = false)
    {
        if (!array_key_exists($sid, $acl)) {
            return false;
        }

        list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

        $permissions = [];
        if ($this->_has_partial_read_setting($permissions_negative, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_read_setting($permissions_positive, $permissions) : $this->_has_complete_read_setting($permissions_positive, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        $permissions = [];
        if ($this->_has_partial_read_setting($permissions_negative_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_read_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_read_setting($permissions_positive_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        return false;
    }

    /**
     * Find if partial read access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_read_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GR', 'R', 'RD', 'RA', 'REA', 'RC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete read access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_read_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GR', 'R', 'RD', 'RA', 'REA', 'RC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['A'])) || // Everything
            (isset($permissions['M'])) || // Everythingish
            (isset($permissions['GR'])) || // Generic
            (isset($permissions['R'])) || // Simple
            (isset($permissions['RD'])) && (isset($permissions['RA'])) && (isset($permissions['REA'])) && (isset($permissions['RC'])) // All specific needed (read data/list directory, read [extended] attributes, read control)
        );
    }

    /**
     * Find if write access is set for the given ACL for the given user.
     *
     * @param  string $sid The user to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $partial_access_check Whether to check for partial access
     * @return boolean Whether it is
     */
    protected function has_write_access($sid, $acl, &$permissions_involved = [], $partial_access_check = false)
    {
        if (!array_key_exists($sid, $acl)) {
            return false;
        }

        list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

        $permissions = [];
        if ($this->_has_partial_write_setting($permissions_negative, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_write_setting($permissions_positive, $permissions) : $this->_has_complete_write_setting($permissions_positive, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        $permissions = [];
        if ($this->_has_partial_write_setting($permissions_negative_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_write_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_write_setting($permissions_positive_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        return false;
    }

    /**
     * Find if partial write access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_write_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GW', 'W', 'WD', 'WA', 'WEA', 'AD', 'D', 'DC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete write access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_write_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GW', 'W', 'WD', 'WA', 'WEA', 'AD', 'D', 'DC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['A'])) || // Everything
            (isset($permissions['M'])) || // Everythingish
            (isset($permissions['GW'])) || // Generic
            (isset($permissions['W'])) || // Simple
            (isset($permissions['WD'])) && (isset($permissions['WA'])) && (isset($permissions['WEA'])) && (isset($permissions['AD'])) && (isset($permissions['D'])) && (isset($permissions['DC'])) // All specific needed (write data/add file, write [extended] attributes, delete, delete child)
        );
    }

    /**
     * Find if execute access is set for the given ACL for the given user.
     *
     * @param  string $sid The user to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $partial_access_check Whether to check for partial access
     * @return boolean Whether it is
     */
    protected function has_execute_access($sid, $acl, &$permissions_involved = [], $partial_access_check = false)
    {
        if (!array_key_exists($sid, $acl)) {
            return false;
        }

        list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

        $permissions = [];
        if ($this->_has_partial_execute_setting($permissions_negative, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_execute_setting($permissions_positive, $permissions) : $this->_has_complete_execute_setting($permissions_positive, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        $permissions = [];
        if ($this->_has_partial_execute_setting($permissions_negative_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return false;
        }

        $permissions = [];
        if ($partial_access_check ? $this->_has_partial_execute_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_execute_setting($permissions_positive_inherited, $permissions)) {
            $permissions_involved = $permissions;
            return true;
        }

        return false;
    }

    /**
     * Find if partial execute access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_execute_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GE', 'RX', 'X'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete execute access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_execute_setting($permissions, &$permissions_involved)
    {
        $possibilities = ['A', 'M', 'GE', 'RX', 'X'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['A'])) || // Everything
            (isset($permissions['M'])) || // Everythingish
            (isset($permissions['GE'])) || // Generic
            (isset($permissions['RX'])) || // Simple
            (isset($permissions['X'])) // All specific needed (execute/traverse)
        );
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $result_type A RESULT_TYPE_* constant
     * @param  string $sid The Sid the permission is for
     * @param  array $perms_involved The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue($path, $result_type, $sid, $perms_involved)
    {
        $perms_involved = $this->convert_permissions_to_written($perms_involved);

        switch ($result_type) {
            case self::RESULT_TYPE_SUGGESTION_MISSING:
                $message = 'Suggestion: set additional permissions for ' . $path . ' (' . $perms_involved . ' on ' . $sid . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, '+');
                break;

            case self::RESULT_TYPE_ERROR_MISSING:
                $message = 'Error: set additional permissions for ' . $path . ' (' . $perms_involved . ' on ' . $sid . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, '+');
                break;

            case self::RESULT_TYPE_SUGGESTION_EXCESSIVE:
                $message = 'Suggestion: remove unnecessary permissions for ' . $path . ' (' . $perms_involved . ' on ' . $sid . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, '-');
                break;

            case self::RESULT_TYPE_ERROR_EXCESSIVE:
                $message = 'Error: remove dangerous permissions for ' . $path . ' (' . $perms_involved . ' on ' . $sid . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, '-');
                break;

            default:
                throw new Exception('Internal Error');
        }

        return [$message, $command];
    }

    /**
     * Convert permissions to written ones.
     *
     * @param  integer $permissions Permissions
     * @return string Written permissions
     */
    protected function convert_permissions_to_written($permissions)
    {
        $perms = [];

        TODO

        if (($bitmask & self::BITMASK_PERMISSIONS_READ) != 0) {
            $perms[] = 'read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            $perms[] = 'write';
        }
        if (($octal & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            $perms[] = 'execute';
        }

        return implode(', ', $perms);
    }

    /**
     * Generate a chmod command from differential permissions.
     *
     * @param  PATH $path The path the command is for
     * @param  string $sid The user to apply to
     * @param  array $perms_involved Permissions to set
     * @param  string $operator Change operator
     * @set - +
     * @param  ?boolean $inherits_from_parent Whether inherits permissions (null: do not change)
     * @return string Chmod command
     */
    protected function generate_chmod_command($path, $sid, $perms_involved, $operator, $inherits_from_parent = null)
    {
        // https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls

        $cmd = ($operator == '+') ? '/grant' : '/deny';

        $command = 'icacls ' . escapeshellarg($path) . ' /' . $cmd . ' ' . escapeshellarg($sid) . ':(' . implode(',', $perms_involved) . ')';
        if ($inherits_from_parent !== null) {
            $command .= ' /inheritancelevel:' . ($inherits_from_parent ? 'e' : 'r');
        }

        return $command;
    }
}
