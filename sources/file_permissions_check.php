<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2020

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*EXTRA FUNCTIONS: shell_exec|escapeshellarg|posix_.*|fileowner*/

// Everything in this file can run without Composr having bootstrapped, although it will run better if it has

/**
 * Execute a shell command, returning full output, with a guaranteed line break if not blank.
 *
 * @param  string $command Command to run
 * @return string Command output
 */
function execute_nicely($command)
{
    $ret = @trim(shell_exec($command . ' 2>&1'));
    if ($ret != '') {
        $ret .= "\n";
    }
    return $ret;
}

/**
 * Scan permissions.
 *
 * @param  boolean $live_output Whether to produce live output of issues
 * @param  boolean $live_commands Whether to run commands live
 * @param  ?string $web_username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
 * @param  ?boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP (null: default / auto-detect if possible)
 * @param  integer $minimum_level Minimum RESULT_TYPE_* level
 * @return array A tuple: Messages to show, Commands to run, Paths with issues, Whether any issues were found
 */
function scan_permissions($live_output = false, $live_commands = false, $web_username = null, $has_ftp_loopback_for_write = null, $minimum_level = 3)
{
    $sensitive_paths = [
        '_config.php',
        'exports/backups/[^/]*\.tar(\.gz)?',
        'exports/file_backups/_config.php\.\d+',
    ];

    $chmod_array = get_chmod_array('**', true);
    $chmod_paths = [];
    foreach ($chmod_array as $chmod) {
        $chmod = preg_quote($chmod, '#');
        $chmod = str_replace('\*\*', '[^/\.]*', $chmod);
        $chmod = str_replace('\*', '[^/]*', $chmod);
        $chmod_paths[] = $chmod;
    }

    if ($has_ftp_loopback_for_write === null) {
        $has_ftp_loopback_for_write = ((function_exists('ftp_ssl_connect')) || (function_exists('ftp_connect'))) && ((!function_exists('get_value')) || (get_value('uses_ftp') !== '0'));
    }

    $ob = new CMSPermissionsScanner();

    $ob->set_path_patterns($sensitive_paths, $chmod_paths);

    $ob->set_live_output($live_output);
    $ob->set_live_commands($live_commands);

    if ($web_username !== null) {
        $ob->set_web_username($web_username);
    }

    $ob->set_minimum_level($minimum_level);

    $ob->set_has_ftp_loopback_for_write($has_ftp_loopback_for_write);

    $subdir = '';

    if (function_exists('get_file_base')) {
        $stub = get_file_base() . (($subdir == '') ? '' : '/');
    } else {
        $stub = dirname(__DIR__) . (($subdir == '') ? '' : '/');
    }

    $found_any_issue = false;

    $messages = [];
    $commands = [];
    $_paths = [];

    list($_messages, $_commands) = $ob->process_directory($stub . $subdir, $subdir, null, true, $_paths, $found_any_issue);
    $messages = array_merge($messages, $_messages);
    $commands = array_merge($commands, $_commands);

    if ((function_exists('get_file_base')) && (get_file_base() != get_custom_file_base())) {
        list($_messages, $_commands) = $ob->process_directory(get_custom_file_base() . (($subdir == '') ? '' : '/') . $subdir, $subdir, null, true, $_paths, $found_any_issue);
        $messages = array_merge($messages, $_messages);
        $commands = array_merge($commands, $_commands);
    }

    $paths = array_keys($_paths);

    return [$messages, $commands, $paths, $found_any_issue];
}

/**
 * Get the list of files that need CHmodding for write access.
 *
 * @param  string $lang Language to use, may be whatever wildcard syntax the caller supports
 * @param  boolean $runtime Whether to include wildcards represented runtime-created chmoddable files
 * @return array The list of files
 */
function get_chmod_array($lang = '*', $runtime = false)
{
    $extra_files = [];

    if (function_exists('find_all_hooks')) {
        $hooks = find_all_hooks('systems', 'addon_registry');
        $hook_keys = array_keys($hooks);
        foreach ($hook_keys as $hook) {
            /*require_code('hooks/systems/addon_registry/' . filter_naughty_harsh($hook));
            $object = object_factory('Hook_addon_registry_' . filter_naughty_harsh($hook));
            $extra_files = array_merge($extra_files, $object->get_chmod_array());*/

            // Save memory compared to above commented code...

            $path = get_file_base() . '/sources_custom/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            if (!file_exists($path)) {
                $path = get_file_base() . '/sources/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            }
            $matches = [];
            if (preg_match('#function get_chmod_array\(\)\s*\{([^\}]*)\}#', cms_file_get_contents_safe($path, FILE_READ_LOCK), $matches) != 0) {
                $extra_files = array_merge($extra_files, cms_eval($matches[1], $path));
            }
        }
    }

    if ($runtime) {
        $extra_files = array_merge($extra_files, [
            'adminzone/pages/comcode_custom/*/*.txt',
            'adminzone/pages/html_custom/*/*.htm',
            'cms/pages/comcode_custom/*/*.txt',
            'cms/pages/html_custom/*/*.htm',
            'data_custom/modules/admin_backup/*',
            'data_custom/modules/admin_stats/*',
            'data_custom/modules/chat/*',
            'data_custom/modules/web_notifications/*',
            'data_custom/sitemaps/*',
            'data_custom/spelling/personal_dicts/*',
            'data_custom/xml_config/*.xml',
            'exports/*/*',
            'forum/pages/comcode_custom/*/*.txt',
            'forum/pages/html_custom/*/*.htm',
            'imports/*/*',
            'lang_custom/*/*.ini',
            'pages/comcode_custom/*/*.txt',
            'pages/html_custom/*/*.htm',
            'site/pages/comcode_custom/*/*.txt',
            'site/pages/html_custom/*/*.htm',
            'text_custom/*.txt',
            'text_custom/*/*.txt',
            'themes/*/css_custom/*',
            'themes/*/images_custom/*',
            'themes/*/javascript_custom/*',
            'themes/*/templates_custom/*',
            'themes/*/text_custom/*',
            'themes/*/xml_custom/*',
            'uploads/attachments/*',
            'uploads/attachments_thumbs/*',
            'uploads/auto_thumbs/*',
            'uploads/banners/*',
            'uploads/captcha/*',
            'uploads/catalogues/*',
            'uploads/cns_avatars/*',
            'uploads/cns_cpf_upload/*',
            'uploads/cns_photos/*',
            'uploads/cns_photos_thumbs/*',
            'uploads/downloads/*',
            'uploads/filedump/*',
            'uploads/galleries/*',
            'uploads/galleries_thumbs/*',
            'uploads/personal_sound_effects/*',
            'uploads/repimages/*',
            'uploads/watermarks/*',
            'uploads/website_specific/*',
        ]);
    }

    return array_merge(
        $extra_files,
        [
            'adminzone/pages/comcode_custom/' . $lang,
            'adminzone/pages/html_custom/' . $lang,
            'caches/static',
            'caches/lang',
            'caches/lang/' . $lang,
            'caches/persistent',
            'caches/self_learning',
            'caches/http',
            'cms/pages/comcode_custom/' . $lang,
            'cms/pages/html_custom/' . $lang,
            'data_custom/errorlog.php',
            'data_custom/firewall_rules.txt',
            'data_custom/modules/admin_backup',
            'data_custom/modules/admin_stats',
            'data_custom/modules/chat',
            'data_custom/modules/web_notifications',
            'data_custom/sitemaps',
            'data_custom/spelling/personal_dicts',
            'data_custom/xml_config',
            'data_custom',
            'exports/addons',
            'exports/backups',
            'exports/file_backups',
            'forum/pages/comcode_custom/' . $lang,
            'forum/pages/html_custom/' . $lang,
            'imports/addons',
            'lang_custom',
            'lang_custom/' . $lang,
            'pages/comcode_custom/' . $lang,
            'pages/html_custom/' . $lang,
            'temp',
            'site/pages/comcode_custom/' . $lang,
            'site/pages/html_custom/' . $lang,
            'text_custom',
            'text_custom/' . $lang,
            'themes',
            'themes/admin/css_custom',
            'themes/admin/images_custom',
            'themes/admin/javascript_custom',
            'themes/admin/templates_cached/' . $lang,
            'themes/admin/templates_custom',
            'themes/admin/text_custom',
            'themes/admin/xml_custom',
            'themes/default/css_custom',
            'themes/default/images_custom',
            'themes/default/javascript_custom',
            'themes/default/templates_cached/' . $lang,
            'themes/default/templates_custom',
            'themes/default/text_custom',
            'themes/default/theme.ini',
            'themes/default/xml_custom',
            'themes/map.ini',
            'uploads/attachments',
            'uploads/attachments_thumbs',
            'uploads/auto_thumbs',
            'uploads/banners',
            'uploads/captcha',
            'uploads/catalogues',
            'uploads/cns_avatars',
            'uploads/cns_cpf_upload',
            'uploads/cns_photos',
            'uploads/cns_photos_thumbs',
            'uploads/downloads',
            'uploads/filedump',
            'uploads/galleries',
            'uploads/galleries_thumbs',
            'uploads/incoming',
            'uploads/personal_sound_effects',
            'uploads/repimages',
            'uploads/watermarks',
            'uploads/website_specific',
            '_config.php',
        ]
    );
}

/**
 * Dispatcher object.
 * Used to create a closure for a notification dispatch, so we can then tell that to send in the background (register_shutdown_function), for performance reasons.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScanner
{
    // Constants...

    const BITMASK_PERMISSIONS_STICKY = 01000;
    const BITMASK_PERMISSIONS_SETGID = 02000;
    const BITMASK_PERMISSIONS_SETUID = 04000;

    const BITMASK_PERMISSIONS_OWNER_EXECUTE = 00100;
    const BITMASK_PERMISSIONS_OWNER_WRITE = 00200;
    const BITMASK_PERMISSIONS_OWNER_READ = 00400;

    const BITMASK_PERMISSIONS_GROUP_EXECUTE = 00010;
    const BITMASK_PERMISSIONS_GROUP_WRITE = 00020;
    const BITMASK_PERMISSIONS_GROUP_READ = 00040;

    const BITMASK_PERMISSIONS_OTHER_EXECUTE = 00001;
    const BITMASK_PERMISSIONS_OTHER_WRITE = 00002;
    const BITMASK_PERMISSIONS_OTHER_READ = 00004;

    const RESULT_TYPE_SUCCESS = 0;
    const RESULT_TYPE_SUGGESTION_EXCESSIVE = 1;
    const RESULT_TYPE_SUGGESTION_MISSING = 2;
    const RESULT_TYPE_ERROR_EXCESSIVE = 3;
    const RESULT_TYPE_ERROR_MISSING = 4;

    // Options...

    protected $web_user;
    protected $web_user_group;

    protected $sensitive_paths = [];
    protected $chmod_paths = [];
    protected $script_paths = null;

    protected $has_ftp_loopback_for_write = false;

    protected $minimum_level = 1;
    protected $live_output = false;
    protected $live_commands = false;

    // Run-time data...

    protected $has_lsattr;

    // Code...

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->set_web_username();

        $this->set_path_patterns();

        $this->has_lsattr = false;
        if ((!$this->is_windows()) && ($this->php_function_allowed('shell_exec')) && ($this->php_function_allowed('escapeshellarg'))) {
            if (preg_match('#lsattr \d#', shell_exec('lsattr -V 2>&1')) != 0) {
                $this->has_lsattr = true;
            }
        }
    }

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username($username = null)
    {
        $this->web_user = null;
        $this->web_user_group = 'IIS_IUSRS'; // Only used on Windows

        if ($this->is_windows()) {
            if ($username === null) {
                if (($this->php_function_allowed('posix_getpwnam')) && (@posix_getpwnam('IUSR') !== false)) {
                    $this->web_user = 'IUSR';
                } else {
                    if (($this->php_function_allowed('posix_getuid')) && ($this->php_function_allowed('posix_getpwuid'))) {
                        $details = @posix_getpwnam(posix_getpwuid());
                        if ($details !== false) {
                            $this->web_user = $details['name'];
                            if ($this->php_function_allowed('posix_getgrgid')) {
                                $details_group = posix_getgrgid($details['gid']);
                                $this->web_user_group = $details_group['name'];
                            }
                        } else {
                            $this->web_user = 'IUSR'; // Fallback, we need something for icacls
                        }
                    } else {
                        $this->web_user = 'IUSR'; // Fallback, we need something for icacls
                    }
                }
            } else {
                $this->web_user = $username;
            }
        } else {
            if ($username === null) {
                if ($this->php_function_allowed('posix_getuid')) {
                    $this->web_user = posix_getuid();
                }
            } else {
                if (is_numeric($username)) {
                    $this->web_user = intval($username);
                } else {
                    if ($this->php_function_allowed('posix_getpwnam')) {
                        $details = @posix_getpwnam($username);
                        if ($details === false) {
                            throw new Exception('Cannot find user, ' . $username);
                        }
                        $this->web_user = $details['uid'];
                    } else {
                        throw new Exception('Posix extension is needed if passing a username');
                    }
                }
            }
        }
    }

    /**
     * Set paths patterns.
     *
     * @param  array $sensitive_paths A list of sensitive path regexps that really should have minimal read permission
     * @param  array $chmod_paths A list of path regexps that should be chmodded as writable for non-suEXEC-style servers
     * @param  ?array $script_paths A list of path regexps for scripts that need Unix execute permission (null: .sh files)
     */
    public function set_path_patterns($sensitive_paths = [], $chmod_paths = [], $script_paths = null)
    {
        $this->sensitive_paths = $sensitive_paths;
        $this->chmod_paths = $chmod_paths;
        if ($script_paths === null) {
            $this->script_paths = [
                '.*\.sh',
            ];
        } else {
            $this->script_paths = $script_paths;
        }
    }

    /**
     * Set whether we can 'get' write access via some kind of loopback.
     *
     * @param  boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP
     */
    public function set_has_ftp_loopback_for_write($has_ftp_loopback_for_write)
    {
        $this->has_ftp_loopback_for_write = $has_ftp_loopback_for_write;
    }

    /**
     * Set minimum result level.
     *
     * @param  integer $minimum_level Minimum RESULT_TYPE_* level
     */
    public function set_minimum_level($minimum_level)
    {
        $this->minimum_level = $minimum_level;
    }

    /**
     * Set whether to show live output, rather than just returning at the end.
     *
     * @param  boolean $live_output Whether to output live
     */
    public function set_live_output($live_output)
    {
        $this->live_output = $live_output;
    }

    /**
     * Set whether to run live commands, rather than just returning at the end.
     *
     * @param  boolean $live_commands Whether to run commands
     */
    public function set_live_commands($live_commands)
    {
        $this->live_commands = $live_commands;
    }

    /**
     * Find whether a particular PHP function is allowed.
     *
     * @param  string $function Function name
     * @return boolean Whether it is
     */
    protected function php_function_allowed($function)
    {
        if (!function_exists($function)) {
            return false;
        }
        $disabled_functions = @strtolower(ini_get('disable_functions') . ',' . ini_get('suhosin.executor.func.blacklist') . ',' . ini_get('suhosin.executor.include.blacklist') . ',' . ini_get('suhosin.executor.eval.blacklist'));
        return (@preg_match('#(\s|,|^)' . preg_quote($function, '#') . '(\s|$|,)#', $disabled_functions) == 0);
    }

    /**
     * Find the extended attributes for a path.
     *
     * @param  PATH $path The absolute path
     * @param  boolean $directory_contents Whether this is a directory to get the contents of
     * @return array A map of file paths to extended attribute strings
     */
    protected function process_lsattr($path, $directory_contents = false)
    {
        $lsattr = [];
        if ($this->has_lsattr) {
            $cmd = 'lsattr';
            if (!$directory_contents) {
                $cmd .= ' -d';
            }
            $cmd .= ' ' . escapeshellarg($path);
            $_lsattr = @strval(shell_exec($cmd . ' 2>&1'));

            $matches = [];
            $num_matches = preg_match_all('#^([A-Za-z\-])\t(.*)$#m', $_lsattr, $matches);
            for ($i = 0; $i < $num_matches; $i++) {
                $lsattr[$matches[2][$i]] = $matches[1][$i];
            }
        }
        return $lsattr;
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory($path, $rel_path = '', $attr = null, $top_level = true, &$paths = [], &$found_any_issue = false)
    {
        $messages = [];
        $commands = [];

        if ($top_level) {
            if ((!$this->is_windows()) && ($this->php_function_allowed('shell_exec'))) {
                if (strpos(shell_exec('sestatus'), 'enabled') !== false) {
                    if (strpos(shell_exec('ps -eZ'), 'httpd_t') !== false) {
                        $found_selinux_rule = false;

                        $path_up = $path;
                        do {
                            $cmd = 'ls -Zld ' . escapeshellarg($path_up);
                            if (strpos(shell_exec($cmd), 'httpd_sys_rw_content_t') !== false) {
                                $found_selinux_rule = true;
                            }

                            $_path_up = $path_up;
                            $path_up = dirname($path_up);
                        } while (($path_up != '.') && (!empty($path_up)) && ($path_up != $_path_up));

                        if (!$found_selinux_rule) {
                            $message = 'Error: selinux is running and httpd_sys_rw_content_t is not set in the directory tree of ' . $path;
                            $messages[] = $message;
                            if ($this->live_output) {
                                echo $message . "\n";
                            }
                        }
                    }
                }
            }
        }

        if ($attr === null) {
            $lsattr = $this->process_lsattr($path);
            $attr = isset($lsattr[$path]) ? $lsattr[$path] : '';
        }

        $_messages = $this->process_node($path, $rel_path, true, $attr, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $lsattr = $this->process_lsattr($path, true);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, isset($lsattr[$_path]) ? $lsattr[$_path] : '', false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, isset($lsattr[$_path]) ? $lsattr[$_path] : '', $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }

    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  boolean $is_directory Whether this is a directory
     * @param  string $attr A string of extended attributes from lsattr
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node($path, $rel_path, $is_directory, $attr, &$paths = [], &$found_any_issue = false)
    {
        // (We will assume the file owner is not something we want to change, just the permissions to work best with that owner)

        $messages = [];
        $commands = [];

        $file_owner = @fileowner($path);
        $file_perms = @fileperms($path);

        if (($file_owner === false) || ($file_perms === false)) {
            return [[], []]; // Likely as parent directory is missing perms, which will be flagged
        }

        $perms_needed = 0;
        $perms_desired = 0;
        $perms_irrelevant = 0;
        $perms_avoided = 0;
        $perms_dangerous = 0;

        $contains_sensitive = false;
        foreach ($this->sensitive_paths as $sensitive_path) {
            if (preg_match('#^' . $sensitive_path . '$#', $rel_path) != 0) {
                $contains_sensitive = true;
            }
        }

        $is_shell_script = false;
        if (!$is_directory) {
            foreach ($this->script_paths as $script_path) {
                if (preg_match('#^' . $script_path . '$#', $rel_path) != 0) {
                    $is_shell_script = true;
                }
            }
        }

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETGID;
        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETUID;

        if (($this->is_windows()/*We are setting against ACLs really anyway*/) || ($this->web_user === null) || ($file_owner == $this->web_user)) {
            // suEXEC style...

            $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;

            if ($is_directory) {
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if ($on_chmod_list) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            } else {
                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if ($on_chmod_list) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            }
        } else {
            // nobody style...

            if ($is_directory) {
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                if ($on_chmod_list) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                } else {
                    if ($this->has_ftp_loopback_for_write) {
                        $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                        $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    } else {
                        $perms_avoided |= self::BITMASK_PERMISSIONS_STICKY;
                        $perms_desired |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    }
                }
            } else {
                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                if ($on_chmod_list) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                } else {
                    if ($this->has_ftp_loopback_for_write) {
                        $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                        $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    } else {
                        $perms_avoided |= self::BITMASK_PERMISSIONS_STICKY;
                        $perms_desired |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    }
                }
            }
        }

        $found_issue = false;

        $new_file_perms = $file_perms;

        // $perms_needed
        if ($this->minimum_level <= self::RESULT_TYPE_ERROR_MISSING) {
            if (($file_perms & $perms_needed) != $perms_needed) {
                list($message, $command) = $this->output_issue($path, self::RESULT_TYPE_ERROR_MISSING, ($file_perms ^ $perms_needed) & $perms_needed);
                $messages[] = $message;
                if ($command !== null) {
                    $commands[] = $command;
                }
                $paths[$path] = true;
                if ($this->live_output) {
                    echo $message . "\n";
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
                $found_issue = true;
                $found_any_issue = true;
                $new_file_perms = $new_file_perms | $perms_needed;
            }

            // Extended attributes checks
            if (($perms_needed & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $extended_attribute_issues = [];
                $extended_attribute_commands = [];
                if (strpos($attr, 'a') !== false) {
                    $extended_attribute_issues[] = 'remove "a" append-only attribute';
                    $command = 'chattr -a ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (strpos($attr, 'i') !== false) {
                    $extended_attribute_issues[] = 'remove "i" immutable attribute';
                    $command = 'chattr -i ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (!empty($extended_attribute_issues)) {
                    $message = 'Error: extended attributes problem on ' . $path . ' (' . implode(', ', $extended_attribute_issues) . ')';
                    if ($this->live_output) {
                        echo $message . "\n";
                        foreach ($extended_attribute_commands as $command) {
                            echo $command . "\n";
                        }
                    }
                    $found_issue = true;
                    $found_any_issue = true;
                    $paths[$path] = true;
                    $commands = array_merge($commands, $extended_attribute_commands);
                }
            }
        }

        // $perms_desired
        if ($this->minimum_level <= self::RESULT_TYPE_SUGGESTION_MISSING) {
            if (($file_perms & $perms_desired) != $perms_desired) {
                list($message, $command) = $this->output_issue($path, self::RESULT_TYPE_SUGGESTION_MISSING, ($file_perms ^ $perms_desired) & $perms_desired);
                $messages[] = $message;
                if ($command !== null) {
                    $commands[] = $command;
                }
                $paths[$path] = true;
                if ($this->live_output) {
                    echo $message . "\n";
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
                $found_issue = true;
                $found_any_issue = true;
                $new_file_perms = $new_file_perms | $perms_desired;
            }
        }

        // $perms_dangerous
        if ($this->minimum_level <= self::RESULT_TYPE_ERROR_EXCESSIVE) {
            if (($file_perms & $perms_dangerous) != 0) {
                list($message, $command) = $this->output_issue($path, self::RESULT_TYPE_ERROR_EXCESSIVE, $file_perms & $perms_dangerous);
                $messages[] = $message;
                if ($command !== null) {
                    $commands[] = $command;
                }
                $paths[$path] = true;
                if ($this->live_output) {
                    echo $message . "\n";
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
                $found_issue = true;
                $found_any_issue = true;
                $new_file_perms = $new_file_perms & ~$perms_dangerous;
            }
        }

        // $perms_avoided
        if ($this->minimum_level <= self::RESULT_TYPE_SUGGESTION_EXCESSIVE) {
            if (($file_perms & $perms_avoided) != 0) {
                list($message, $command) = $this->output_issue($path, self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $file_perms & $perms_avoided);
                $messages[] = $message;
                if ($command !== null) {
                    $commands[] = $command;
                }
                $paths[$path] = true;
                if ($this->live_output) {
                    echo $message . "\n";
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
                $found_issue = true;
                $found_any_issue = true;
                $new_file_perms = $new_file_perms & ~$perms_avoided;
            }
        }

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        if ($this->live_commands) {
            foreach ($commands as $command) {
                if (($this->is_windows()) || (substr($command, 0, 6) != 'chmod ')) {
                    echo execute_nicely($command);
                }
            }
            if (!$this->is_windows()) {
                if ($new_file_perms != $file_perms) {
                    chmod($path, $new_file_perms);
                }
            }
        }

        return [$messages, $commands];
    }

    /**
     * Create a success message.
     *
     * @param  PATH $path The path the message is about
     * @return string The message
     */
    protected function output_success($path)
    {
        $path = str_replace('/', DIRECTORY_SEPARATOR, $path);

        $message = 'Success: ' . $path;

        return $message;
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $result_type A RESULT_TYPE_* constant
     * @param  integer $perms_involved_octal The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue($path, $result_type, $perms_involved_octal)
    {
        $path = str_replace('/', DIRECTORY_SEPARATOR, $path);

        $perms_involved_written = $this->convert_octal_to_written($perms_involved_octal);

        switch ($result_type) {
            case self::RESULT_TYPE_SUGGESTION_MISSING:
                $message = 'Suggestion: set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '+');
                break;

            case self::RESULT_TYPE_ERROR_MISSING:
                $message = 'Error: set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '+');
                break;

            case self::RESULT_TYPE_SUGGESTION_EXCESSIVE:
                $message = 'Suggestion: remove unnecessary permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '-');
                break;

            case self::RESULT_TYPE_ERROR_EXCESSIVE:
                $message = 'Error: remove dangerous permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, '-');
                break;

            default:
                throw new Exception('Internal Error');
        }

        return [$message, $command];
    }

    /**
     * Find if we are running Windows.
     *
     * @return boolean Whether we are running Windows
     */
    protected function is_windows()
    {
        return (strpos(PHP_OS, 'WIN') !== false);
    }

    /**
     * Generate a chmod command from differential octal permissions.
     *
     * @param  PATH $path The path the command is for
     * @param  integer $octal Permissions
     * @param  string $operator Change operator
     * @set - +
     * @return string Chmod command
     */
    public function generate_chmod_command($path, $octal, $operator)
    {
        if ($this->is_windows()) {
            // Windows...

            $path = str_replace('/', DIRECTORY_SEPARATOR, $path);

            $cmd = ($operator == '+') ? '/grant' : '/deny';

            $owner_user = $this->web_user;
            $owner_commands = [];
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
                $owner_commands[] = '/' . $cmd . ' ' . $owner_user . ':(X)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
                $owner_commands[] = '/' . $cmd . ' ' . $owner_user . ':(RD,RA,REA)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $owner_commands[] = '/' . $cmd . ' ' . $owner_user . ':(WD,WA,WEA,AD,D)';
            }

            $group_user = $this->web_user_group;
            $group_commands = [];
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
                $group_commands[] = '/' . $cmd . ' ' . $group_user . ':(X)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
                $group_commands[] = '/' . $cmd . ' ' . $group_user . ':(RD,RA,REA)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
                $group_commands[] = '/' . $cmd . ' ' . $group_user . ':(WD,WA,WEA,AD,D)';
            }

            $other_user = 'Users';
            $other_commands = [];
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
                $other_commands[] = '/' . $cmd . ' ' . $other_user . ':(X)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
                $other_commands[] = '/' . $cmd . ' ' . $other_user . ':(RD,RA,REA)';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
                $other_commands[] = '/' . $cmd . ' ' . $other_user . ':(WD,WA,WEA,AD,D)';
            }

            $command = 'icacls ' . escapeshellarg($path) . implode(' ', $owner_commands) . implode(' ', $group_commands) . implode(' ', $other_commands) .  ' /inheritancelevel:r';
        } else {
            // MacOS and Linux...

            $owner_perms = [];
            if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
                $owner_perms[] = 's';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
                $owner_perms[] = 'x';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
                $owner_perms[] = 'r';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $owner_perms[] = 'w';
            }

            $group_perms = [];
            if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
                $group_perms[] = 's';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
                $group_perms[] = 'x';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
                $group_perms[] = 'r';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
                $group_perms[] = 'w';
            }

            $other_perms = [];
            if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
                $other_perms[] = 't';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
                $other_perms[] = 'x';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
                $other_perms[] = 'r';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
                $other_perms[] = 'w';
            }

            $chmod = '';
            foreach (['u' => $owner_perms, 'g' => $group_perms, 'o' => $other_perms] as $permission_class => $perms) {
                if (!empty($perms)) {
                    if ($chmod != '') {
                        $chmod .= ',';
                    }
                    $chmod .= $permission_class . $operator . implode('', $perms);
                }
            }
            $command = 'chmod ' . $chmod . ' ' . escapeshellarg($path);
        }

        return $command;
    }

    /**
     * Convert octal permissions to written ones.
     *
     * @param  integer $octal Permissions
     * @return string Written permissions
     */
    protected function convert_octal_to_written($octal)
    {
        $perms = [];

        if ($this->is_windows()) {
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
                $perms[] = 'IUSR execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
                $perms[] = 'IUSR read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $perms[] = 'IUSR write';
            }

            if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
                $perms[] = 'IIS_IUSRS execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
                $perms[] = 'IIS_IUSRS read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
                $perms[] = 'IIS_IUSRS write';
            }

            if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
                $perms[] = 'Users execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
                $perms[] = 'Users read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
                $perms[] = 'Users write';
            }
        } else {
            if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
                $perms[] = 'sticky';
            }
            if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
                $perms[] = 'setgid';
            }
            if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
                $perms[] = 'setuid';
            }

            if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
                $perms[] = 'owner execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
                $perms[] = 'owner read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $perms[] = 'owner write';
            }

            if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
                $perms[] = 'group execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
                $perms[] = 'group read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
                $perms[] = 'group write';
            }

            if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
                $perms[] = 'other execute';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
                $perms[] = 'other read';
            }
            if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
                $perms[] = 'other write';
            }
        }

        return implode(', ', $perms);
    }
}
