<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/*EXTRA FUNCTIONS: shell_exec|escapeshellarg|posix_.*|fileowner|filegroup|get_current_user|is_executable|strtolower*/

// Everything in this file can run without Composr having bootstrapped, although it will run better if it has

/**
 * Execute a shell command, returning full output, with a guaranteed line break if not blank.
 *
 * @param  string $command Command to run
 * @return string Command output
 */
function execute_nicely(string $command) : string
{
    $ret = @trim(shell_exec($command . ' 2>&1'));
    if ($ret != '') {
        $ret .= "\n";
    }
    return $ret;
}

/**
 * Scan permissions. Composr-specific wrapper for the CMSPermissionsScanner* classes.
 *
 * @param  boolean $live_output Whether to produce live output of issues
 * @param  boolean $live_commands Whether to run commands live
 * @param  ?string $web_username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
 * @param  ?boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP (null: default / auto-detect if possible)
 * @param  integer $minimum_level Minimum RESULT_TYPE_* level
 * @return array A tuple: Messages to show, Commands to run, Paths with issues, Whether any issues were found
 */
function scan_permissions(bool $live_output = false, bool $live_commands = false, ?string $web_username = null, ?bool $has_ftp_loopback_for_write = null, int $minimum_level = 3) : array
{
    $sensitive_paths = [
        '_config.php',
        'exports/backups/[^/]*\.tar(\.gz)?',
        'exports/file_backups/_config.php\.\d+',
    ];

    $skip_paths = [ // For performance, often lots of files on dev machines
        '_tests/screens_tested',
        'exports/builds',
        'uploads/website_specific/cms',
        'uploads/website_specific/test',
        'uploads/website_specific/compo.sr/demonstratr/servers',
    ];

    $chmod_array = get_chmod_array();
    $chmod_paths = [];
    foreach ($chmod_array as $chmod) {
        $chmod = preg_quote($chmod, '#');
        $chmod = str_replace('\*\*', '[^/\.]*', $chmod); // Wildcarded directories
        $chmod = str_replace('\*', '[^/]*', $chmod); // Wildcarded files
        $chmod_paths[] = $chmod;
    }

    if ($has_ftp_loopback_for_write === null) {
        $has_ftp_loopback_for_write = ((function_exists('ftp_ssl_connect')) || (function_exists('ftp_connect'))) && ((!function_exists('get_value')) || (get_value('uses_ftp') !== '0'));
    }

    if (($minimum_level >= CMSPermissionsScanner::RESULT_TYPE_ERROR_MISSING) && (!$live_commands) && ($web_username === null)) {
        $ob = new CMSPermissionsScannerSimplified();
    } elseif (strpos(PHP_OS, 'WIN') !== false) {
        $ob = new CMSPermissionsScannerWindows();
    } else {
        $ob = new CMSPermissionsScannerLinux();
    }

    $ob->set_path_patterns($sensitive_paths, $chmod_paths, null, $skip_paths);

    $ob->set_live_output($live_output);
    $ob->set_live_commands($live_commands);

    if ($web_username !== null) {
        $ob->set_web_username($web_username);
    }

    $ob->set_minimum_level($minimum_level);

    $ob->set_has_ftp_loopback_for_write($has_ftp_loopback_for_write);

    $subdir = '';

    if (function_exists('get_file_base')) {
        $stub = get_file_base() . (($subdir == '') ? '' : '/');
    } else {
        $stub = dirname(__DIR__) . (($subdir == '') ? '' : '/');
    }

    $found_any_issue = false;

    $messages = [];
    $commands = [];
    $_paths = [];

    list($_messages, $_commands) = $ob->process_directory($stub . $subdir, $subdir, null, true, $_paths, $found_any_issue);
    $messages = array_merge($messages, $_messages);
    $commands = array_merge($commands, $_commands);

    if ((function_exists('get_file_base')) && (get_file_base() != get_custom_file_base())) {
        list($_messages, $_commands) = $ob->process_directory(get_custom_file_base() . (($subdir == '') ? '' : '/') . $subdir, $subdir, null, true, $_paths, $found_any_issue);
        $messages = array_merge($messages, $_messages);
        $commands = array_merge($commands, $_commands);
    }

    $paths = array_keys($_paths);

    return [$messages, $commands, $paths, $found_any_issue];
}

/**
 * Get the list of folders/files that need CHmodding for write access.
 *
 * @param  boolean $runtime Include folders/files that are created dynamically
 * @param  boolean $check_custom Whether to consider and prioritise sources_custom hooks
 * @return array The list of paths; ** represents directory-wildcards
 */
function get_chmod_array(bool $runtime = true, bool $check_custom = true) : array
{
    $chmod = [];

    if (function_exists('find_all_hooks')) {
        $hooks = find_all_hooks('systems', 'addon_registry', $check_custom);
        foreach ($hooks as $hook => $place) {
            /*require_code('hooks/systems/addon_registry/' . filter_naughty_harsh($hook));
            $object = object_factory('Hook_addon_registry_' . filter_naughty_harsh($hook));
            $chmod = array_merge($chmod, $object->get_chmod_array());*/

            // Save memory compared to above commented code...

            $path = get_file_base() . '/' . $place . '/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            $_hook_bits = extract_module_functions($path, ['get_chmod_array']);
            $_chmod = is_array($_hook_bits[0]) ? call_user_func_array($_hook_bits[0][0], $_hook_bits[0][1]) : cms_eval($_hook_bits[0], $path);
            $chmod = array_merge($chmod, $_chmod);
        }
    } else { // Manually scan hooks using PHP
        if ($check_custom) {
            // sources_custom should be first in case of overrides
            $base_dirs = [__DIR__ . '/../sources_custom/hooks/systems/addon_registry', __DIR__ . '/../sources/hooks/systems/addon_registry'];
        } else {
            $base_dirs = [__DIR__ . '/../sources/hooks/systems/addon_registry'];
        }

        $hooks_processed = [];
        foreach ($base_dirs as $base_dir) {
            $files = scandir($base_dir);
            foreach ($files as $file) {
                $path_parts = pathinfo($file);
                if (!isset($path_parts['extension']) || (strtolower($path_parts['extension']) != 'php')) { // Skip non-PHP files
                    continue;
                }

                $hook_name = strtolower($path_parts['filename']);
                if (array_key_exists($hook_name, $hooks_processed)) { // If we already processed the hook (e.g. override), don't process it again
                    continue;
                }

                require_once($base_dir . '/' . $file);
                $class = 'Hook_addon_registry_' . $hook_name;
                $object = new $class();

                if (method_exists($object, 'get_chmod_array')) {
                    $chmod = array_merge($chmod, $object->get_chmod_array());
                    $hooks_processed[] = $hook_name;
                }
            }
        }
    }

    if ($runtime) {
        $chmod = array_merge(
            $chmod,
            [
                'adminzone/pages/comcode_custom/**/*.txt',
                'adminzone/pages/html_custom/**/*.htm',
                'caches/http/*.bin',
                'caches/lang/**/*.lcd',
                'caches/lang/*.lcd',
                'caches/persistent/*.gcd',
                'caches/self_learning/*.gcd',
                'caches/static/*',
                'cms/pages/comcode_custom/**/*.txt',
                'cms/pages/html_custom/**/*.htm',
                'data_custom/modules/web_notifications/*.bin',
                'data_custom/sitemaps/* ',
                'data_custom/spelling/personal_dicts/*',
                'data_custom/xml_config/*.xml',
                'exports/**/*.tar',
                'imports/**/*.tar',
                'lang_custom/**/*.ini',
                'pages/comcode_custom/**/*.txt',
                'pages/html_custom/**/*.htm',
                'site/pages/comcode_custom/**/*.txt',
                'site/pages/html_custom/**/*.htm',
                'temp/*',
                'text_custom/**/*.txt',
                'text_custom/*.txt',
                'themes/**/css_custom/*.css',
                'themes/**/images_custom/*',
                'themes/**/javascript_custom/*.js',
                'themes/**/templates_cached/**/*',
                'themes/**/templates_custom/*.tpl',
                'themes/**/text_custom/*.txt',
                'themes/**/xml_custom/*.xml',
                'themes/**/theme.ini',
                'uploads/attachments/*',
                'uploads/attachments_thumbs/*',
                'uploads/auto_thumbs/*',
                'uploads/repimages/*',
                'uploads/website_specific/*',
            ]
        );
    }

    $chmod = array_merge(
        $chmod,
        [
            '_config.php',
            'adminzone/pages/comcode_custom/**',
            'adminzone/pages/html_custom/**',
            'caches/http',
            'caches/lang',
            'caches/lang/**',
            'caches/persistent',
            'caches/self_learning',
            'caches/static',
            'cms/pages/comcode_custom/**',
            'cms/pages/html_custom/**',
            'data_custom/errorlog.php',
            'data_custom/firewall_rules.txt',
            'data_custom/modules/web_notifications',
            'data_custom/sitemaps',
            'data_custom/spelling/personal_dicts',
            'data_custom/xml_config',
            'exports/**',
            'imports/**',
            'lang_custom',
            'lang_custom/**',
            'pages/comcode_custom/**',
            'pages/html_custom/**',
            'site/pages/comcode_custom/**',
            'site/pages/html_custom/**',
            'temp',
            'text_custom',
            'text_custom/**',
            'themes',
            'themes/**/css_custom',
            'themes/**/images_custom',
            'themes/**/javascript_custom',
            'themes/map.ini',
            'themes/**/templates_cached/**',
            'themes/**/templates_custom',
            'themes/**/text_custom',
            'themes/**/xml_custom',
            'uploads/attachments',
            'uploads/attachments_thumbs',
            'uploads/auto_thumbs',
            'uploads/incoming',
            'uploads/repimages',
            'uploads/website_specific',
        ]
    );

    return $chmod;
}

/**
 * Check/fix permissions, base class.
 *
 * @package cms_permissions_scanner
 */
abstract class CMSPermissionsScanner
{
    // Constants...

    public const RESULT_TYPE_SUCCESS = 0;
    public const RESULT_TYPE_SUGGESTION_EXCESSIVE = 1;
    public const RESULT_TYPE_SUGGESTION_MISSING = 2;
    public const RESULT_TYPE_ERROR_EXCESSIVE = 3;
    public const RESULT_TYPE_ERROR_MISSING = 4;

    // Options...

    protected $sensitive_paths = [];
    protected $chmod_paths = [];
    protected $script_paths = null;
    protected $skip_paths = [];

    protected $has_ftp_loopback_for_write = false;

    protected $minimum_level = 1;
    protected $live_output = false;
    protected $live_commands = false;

    // Code...

    /**
     * Constructor.
     */
    public function __construct()
    {
        $this->set_web_username();

        $this->set_path_patterns();
    }

    /**
     * Find out whether a directory will be filtered out from checks.
     *
     * @param  PATH $rel_path The relative path to the base directory
     * @return boolean Whether it is filtered
     */
    protected function filtered(string $rel_path) : bool
    {
        if ($rel_path == '') {
            return false;
        }

        // Optimisation
        if ($this->minimum_level == self::RESULT_TYPE_ERROR_MISSING) {
            static $unwrapped_chmodded_list = null;
            if ($unwrapped_chmodded_list === null) {
                $unwrapped_chmodded_list = [];
                foreach ($this->chmod_paths as $chmod_path) {
                    do {
                        $unwrapped_chmodded_list[] = $chmod_path;
                        if (strpos($chmod_path, '/') === false) {
                            break;
                        }
                        $chmod_path = preg_replace('#/([^/]*|\[[^\]]*\][^/]*)$#', '', $chmod_path);
                    } while (true);
                }
                $unwrapped_chmodded_list = array_unique($unwrapped_chmodded_list);
                sort($unwrapped_chmodded_list);
            }

            $on_chmod_list = false;
            foreach ($unwrapped_chmodded_list as $chmod_path) {
                if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                    $on_chmod_list = true;
                }
            }
            if (!$on_chmod_list) {
                return true;
            }
        }

        return false;
    }

    /**
     * Generate a message prefix, based on whether we are only showing messages of one level or not.
     *
     * @param  string $prefix The raw prefix
     * @return string The prefix
     */
    protected function message_prefix(string $prefix) : string
    {
        if ($this->minimum_level >= self::RESULT_TYPE_ERROR_MISSING) {
            return '';
        }
        return $prefix . ': ';
    }

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username(?string $username = null)
    {
    }

    /**
     * Set paths patterns.
     *
     * @param  array $sensitive_paths A list of sensitive path regexps that really should have minimal read permission
     * @param  array $chmod_paths A list of path regexps that should be chmodded as writable for non-suEXEC-style servers
     * @param  ?array $script_paths A list of path regexps for scripts that need Unix execute permission (null: .sh files)
     * @param  array $skip_paths A list of paths to skip
     */
    public function set_path_patterns(array $sensitive_paths = [], array $chmod_paths = [], ?array $script_paths = null, array $skip_paths = [])
    {
        $this->sensitive_paths = $sensitive_paths;
        $this->chmod_paths = $chmod_paths;
        if ($script_paths === null) {
            $this->script_paths = [
                '.*\.sh',
            ];
        } else {
            $this->script_paths = $script_paths;
        }
        $this->skip_paths = $skip_paths;
    }

    /**
     * Set whether we can 'get' write access via some kind of loopback.
     *
     * @param  boolean $has_ftp_loopback_for_write Whether the system has the potential to 'get' write access on non-suEXEC-style servers by (for example) looping through FTP
     */
    public function set_has_ftp_loopback_for_write(bool $has_ftp_loopback_for_write)
    {
        $this->has_ftp_loopback_for_write = $has_ftp_loopback_for_write;
    }

    /**
     * Set minimum result level.
     *
     * @param  integer $minimum_level Minimum RESULT_TYPE_* level
     */
    public function set_minimum_level(int $minimum_level)
    {
        $this->minimum_level = $minimum_level;
    }

    /**
     * Set whether to show live output, rather than just returning at the end.
     *
     * @param  boolean $live_output Whether to output live
     */
    public function set_live_output(bool $live_output)
    {
        $this->live_output = $live_output;
    }

    /**
     * Set whether to run live commands, rather than just returning at the end.
     *
     * @param  boolean $live_commands Whether to run commands
     */
    public function set_live_commands(bool $live_commands)
    {
        $this->live_commands = $live_commands;
    }

    /**
     * Find whether a particular PHP function is allowed.
     *
     * @param  string $function Function name
     * @return boolean Whether it is
     */
    protected function php_function_allowed(string $function) : bool
    {
        if (!function_exists($function)) {
            return false;
        }
        $to_block = ['disable_functions', 'suhosin.executor.func.blacklist', 'suhosin.executor.include.blacklist', 'suhosin.executor.eval.blacklist'];
        $_blocked = [];
        foreach ($to_block as $func) {
            $ini_val = ini_get($func);
            if ($ini_val !== false) {
                $_blocked[] = $ini_val;
            }
        }
        $blocked = implode(',', $_blocked);
        return (@preg_match('#(\s|,|^)' . preg_quote($function, '#') . '(\s|$|,)#i', $blocked) == 0);
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    abstract public function process_directory(string $path, string $rel_path = '', ?string $attr = null, bool $top_level = true, array &$paths = [], bool &$found_any_issue = false) : array;


    /**
     * Create a success message.
     *
     * @param  PATH $path The path the message is about
     * @return string The message
     */
    protected function output_success(string $path) : string
    {
        $message = 'Success: ' . $path;

        return $message;
    }
}

/**
 * Check/fix permissions that just does simple cross-platform writability checks.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScannerSimplified extends CMSPermissionsScanner
{
    protected const BITMASK_PERMISSIONS_READ = 1;
    protected const BITMASK_PERMISSIONS_WRITE = 2;
    protected const BITMASK_PERMISSIONS_EXECUTE = 4;

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory(string $path, string $rel_path = '', ?string $attr = null, bool $top_level = true, array &$paths = [], bool &$found_any_issue = false) : array
    {
        $messages = [];
        $commands = [];

        if ($this->filtered($rel_path)) {
            return [$messages, $commands];
        }

        $_messages = $this->process_node($path, $rel_path, true, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                if (in_array($_rel_path, $this->skip_paths)) {
                    continue;
                }

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, $attr, false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }

    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the file
     * @param  boolean $is_directory Whether this is a directory
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node(string $path, string $rel_path, bool $is_directory, array &$paths = [], bool &$found_any_issue = false) : array
    {
        // (We will assume the file owner is not something we want to change, just the permissions to work best with that owner)

        $messages = [];
        $commands = [];

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        $fileperm_problems = 0;

        if ($on_chmod_list) {
            if (function_exists('cms_is_writable')) {
                if (!cms_is_writable($path)) {
                    $fileperm_problems |= self::BITMASK_PERMISSIONS_WRITE;
                }
            } else {
                if (!is_writable($path)) {
                    $fileperm_problems |= self::BITMASK_PERMISSIONS_WRITE;
                }
            }
        }

        if (!is_readable($path)) {
            $fileperm_problems |= self::BITMASK_PERMISSIONS_READ;
        }

        if (($is_directory) && (function_exists('is_executable'))) {
            if (!is_executable($path) && (strpos(PHP_OS, 'WIN') === false)) {
                $fileperm_problems |= self::BITMASK_PERMISSIONS_EXECUTE;
            }
        }

        if ($fileperm_problems != 0) {
            list($message, $command) = $this->output_issue($path, $fileperm_problems);

            $messages[] = $message;
            if ($command !== null) {
                $commands[] = $command;
            }
            $paths[$path] = true;
            if ($this->live_output) {
                echo $message . "\n";
                if ($command !== null) {
                    echo $command . "\n";
                }
            }
            $found_issue = true;
            $found_any_issue = true;
        }

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        return [$messages, $commands];
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $perms_involved The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue(string $path, int $perms_involved) : array
    {
        $perms_involved_written = $this->convert_constants_to_written($perms_involved);

        $message = $this->message_prefix('Error') . 'Set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';

        return [$message, null];
    }

    /**
     * Convert bitmask of permissions to written ones.
     *
     * @param  integer $_perms Permissions
     * @return string Written permissions
     */
    protected function convert_constants_to_written(int $_perms) : string
    {
        $perms = [];

        if (($_perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            $perms[] = 'execute';
        }
        if (($_perms & self::BITMASK_PERMISSIONS_READ) != 0) {
            $perms[] = 'read';
        }
        if (($_perms & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            $perms[] = 'write';
        }

        return implode(', ', $perms);
    }
}

/**
 * Check/fix permissions on Linux/Mac OS.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScannerLinux extends CMSPermissionsScanner
{
    // Constants...

    protected const BITMASK_PERMISSIONS_STICKY = 01000;
    protected const BITMASK_PERMISSIONS_SETGID = 02000;
    protected const BITMASK_PERMISSIONS_SETUID = 04000;

    protected const BITMASK_PERMISSIONS_OWNER_EXECUTE = 00100;
    protected const BITMASK_PERMISSIONS_OWNER_WRITE = 00200;
    protected const BITMASK_PERMISSIONS_OWNER_READ = 00400;

    protected const BITMASK_PERMISSIONS_GROUP_EXECUTE = 00010;
    protected const BITMASK_PERMISSIONS_GROUP_WRITE = 00020;
    protected const BITMASK_PERMISSIONS_GROUP_READ = 00040;

    protected const BITMASK_PERMISSIONS_OTHER_EXECUTE = 00001;
    protected const BITMASK_PERMISSIONS_OTHER_WRITE = 00002;
    protected const BITMASK_PERMISSIONS_OTHER_READ = 00004;

    // Run-time data...

    protected $has_lsattr;
    protected $web_user;

    // Code...

    /**
     * Constructor.
     */
    public function __construct()
    {
        parent::__construct();

        $this->has_lsattr = false;
        if (($this->php_function_allowed('shell_exec')) && ($this->php_function_allowed('escapeshellarg'))) {
            if (preg_match('#lsattr \d#', shell_exec('lsattr -V 2>&1')) != 0) {
                $this->has_lsattr = true;
            }
        }
    }

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username(?string $username = null)
    {
        $this->web_user = null;

        $is_cli = (function_exists('php_sapi_name')) && (php_sapi_name() == 'cli') && (empty($_SERVER['REMOTE_ADDR']));

        if ($username === null) {
            if ($this->php_function_allowed('posix_getuid')) {
                $this->web_user = $is_cli ? false : posix_getuid();
            }
        } else {
            if (is_numeric($username)) {
                $this->web_user = intval($username);
            } else {
                if ($this->php_function_allowed('posix_getpwnam')) {
                    $details = @posix_getpwnam($username);
                    if ($details === false) {
                        throw new Exception('Cannot find user, ' . $username);
                    }
                    $this->web_user = $details['uid'];
                } else {
                    throw new Exception('Posix extension is needed if passing a username');
                }
            }
        }
    }

    /**
     * Find the extended attributes for a path.
     *
     * @param  PATH $path The absolute path
     * @param  boolean $directory_contents Whether this is a directory to get the contents of
     * @return array A map of file paths to extended attribute strings
     */
    protected function process_lsattr(string $path, bool $directory_contents = false) : array
    {
        $lsattr = [];
        if (($this->has_lsattr) && ($this->php_function_allowed('shell_exec'))) {
            $cmd = 'lsattr';
            if (!$directory_contents) {
                $cmd .= ' -d';
            }
            $cmd .= ' ' . escapeshellarg($path);
            $_lsattr = @strval(shell_exec($cmd . ' 2>&1'));

            $matches = [];
            $num_matches = preg_match_all('#^([A-Za-z\-])\t(.*)$#m', $_lsattr, $matches);
            for ($i = 0; $i < $num_matches; $i++) {
                $lsattr[$matches[2][$i]] = $matches[1][$i];
            }
        }
        return $lsattr;
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory(string $path, string $rel_path = '', ?string $attr = null, bool $top_level = true, array &$paths = [], bool &$found_any_issue = false) : array
    {
        $messages = [];
        $commands = [];

        if ($this->filtered($rel_path)) {
            return [$messages, $commands];
        }

        if ($top_level) {
            if ($this->php_function_allowed('shell_exec')) {
                if (@strpos(shell_exec('sestatus'), 'enabled') !== false) {
                    if (@strpos(shell_exec('ps -eZ'), 'httpd_t') !== false) {
                        $found_selinux_rule = false;

                        $path_up = $path;
                        do {
                            $cmd = 'ls -Zld ' . escapeshellarg($path_up);
                            if (@strpos(shell_exec($cmd), 'httpd_sys_rw_content_t') !== false) {
                                $found_selinux_rule = true;
                            }

                            $_path_up = $path_up;
                            $path_up = dirname($path_up);
                        } while (($path_up != '.') && (!empty($path_up)) && ($path_up != $_path_up));

                        if (!$found_selinux_rule) {
                            $message = $this->message_prefix('Error') . 'Selinux is running and httpd_sys_rw_content_t is not set in the directory tree of ' . $path;
                            $messages[] = $message;
                            if ($this->live_output) {
                                echo $message . "\n";
                            }
                        }
                    }
                }
            }
        }

        if ($attr === null) {
            $lsattr = $this->process_lsattr($path);
            $attr = isset($lsattr[$path]) ? $lsattr[$path] : '';
        }

        $_messages = $this->process_node($path, $rel_path, true, $attr, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $lsattr = $this->process_lsattr($path, true);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                if (in_array($_rel_path, $this->skip_paths)) {
                    continue;
                }

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, isset($lsattr[$_path]) ? $lsattr[$_path] : '', false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, isset($lsattr[$_path]) ? $lsattr[$_path] : '', $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }

    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the file
     * @param  boolean $is_directory Whether this is a directory
     * @param  string $attr A string of extended attributes from lsattr
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node(string $path, string $rel_path, bool $is_directory, string $attr, array &$paths = [], bool &$found_any_issue = false) : array
    {
        // (We will assume the file owner is not something we want to change, just the permissions to work best with that owner)

        $messages = [];
        $commands = [];

        $perms_needed = 0;
        $perms_desired = 0;
        $perms_irrelevant = 0;
        $perms_avoided = 0;
        $perms_dangerous = 0;

        $contains_sensitive = false;
        foreach ($this->sensitive_paths as $sensitive_path) {
            if (preg_match('#^' . $sensitive_path . '$#', $rel_path) != 0) {
                $contains_sensitive = true;
            }
        }

        $is_shell_script = false;
        if (!$is_directory) {
            foreach ($this->script_paths as $script_path) {
                if (preg_match('#^' . $script_path . '$#', $rel_path) != 0) {
                    $is_shell_script = true;
                }
            }
        }

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        if (($this->minimum_level >= self::RESULT_TYPE_ERROR_MISSING) && (!$on_chmod_list)) {
            return [$messages, $commands]; // Optimisation
        }

        if (function_exists('fileowner') && function_exists('fileperms')) {
            $file_owner = @fileowner($path);
            $file_perms = @fileperms($path);
        } else {
            $file_owner = false;
            $file_perms = false;
        }

        if (($file_owner === false) || ($file_perms === false)) {
            return [[], [], []]; // Likely as parent directory is missing perms, which will be flagged
        }

        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETGID;
        $perms_dangerous |= self::BITMASK_PERMISSIONS_SETUID;

        if (($this->web_user === null) || ($file_owner === $this->web_user)) {
            // suEXEC style...

            $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;

            if ($is_directory) {
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            } else {
                if ($is_shell_script) {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                } else {
                    $perms_desired |= self::BITMASK_PERMISSIONS_OWNER_WRITE;
                }

                $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                if ($contains_sensitive) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_READ;
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
            }
        } else {
            // nobody style...

            $file_group = @filegroup($path);
            if ($this->web_user === false) {
                $group_based = false;
            } else {
                $web_user_groups = $this->posix_getgroups($this->web_user);
                $file_owner_groups = $this->posix_getgroups($file_owner);
                $group_based = $web_user_groups !== null && $file_owner_groups !== null && in_array($file_group, $web_user_groups) && in_array($this->web_user, $file_owner_groups);
            }

            if ($is_directory) {
                // Because of precedence we would expect all of ugo to have permissions
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                if ($group_based) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_EXECUTE;
                } else {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_EXECUTE; // Because of precedence we would expect all of ugo to have permissions
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                }
                if ($group_based) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_READ;
                } else {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_READ; // Because of precedence we would expect all of ugo to have permissions
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    if ($group_based) {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_WRITE;
                        $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    } else {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_WRITE; // Because of precedence we would expect all of ugo to have permissions
                        $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    }
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_GROUP_WRITE;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                }
            } else {
                // Because of precedence we would expect all of ugo to have permissions
                if ($is_shell_script) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OWNER_EXECUTE;
                }
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_READ;
                $perms_needed |= self::BITMASK_PERMISSIONS_OWNER_WRITE;

                if ($is_shell_script) {
                    if ($group_based) {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_EXECUTE;
                    } else {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_EXECUTE; // Because of precedence we would expect all of ugo to have permissions
                        $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                    }
                } else {
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_EXECUTE;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_GROUP_EXECUTE;
                }
                if ($group_based) {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_READ;
                } else {
                    $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_READ; // Because of precedence we would expect all of ugo to have permissions
                    $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_READ;
                }
                if (($on_chmod_list) || (!$this->has_ftp_loopback_for_write)) {
                    $perms_dangerous |= self::BITMASK_PERMISSIONS_STICKY;
                    if ($group_based) {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_WRITE;
                        $perms_dangerous |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    } else {
                        $perms_needed |= self::BITMASK_PERMISSIONS_GROUP_WRITE; // Because of precedence we would expect all of ugo to have permissions
                        $perms_needed |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                    }
                } else {
                    $perms_irrelevant |= self::BITMASK_PERMISSIONS_STICKY;
                    $perms_avoided |= self::BITMASK_PERMISSIONS_OTHER_WRITE;
                }
            }
        }

        $found_issue = false;

        $new_file_perms = $file_perms;

        if ($this->minimum_level <= self::RESULT_TYPE_ERROR_MISSING) {
            // Extended attributes checks
            if (($perms_needed & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
                $extended_attribute_issues = [];
                $extended_attribute_commands = [];
                if (strpos($attr, 'a') !== false) {
                    $extended_attribute_issues[] = 'remove "a" append-only attribute';
                    $command = 'chattr -a ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (strpos($attr, 'i') !== false) {
                    $extended_attribute_issues[] = 'remove "i" immutable attribute';
                    $command = 'chattr -i ' . escapeshellarg($path);
                    $extended_attribute_commands[] = $command;
                }
                if (!empty($extended_attribute_issues)) {
                    $message = $this->message_prefix('Error') . 'Extended attributes problem on ' . $path . ' (' . implode(', ', $extended_attribute_issues) . ')';
                    if ($this->live_output) {
                        echo $message . "\n";
                        foreach ($extended_attribute_commands as $command) {
                            echo $command . "\n";
                        }
                    }
                    $found_issue = true;
                    $found_any_issue = true;
                    $paths[$path] = true;
                    $commands = array_merge($commands, $extended_attribute_commands);
                }
            }
        }

        $check_types = [
            [self::RESULT_TYPE_ERROR_MISSING, $perms_needed, '+'],
            [self::RESULT_TYPE_SUGGESTION_MISSING, $perms_desired, '+'],
            [self::RESULT_TYPE_ERROR_EXCESSIVE, $perms_dangerous, '-'],
            [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $perms_avoided, '-'],
        ];
        foreach ($check_types as $check_type) {
            list($check_type_level, $bitmask, $operator) = $check_type;

            if ($this->minimum_level <= $check_type_level) {
                if ($operator == '+') {
                    $ok = ($file_perms & $bitmask) == $bitmask; // Has all
                } else {
                    $ok = ($file_perms & $bitmask) == 0; // Has none
                }
                if (!$ok) {
                    if ($operator == '+') {
                        $perms_involved_octal = ($file_perms ^ $bitmask) & $bitmask; // What is missing
                        $new_file_perms = $new_file_perms | $bitmask;
                    } else {
                        $perms_involved_octal = $file_perms & $bitmask; // What is excessive
                        $new_file_perms = $new_file_perms & ~$bitmask;
                    }
                    list($message, $command) = $this->output_issue($path, $check_type_level, $operator, $perms_involved_octal);
                    $messages[] = $message;
                    if ($command !== null) {
                        $commands[] = $command;
                    }
                    $paths[$path] = true;
                    if ($this->live_output) {
                        echo $message . "\n";
                        if ($command !== null) {
                            echo $command . "\n";
                        }
                    }
                    $found_issue = true;
                    $found_any_issue = true;
                }
            }
        }

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        if ($this->live_commands) {
            foreach ($commands as $command) {
                if (substr($command, 0, 6) != 'chmod ') {
                    echo execute_nicely($command);
                }
            }
            if ($new_file_perms != $file_perms) {
                if (function_exists('afm_chmod')) {
                    afm_chmod($rel_path, $new_file_perms);
                } else {
                    chmod($path, $new_file_perms);
                }
            }
        }

        return [$messages, $commands];
    }

    /**
     * Find groups for a user.
     *
     * @param  integer $user_id The user ID
     * @return ~array A list of group IDs (false: error)
     */
    protected function posix_getgroups(int $user_id)
    {
        static $cache = [];
        if (isset($cache[$user_id])) {
            return $cache[$user_id];
        }
        if ($this->php_function_allowed('shell_exec')) {
            $ret = @shell_exec('id -G ' . strval($user_id));
        } else {
            $ret = false;
        }
        if ($ret === false) {
            $cache[$user_id] = false;
        } else {
            $cache[$user_id] = array_map('intval', explode(' ', $ret));
        }
        return $cache[$user_id];
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $result_type A RESULT_TYPE_* constant
     * @param  string $operator The operator involved
     * @set + -
     * @param  integer $perms_involved_octal The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue(string $path, int $result_type, string $operator, int $perms_involved_octal) : array
    {
        $perms_involved_written = $this->convert_octal_to_written($perms_involved_octal);

        switch ($result_type) {
            case self::RESULT_TYPE_SUGGESTION_MISSING:
                $message = $this->message_prefix('Suggestion') . 'Set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, $operator);
                break;

            case self::RESULT_TYPE_ERROR_MISSING:
                $message = $this->message_prefix('Error') . 'Set additional permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, $operator);
                break;

            case self::RESULT_TYPE_SUGGESTION_EXCESSIVE:
                $message = $this->message_prefix('Suggestion') . 'Remove unnecessary permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, $operator);
                break;

            case self::RESULT_TYPE_ERROR_EXCESSIVE:
                $message = $this->message_prefix('Error') . 'Remove dangerous permissions for ' . $path . ' (' . $perms_involved_written . ')';
                $command = $this->generate_chmod_command($path, $perms_involved_octal, $operator);
                break;

            default:
                throw new Exception('Internal Error');
        }

        return [$message, $command];
    }

    /**
     * Generate a chmod command from differential octal permissions.
     *
     * @param  PATH $path The path the command is for
     * @param  integer $octal Permissions
     * @param  string $operator Change operator
     * @set - +
     * @return string Chmod command
     */
    public function generate_chmod_command(string $path, int $octal, string $operator) : string
    {
        $owner_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
            $owner_perms[] = 's';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
            $owner_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
            $owner_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
            $owner_perms[] = 'w';
        }

        $group_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
            $group_perms[] = 's';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
            $group_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
            $group_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
            $group_perms[] = 'w';
        }

        $other_perms = [];
        if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
            $other_perms[] = 't';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
            $other_perms[] = 'x';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
            $other_perms[] = 'r';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
            $other_perms[] = 'w';
        }

        $chmod = '';
        foreach (['u' => $owner_perms, 'g' => $group_perms, 'o' => $other_perms] as $permission_class => $perms) {
            if (!empty($perms)) {
                if ($chmod != '') {
                    $chmod .= ',';
                }
                $chmod .= $permission_class . $operator . implode('', $perms);
            }
        }
        $command = 'chmod ' . $chmod . ' ' . escapeshellarg($path);

        return $command;
    }

    /**
     * Convert octal permissions to written ones.
     *
     * @param  integer $octal Permissions
     * @return string Written permissions
     */
    protected function convert_octal_to_written(int $octal) : string
    {
        $perms = [];

        if (($octal & self::BITMASK_PERMISSIONS_STICKY) != 0) {
            $perms[] = 'sticky';
        }
        if (($octal & self::BITMASK_PERMISSIONS_SETGID) != 0) {
            $perms[] = 'setgid';
        }
        if (($octal & self::BITMASK_PERMISSIONS_SETUID) != 0) {
            $perms[] = 'setuid';
        }

        if (($octal & self::BITMASK_PERMISSIONS_OWNER_EXECUTE) != 0) {
            $perms[] = 'owner execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_READ) != 0) {
            $perms[] = 'owner read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OWNER_WRITE) != 0) {
            $perms[] = 'owner write';
        }

        if (($octal & self::BITMASK_PERMISSIONS_GROUP_EXECUTE) != 0) {
            $perms[] = 'group execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_READ) != 0) {
            $perms[] = 'group read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_GROUP_WRITE) != 0) {
            $perms[] = 'group write';
        }

        if (($octal & self::BITMASK_PERMISSIONS_OTHER_EXECUTE) != 0) {
            $perms[] = 'other execute';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_READ) != 0) {
            $perms[] = 'other read';
        }
        if (($octal & self::BITMASK_PERMISSIONS_OTHER_WRITE) != 0) {
            $perms[] = 'other write';
        }

        return implode(', ', $perms);
    }
}

/**
 * Check/fix permissions on Windows.
 *
 * @package cms_permissions_scanner
 */
class CMSPermissionsScannerWindows extends CMSPermissionsScanner
{
    // Constants...

    protected const BITMASK_PERMISSIONS_READ = 1;
    protected const BITMASK_PERMISSIONS_WRITE = 2;
    protected const BITMASK_PERMISSIONS_EXECUTE = 4;

    protected const SCAN_PARTIAL_ACCESS_CHECK = 1;
    protected const SCAN_CHECK_GRANTS = 2;
    protected const SCAN_CHECK_DENYS = 4;

    // Run-time data...

    protected $key_users = [];
    protected $common_users = [];

    // Code...

    /**
     * Set username the web user will run as.
     *
     * @param  ?string $username Username or User ID (null: try and auto-detect, failing that assume suEXEC-style)
     */
    public function set_web_username(?string $username = null)
    {
        // Work out key users...

        $this->key_users = [];

        // Web server user
        if ($username === null) {
            $is_cli = (function_exists('php_sapi_name')) && (php_sapi_name() == 'cli') && (empty($_SERVER['REMOTE_ADDR']));

            $current_user = (function_exists('get_current_user') ? get_current_user() : 'DefaultAppPool');
            if (($is_cli) || ($current_user == 'DefaultAppPool')) {
                if ((strpos(__FILE__, 'htdocs') !== false) || (strpos(__FILE__, 'httpdocs') !== false)) {
                    $this->key_users[] = 'SYSTEM'; // The services user which Apache will use
                } else {
                    $this->key_users[] = 'IUSR'; // This is the user; in the past it was IUSR_<machineName>
                    $this->key_users[] = 'IIS_IUSRS'; // This is the usergroup, we'll use it also just to be safe; in the past it was IIS_WPG
                }
            } else {
                $this->key_users[] = preg_replace('#^.*\\\#', '', $current_user); // On Windows this returns the user PHP is running as, counter to documentation
            }
        } else {
            $this->key_users[] = preg_replace('#^.*\\\#', '', $username);
        }

        // File owner
        $path = str_replace('/', DIRECTORY_SEPARATOR, __FILE__);
        if (class_exists('COM')) {
            $su = new COM('ADsSecurityUtility');
            $security_info = $su->GetSecurityDescriptor($path, 1, 1);
            $this->key_users[] = preg_replace('#^.*\\\#', '', $security_info->owner);
        } elseif ($this->php_function_allowed('shell_exec')) {
            $text = shell_exec('dir /a /q ' . escapeshellarg($path));
            $matches = [];
            // FUDGE: We have to parse knowing the character offsets, as there's no other way to parse (date formats may vary, usernames often have spaces and numbers)
            if (preg_match('#^.{38} (.*?) +' . preg_quote(basename($path), '#') . ' *$#im', $text, $matches) != 0) {
                $this->key_users[] = preg_replace('#^.*\\\#', '', $matches[1]);
            } else {
                $this->key_users[] = 'Creator Owner'; // Fallback for when we do not know
            }
        } else {
            $this->key_users[] = 'Creator Owner'; // Fallback for when we do not know
        }

        $this->key_users = array_unique($this->key_users);
        $this->key_users = array_map('cms_mb_strtolower', $this->key_users);

        // Work out users to avoid...

        $this->common_users = [];

        $this->common_users[] = 'Everyone';
        $this->common_users[] = 'Users';
        $this->common_users[] = 'Local account';
        $this->common_users[] = 'Authenticated Users';
        $this->common_users[] = 'ANONYMOUS LOGON';
        $this->common_users[] = 'Guest';
        $this->common_users[] = 'Guests';
        $this->common_users[] = 'CONSOLE LOGON';
        $this->common_users[] = 'DIALUP';
        $this->common_users[] = 'NETWORK';
        $this->common_users[] = 'INTERACTIVE';
        $this->common_users[] = 'Domain Users';
        $this->common_users[] = 'Domain Guests';
        $this->common_users[] = 'Domain Computers';

        $this->common_users = array_map('cms_mb_strtolower', $this->common_users);

        if ($this->minimum_level >= self::RESULT_TYPE_ERROR_MISSING) {
            $this->key_users = array_merge($this->key_users, $this->common_users);
            $this->common_users = [];
        }
    }

    /**
     * Enumerate a directory for permission checks (actual processing is in process_node).
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  ?string $attr A string of extended attributes from lsattr (null: look up individually, which is slower)
     * @param  boolean $top_level Whether this is the top level of the recursion; don't set this manually
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run
     */
    public function process_directory(string $path, string $rel_path = '', ?string $attr = null, bool $top_level = true, array &$paths = [], bool &$found_any_issue = false) : array
    {
        $messages = [];
        $commands = [];

        if (($this->filtered($rel_path)) || (!$this->php_function_allowed('shell_exec'))) {
            return [$messages, $commands];
        }

        $_messages = $this->process_node($path, $rel_path, true, $paths, $found_any_issue);
        $messages = array_merge($messages, $_messages[0]);
        $commands = array_merge($commands, $_messages[1]);

        $dh = @opendir($path);
        if ($dh !== false) {
            while (($f = readdir($dh)) !== false) {
                if (($f == '.') || ($f == '..')) {
                    continue;
                }
                if ($f == '.git') {
                    // Funky things happen with permissions under .git
                    continue;
                }

                $_path = $path . '/' . $f;
                $_rel_path = $rel_path . (($rel_path == '') ? '' : '/') . $f;

                if (in_array($_rel_path, $this->skip_paths)) {
                    continue;
                }

                $is_directory = @is_dir($_path);

                if ($is_directory) {
                    $_messages = $this->process_directory($_path, $_rel_path, '', false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                } else {
                    $_messages = $this->process_node($_path, $_rel_path, false, $paths, $found_any_issue);
                    $messages = array_merge($messages, $_messages[0]);
                    $commands = array_merge($commands, $_messages[1]);
                }
            }

            closedir($dh);
        }

        return [$messages, $commands];
    }


    /**
     * Process a file or directory for permission checks.
     *
     * @param  PATH $path The absolute path
     * @param  PATH $rel_path The relative path to the base directory
     * @param  boolean $is_directory Whether this is a directory
     * @param  array $paths Paths with issues (inverse list), returned by reference
     * @param  boolean $found_any_issue Whether any issues were found, returned by reference
     * @return array A tuple: Messages to show, Commands to run, Paths with issues
     */
    protected function process_node(string $path, string $rel_path, bool $is_directory, array &$paths = [], bool &$found_any_issue = false) : array
    {
        $path = str_replace('/', DIRECTORY_SEPARATOR, $path);

        $messages = [];
        $commands = [];

        $perms_needed_key_users = 0;
        $perms_desired_key_users = 0;
        $perms_irrelevant_key_users = 0;
        $perms_avoided_key_users = 0;
        $perms_dangerous_key_users = 0;

        $perms_needed_common_users = 0;
        $perms_desired_common_users = 0;
        $perms_irrelevant_common_users = 0;
        $perms_avoided_common_users = 0;
        $perms_dangerous_common_users = 0;

        $contains_sensitive = false;
        foreach ($this->sensitive_paths as $sensitive_path) {
            if (preg_match('#^' . $sensitive_path . '$#', $rel_path) != 0) {
                $contains_sensitive = true;
            }
        }

        $on_chmod_list = false;
        foreach ($this->chmod_paths as $chmod_path) {
            if (preg_match('#^' . $chmod_path . '$#', $rel_path) != 0) {
                $on_chmod_list = true;
            }
        }

        if (($this->minimum_level >= self::RESULT_TYPE_ERROR_MISSING) && (!$on_chmod_list)) {
            return [$messages, $commands]; // Optimisation
        }

        $acl = $this->find_acl($path);
        if (empty($acl)) {
            return [[], [], []]; // Likely as parent directory is missing perms, which will be flagged
        }

        // Note the Windows algorithm is very different from Windows in some ways:
        //  - We are working against ACLs, not permission masks
        //  - We do not need to worry about chmodding 'others' to have write access and/or relaying through FTP:
        //   - Because we can set permissions both for the executing web user and the owner user i.e. it's irrelevant if they are different (the non-suEXEC case)
        //   - ACLs are inherited by default for any new files or folders
        // On how we treat inheritance:
        //  - Note that Windows copies ACLs down the hierarchy for performance, as a caching mechanism
        //  - Our approach is to never set permissions via inheriting for simplicity and speed
        //  - If the webmaster wants to use inheriting manually, that's great. We ourselves can't assume we 'own' the whole base directory.
        //  - We respect appropriate permissions that have been granted by inheriting and don't re-set them
        //  - Only if inappropriate permissions are inheriting do we turn off inheritance (i.e. reluctantly)
        //  - We do not recreate what was lost from inheritance when disabling it and is not needed, as that would be messy/complex and too much of an assumption
        //  - As we process permissions recursively, inheritance will be turned off minimally
        // On permission complexity:
        //  - Windows has complex overlapping permissions (simple rights, specific rights, generic rights)
        //  - We use the 'simple rights' when setting
        //  - When checking we accept/consider other rights as synonyms

        if ($is_directory) {
            $perms_needed_key_users |= self::BITMASK_PERMISSIONS_EXECUTE;
        } else {
            $perms_irrelevant_key_users |= self::BITMASK_PERMISSIONS_EXECUTE; // Doesn't even exist
        }
        $perms_needed_key_users |= self::BITMASK_PERMISSIONS_READ;
        if ($on_chmod_list) {
            $perms_needed_key_users |= self::BITMASK_PERMISSIONS_WRITE;
        } else {
            $perms_desired_key_users |= self::BITMASK_PERMISSIONS_WRITE;
        }

        if ($is_directory) {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_EXECUTE;
        } else {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_EXECUTE; // Doesn't even exist
        }
        if ($contains_sensitive) {
            $perms_dangerous_common_users |= self::BITMASK_PERMISSIONS_READ;
        } else {
            $perms_irrelevant_common_users |= self::BITMASK_PERMISSIONS_READ;
        }
        $perms_dangerous_common_users |= self::BITMASK_PERMISSIONS_WRITE;

        $found_issue = false;

        $check_types = [
            [
                $this->key_users,
                [
                    [self::RESULT_TYPE_ERROR_MISSING, $perms_needed_key_users, '+'],
                    [self::RESULT_TYPE_SUGGESTION_MISSING, $perms_desired_key_users, '+'],
                    [self::RESULT_TYPE_ERROR_EXCESSIVE, $perms_dangerous_key_users, '-'],
                    [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $perms_avoided_key_users, '-'],
                ]
            ],
            [
                $this->common_users,
                [
                    [self::RESULT_TYPE_ERROR_MISSING, $perms_needed_common_users, '+'],
                    [self::RESULT_TYPE_SUGGESTION_MISSING, $perms_desired_common_users, '+'],
                    [self::RESULT_TYPE_ERROR_EXCESSIVE, $perms_dangerous_common_users, '-'],
                    [self::RESULT_TYPE_SUGGESTION_EXCESSIVE, $perms_avoided_common_users, '-'],
                ]
            ],
        ];

        // Pre-scan
        $will_disable_inheritance = false;
        $will_do_reset_for = [];
        foreach ($check_types as $i => $_) {
            list($users, $_check_types) = $_;
            foreach ($_check_types as $j => $check_type) {
                list($check_type_level, $perms, $operator) = $check_type;

                if ($this->minimum_level <= $check_type_level) {
                    if ($operator == '+') {
                        list(, $problematic_denys, $disable_inheritance, $do_reset, $sid) = $this->find_missing_file_perms($users, $acl, $perms);
                    } else {
                        list($problematic_grants, $disable_inheritance, $do_reset, $sid) = $this->find_excessive_file_perms($users, $acl, $perms);
                    }
                    if ($disable_inheritance) {
                        $will_disable_inheritance = true;
                    }
                    if (($do_reset) && ($sid !== null)) {
                        if ($operator == '+') {
                            if (!empty($problematic_denys)) {
                                if (!array_key_exists($sid, $will_do_reset_for)) {
                                    $will_do_reset_for[$sid] = [[], []];
                                }
                                $will_do_reset_for[$sid][1] = array_merge($will_do_reset_for[$sid][1], $problematic_denys);
                            }
                        } else {
                            if (!empty($problematic_grants)) {
                                if (!array_key_exists($sid, $will_do_reset_for)) {
                                    $will_do_reset_for[$sid] = [[], []];
                                }
                                $will_do_reset_for[$sid][0] = array_merge($will_do_reset_for[$sid][0], $problematic_grants);
                            }
                        }
                    }
                }
            }
        }

        // Factor in disabling inheritance
        if ($will_disable_inheritance) {
            list($message, $command) = $this->output_issue_disable_inheritance($path);
            $messages[] = $message;
            if ($command !== null) {
                $commands[] = $command;
            }
            $paths[$path] = true;
            if ($this->live_output) {
                echo $message . "\n";
                if ($command !== null) {
                    echo $command . "\n";
                }
            }

            // Update ACL to match
            foreach ($acl as $sid => $parts) {
                $acl[$sid][2] = [];
                $acl[$sid][3] = [];
                $acl[$sid][4] = false;
            }
        }

        // Factor in resets
        foreach ($will_do_reset_for as $sid => $dont_want_back) {
            list($dont_want_back_grants, $dont_want_back_denys) = $dont_want_back;

            list($message, $command) = $this->output_issue_reset($path, $sid);
            $messages[] = $message;
            if ($command !== null) {
                $commands[] = $command;
            }
            $paths[$path] = true;
            if ($this->live_output) {
                echo $message . "\n";
                if ($command !== null) {
                    echo $command . "\n";
                }
            }

            // Update ACL to match and create commands to recreate permissions we do not want to lose (everything non-inherited except $problematic_denys and $excessive)
            list($permissions_negative, $permissions_positive, , ) = $acl[$sid];
            foreach (array_keys($permissions_negative) as $deny) {
                if (in_array($deny, $dont_want_back_denys)) {
                    unset($permissions_negative[$deny]);
                }
            }
            $acl[$sid][0] = $permissions_negative;
            if (!empty($permissions_negative)) {
                $command = $this->generate_chmod_command($path, $sid, array_keys($permissions_negative), '-');
                if ($command !== null) {
                    $commands[] = $command;
                }
                if ($this->live_output) {
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
            }
            foreach (array_keys($permissions_positive) as $grant) {
                if (in_array($grant, $dont_want_back_grants)) {
                    unset($permissions_positive[$grant]);
                }
            }
            $acl[$sid][1] = $permissions_positive;
            if (!empty($permissions_positive)) {
                $command = $this->generate_chmod_command($path, $sid, array_keys($permissions_positive), '+');
                if ($command !== null) {
                    $commands[] = $command;
                }
                if ($this->live_output) {
                    if ($command !== null) {
                        echo $command . "\n";
                    }
                }
            }
        }

        // Main scan
        foreach ($check_types as $i => $_) {
            list($users, $_check_types) = $_;
            foreach ($_check_types as $j => $check_type) {
                list($check_type_level, $perms, $operator) = $check_type;

                if ($this->minimum_level <= $check_type_level) {
                    if ($operator == '+') {
                        list($perms_involved, , $disable_inheritance, $do_reset) = $this->find_missing_file_perms($users, $acl, $perms);
                    } else {
                        list($perms_involved, $disable_inheritance, $do_reset) = $this->find_excessive_file_perms($users, $acl, $perms);
                    }

                    if (!empty($perms_involved)) {
                        list($message, $command) = $this->output_issue($path, $check_type_level, $operator, $sid, $perms_involved);
                        $messages[] = $message;
                        if ($command !== null) {
                            $commands[] = $command;
                        }
                        $paths[$path] = true;
                        if ($this->live_output) {
                            echo $message . "\n";
                            if ($command !== null) {
                                echo $command . "\n";
                            }
                        }
                        $found_issue = true;
                        $found_any_issue = true;
                    }
                }
            }
        }

        // Handle results...

        if ($this->minimum_level <= self::RESULT_TYPE_SUCCESS) {
            if (!$found_issue) {
                $message = $this->output_success($path);
                $messages[] = $message;
                if ($this->live_output) {
                    echo $message . "\n";
                }
            }
        }

        if ($this->live_commands) {
            foreach ($commands as $command) {
                echo execute_nicely($command);
            }
        }

        return [$messages, $commands];
    }

    /**
     * Find the access control list for a path.
     *
     * @param  PATH $path The path
     * @return array ACL
     */
    public function find_acl(string $path) : array
    {
        $acl = [];

        $result = shell_exec('icacls ' . escapeshellarg($path));
        $lines = explode("\n", $result);
        foreach ($lines as $line) {
            if (substr($line, 0, strlen($path) + 1) == $path . ' ') {
                $line = substr($line, strlen($path));
            }

            $matches = [];
            if (preg_match('#^\s*(.*):((\([A-Z,]+\))+)#', $line, $matches) != 0) {
                $sid = cms_mb_strtolower(preg_replace('#^.*\\\#', '', $matches[1]));
                $permissions_negative = [];
                $permissions_positive = [];
                $permissions_negative_inherited = [];
                $permissions_positive_inherited = [];
                $inherits_from_parent = false;
                $operator = '+';

                $matches_2 = [];
                $num_matches_2 = preg_match_all('#\(([A-Z,]+)\)#', $matches[2], $matches_2);
                for ($i = 0; $i < $num_matches_2; $i++) {
                    $_statement = $matches_2[1][$i];
                    foreach (explode(',', $_statement) as $statement) {
                        if ($statement == 'DENY') {
                            $operator = '-';
                        } elseif ($statement == 'I') {
                            $inherits_from_parent = true;
                        } elseif (!in_array($statement, ['OI', 'CI', 'IO', 'NP'])) {
                            if (($operator == '-') && (!$inherits_from_parent)) {
                                $permissions_negative[$statement] = true;
                            } elseif (($operator == '+') && (!$inherits_from_parent)) {
                                $permissions_positive[$statement] = true;
                            } elseif (($operator == '-') && ($inherits_from_parent)) {
                                $permissions_negative_inherited[$statement] = true;
                            } else {
                                $permissions_positive_inherited[$statement] = true;
                            }
                        }
                    }
                }

                if (array_key_exists($sid, $acl)) {
                    $acl[$sid][0] = array_merge($acl[$sid][0], $permissions_negative);
                    $acl[$sid][1] = array_merge($acl[$sid][1], $permissions_positive);
                    $acl[$sid][2] = array_merge($acl[$sid][2], $permissions_negative_inherited);
                    $acl[$sid][3] = array_merge($acl[$sid][3], $permissions_positive_inherited);
                    if ($inherits_from_parent) {
                        $acl[$sid][4] = true;
                    }
                } else {
                    $acl[$sid] = [$permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited, $inherits_from_parent/*if at least one rule is inherited from a parent*/];
                }
            }
        }

        return $acl;
    }

    /**
     * Find missing file permissions.
     *
     * @param  array $users Users to check for
     * @param  array $acl The ACL for the file
     * @param  integer $perms A bitmask of permissions that could be missing
     * @return array A tuple: A list of missing permissions, A list of problematic denys, Whether we will need to disable inheritance, Whether we will need to do a full 'reset', The SID we ended up using
     */
    protected function find_missing_file_perms(array $users, array $acl, int $perms) : array
    {
        $missing = [];
        $problematic_denys = [];
        $disable_inheritance = false;
        $do_reset = false;
        $sid_used = null;

        if (($perms & self::BITMASK_PERMISSIONS_READ) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if (!$this->has_read_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } elseif (!empty($permissions_involved)) {
                    $do_reset = true;
                    $problematic_denys = array_merge($problematic_denys, $permissions_involved);
                    if (!$this->has_read_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS)) {
                        $missing[] = 'R';
                    }
                } else {
                    $missing[] = 'R';
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if (!$this->has_write_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } elseif (!empty($permissions_involved)) {
                    $do_reset = true;
                    $problematic_denys = array_merge($problematic_denys, $permissions_involved);
                    if (!$this->has_write_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS)) {
                        $missing[] = 'W';
                    }
                } else {
                    $missing[] = 'W';
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if (!$this->has_execute_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } elseif (!empty($permissions_involved)) {
                    $do_reset = true;
                    $problematic_denys = array_merge($problematic_denys, $permissions_involved);
                    if (!$this->has_execute_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_CHECK_GRANTS)) {
                        $missing[] = 'X';
                    }
                } else {
                    $missing[] = 'X';
                }
            }
        }

        $missing = array_unique($missing);
        $problematic_denys = array_unique($problematic_denys);

        return [$missing, $problematic_denys, $disable_inheritance, $do_reset, $sid_used];
    }

    /**
     * Find excessive file permissions.
     *
     * @param  array $users Users to check for
     * @param  array $acl The ACL for the file
     * @param  integer $perms A bitmask of permissions that would excessive
     * @return array A tuple: A list of excessive permissions, Whether we will need to disable inheritance, Whether we will need to do a full 'reset', The SID we ended up using
     */
    protected function find_excessive_file_perms(array $users, array $acl, int $perms) : array
    {
        $excessive = [];
        $disable_inheritance = false;
        $do_reset = true;
        $sid_used = null;

        if (($perms & self::BITMASK_PERMISSIONS_READ) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if ($this->has_read_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_PARTIAL_ACCESS_CHECK | self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } else {
                    $do_reset = true;
                    $excessive = array_merge($excessive, $permissions_involved);
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_WRITE) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if ($this->has_write_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_PARTIAL_ACCESS_CHECK | self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } else {
                    $do_reset = true;
                    $excessive = array_merge($excessive, $permissions_involved);
                }
            }
        }

        if (($perms & self::BITMASK_PERMISSIONS_EXECUTE) != 0) {
            $permissions_involved = [];
            $due_to_inheritance = false;
            if ($this->has_execute_access($users, $acl, $permissions_involved, $due_to_inheritance, $sid_used, self::SCAN_PARTIAL_ACCESS_CHECK | self::SCAN_CHECK_GRANTS | self::SCAN_CHECK_DENYS)) {
                if ($due_to_inheritance) {
                    $disable_inheritance = true; // We will disable then re-scan
                } else {
                    $do_reset = true;
                    $excessive = array_merge($excessive, $permissions_involved);
                }
            }
        }

        $excessive = array_unique($excessive);

        return [$excessive, $disable_inheritance, $do_reset, $sid_used];
    }

    /**
     * Find if read access is set for the given ACL for the given user.
     *
     * @param  array $users Users to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $due_to_inheritance Whether the result given is due to inheritance, returned by reference
     * @param  ?string $sid_used The SID we ended up using, returned by reference (null: none)
     * @param  integer $check_flags The flags specifying how to do our checks
     * @return boolean Whether it is
     */
    protected function has_read_access(array $users, array $acl, array &$permissions_involved, bool &$due_to_inheritance, ?string &$sid_used, int $check_flags) : bool
    {
        $due_to_inheritance = false;
        $permissions_involved = [];

        foreach ($users as $sid) {
            if (!array_key_exists($sid, $acl)) {
                continue;
            }

            list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

            $partial_access_check = ($check_flags & self::SCAN_PARTIAL_ACCESS_CHECK) != 0;
            $check_grants = ($check_flags & self::SCAN_CHECK_GRANTS) != 0;
            $check_denys = ($check_flags & self::SCAN_CHECK_DENYS) != 0;

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_read_setting($permissions_negative, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_read_setting($permissions_positive, $permissions) : $this->_has_complete_read_setting($permissions_positive, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_read_setting($permissions_negative_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_read_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_read_setting($permissions_positive_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Find if partial read access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_read_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GR', 'R', 'RX', 'RD', 'RA', 'REA', 'RC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete read access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_read_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GR', 'R', 'RX', 'RD', 'RA', 'REA', 'RC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['F'])) || // Simple-Everything
            (isset($permissions['M'])) || // Simple-Modify
            (isset($permissions['GR'])) || // Generic-Read
            (isset($permissions['R'])) || // Simple-Read
            (isset($permissions['RX'])) || // Simple-Execute, which actually implies Simple-Read (Simple-Read won't save if Simple-Execute is already set)
            (isset($permissions['RD'])) && (isset($permissions['RA'])) && (isset($permissions['REA'])) && (isset($permissions['RC'])) // All specific needed (read data/list directory, read [extended] attributes, read control)
        );
    }

    /**
     * Find if write access is set for the given ACL for the given user.
     *
     * @param  array $users Users to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $due_to_inheritance Whether the result given is due to inheritance, returned by reference
     * @param  ?string $sid_used The SID we ended up using, returned by reference (null: none)
     * @param  integer $check_flags The flags specifying how to do our checks
     * @return boolean Whether it is
     */
    protected function has_write_access(array $users, array $acl, array &$permissions_involved, bool &$due_to_inheritance, ?string &$sid_used, int $check_flags) : bool
    {
        $due_to_inheritance = false;
        $permissions_involved = [];

        foreach ($users as $sid) {
            if (!array_key_exists($sid, $acl)) {
                continue;
            }

            list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

            $partial_access_check = ($check_flags & self::SCAN_PARTIAL_ACCESS_CHECK) != 0;
            $check_grants = ($check_flags & self::SCAN_CHECK_GRANTS) != 0;
            $check_denys = ($check_flags & self::SCAN_CHECK_DENYS) != 0;

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_write_setting($permissions_negative, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_write_setting($permissions_positive, $permissions) : $this->_has_complete_write_setting($permissions_positive, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_write_setting($permissions_negative_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_write_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_write_setting($permissions_positive_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Find if partial write access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_write_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GW', 'W', 'WD', 'WA', 'WEA', 'AD', 'D', 'DC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete write access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_write_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GW', 'W', 'WD', 'WA', 'WEA', 'AD', 'D', 'DC'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['F'])) || // Simple-Everything
            (isset($permissions['M'])) || // Simple-Modify
            (isset($permissions['GW'])) || // Generic-Write
            (isset($permissions['W'])) || // Simple-Write
            (isset($permissions['WD'])) && (isset($permissions['WA'])) && (isset($permissions['WEA'])) && (isset($permissions['AD'])) && (isset($permissions['D'])) && (isset($permissions['DC'])) // All specific needed (write data/add file, write [extended] attributes, append data/add subdirectory, delete, delete child)
        );
    }

    /**
     * Find if execute access is set for the given ACL for the given user.
     *
     * @param  array $users Users to check for
     * @param  array $acl The ACL for the file
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @param  boolean $due_to_inheritance Whether the result given is due to inheritance, returned by reference
     * @param  ?string $sid_used The SID we ended up using, returned by reference (null: none)
     * @param  integer $check_flags The flags specifying how to do our checks
     * @return boolean Whether it is
     */
    protected function has_execute_access(array $users, array $acl, array &$permissions_involved, bool &$due_to_inheritance, ?string &$sid_used, int $check_flags) : bool
    {
        $due_to_inheritance = false;
        $permissions_involved = [];

        foreach ($users as $sid) {
            if (!array_key_exists($sid, $acl)) {
                continue;
            }

            list($permissions_negative, $permissions_positive, $permissions_negative_inherited, $permissions_positive_inherited) = $acl[$sid];

            $partial_access_check = ($check_flags & self::SCAN_PARTIAL_ACCESS_CHECK) != 0;
            $check_grants = ($check_flags & self::SCAN_CHECK_GRANTS) != 0;
            $check_denys = ($check_flags & self::SCAN_CHECK_DENYS) != 0;

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_execute_setting($permissions_negative, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_execute_setting($permissions_positive, $permissions) : $this->_has_complete_execute_setting($permissions_positive, $permissions)) {
                    $due_to_inheritance = false;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }

            if ($check_denys) {
                $permissions = [];
                if ($this->_has_partial_execute_setting($permissions_negative_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    continue;
                }
            }

            if ($check_grants) {
                $permissions = [];
                if ($partial_access_check ? $this->_has_partial_execute_setting($permissions_positive_inherited, $permissions) : $this->_has_complete_execute_setting($permissions_positive_inherited, $permissions)) {
                    $due_to_inheritance = true;
                    $permissions_involved = $permissions;
                    $sid_used = $sid;
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Find if partial execute access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_partial_execute_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GE', 'RX', 'X'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }
        return !empty($permissions_involved);
    }

    /**
     * Find if complete execute access is set for the given ACE.
     *
     * @param  array $permissions The ACE
     * @param  array $permissions_involved A list of permissions involved, returned by reference
     * @return boolean Whether it is
     */
    protected function _has_complete_execute_setting(array $permissions, array &$permissions_involved) : bool
    {
        $possibilities = ['F', 'M', 'GE', 'RX', 'X'];
        foreach ($possibilities as $possibility) {
            if (isset($permissions[$possibility])) {
                $permissions_involved[] = $possibility;
            }
        }

        return (
            (isset($permissions['F'])) || // Simple-Everything
            (isset($permissions['M'])) || // Simple-Modify
            (isset($permissions['GE'])) || // Generic-List-Folder-Contents
            (isset($permissions['RX'])) || // Simple-List-Folder-Contents
            (isset($permissions['X'])) // All specific needed (execute/traverse)
        );
    }

    /**
     * Create an issue message about resetting permissions.
     *
     * @param  PATH $path The path the message is about
     * @param  string $sid The Sid the permissions are for
     * @return array A pair: The message, A command
     */
    protected function output_issue_reset(string $path, string $sid) : array
    {
        $message = 'Problematic: There are grants or denys we don\'t want for ' . $path . ' on ' . $sid . ', so we will now assume reset to a fresh state and put anything back we want or do not care about';
        $command = $this->generate_chmod_command($path, $sid, [], '+', true);

        return [$message, $command];
    }

    /**
     * Create an issue message about disabling inheritance.
     *
     * @param  PATH $path The path the message is about
     * @return array A pair: The message, A comman
     */
    protected function output_issue_disable_inheritance(string $path) : array
    {
        $message = 'Problematic: Permission inheritance is creating problems for us for ' . $path . ', so we will now advise disabling it and will henceforth assume it is disabled';
        $command = $this->generate_disable_inheritance_command($path);

        return [$message, $command];
    }

    /**
     * Create an issue message.
     *
     * @param  PATH $path The path the message is about
     * @param  integer $result_type A RESULT_TYPE_* constant
     * @param  string $operator The operator involved
     * @set + -
     * @param  string $sid The Sid the permission is for
     * @param  array $perms_involved The permissions the issue is about
     * @return array A pair: The message, A command (which may be null)
     */
    protected function output_issue(string $path, int $result_type, string $operator, string $sid, array $perms_involved) : array
    {
        $written_perms = $this->convert_permissions_to_written($perms_involved);

        switch ($result_type) {
            case self::RESULT_TYPE_SUGGESTION_MISSING:
                $message = $this->message_prefix('Suggestion') . 'Set additional permissions for ' . $path . ' (' . $sid . ': ' . $written_perms . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, $operator);
                break;

            case self::RESULT_TYPE_ERROR_MISSING:
                $message = $this->message_prefix('Error') . 'Set additional permissions for ' . $path . ' (' . $sid . ': ' . $written_perms . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, $operator);
                break;

            case self::RESULT_TYPE_SUGGESTION_EXCESSIVE:
                $message = $this->message_prefix('Suggestion') . 'Remove unnecessary permissions for ' . $path . ' (' . $sid . ': ' . $written_perms . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, $operator);
                break;

            case self::RESULT_TYPE_ERROR_EXCESSIVE:
                $message = $this->message_prefix('Error') . 'Remove dangerous permissions for ' . $path . ' (' . $sid . ': ' . $written_perms . ')';
                $command = $this->generate_chmod_command($path, $sid, $perms_involved, $operator);
                break;

            default:
                throw new Exception('Internal Error');
        }

        return [$message, $command];
    }

    /**
     * Convert permissions to written ones.
     *
     * @param  array $permissions Permissions
     * @return string Written permissions
     */
    protected function convert_permissions_to_written(array $permissions) : string
    {
        $written_perms = [];

        $possibilities = [
            'F' => 'Simple-Everything',
            'M' => 'Simple-Modify',
            'GR' => 'Generic-Read',
            'R' => 'Simple-Read',
            'RD' => 'Advanced-List-Folder/Read-Data',
            'RA' => 'Advanced-Read-Attributes',
            'REA' => 'Advanced-Read-Extended-Attributes',
            'RC' => 'Advanced-Read-Permissions',
            'GW' => 'Generic-Write',
            'W' => 'Simple-Write',
            'WD' => 'Advanced-Create-Files/Write-Data',
            'WA' => 'Advanced-Write-Attributes',
            'WEA' => 'Advanced-Write-Extended-Attributes',
            'AD' => 'Advanced-Create-Folders/Append-Data',
            'D' => 'Advanced-Delete',
            'DC' => 'Advanced-Delete-Subfolders-And-Files',
            'GE' => 'Generic-List-Folder-Contents',
            'RX' => 'Simple-List-Folder-Contents',
            'X' => 'Advanced-Traverse-Folder/Execute-File',
        ];

        foreach ($permissions as $permission) {
            $written_perms[] = $possibilities[$permission];
        }

        return implode(', ', $written_perms);
    }

    /**
     * Generate a chmod command from differential permissions.
     *
     * @param  PATH $path The path the command is for
     * @param  string $sid The user to apply to
     * @param  array $perms_involved Permissions to set
     * @param  string $operator Change operator
     * @set - +
     * @param  boolean $reset Reset permissions for the SID
     * @return string Chmod command
     */
    public function generate_chmod_command(string $path, string $sid, array $perms_involved, string $operator, bool $reset = false) : string
    {
        // https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls

        $cmd = ($operator == '+') ? 'grant' : 'deny';

        $command = 'icacls ' . escapeshellarg($path);
        if (!empty($perms_involved)) {
            $command .= ' /' . $cmd . ' ' . escapeshellarg($sid) . ':(' . implode(',', $perms_involved) . ')';
        }
        if ($reset) {
            $command .= ' /remove ' . escapeshellarg($sid);
        }

        return $command;
    }

    /**
     * Generate a command to remove permission inheritance.
     *
     * @param  PATH $path The path the command is for
     * @return string Chmod command
     */
    protected function generate_disable_inheritance_command(string $path) : string
    {
        return 'icacls ' . escapeshellarg($path) . ' /inheritancelevel:r';
    }
}
