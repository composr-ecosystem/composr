<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2021

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_webstandards
 */

/*EXTRA FUNCTIONS: pspell\_.+*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__webstandards2()
{
    if (!defined('CSS_AT_RULE_BLOCK')) {
        define('CSS_AT_RULE_BLOCK', -4);
        define('CSS_AT_RULE', -3);
        define('CSS_NO_MANS_LAND', -2);
        define('CSS_EXPECTING_IDENTIFIER', -1);
        define('CSS_IN_COMMENT', 0);
        define('CSS_IN_CLASS', 1);
        define('CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS', 2);
        define('CSS_IN_IDENTIFIER', 3);
        define('CSS_IN_PSEUDOCLASS_EXPRESSION', 6);

        define('_CSS_NO_MANS_LAND', 0);
        define('_CSS_IN_PROPERTY_KEY', 1);
        define('_CSS_IN_PROPERTY_BETWEEN', 2);
        define('_CSS_IN_PROPERTY_VALUE', 3);
        define('_CSS_IN_COMMENT', 4);
        define('_CSS_EXPECTING_END', 5);
    }
}

/**
 * Checks an XHTML tag for conformance, including attributes. Return the results.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @param  array $errors Errors detected so far. We will add to these and return
 * @return array List of errors
 *
 * @ignore
 */
function __check_tag(string $tag, array $attributes, bool $self_close, bool $close, array $errors) : array
{
    global $XML_CONSTRAIN, $TAG_STACK, $ATT_STACK, $TABS_SEEN, $KEYS_SEEN, $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_RANGES, $WEBSTANDARDS_CSP;

    // CSP violation
    if ($WEBSTANDARDS_CSP) {
        if (!$close) {
            if (($tag === 'script') && (empty($attributes['nonce']))) {
                $errors[] = ['CSP_SCRIPT_TAG'];
            }
            if (($tag === 'style') && (empty($attributes['nonce']))) {
                $errors[] = ['CSP_STYLE_TAG'];
            }
            if (($tag === 'link') && (empty($attributes['nonce'])) && (isset($attributes['rel'])) && ($attributes['rel'] == 'stylesheet')) {
                $errors[] = ['CSP_STYLE_TAG'];
            }

            foreach (array_keys($attributes) as $attribute) {
                if (substr($attribute, 0, 2) == 'on') {
                    $errors[] = ['CSP_EVENT_HANDLER'];
                }
            }
        }
    }

    // Dodgy mouse events.
    if ((isset($attributes['onclick'])) && (strpos($attributes['onclick'], '/*Access-note: checked*/') === false) && (strpos($attributes['onclick'], '/*Access-note: code has other activation*/') === false) && ((!isset($attributes['onmouseover'])) || (strpos($attributes['onmouseover'], 'activate_rich_semantic_tooltip') === false)) && (!isset($attributes['onkeypress'])) && (!isset($attributes['onkeydown'])) && (!isset($attributes['onkeyup'])) && (!in_array($tag, ['a', 'input', 'textarea', 'select', 'button']))) {
        $errors[] = ['WCAG_MOUSE_EVENT_UNMATCHED', 'onclick'];
    }
    if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
        if ((isset($attributes['onmouseover'])) && (strpos($attributes['onmouseover'], '/*Access-note: checked*/') === false) && (!isset($attributes['onfocus'])) && (in_array($tag, ['a', 'area', 'button', 'input', 'label', 'select', 'textarea']))) {
            $errors[] = ['WCAG_MOUSE_EVENT_UNMATCHED', 'onmouseover'];
        }
        if ((isset($attributes['onmouseout'])) && (strpos($attributes['onmouseout'], '/*Access-note: checked*/') === false) && (!isset($attributes['onblur'])) && (in_array($tag, ['a', 'area', 'button', 'input', 'label', 'select', 'textarea']))) {
            $errors[] = ['WCAG_MOUSE_EVENT_UNMATCHED', 'onmouseout'];
        }
    }

    // Unexpected tags
    if (($EXPECTING_TAG !== null) && ($EXPECTING_TAG != $tag)) {
        $errors[] = ['XHTML_EXPECTING', $EXPECTING_TAG];
    }
    $EXPECTING_TAG = null;

    // Note that we do NOT take into account display:inline, because the W3C one doesn't either - probably because 'display' implies not 'semantic'
    $tmp = _check_blockyness($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    // Look for unknown attributes, or bad values
    $tmp = _check_attributes($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    if (!$close) {
        // Check all required attributes are here
        global $TAG_ATTRIBUTES_REQUIRED;
        if ((isset($TAG_ATTRIBUTES_REQUIRED[$tag])) && (($tag != 'html') || ($XML_CONSTRAIN))) {
            $diff = array_diff($TAG_ATTRIBUTES_REQUIRED[$tag], array_keys($attributes));
            foreach ($diff as $attribute) {
                $errors[] = ['XHTML_MISSING_ATTRIBUTE', $tag, $attribute];
            }
        }

        // Iframes and CSS sheets need external checking
        if ($GLOBALS['WEBSTANDARDS_EXT_FILES']) {
            $tmp = _check_externals($tag, $attributes, $self_close, $close);
            if ($tmp !== null) {
                $errors = array_merge($errors, $tmp);
            }
        }

        // Check our links are OK
        if (($tag == 'a') && (isset($attributes['href']))) {
            if ((substr($attributes['href'], 0, 5) == 'mailto:') && (strpos($attributes['href'], '&') === false) && (strpos($attributes['href'], 'unsubscribe') !== false)) {
                $errors[] = ['XHTML_SPAM'];
            }
            $tmp = _check_link_accessibility($tag, $attributes, $self_close, $close);
            if ($tmp !== null) {
                $errors = array_merge($errors, $tmp);
            }
        }

        // Embed is a special case
        //if (($tag == 'embed') && (!$self_close)) $EXPECTING_TAG = 'noembed'; // noembed not valid in (X)HTML5

        if (($tag == 'fieldset') && (!$self_close)) {
            $EXPECTING_TAG = 'legend';
        }
    } else {
        if ($tag == 'a') {
            $LAST_A_TAG = $TAG_RANGES[count($TAG_RANGES) - 1][1];
        }
    }

    // Check our form labelling is OK
    $tmp = _check_labelling($tag, $attributes, $self_close, $close);
    if ($tmp !== null) {
        $errors = array_merge($errors, $tmp);
    }

    if (!$close) { // Intentionally placed after labelling is checked
        if (($tag == 'input') || ($tag == 'select')) {
            if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (isset($attributes['name'])) && (stripos($GLOBALS['OUT'], 'privacy') === false)) {
                $privacy = ['dob', 'name', 'age', 'address', 'date_of_birth', 'dateofbirth', 'email', 'e_mail', 'gender', 'salutation'];
                foreach ($privacy as $priv) {
                    if (stripos($attributes['name'], $priv) !== false) {
                        $errors[] = ['MANUAL_PRIVACY'];
                    }
                }
            }
        }

        switch ($tag) {
            case 'meta':
                if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (isset($attributes['name'])) && ($attributes['name'] == 'robots')) {
                    $errors[] = ['MANUAL_META'];
                }
                if ((isset($attributes['http-equiv'], $attributes['content'])) && (cms_strtolower_ascii($attributes['http-equiv']) == 'content-type') && ((strpos($attributes['content'], 'text/html;') !== false) || (strpos($attributes['content'], 'application/xhtml+xml;') !== false)) && (strpos($attributes['content'], 'charset=') !== false)) {
                    $GLOBALS['FOUND_CONTENTTYPE'] = true;
                }
                if (!empty($attributes['content'])) {
                    if ((isset($attributes['name'])) && ($attributes['name'] == 'keywords')) {
                        $GLOBALS['FOUND_KEYWORDS'] = true;
                    }
                    if ((isset($attributes['name'])) && ($attributes['name'] == 'description')) {
                        $GLOBALS['FOUND_DESCRIPTION'] = true;
                    }
                }
                break;

            case 'blockquote':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = ['MANUAL_WCAG_SEMANTIC_BLOCKQUOTE'];
                }
                break;

            case 'ul':
            case 'ol':
            case 'dl':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = ['MANUAL_WCAG_SEMANTIC_LIST'];
                }
                break;

            case 'script':
                if ($GLOBALS['WEBSTANDARDS_MANUAL']) {
                    $errors[] = ['MANUAL_WCAG_ANIMATION'];
                    $EXPECTING_TAG = 'noscript';
                }
                if (($GLOBALS['WEBSTANDARDS_JAVASCRIPT']) && ((!isset($attributes['type'])) || ((isset($attributes['type'])) && (($attributes['type'] == 'text/javascript') || ($attributes['type'] == 'application/javascript') || (($attributes['type'] == 'application/x-javascript')))))) { // Validate CSS
                    if (function_exists('require_code')) {
                        require_code('webstandards_js_lint');
                    }
                    $content = substr($OUT, $POS, strpos($OUT, '</script>', $POS) - $POS); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                    $content = preg_replace('#((<![CDATA[)|(]]>)|(<!--)|(-->))#', '', $content);
                    $js_conformance = check_js($content, true);
                    if (is_array($js_conformance)) {
                        $errors = array_merge($errors, $js_conformance); // Some kind of error
                    }
                }
                break;

            case 'style':
                if (($GLOBALS['WEBSTANDARDS_CSS']) && ((!isset($attributes['type'])) || ((isset($attributes['type'])) && ($attributes['type'] == 'text/css')))) { // Validate CSS
                    $content = substr($OUT, $POS, strpos($OUT, '</style>', $POS) - $POS); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                    $content = preg_replace('#((<![CDATA[)|(]]>)|(<!--)|(-->))#', '', $content);
                    $css_conformance = _webstandards_css_sheet($content);
                    if (is_array($css_conformance)) {
                        $errors = array_merge($errors, $css_conformance); // Some kind of error
                    }
                }
                break;

            case 'area':
                global $AREA_LINKS;
                if (isset($attributes['href'])) {
                    $AREA_LINKS[@html_entity_decode($attributes['href'], ENT_QUOTES)] = 1;
                }
                break;

            case 'base':
                global $URL_BASE;
                if (isset($attributes['href'])) {
                    $URL_BASE = @html_entity_decode($attributes['href'], ENT_QUOTES);
                }
                break;

            case 'form':
                if ((isset($attributes['action'])) && (strpos($attributes['action'], '?') !== false) && (isset($attributes['method'])) && ($attributes['method'] == 'get')) {
                    $errors[] = ['XHTML_FORM_TYPE'];
                }
                $GLOBALS['XHTML_FORM_ENCODING'] = isset($attributes['enctype']) ? $attributes['enctype'] : 'application/x-www-form-urlencoded';
                if ((isset($attributes['target'])) && ($attributes['target'] == '_blank') && ((!isset($attributes['title'])) || (strpos($attributes['title'], do_lang('LINK_NEW_WINDOW')) === false))) {
                    $errors[] = ['WCAG_BLANK'];
                }
                if (($GLOBALS['XHTML_FORM_ENCODING'] == 'multipart/form-data') && (array_key_exists('method', $attributes)) && ($attributes['method'] == 'get')) {
                    $errors[] = ['XHTML_FORM_ENCODING_2'];
                }
                // no break

            case 'map':
            case 'iframe':
            case 'object': // Check that our 'name' attributes for frames etc are unique between selves and against IDs
                if (isset($attributes['name'])) {
                    global $ANCHORS_SEEN;
                    if (isset($ANCHORS_SEEN[$attributes['name']])) {
                        $errors[] = ['XHTML_A_NAME', $tag];
                    } else {
                        $ANCHORS_SEEN[$attributes['name']] = 1;
                    }

                    if ((!isset($attributes['id'])) || ((isset($attributes['id'])) && ($attributes['id'] != $attributes['name']))) {
                        $errors[] = ['XHTML_NAME_ID_DEPRECATED'];
                    }
                }
                break;

            case 'input':
                if (isset($attributes['type'])) {
                    // Special case for missing 'name' in form elements
                    if (($attributes['type'] != 'image') && ($attributes['type'] != 'submit') && ($attributes['type'] != 'button') && ($attributes['type'] != 'reset')) {
                        if (!isset($attributes['name'])) {
                            $errors[] = ['XHTML_MISSING_ATTRIBUTE', $tag, 'name'];
                        }
                    }

                    if ((isset($attributes['size'], $attributes['type'])) && (($attributes['type'] == 'week') || ($attributes['type'] == 'hidden')/* || ($attributes['type'] == 'color') || ($attributes['type'] == 'number') Size would apply if browser is using non-HTML5 fallback*/ || ($attributes['type'] == 'month') || ($attributes['type'] == 'range') || ($attributes['type'] == 'radio') || ($attributes['type'] == 'checkbox'))) {
                        $errors[] = ['XHTML_NO_SIZE_FOR'];
                    }

                    if (($attributes['type'] == 'image') && (!isset($attributes['alt']))) {
                        $errors[] = ['XHTML_MISSING_ATTRIBUTE', 'input', 'alt'];
                    }

                    if (($attributes['type'] == 'checkbox') && (isset($attributes['id']))) {
                        $pre_content = substr($OUT, 0, $POS);
                        if (preg_match('#<label for="' . preg_quote($attributes['id'], '#') . '">[^:]+<input[^<>]+id="' . preg_quote($attributes['id'], '#') . '"#', $pre_content) != 0) {
                            //$errors[] = ['ACCESSIB_COLONS_IN_PRE_LABELS'];   Over-prescriptive
                        }
                    }

                    if ($attributes['type'] == 'file') {
                        if (isset($attributes['value'])) {
                            $errors[] = ['XHTML_FILE_VALUE'];
                        }
                        if (($GLOBALS['XHTML_FORM_ENCODING'] != 'multipart/form-data') && ($GLOBALS['XHTML_FORM_ENCODING'] != '')) {
                            $errors[] = ['XHTML_FORM_ENCODING'];
                        }
                    }
                }
                break;

            case 'select':
                $webstandards_check = function_exists('get_param_integer') ? get_param_integer('keep_webstandards_check', get_param_integer('webstandards_check', 0)) : 0;
                if ((isset($attributes['onchange'])) && (strpos($attributes['onchange'], 'form.submit()') !== false) && (strpos($attributes['onchange'], '/*guarded*/') === false) && ($webstandards_check == 0)) {
                    //$errors[] = ['WCAG_AUTO_SUBMIT_LIST']; Outdated, active JS now expected
                }
                break;

            case 'table':
                if (!isset($attributes['class']) || (strpos($attributes['class'], 'layout-table') === false)) {
                    $content = cms_strtolower_ascii(substr($OUT, $POS, strpos($OUT, '</table>', $POS) - $POS)); // While the </table> found may not be the closing tag to our table, we do know a <th> should occur before any such one (unless it's a really weird table layout)
                    $th_count = substr_count($content, '<th');
                    if (($th_count == 0) && (trim($content) != 'x')) {
                        $errors[] = ['WCAG_MISSING_TH'];
                    } else {
                        if (strpos($content, '<thead') === false) {
                            $tr_count = substr_count($content, '<tr');
                            if ($th_count > $tr_count) {
                                $errors[] = ['WCAG_HD_SPECIAL'];
                            }
                        }
                    }
                }
                break;

            case 'thead':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }
                break;

            case 'tfoot':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }
                break;

            case 'th':
                $array_pos = array_search('table', array_reverse($TAG_STACK));
                if ($array_pos !== false) {
                    $array_pos = count($TAG_STACK) - $array_pos - 1;
                }

                /* We used to enforce th length for accessibility, but this is impractical since 'abbr' attribute was dropped in HTML5
                if (!isset($attributes['abbr'])) {
                    $content = trim(substr($OUT, $POS, strpos($OUT, '</th>', $POS) - $POS)); // This isn't perfect - In theory a th could contain a table itself: but it's not very semantic if it does
                    if (strlen(trim(@html_entity_decode(strip_tags($content), ENT_QUOTES))) > 40) {
                        $errors[] = ['WCAG_TH_TOO_LONG'];
                    }
                }
                */
                break;

            case 'a':
                // Handle empty tag check for <a> (couldn't handle with normal case due to complexity)
                if ((!isset($attributes['id'])) && (!isset($attributes['title'])) && (substr($OUT, $POS, 4) == '</a>')) {
                    $errors[] = ['XHTML_EMPTY_TAG', $tag];
                }
                break;

            case 'img':
                if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (!isset($attributes['width']))) {
                    $errors[] = ['XHTML_WIDTH'];
                }
                if ((isset($attributes['longdesc'])) && (!isset($attributes['dlink']))) {
                    $errors[] = ['WCAG_LONGTEXT_DLINK'];
                }
                if ((isset($attributes['alt'], $attributes['src'])) && ($attributes['alt'] != '') && ($attributes['alt'] == $attributes['src'])) {
                    $errors[] = ['XHTML_MISSING_ATTRIBUTE', 'img', 'alt'];
                }
                break;
        }

        /*if (($tag[0]=='h') && (is_numeric(substr($tag,1))))   Excessive check, heading order gaps are okay as long as order is still logical
        {
            global $LAST_HEADING;
            if ($LAST_HEADING < intval(substr($tag, 1)) - 1) {
                $errors[] = ['WCAG_HEADING_ORDER'];
            }
            $LAST_HEADING = intval(substr($tag, 1));
        }*/

        if (isset($attributes['accesskey'])) {
            $this_href = isset($attributes['href']) ? $attributes['href'] : uniqid('', true);
            if ((isset($KEYS_SEEN[$attributes['accesskey']])) && ($KEYS_SEEN[$attributes['accesskey']] != $this_href)) {
                $errors[] = ['WCAG_ACCESSKEY_UNIQUE'];
            }
            $KEYS_SEEN[$attributes['accesskey']] = $this_href;
        }
        if (isset($attributes['tabindex'])) {
            if ((in_array($attributes['tabindex'], $TABS_SEEN)) && ($attributes['tabindex'] != 'x')) {
                $last = array_pop($TABS_SEEN);
                if ($last != $attributes['tabindex']) { // We do allow repeating of tabindexes as long as they are next to each other
                    $errors[] = ['WCAG_TABINDEX_UNIQUE'];
                } else {
                    array_push($TABS_SEEN, $last);
                }
            }
            $TABS_SEEN[] = $attributes['tabindex'];
        }
    }

    return $errors;
}

/**
 * Checks a tag's inline/block/normal nesting situations.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?array Array of errors (null: none)
 * @ignore
 */
function _check_blockyness(string $tag, array $attributes, bool $self_close, bool $close) : ?array
{
    global $THE_DOCTYPE, $BLOCK_CONSTRAIN, $XML_CONSTRAIN, $TAGS_DEPRECATE_ALLOW, $PARENT_TAG, $TAGS_INLINE, $TAGS_BLOCK, $TAGS_NORMAL, $TAGS_INLINE_DEPRECATED, $TAGS_BLOCK_DEPRECATED, $TAGS_NORMAL_DEPRECATED, $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $UNDER_XMLNS;

    $errors = [];

    $dif = $close ? -1 : 1;
    if ($self_close) {
        $dif = 0;
    }
    if ((isset($TAGS_BLOCK[$tag])) || (isset($TAGS_BLOCK_DEPRECATED[$tag]))) {
        if ((!empty($ANCESTOR_INLINE)) && ($BLOCK_CONSTRAIN) && (!$close)) {
            $errors[] = ['XHTML_ANCESTOR_BLOCK_INLINE', $tag, array_peek($ANCESTOR_INLINE)];
        }
        if ($dif == 1) {
            array_push($ANCESTOR_BLOCK, $tag);
        } elseif ($dif == -1) {
            array_pop($ANCESTOR_BLOCK);
        }
        if (isset($TAGS_BLOCK_DEPRECATED[$tag])) {
            $errors[] = [$TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag];
        }
    } elseif ((isset($TAGS_INLINE[$tag])) || (isset($TAGS_INLINE_DEPRECATED[$tag]))) {
        //if (($BLOCK_CONSTRAIN) && ($PARENT_TAG != 'span') && ((isset($TAGS_NORMAL[$PARENT_TAG])) || ((isset($TAGS_NORMAL_DEPRECATED[$PARENT_TAG]))))) $errors[] = ['XHTML_ANCESTOR_INLINE_NORMAL', $tag]; This restriction isn't really a proper one, some checkers seem to have it but it is not used anymore (XHTML5+) and pretty silly
        if (($tag !== 'label') && ($tag !== 'a')) { // We don't count <a> as an inline ancestor as although it's an inline element, its Content model is defined as "Transparent" in HTML5 - which means it inherits the Content model of its parent.
            if ($dif == 1) {
                array_push($ANCESTOR_INLINE, $tag);
            } elseif ($dif == -1) {
                array_pop($ANCESTOR_INLINE);
            }
        }
        if (isset($TAGS_INLINE_DEPRECATED[$tag])) {
            $errors[] = [$TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag];
        }
    } elseif ((isset($TAGS_NORMAL[$tag])) || (isset($TAGS_NORMAL_DEPRECATED[$tag]))) {
        if ($tag == 'title') {
            if ($dif == 1) {
                array_push($ANCESTOR_BLOCK, $tag);
            } elseif ($dif == -1) {
                array_pop($ANCESTOR_BLOCK);
            }
        }
        if (($tag == 'iframe') && (($THE_DOCTYPE == DOCTYPE_XHTML_STRICT) || ($THE_DOCTYPE == DOCTYPE_XHTML_11))) {
            $errors[] = ['XHTML_UNKNOWN_TAG', $tag];
        }
        if (isset($TAGS_NORMAL_DEPRECATED[$tag])) {
            $errors[] = [$TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_TAG' : 'XHTML_UNKNOWN_TAG', $tag];
        }
    } elseif (!$close) {
        if ($UNDER_XMLNS == 0) {
            $errors[] = ['XHTML_UNKNOWN_TAG', $tag];
        }
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks a tag's attributes.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?array Array of errors (null: none)
 * @ignore
 */
function _check_attributes(string $tag, array $attributes, bool $self_close, bool $close) : ?array
{
    global $PSPELL_LINK, $THE_LANGUAGE, $XML_CONSTRAIN, $TAGS_DEPRECATE_ALLOW, $THE_DOCTYPE, $HYPERLINK_URLS, $CRAWLED_URLS, $EMBED_URLS, $TAGS_INLINE, $TAGS_BLOCK, $TAGS_NORMAL, $TAGS_INLINE_DEPRECATED, $TAGS_BLOCK_DEPRECATED, $TAGS_NORMAL_DEPRECATED, $TAG_ATTRIBUTES, $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_ATTRIBUTES_REQUIRED, $WEBSTANDARDS_CHECKER_OFF;

    $errors = [];

    $stub = $tag . '.';
    foreach ($attributes as $attribute => $value) {
        $lattribute = cms_strtolower_ascii($attribute);
        if ($lattribute != $attribute) {
            if ($XML_CONSTRAIN) {
                $errors[] = ['XHTML_CASE_ATTRIBUTE', $tag, $attribute];
            }
            $attribute = $lattribute;
        }

        if (($attribute == 'lang') || ($attribute == 'xml:lang')) {
            $THE_LANGUAGE = $value;
        }

        if (($GLOBALS['WEBSTANDARDS_MANUAL']) && (($value == 'TODO') || (strpos($value, 'Lorem ') !== false))) {
            $errors[] = ['XHTML_PLACEHOLDER'];
        }

        if ((!isset($TAG_ATTRIBUTES[$stub . $attribute])) && (!isset($TAG_ATTRIBUTES['*.' . $attribute])) && (!isset($TAG_ATTRIBUTES_REQUIRED[$stub . $attribute]))) {
            if ((!isset($TAGS_BLOCK[$tag])) && (!isset($TAGS_INLINE[$tag])) && (!isset($TAGS_NORMAL[$tag]))) {
                continue;
            }
            if ((!isset($TAGS_BLOCK_DEPRECATED[$tag])) && (!isset($TAGS_INLINE_DEPRECATED[$tag])) && (!isset($TAGS_NORMAL_DEPRECATED[$tag]))) {
                continue;
            }
            if (strpos($attribute, ':') !== false) {
                continue;
            }
            if (substr($attribute, 0, 5) == 'data-') {
                continue;
            }

            if ($tag == 'embed') {
                continue;
            }

            $errors[] = ['XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute];
            continue;
        } else {
            if (isset($TAG_ATTRIBUTES_REQUIRED[$stub . $attribute])) {
                $errors[] = [$TAGS_DEPRECATE_ALLOW ? 'XHTML_DEPRECATED_ATTRIBUTE' : 'XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute];
            }

            if (($attribute == 'target') && (($THE_DOCTYPE == DOCTYPE_XHTML_STRICT) || ($THE_DOCTYPE == DOCTYPE_XHTML_11))) {
                $errors[] = ['XHTML_UNKNOWN_ATTRIBUTE', $tag, $attribute];
            }
        }

        if ((($attribute == 'alt') || ($attribute == 'title') || (($attribute == 'content') && (array_key_exists('http-equiv', $attributes)) && ((cms_strtolower_ascii($attributes['http-equiv']) == 'description') || (cms_strtolower_ascii($attributes['http-equiv']) == 'keywords')))) && (function_exists('pspell_new')) && (!empty($GLOBALS['FLAG__SPELLING'])) && ($value != '')) {
            $errors = array_merge($errors, check_spelling(clean_simple_html_for_spellcheck($value)));
        }

        //if (($attribute == 'alt') && ($tag != 'input') && (strlen(strip_tags($value)) > 150)) $errors[] = ['WCAG_ATTRIBUTE_TOO_LONG', $attribute];

        if (($attribute == 'href') || ($attribute == 'src') || (($attribute == 'data') && ($tag == 'object'))) {
            $CRAWLED_URLS[] = @html_entity_decode($value, ENT_QUOTES);
            if ($tag == 'a') {
                $HYPERLINK_URLS[] = @html_entity_decode($value, ENT_QUOTES);
            }
        }
        if ((($attribute == 'src') && ($tag == 'embed')) || (($attribute == 'src') && ($tag == 'script')) || (($attribute == 'src') && ($tag == 'iframe')) || (($attribute == 'src') && ($tag == 'img')) || (($attribute == 'href') && ($tag == 'link') && (isset($attributes['rel'])) && ($attributes['rel'] == 'stylesheet')) || (($attribute == 'data') && ($tag == 'object')) || (($attribute == 'code') && ($tag == 'applet'))) {
            $EMBED_URLS[] = @html_entity_decode($value, ENT_QUOTES);
        }

        if (($attribute == 'href') && (@cms_strtolower_ascii(@$value[0]) == 'j') && (cms_strtolower_ascii(substr($value, 0, 11)) == 'javascript:')) {
            $errors[] = ['XHTML_BAD_ATTRIBUTE_VALUE', $attribute, $value, 'no js href'];
        }

        if (isset($TAG_ATTRIBUTES[$stub . $attribute])) {
            $reg_exp = $TAG_ATTRIBUTES[$stub . $attribute];
        } else {
            $reg_exp = $TAG_ATTRIBUTES['*.' . $attribute];
        }

        if (($reg_exp != '(.|\n)*') && (preg_match('#^' . $reg_exp . '$#s', $value) == 0) && ($value != 'x')) {
            $errors[] = ['XHTML_BAD_ATTRIBUTE_VALUE', $attribute, $value, $reg_exp];
        }

        if (($attribute == 'style') && ($WEBSTANDARDS_CHECKER_OFF === null) && ($GLOBALS['WEBSTANDARDS_CSS'])) { // Validate CSS
            if ((!function_exists('do_template')) && (strpos($value, '{') === false) && (strpos($value, 'float:') === false) && (strpos($value, ': none') === false) && (strpos($value, ': inline') === false) && (strpos($value, ': block') === false)) {
                $errors[] = ['CSS_INLINE_STYLES'];
            }

            $css_conformance = _webstandards_css_class($value, 0);
            if (is_array($css_conformance)) {
                $errors = array_merge($errors, $css_conformance); // Some kind of error
            }
        }

        if ($attribute == 'id') { // Check we don't have duplicate IDs
            if (isset($IDS_SO_FAR[cms_strtolower_ascii($value)])) { // cms_strtolower_ascii is for compatibility - in reality, IDs are not meant to be case insensitive
                $errors[] = ['XHTML_DUPLICATED_ID', $value];
            }
            $IDS_SO_FAR[cms_strtolower_ascii($value)] = 1;
        }
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks the spelling of some text.
 *
 * @param  string $value The text
 * @return array Array of errors
 */
function check_spelling(string $value) : array
{
    global $THE_LANGUAGE;
    $lang = cms_strtolower_ascii($THE_LANGUAGE);

    require_code('spelling');
    if (!defined('WORD_REGEXP')) {
        init__spelling();
    }
    $misspellings = run_spellcheck($value, $lang, false, false, false);
    spellchecker_shutdown();

    $errors = [];
    foreach (array_keys($misspellings) as $word) {
        $errors[] = ['XHTML_SPELLING', $word];
    }
    return $errors;
}

/**
 * Checks the content under a tag's external references.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?array Array of errors (null: none)
 * @ignore
 */
function _check_externals(string $tag, array $attributes, bool $self_close, bool $close) : ?array
{
    if ((function_exists('get_param_integer')) && (get_param_integer('keep_ext_check', null) === 0)) {
        return null;
    }

    unset($self_close);
    unset($close);

    global $VALIDATED_ALREADY, $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG;

    $errors = [];

    if (($tag == 'link') && ($GLOBALS['WEBSTANDARDS_CSS']) && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (isset($attributes['href'], $attributes['type'])) && ($attributes['type'] == 'text/css') && (!isset($VALIDATED_ALREADY[$attributes['href']]))) { // Validate CSS
        $VALIDATED_ALREADY[$attributes['href']] = 1;
        $url = qualify_url($attributes['href'], $GLOBALS['URL_BASE']);
        if ($url != '') {
            $sheet = http_get_contents($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false]);
            if ($sheet !== null) {
                $css_conformance = _webstandards_css_sheet($sheet);
                if (is_array($css_conformance)) {
                    $errors = array_merge($errors, $css_conformance); // Some kind of error
                }
            }
        }
    }

    if (($GLOBALS['WEBSTANDARDS_JAVASCRIPT']) && ($tag == 'script') && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (isset($attributes['src'])) && ((!isset($attributes['type'])) || (isset($attributes['type'])) && (($attributes['type'] == 'text/javascript') || ($attributes['type'] == 'application/javascript') || ($attributes['type'] == 'application/x-javascript'))) && (!isset($VALIDATED_ALREADY[$attributes['src']]))) { // Validate CSS
        $VALIDATED_ALREADY[$attributes['src']] = 1;
        $url = qualify_url($attributes['src'], $GLOBALS['URL_BASE']);
        if (!empty($url)) {
            $js = http_get_contents($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false]);
            if ($js !== null) {
                $VALIDATED_ALREADY[$attributes['src']] = 1;

                if (function_exists('require_code')) {
                    require_code('webstandards_js_lint');
                }
                $js_conformance = check_js($js, true);
                if (is_array($js_conformance)) {
                    $errors = array_merge($errors, $js_conformance); // Some kind of error
                }
            }
        }
    }

    if (($tag == 'iframe') && (!empty($attributes['src'])) && (!$GLOBALS['NO_XHTML_LINK_FOLLOW']) && (!isset($VALIDATED_ALREADY[$attributes['src']]))) { // Validate iframe's
        $VALIDATED_ALREADY[$attributes['src']] = 1;
        $url = qualify_url($attributes['src'], $GLOBALS['URL_BASE']);
        if ($url != '') {
            $iframe = cms_http_request($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false]); // Sometimes disabled due to my iframe producing a weird PHP exception, that was stopping me working
            if (!empty($iframe->data)) {
                if (($iframe->download_mime_type == 'text/html') || ($iframe->download_mime_type == 'application/xhtml+xml')) {
                    global $EXTRA_CHECK;
                    $EXTRA_CHECK[] = $iframe;
                }
            }
        }
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks link accessibility.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?array Array of errors (null: none)
 * @ignore
 */
function _check_link_accessibility(string $tag, array $attributes, bool $self_close, bool $close) : ?array
{
    global $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG, $TAG_RANGES, $WEBSTANDARDS_MANUAL;

    $errors = [];

    require_code('global4');

    // Check captioning
    global $A_LINKS;
    if (!isset($attributes['title'])) {
        $title = '';
    } else {
        $title = $attributes['title'];
    }
    $content = cms_mb_strtolower(substr($OUT, $POS, strpos($OUT, '</a>', $POS) - $POS));
    if ((isset($attributes['target'])) && ($attributes['target'] == '_blank') && (function_exists('do_lang')) && (strpos($content, do_lang('LINK_NEW_WINDOW')) === false) && (strpos($title, do_lang('LINK_NEW_WINDOW')) === false)) {
        $errors[] = ['WCAG_BLANK'];
    }
    if (substr($content, 0, 4) != '<img') {
        $filtered_href = str_replace('/index.php', '', $attributes['href']);
        $filtered_href = preg_replace('#&keep_session=[^&]*#', '', $filtered_href);

        if (($WEBSTANDARDS_MANUAL) && (isset($A_LINKS[$title], $A_LINKS[$title][$content])) && ($A_LINKS[$title][$content] != $attributes['href']) && ($A_LINKS[$title][$content] != $filtered_href)) {
            $errors[] = ['WCAG_DODGY_LINK', $A_LINKS[$title][$content]];
        }
        $bad_strings = ['click'/*,'here'*/];
        if (trim($content) != $content) {
            $errors[] = ['XHTML_A_SPACES'];
        }
        $_content = strip_tags($content);
        if (($_content == $content) && (strlen($content) < 12)) {
            $in_strings = cms_mb_str_word_count($_content, 1);
            foreach ($bad_strings as $string) {
                if (in_array($string, $in_strings) !== false) {
                    $errors[] = ['WCAG_DODGY_LINK_2', $string];
                }
            }
        }
        if ($title == '') {
            if (cms_mb_strtolower($content) == 'more') {
                $errors[] = ['WCAG_DODGY_LINK_2', $string];
            }
        }
        $A_LINKS[$title][$content] = $filtered_href;
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks form field labelling.
 *
 * @param  string $tag The name of the tag to check
 * @param  array $attributes A map of attributes (name=>value) the tag has
 * @param  boolean $self_close Whether this is a self-closing tag
 * @param  boolean $close Whether this is a closing tag
 * @return ?array Array of errors (null: none)
 * @ignore
 */
function _check_labelling(string $tag, array $attributes, bool $self_close, bool $close) : ?array
{
    global $TAG_STACK, $IDS_SO_FAR, $ANCESTOR_BLOCK, $ANCESTOR_INLINE, $EXPECTING_TAG, $OUT, $POS, $LAST_A_TAG;

    $errors = [];

    global $FOR_LABEL_IDS, $FOR_LABEL_IDS_2, $INPUT_TAG_IDS;
    if (($tag == 'td')/* || ($tag == 'div')*/) {
        //$FOR_LABEL_IDS = []; // Can't work across table cells      Actually this is an ancient and lame restriction that hurts accessibility more than helping it
    }
    if (($tag == 'label') && (isset($attributes['for']))) {
        $FOR_LABEL_IDS[$attributes['for']] = 1;
        $FOR_LABEL_IDS_2[$attributes['for']] = 1;
    } elseif ((!$close) && (($tag == 'textarea') || ($tag == 'select') || (($tag == 'input') && ((!isset($attributes['type'])) || (($attributes['type'] != 'hidden') && ($attributes['type'] != 'button') && ($attributes['type'] != 'image') && ($attributes['type'] != 'reset') && ($attributes['type'] != 'submit')))))) {
        // Check we that all input tags have labels...

        if (isset($attributes['id'])) {
            $INPUT_TAG_IDS[$attributes['id']] = 1;
        }

        if ((!isset($attributes['style'])) || (($attributes['style'] != 'display:none') && ($attributes['style'] != 'display: none'))) {
            if ($tag == 'input') {
                if (!isset($attributes['type'])) {
                    return null;
                }

                if ((($attributes['type'] == 'radio') || ($attributes['type'] == 'checkbox')) && (isset($attributes['onchange'])) && ($GLOBALS['WEBSTANDARDS_COMPAT'])) {
                    $errors[] = ['XHTML_IE_ONCHANGE'];
                }
            }

            if (!isset($attributes['id'])) {
                $attributes['id'] = 'unnamed_' . strval(mt_rand(0, mt_getrandmax()));
            }

            if ((!isset($FOR_LABEL_IDS[$attributes['id']])) && ($attributes['id'] != 'x') && (preg_match('#<label[^<>]+for="' . preg_quote($attributes['id'], '#') . '"#', $OUT) == 0)) {
                $errors[] = ['WCAG_NO_INPUT_LABEL', $attributes['id']];
            }
        }
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks a CSS style sheet (high level).
 *
 * @param  string $data The data of the style sheet
 * @return array Parse information
 */
function check_css(string $data) : array
{
    $_errors = _webstandards_css_sheet($data);
    if ($_errors === null) {
        $_errors = [];
    }
    $errors = [];
    global $POS, $OUT;
    $POS = 0;
    $LINENO = 0;
    $LINESTART = 0;
    global $CSS_TAG_RANGES, $CSS_VALUE_RANGES;
    $OUT = $data;

    foreach ($_errors as $error) {
        $POS = 0;
        $errors[] = _xhtml_error($error[0], array_key_exists(1, $error) ? $error[1] : '', array_key_exists(2, $error) ? $error[2] : '', array_key_exists(3, $error) ? $error[3] : '', false, $error['pos']);
    }
    return ['level_ranges' => null, 'tag_ranges' => $CSS_TAG_RANGES, 'value_ranges' => $CSS_VALUE_RANGES, 'errors' => $errors];
}

/**
 * Checks a CSS style sheet.
 *
 * @param  string $data The data of the style sheet
 * @return ?array Error information (null: no error)
 * @ignore
 */
function _webstandards_css_sheet(string $data) : ?array
{
    global $CSS_TAG_RANGES, $CSS_VALUE_RANGES, $VALIDATED_ALREADY;
    $CSS_TAG_RANGES = [];
    $CSS_VALUE_RANGES = [];

    $errors = [];

    // We don't want to write code to parse out property referencing stuff which is very irregular compared to other CSS, so let's just simplify that to something else
    $data = preg_replace('#\[([\w\-]+|)?[\w\-]+([$*~|^]?="[^;"]*")?\]#', '.foobar', $data);

    $len = strlen($data);
    $status = CSS_NO_MANS_LAND;
    $line = 0;
    $class_before_comment = null;
    $class = '';
    $at_rule = '';
    $at_rule_block = '';
    $brace_level = 0;
    $i = 0;
    $class_start_line = null;
    $class_start_i = null;
    $class_name = '';
    $in_comment = false;
    $quoting = false;
    while ($i < $len) {
        $next = $data[$i];
        $val = ord($next);
        if (($next == '_') || ($next == '.') || ($next == '-') || (($val >= 65) && ($val <= 90)) || (($val >= 97) && ($val <= 122)) || (($val >= 48) && ($val <= 57))) {
            $alpha_numeric = true;
            $whitespace = false;
            $comment_starting = false;
        } else {
            $alpha_numeric = false;
            $whitespace = (($next == "\t") || ($val == 13) || ($val == 10) || ($next == ' '));
            $comment_starting = (($next == '/') && ($i < $len - 2) && ($data[$i + 1] == '*'));
        }

        switch ($status) {
            case CSS_AT_RULE:
                if ($next == '{') {
                    $brace_level = 0;
                    $status = CSS_AT_RULE_BLOCK;
                    $at_rule_block = '';
                } elseif ($next == ';') {
                    $matches = [];
                    if (preg_match('#^(\w+)\s*$#', $at_rule, $matches) != 0) {
                        global $CSS_AT_RULES;
                        if (!in_array($matches[1], $CSS_AT_RULES)) {
                            $errors[] = [0 => 'CSS_UNKNOWN_AT_RULE', 1 => $matches[1], 2 => integer_format($line), 'pos' => $i];
                        }
                    }

                    $status = CSS_NO_MANS_LAND;
                    if (preg_match('#^(import)\s*#', $at_rule, $matches) != 0) { // Contains regular CSS, which we will validate
                        $count = substr_count($at_rule, '"');
                        $first = strpos($at_rule, '"') + 1;
                        if ($count < 2) {
                            $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                            return $errors;
                        }
                        $at_file = substr($at_rule, $first, (strpos($at_rule, '"', $first) - 1) - $first);
                        if (!isset($VALIDATED_ALREADY[$at_file])) {
                            $at_file = qualify_url($at_file, $GLOBALS['URL_BASE']);
                            if ($at_file != '') {
                                $data2 = http_get_contents($at_file, ['convert_to_internal_encoding' => true, 'trigger_error' => false]);
                                if ($data2 !== null) {
                                    $css_tag_ranges_backup = $CSS_TAG_RANGES;
                                    $css_value_ranges_backup = $CSS_VALUE_RANGES;
                                    $test = _webstandards_css_sheet($data2);
                                    $CSS_TAG_RANGES = $css_tag_ranges_backup;
                                    $CSS_VALUE_RANGES = $css_value_ranges_backup;
                                    if (is_array($test)) {
                                        foreach ($test as $error) {
                                            $error['pos'] = $i;
                                            $errors[] = $error;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // We don't explicitly support validating other @-rules (#3928)
                } else {
                    $at_rule .= $next;
                }
                break;

            case CSS_AT_RULE_BLOCK:
                if ($next == '{') {
                    ++$brace_level;
                    $at_rule_block .= $next;
                } elseif ($next == '}') {
                    if ($brace_level == 0) {
                        if (preg_match('#^(media)\s*$#', $at_rule, $matches) != 0) { // Contains regular CSS, which we will validate
                            $css_tag_ranges_backup = $CSS_TAG_RANGES;
                            $css_value_ranges_backup = $CSS_VALUE_RANGES;
                            $test = _webstandards_css_sheet($at_rule_block);
                            $CSS_TAG_RANGES = $css_tag_ranges_backup;
                            $CSS_VALUE_RANGES = $css_value_ranges_backup;
                            if (is_array($test)) {
                                foreach ($test as $error) {
                                    $error['pos'] = $i;
                                    $errors[] = $error;
                                }
                            }
                        }
                        // We don't explicitly support validating other @-rules (#3928)

                        $matches = [];
                        if (preg_match('#^(\w+)\s*$#', $at_rule, $matches) != 0) {
                            global $CSS_AT_BLOCK_RULES;
                            if (!in_array($matches[1], $CSS_AT_BLOCK_RULES)) {
                                $errors[] = [0 => 'CSS_UNKNOWN_AT_BLOCK_RULE', 1 => $matches[1], 2 => integer_format($line), 'pos' => $i];
                            }
                        }

                        $status = CSS_NO_MANS_LAND;
                    } else {
                        $brace_level--;
                        $at_rule_block .= $next;
                    }
                } else {
                    $at_rule_block .= $next;
                }
                break;

            case CSS_NO_MANS_LAND:
                if ($whitespace) {
                    // Continuing
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = $next;
                } elseif ($next == '@') {
                    $status = CSS_AT_RULE;
                    $at_rule = '';
                } elseif ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_NO_MANS_LAND;
                } elseif ($next == '*') {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = '*';
                } else {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                }
                break;

            case CSS_EXPECTING_IDENTIFIER:
                if ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_EXPECTING_IDENTIFIER;
                } elseif ($whitespace) {
                    // Continuing
                } elseif ($next == '*') {
                    $status = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = $next;
                } else {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                }
                break;

            case CSS_IN_COMMENT:
                if (($next == '*') && ($i != $len - 1) && ($data[$i + 1] == '/')) {
                    $status = $class_before_comment;
                    ++$i;
                }
                break;

            case CSS_IN_PSEUDOCLASS_EXPRESSION:
                if ($next == ')') {
                    $status = CSS_IN_IDENTIFIER;
                }
                break;

            case CSS_IN_IDENTIFIER:
                if ($next == '(') {
                    $status = CSS_IN_PSEUDOCLASS_EXPRESSION;
                    break;
                }
                if (($alpha_numeric) || ($next == ':') || ($next == '#')) {
                    $class_name .= $next;
                } elseif ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                } else {
                    // Test class name
                    $cnt = substr_count($class_name, ':');
                    if ($cnt > 0) {
                        $matches = [];
                        $pseudo = '';
                        $num_matches = preg_match_all('#:(:?[\w\-]+)(\([^()]*\))?#', $class_name, $matches);
                        for ($j = 0; $j < $num_matches; $j++) {
                            $pseudo = $matches[1][$j];
                        }

                        global $CSS_PSEUDO_CLASSES;
                        if (!in_array($pseudo, $CSS_PSEUDO_CLASSES)) {
                            $errors[] = [0 => 'CSS_UNKNOWN_PSEUDO', 1 => $pseudo, 2 => integer_format($line), 'pos' => $i];
                        }
                    }

                    if ($whitespace) {
                        $status = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                    } elseif (($next == ',') || ($next == '>') || ($next == '+') || ($next == '~')) {
                        $status = CSS_EXPECTING_IDENTIFIER;
                    } elseif ($next == '{') {
                        $status = CSS_IN_CLASS;
                        $class_start_line = $line;
                        $class_start_i = $i;
                        $class = '';
                    } else {
                        $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                    }
                }
                break;

            case CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS:
                if ($next == '{') {
                    $status = CSS_IN_CLASS;
                    $class_start_line = $line;
                    $class_start_i = $i;
                    $class = '';
                } elseif ($next == '*') {
                    // Continuing
                } elseif ($whitespace) {
                    // Continuing
                } elseif (($next == ',') || ($next == '>') || ($next == '+') || ($next == '~')) {
                    $status = CSS_EXPECTING_IDENTIFIER;
                } elseif ($comment_starting) {
                    $status = CSS_IN_COMMENT;
                    $class_before_comment = CSS_EXPECTING_SEP_OR_IDENTIFIER_OR_CLASS;
                } elseif (($next == '.') || ($next == ':') || ($next == '#') || ($alpha_numeric)) {
                    $status = CSS_IN_IDENTIFIER;
                    $class_name = $next;
                } else {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                }
                break;

            case CSS_IN_CLASS:
                if ($quoting) {
                    if ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                        $quoting = !$quoting;
                    }
                    $class .= $next;
                } elseif ($in_comment) {
                    $comment_ending = (($next == '*') && ($i < $len - 2) && ($data[$i + 1] == '/'));
                    if ($comment_ending) {
                        $in_comment = false;
                    }
                    $class .= $next;
                } elseif ($next == '}') {
                    $status = CSS_NO_MANS_LAND;
                    $test = _webstandards_css_class($class, $class_start_i, $class_start_line + 1);
                    if (is_array($test)) {
                        $errors = array_merge($errors, $test);
                    }
                } elseif ($comment_starting) {
                    $in_comment = true;
                    $class .= $next;
                } elseif ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                    $quoting = true;
                    $class .= $next;
                } elseif ($next == '{') {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $i];
                    return $errors;
                } else {
                    $class .= $next;
                }
                break;
        }

        if ($val == 10) {
            ++$line;
        }

        ++$i;
    }

    if ($status != CSS_NO_MANS_LAND) {
        $errors[] = [0 => 'CSS_UNEXPECTED_TERMINATION', 'pos' => $i];
        return $errors;
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks a CSS class.
 *
 * @param  string $data The data of the CSS class
 * @param  integer $_i Current parse position
 * @param  integer $line The higher-level line number we are checking for (to give better debug output)
 * @return ?array Error information (null: no error)
 * @ignore
 */
function _webstandards_css_class(string $data, int $_i, int $line = 0) : ?array
{
    $errors = [];

    global $CSS_TAG_RANGES;
    global $CSS_VALUE_RANGES;

    $len = strlen($data);
    $i = 0;
    $key = '';
    $value = '';
    $status = _CSS_NO_MANS_LAND;
    $class_before_comment = null;
    $quoting = false;
    while ($i < $len) {
        $next = $data[$i];
        $val = ord($next);
        $alpha_numeric = ($next == '_') || ($next == '.') || ($next == '-') || (($val >= 65) && ($val <= 90)) || (($val >= 97) && ($val <= 122)) || (($val >= 48) && ($val <= 57));
        $whitespace = (($next == "\t") || ($val == 13) || ($val == 10) || ($next == ' '));
        $comment_starting = (($next == '/') && ($i != $len - 2) && ($i + 1 < $len) && ($data[$i + 1] == '*'));

        switch ($status) {
            case _CSS_NO_MANS_LAND:
                if ($alpha_numeric) {
                    $CSS_TAG_RANGES[] = [$_i + $i + 1, $_i + $i + 2];
                    $status = _CSS_IN_PROPERTY_KEY;
                    $key = $next;
                } elseif (($whitespace) || ($next == ';')) { // ; is unusual here, but allowed; It occurs when we substitute nothing into a part of a style attribute
                    // Continuing
                } elseif ($comment_starting) {
                    $class_before_comment = $status;
                    $status = _CSS_IN_COMMENT;
                } else {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $_i];
                }
                break;

            case _CSS_IN_COMMENT:
                if (($next == '*') && ($i != $len - 1) && ($data[$i + 1] == '/')) {
                    $status = $class_before_comment;
                    ++$i;
                }
                break;

            case _CSS_IN_PROPERTY_KEY:
                if ($next == ':') {
                    $status = _CSS_IN_PROPERTY_BETWEEN;
                    $value = '';
                } elseif ($alpha_numeric) {
                    $key .= $next;
                    $CSS_TAG_RANGES[count($CSS_TAG_RANGES) - 1][1]++;
                }
                break;

            case _CSS_IN_PROPERTY_BETWEEN:
                if (!$whitespace) {
                    $status = _CSS_IN_PROPERTY_VALUE;
                    $CSS_VALUE_RANGES[] = [$_i + $i + 1, $_i + $i + 1];
                    $i--;
                }
                break;

            case _CSS_IN_PROPERTY_VALUE:
                if (($next == ';') && (!$quoting)) {
                    $test = _check_css_value($key, $value, $_i);
                    if (is_array($test)) {
                        $errors[] = $test;
                    }
                    $status = _CSS_NO_MANS_LAND;
                } elseif ($comment_starting) {
                    $class_before_comment = $status;
                    $status = _CSS_IN_COMMENT;
                } elseif (($val == 10) || ($val == 13)) {
                    $status = _CSS_EXPECTING_END;
                } else {
                    if ((($next == '"') || ($next == "'")) && ($data[$i - 1] != "\\")) {
                        $quoting = !$quoting;
                    }
                    $value .= $next;
                    $CSS_VALUE_RANGES[count($CSS_VALUE_RANGES) - 1][1]++;
                }
                break;

            case _CSS_EXPECTING_END:
                if (!$whitespace) {
                    $errors[] = [0 => 'CSS_UNEXPECTED_CHARACTER_CLASS', 1 => $next, 2 => integer_format($line), 'pos' => $_i];
                    return $errors;
                }
                break;
        }

        if ($val == 10) {
            ++$line;
        }

        ++$i;
    }

    if (($status != _CSS_NO_MANS_LAND) && ($status != _CSS_IN_PROPERTY_VALUE) && ($status != _CSS_EXPECTING_END)) {
        $errors[] = [0 => 'CSS_UNEXPECTED_TERMINATION_PROPERTY', 'pos' => $_i];
        return $errors;
    }

    if ($status == _CSS_IN_PROPERTY_VALUE) {
        $test = _check_css_value($key, $value, $_i);
        if (is_array($test)) {
            $errors[] = $test;
        }
    }

    return empty($errors) ? null : $errors;
}

/**
 * Checks a CSS attribute/value combination is appropriate.
 *
 * @param  string $key The name of the attribute
 * @param  string $value The value of the attribute
 * @param  integer $_i Current parse position
 * @return ?array Error information (null: no error)
 * @ignore
 */
function _check_css_value(string $key, string $value, int $_i) : ?array
{
    $value = str_replace(' !important', '', $value);
    $value = trim($value);

    if (substr($value, 0, 11) == '!important ') {
        $value = substr($value, 11); // Strip off the important flag if it's present
    }

    $error = null;

    global $CSS_PROPERTIES;
    if (!isset($CSS_PROPERTIES[$key])) {
        if (substr($key, 0, 1) == '-') {
            return null;
        }
        return [0 => 'CSS_UNKNOWN_PROPERTY', 1 => $key, 'pos' => $_i];
    } else {
        $reg_exp = $CSS_PROPERTIES[$key];
    }

    if (
        (preg_match('#^' . $reg_exp . '$#s', $value) == 0) &&

        // Special values
        ($value != 'inherit') &&
        ($value != 'initial') &&
        (substr($value, 0, 5) != 'calc(') && // #3928
        (substr($value, 0, 4) != 'var(')
    ) {
        return [0 => 'CSS_BAD_PROPERTY_VALUE', 1 => $key, 2 => $value, 3 => $reg_exp, 'pos' => $_i];
    }

    if (!empty($GLOBALS['FLAG__PEDANTIC'])) {
        if (($key == 'font-size') && (substr($value, -2) == 'px')) {
            return [0 => 'CSS_PX_FONT', 'pos' => $_i];
        }
    }

    return $error;
}
