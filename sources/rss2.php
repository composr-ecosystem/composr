<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    syndication
 */

/**
 * Handle RSS cloud registrations.
 */
function backend_cloud_script()
{
    if (!addon_installed('syndication')) {
        warn_exit(do_lang_tempcode('MISSING_ADDON', escape_html('syndication')));
    }

    header('X-Robots-Tag: noindex');

    // Closed site
    $site_closed = get_option('site_closed');
    if (($site_closed != '0') && (!has_privilege(get_member(), 'access_closed_site')) && (!$GLOBALS['IS_ACTUALLY_ADMIN'])) {
        http_response_code(503);
        header('Content-Type: text/plain; charset=' . get_charset());
        @exit(get_option('closed'));
    }

    $path = post_param_string('path', '');
    $procedure = post_param_string('registerProcedure', '');
    $protocol = post_param_string('protocol', '');
    if ($protocol == 'soap') {
        exit('false');
    }
    if ($protocol == 'http-post') {
        exit('false');
    }
    $port = post_param_integer('port', 80);
    // $watch_channel_url = $_POST['channels'];
    $GLOBALS['SITE_DB']->query_delete('news_rss_cloud', ['watch_channel_url' => get_param_string('type', ''), 'rem_procedure' => $procedure, 'rem_port' => $port, 'rem_path' => $path, 'rem_protocol' => $protocol, 'rem_ip_address' => get_ip_address()]);
    $GLOBALS['SITE_DB']->query_insert('news_rss_cloud', ['register_time' => time(), 'watch_channel_url' => get_param_string('type', ''), 'rem_procedure' => $procedure, 'rem_port' => $port, 'rem_path' => $path, 'rem_protocol' => $protocol, 'rem_ip_address' => get_ip_address()]);
    exit('true');
}

/**
 * Handle RSS/Atom output.
 */
function rss_backend_script()
{
    if (!addon_installed('syndication')) {
        warn_exit(do_lang_tempcode('MISSING_ADDON', escape_html('syndication')));
    }

    if (get_option('is_on_rss') == '0') {
        return;
    }

    $type = filter_naughty_harsh(get_param_string('type', 'RSS2'));
    $mode = filter_naughty_harsh(get_param_string('mode', 'opml'));

    $canonical_url = find_script('backend') . '?mode=' . $mode;
    header('Link: <' . $canonical_url . '>; rel="canonical"');

    // Closed site
    $site_closed = get_option('site_closed');
    if (($site_closed != '0') && (!has_privilege(get_member(), 'access_closed_site')) && (!is_our_server(get_ip_address())) && (!$GLOBALS['IS_ACTUALLY_ADMIN'])) {
        http_response_code(503);
        header('Content-Type: text/plain; charset=' . get_charset());
        @exit(get_option('closed'));
    }

    require_lang('rss');
    require_code('xml');

    if ($type == 'xslt-rss') {
        // Feed stylesheet for RSS
        header('Content-Type: text/xsl; charset=' . get_charset());
        require_css('rss');
        $js = get_custom_base_url() . substr(javascript_enforce('xsl_mopup'), strlen(get_custom_file_base()));
        $echo = do_template('RSS_XSLT', ['_GUID' => 'c443e0195c935117cf0d9a7bc2730d7a', 'JAVASCRIPT_XSL_MOPUP' => $js], null, false, null, '.xml', 'xml');
        $echo->evaluate_echo();
        return;
    }
    if ($type == 'xslt-atom') {
        // Feed stylesheet for Atom
        header('Content-Type: text/xsl; charset=' . get_charset());
        require_css('rss');
        $js = get_custom_base_url() . substr(javascript_enforce('xsl_mopup'), strlen(get_custom_file_base()));
        $echo = do_template('ATOM_XSLT', ['_GUID' => '27fec456a6b3144aa847130e74463d99', 'JAVASCRIPT_XSL_MOPUP' => $js], null, false, null, '.xml', 'xml');
        $echo->evaluate_echo();
        return;
    }
    if ($type == 'xslt-opml') {
        // Feed stylesheet for Atom
        header('Content-Type: text/xsl; charset=' . get_charset());
        require_css('rss');
        $js = get_custom_base_url() . substr(javascript_enforce('xsl_mopup'), strlen(get_custom_file_base()));
        $echo = do_template('OPML_XSLT', ['_GUID' => 'c0c6bd1d7a0e263768a2208061f799f5', 'JAVASCRIPT_XSL_MOPUP' => $js], null, false, null, '.xml', 'xml');
        $echo->evaluate_echo();
        return;
    }

    load_csp([
        'csp_enabled' => '1',
        'csp_allow_plugins' => '0',
        'csp_allow_inline_js' => '1',
        'csp_allow_eval_js' => '0',
        'csp_allow_dyn_js' => '1',
        'csp_allow_insecure_resources' => '0',
        'csp_allow_workers' => '0',
        'csp_on_forms' => '0',
    ]);

    $type = cms_strtoupper_ascii($type);
    if (($type != 'RSS2') && ($type != 'ATOM')) {
        $type = 'RSS2';
    }
    if ($type == 'RSS2') {
        $prefix = 'RSS_';
    } else {
        $prefix = 'ATOM_';
    }

    if ($type == 'RSS2') {
        $date_string = 'r';
    } else {
        $offset_seconds = intval(date('Z'));
        $offset_minutes = abs(intval(round(floatval($offset_seconds) / 60.0)));
        $offset_hours = intval(round(floatval($offset_minutes) / 60.0));
        $offset_minutes -= $offset_hours * 60;
        $offset = sprintf('%02d:%02d', $offset_hours, $offset_minutes);
        $date_string = 'Y-m-d\\TH:i:s';
        if ($offset_seconds >= 0) {
            $date_string .= '+';
        } else {
            $date_string .= '-';
        }
        for ($i = 0; $i < strlen($offset); $i++) {
            $date_string .= '\\' . $offset[$i];
        }
    }

    $date = date($date_string);

    $site_about = xmlentities(get_option('description'));
    $logo_url = xmlentities(find_theme_image('logo/standalone_logo'));

    $cutoff = get_param_integer('cutoff', time() - 60 * 60 * 24 * get_param_integer('days', 30));
    $max = get_param_integer('max', 100);
    $select = get_param_string('select', '*', INPUT_FILTER_GET_COMPLEX);
    if ($select == '') {
        $select = '*';
    }

    if ($mode == 'opml') {
        prepare_backend_response('text/xml', BACKEND_RESPONSE_CACHE_BREAK);

        $_feeds = find_all_hook_obs('systems', 'rss', 'Hook_rss_');
        $feeds = [];
        foreach ($_feeds as $feed => $object) {
            if ((get_forum_type() != 'cns') && (substr($feed, 0, 4) == 'cns_')) {
                continue;
            }

            // Feeds we do not want to present to those without the correct privilege
            if (!$object->has_access(get_member())) {
                continue;
            }

            $feed_title = titleify($feed);

            // Try and get a better feed title
            require_code('selectcode');
            $_content = $object->run('', time(), 'ATOM_', '', 0);
            if ($_content === null) {
                continue;
            }
            if (is_array($_content)) {
                list(, $feed_title) = $_content;
            }

            $feeds[] = ['MODE' => $feed, 'TITLE' => $feed_title];
        }
        $echo = do_template('OPML_WRAPPER', ['_GUID' => '712b78d1b4c23aefc8a92603477f84ed', 'FEEDS' => $feeds, 'ABOUT' => $site_about, 'DATE' => $date], null, false, null, '.xml', 'xml');
        $echo->evaluate_echo();

        require_code('site');
        save_static_caching($echo, 'text/xml');

        return;
    }

    prepare_backend_response('text/xml', BACKEND_RESPONSE_CACHE_BREAK);
    // NB: Firefox (and probably other browsers, but I didn't test) doesn't want to display Atom feeds inline if they're sent as text/xml+atom / text/xml+rss, even if the Content-Disposition is sent to inline :(

    push_query_limiting(false);

    if ((!file_exists(get_file_base() . '/sources/hooks/systems/rss/' . $mode . '.php')) && (!file_exists(get_file_base() . '/sources_custom/hooks/systems/rss/' . $mode . '.php'))) {
        warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('8b2cb1058ab75243b94a1db66939609e')));
    }

    // Firefox (and probably other browsers, but I didn't test) doesn't want to display Atom feeds inline if they're sent as text/xml+atom, even if the Content-Disposition is sent to inline :(
    header('Content-Type: text/xml'); // application/rss+xml ?

    require_code('hooks/systems/rss/' . $mode, true);
    $object = object_factory('Hook_rss_' . $mode);
    require_code('selectcode');
    $_content = $object->run($select, $cutoff, $prefix, $date_string, $max);
    $mode_nice = $mode;
    if (is_array($_content)) {
        list($content, $mode_nice) = $_content;
    } else {
        $content = ($_content === null) ? [] : $_content;
    }

    pop_query_limiting();

    if ($type == 'RSS2') {
        // Change a full URL into constituent parts
        $base_url = get_base_url();
        $url_bits = cms_parse_url_safe($base_url);
        $domain = get_base_url_hostname();
        $port = $url_bits['port'];
        $path = $url_bits['path'];

        $rss_cloud = do_template('RSS_CLOUD', ['_GUID' => 'a47c40a4c137ea1e5abfc71346547313', 'TYPE' => ($type == 'news') ? '' : $type, 'DOMAIN' => $domain, 'PORT' => strval($port), 'PATH' => $path], null, false, null, '.xml', 'xml');
    } else {
        $rss_cloud = new Tempcode();
    }

    if ($_SERVER['REQUEST_METHOD'] == 'HEAD') {
        return;
    }

    $echo = do_template($prefix . 'WRAPPER', ['SELECT' => $select, 'CUTOFF' => strval($cutoff), 'MODE' => $mode, 'MODE_NICE' => $mode_nice, 'RSS_CLOUD' => $rss_cloud, 'VERSION' => cms_version_pretty(), 'DATE' => $date, 'LOGO_URL' => $logo_url, 'ABOUT' => $site_about, 'CONTENT' => $content, 'SELF_URL' => get_self_url_easy()], null, false, null, '.xml', 'xml');
    $echo->evaluate_echo();

    if ($mode != 'comments') {
        require_code('site');

        // This is just signalling to the static cache in this case, as there's no HTML <head>
        inform_non_canonical_parameter('cutoff');
        inform_non_canonical_parameter('days');
        inform_non_canonical_parameter('max');
        inform_non_canonical_parameter('select');

        save_static_caching($echo, 'text/xml');
    }
}

/**
 * Get enclosure details from a URL, as efficiently as possible.
 *
 * @param  URLPATH $url The (possibly short) URL to get details for
 * @param  URLPATH $enclosure_url The full URL to get details for
 * @return array A pair: the length of the data, the mime type
 */
function get_enclosure_details(string $url, string &$enclosure_url) : array
{
    $base_url = get_custom_base_url();

    if (url_is_local($enclosure_url)) {
        $enclosure_url = $base_url . '/' . $enclosure_url;
    }

    require_code('mime_types');
    $enclosure_type = get_mime_type(get_file_extension($url), false);

    if (substr($url, 0, strlen($base_url) + 1) == $base_url . '/') {
        $url = substr($url, strlen($base_url) + 1);
    }

    $enclosure_length = '0';
    if ((url_is_local($url)) && ((file_exists(get_custom_file_base() . '/' . rawurldecode($url))) || (preg_match('#^(image|video)/#', $enclosure_type) != 0))) {
        $path = get_custom_file_base() . '/' . rawurldecode($url);
        if (!is_file($path)) {
            return [null, null];
        }
        $enclosure_length = strval(filesize($path));
    } else {
        if (url_is_local($url)) {
            $url = $base_url . '/' . $url;
        }

        $http_response = cms_http_request($enclosure_url, ['trigger_error' => false, 'byte_limit' => 0]);
        if ($http_response->download_size === null) {
            $_data = http_get_contents($enclosure_url, ['trigger_error' => false]);
            $enclosure_length = ($_data === null) ? '0' : strval(strlen($_data));
        } else {
            $enclosure_length = strval($http_response->download_size);
        }
        $enclosure_type = $http_response->download_mime_type;
    }
    return [$enclosure_length, $enclosure_type];
}
