<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_abstract_interfaces
 */

/*
Results table = Built on top of columned table, with inbuilt integration of Composr pagination and column/<select>-based sorting
*/

/**
 * Get the Tempcode for a results table.
 *
 * @param  mixed $text_id Some text/word describing what is being browsed (string or Tempcode)
 * @param  integer $start The result number our table starts at (x of n)
 * @param  ID_TEXT $start_name The parameter name used to store our position in the results (usually, 'start')
 * @param  integer $max The total number of results to show per-page
 * @param  ID_TEXT $max_name The parameter name used to store the total number of results to show per-page (usually, 'max')
 * @param  integer $max_rows The maximum number of rows in the entire dataset
 * @param  Tempcode $header_row The titles of the fields we are showing in our table, presented in pre-prepared Tempcode
 * @param  Tempcode $result_entries The entry rows we are showing in our table
 * @param  array $sortables A map of sortable code (usually, db field names), to strings giving the human name for the sort order
 * @param  ?ID_TEXT $sortable The current sortable (null: none)
 * @param  ?ID_TEXT $sort_order The order we are sorting in (null: none)
 * @set ASC DESC
 * @param  ?ID_TEXT $sort_name The parameter name used to store our sortable (usually 'sort') (null: none)
 * @param  ?Tempcode $message Message to show; you want to set this to new Tempcode() if you do not want any message to show (null: auto)
 * @param  array $widths Widths to specify to the table (strings, ending 'px')
 * @param  ?string $tpl_set The template set to use (null: default)
 * @param  ?integer $max_pagination_links The maximum number of quick-jump pagination-links to show (null: configured default)
 * @param  string $guid GUID to pass to template
 * @param  boolean $skip_sortables_form Whether to skip showing a sort form (useful if there is another form wrapped around this)
 * @param  ?ID_TEXT $hash URL hash component without the # (null: none)
 * @param  boolean $interactive Whether to allow interactive sorting and filtering
 * @param  boolean $responsive Whether the table should be responsive
 * @param  ?Tempcode $footer_row The footer row of the fields we are showing in our table, presented in pre-prepared Tempcode (null: do not show a footer)
 * @return Tempcode The results table
 */
function results_table($text_id, int $start, string $start_name, int $max, string $max_name, int $max_rows, object $header_row, object $result_entries, array $sortables = [], ?string $sortable = null, ?string $sort_order = null, ?string $sort_name = 'sort', ?object $message = null, array $widths = [], ?string $tpl_set = null, ?int $max_pagination_links = null, string $guid = '1c8645bc2a3ff5bec2e003142185561f', bool $skip_sortables_form = false, ?string $hash = null, bool $interactive = false, bool $responsive = true, ?object $footer_row = null) : object
{
    require_code('templates_pagination');

    if ($sort_name !== null) {
        inform_non_canonical_parameter($sort_name);
    }

    if ($message === null) {
        $message = new Tempcode();
        foreach ($sortables as $_sortable => $text) {
            if (is_array($text)) {
                $text = $text[0];
            }
            if (is_object($text)) {
                $text = $text->evaluate();
            }
            if (($text == do_lang('DATE_TIME')) && (strpos($result_entries->evaluate(), '<a ') !== false)) {
                $message = paragraph(do_lang_tempcode('CLICK_DATE_FOR_MORE'));
            }
        }
    }

    // Sorting
    if (!empty($sortables)) {
        $sort = results_sorter($sortables, $sortable, $sort_order, $sort_name, $hash);
    } else {
        $sort = new Tempcode();
    }

    // Pagination
    $pagination = pagination(is_object($text_id) ? $text_id : make_string_tempcode($text_id), $start, $start_name, $max, $max_name, $max_rows, true, $max_pagination_links, null, ($hash === null) ? '' : $hash);

    $map = [
        '_GUID' => $guid,
        'TEXT_ID' => $text_id,
        'HEADER_ROW' => $header_row,
        'RESULT_ENTRIES' => $result_entries,
        'MESSAGE' => $message,
        'SORT' => $skip_sortables_form ? new Tempcode() : $sort,
        'PAGINATION' => $pagination,
        'WIDTHS' => $widths,
        'INTERACTIVE' => $interactive,
        'NONRESPONSIVE' => !$responsive
    ];
    if ($footer_row !== null) {
        $map['FOOTER_ROW'] = $footer_row;
    }
    return do_template(
        ($tpl_set === null) ? 'RESULTS_TABLE' : ('RESULTS_' . $tpl_set . '_TABLE'),
        $map,
        null,
        false,
        'RESULTS_TABLE'
    );
}

/**
 * Get the Tempcode for a results table header row. You would take the output of this, and feed it in as $header_row, in a results_table function call.
 *
 * @param  array $values The array of field titles that header the entries in the results table (a null value will increment the previous non-null column's colspan - do not use any nulls if there is no previous non-null column)
 * @param  array $sortables A map of sortable code (usually, db field names), to strings giving the human name for the sort order
 * @param  ID_TEXT $order_param The parameter name used to store our sortable
 * @param  ID_TEXT $current_ordering The current ordering ("$sortable $sort_order")
 * @param  string $guid GUID to pass to template
 * @param  ?array $interactive_options Array of tuples matching the indices of $values, each pair being a boolean whether the value is searchable, boolean whether the value is filterable, and a sortable type supported by sortable_tables.js (or null) (null: no interactivity)
 * @param  ?ID_TEXT $hash URL hash component without the # (null: none)
 * @return Tempcode The generated header row
 */
function results_header_row(array $values, array $sortables = [], string $order_param = 'sort', string $current_ordering = '', string $guid = 'fbcaf8b021e3939bfce1dce9ff8ed63a', ?array $interactive_options = null, ?string $hash = null) : object
{
    $cells = new Tempcode();
    $cnt = count($values);
    foreach ($values as $i => $value) {
        if ($value === null) {
            continue;
        }

        $colspan = 1;
        for ($j = $i + 1; $j < $cnt; $j++) {
            if ($values[$j] !== null) {
                break;
            }

            $colspan++;
        }
        if ($colspan == 1) {
            $colspan = null;
        }

        $found = null;
        foreach ($sortables as $key => $sortable) {
            $_value = is_object($value) ? $value->evaluate() : $value;

            if (is_array($sortable)) {
                $sortable = $sortable[0];
            }

            if (((is_string($sortable)) && ($sortable == $_value)) || ((is_object($sortable)) && ($sortable->evaluate() == $_value))) {
                $found = $key;
                break;
            }
        }

        $map = [
            '_GUID' => $guid,
            'VALUE' => $value,
            'COLSPAN' => ($colspan === null) ? null : strval($colspan),

            // Interactivity
            'INTERACTIVE' => ($interactive_options !== null),
            'SEARCHABLE' => (($interactive_options !== null) && (array_key_exists($i, $interactive_options))) ? $interactive_options[$i][0] : false,
            'FILTERABLE' => (($interactive_options !== null) && (array_key_exists($i, $interactive_options))) ? $interactive_options[$i][1] : false,
            'SORTABLE_TYPE' => (($interactive_options !== null) && (array_key_exists($i, $interactive_options))) ? $interactive_options[$i][2] : null,
        ];

        if ($found !== null) {
            $sort_url_asc = get_self_url(false, false, [$order_param => $found . ' ASC'], true);
            $sort_url_desc = get_self_url(false, false, [$order_param => $found . ' DESC'], true);
            $sort_asc_selected = ($current_ordering == $found . ' ASC');
            $sort_desc_selected = ($current_ordering == $found . ' DESC');
            $map += [
                'SORT_ASC_SELECTED' => $sort_asc_selected,
                'SORT_DESC_SELECTED' => $sort_desc_selected,
                'SORT_URL_DESC' => $sort_url_desc,
                'SORT_URL_ASC' => $sort_url_asc,
                'HASH' => $hash,
            ];
            $cells->attach(do_template('RESULTS_TABLE_FIELD_TITLE_SORTABLE', $map));
        } else {
            $cells->attach(do_template('RESULTS_TABLE_FIELD_TITLE', $map));
        }
    }

    return $cells;
}

/**
 * Get the Tempcode for a results table footer row. You would take the output of this, and feed it in as $footer_row, in a results_table function call.
 *
 * @param  array $values The array of field titles that footer the entries in the results table (a null value will increment the previous non-null column's colspan - do not use any nulls if there is no previous non-null column)
 * @param  string $guid GUID to pass to template
 * @return Tempcode The generated footer row
 */
function results_footer_row(array $values, string $guid = 'e5df01c02d364a45b3cc56551407123f') : object
{
    $cells = new Tempcode();
    $cnt = count($values);
    foreach ($values as $i => $value) {
        if ($value === null) {
            continue;
        }

        $colspan = 1;
        for ($j = $i + 1; $j < $cnt; $j++) {
            if ($values[$j] !== null) {
                break;
            }

            $colspan++;
        }
        if ($colspan == 1) {
            $colspan = null;
        }

        $map = [
            '_GUID' => $guid,
            'VALUE' => $value,
            'COLSPAN' => ($colspan === null) ? null : strval($colspan),
        ];

        $cells->attach(do_template('RESULTS_TABLE_FIELD_FOOTER', $map));
    }

    return $cells;
}

/**
 * Get the Tempcode for a results entry (a row). You would gather together the outputs of several of these functions, then put them in as the $fields in a results_table function call.
 *
 * @param  array $values The array of values that make up this entry (of string or Tempcode, or mixture)
 * @param  boolean $auto_escape Whether to automatically escape each plain-text entry so that it cannot contain HTML (ignored for Tempcode values)
 * @param  ?string $tpl_set The template set to use (null: default)
 * @param  string $guid GUID to pass to template
 * @param  string $td_class Additional classes to assign to the row other than zebra (blank: none)
 * @return Tempcode The generated entry
 */
function results_entry(array $values, bool $auto_escape, ?string $tpl_set = null, string $guid = '9e340dd14173c7320b57243d607718ab', string $td_class = '') : object
{
    $i = 0;
    $cells = new Tempcode();
    $_values = array_values($values);
    $cnt = count($_values);
    foreach ($values as $class => $value) {
        if ($value === null) {
            continue;
        }

        $colspan = 1;
        for ($j = $i + 1; $j < $cnt; $j++) {
            if ($_values[$j] !== null) {
                break;
            }

            $colspan++;
        }
        if ($colspan == 1) {
            $colspan = null;
        }

        if (($auto_escape) && (!is_object($value))) {
            $value = escape_html($value);
        }
        $results_table_field_tpl = ($tpl_set === null) ? 'RESULTS_TABLE_FIELD' : ('RESULTS_TABLE_' . $tpl_set . '_FIELD');
        $cells->attach(do_template($results_table_field_tpl, [
            '_GUID' => $guid,
            'VALUE' => $value,
            'CLASS' => (is_string($class)) ? $class : '',
            'COLSPAN' => ($colspan === null) ? null : strval($colspan),
        ], null, false, 'RESULTS_TABLE_FIELD'));

        $i++;
    }

    $results_table_tpl = ($tpl_set === null) ? 'RESULTS_TABLE_ENTRY' : ('RESULTS_TABLE_' . $tpl_set . '_ENTRY');
    return do_template($results_table_tpl, [
        '_GUID' => $guid,
        'VALUES' => $cells,
        'TD_CLASS' => $td_class,
    ], null, false, 'RESULTS_TABLE_ENTRY');
}

/**
 * Get the Tempcode for a results sorter.
 *
 * @param  array $sortables A map of sortable code (usually, db field names), to strings giving the human name for the sort order or a pair of such and which direction to limit to
 * @param  ?ID_TEXT $sortable The current sortable (null: none)
 * @param  ?ID_TEXT $sort_order The order we are sorting in (null: none)
 * @set ASC DESC
 * @param  ?ID_TEXT $sort_name The parameter name used to store our sortable (usually 'sort') (null: none)
 * @param  ?ID_TEXT $hash URL hash component without the # (null: none)
 * @return Tempcode The results sorter
 */
function results_sorter(array $sortables, ?string $sortable = null, ?string $sort_order = null, ?string $sort_name = 'sort', ?string $hash = '') : object
{
    require_code('templates_pagination'); // Required because INCREMENTAL_ID_GENERATOR defined there

    $selectors = new Tempcode();
    foreach ($sortables as $_sortable => $text) {
        if (is_array($text)) {
            $limit_direction = $text[1];
            $text = $text[0];
        } else {
            $limit_direction = ($_sortable == 'random') ? 'ASC' : null;
        }

        if ($limit_direction !== 'DESC') {
            $text_ascending = new Tempcode();
            $text_ascending->attach($text);
            if ($limit_direction === null) {
                $text_ascending->attach(do_lang_tempcode('_ASCENDING'));
            }

            $selector_value = $_sortable . ' ASC';
            $selected = (($sortable !== null) && ($sort_order !== null) && (($sortable . ' ' . $sort_order) == $selector_value));
            $selectors->attach(do_template('PAGINATION_SORTER', ['_GUID' => '6a57bbaeed04743ba2cafa2d262a1c98', 'SELECTED' => $selected, 'NAME' => $text_ascending, 'VALUE' => $selector_value]));
        }

        if ($limit_direction !== 'ASC') {
            $text_descending = new Tempcode();
            $text_descending->attach($text);
            if ($limit_direction === null) {
                $text_descending->attach(do_lang_tempcode('_DESCENDING'));
            }

            $selector_value = $_sortable . ' DESC';
            $selected = (($sortable !== null) && ($sort_order !== null) && (($sortable . ' ' . $sort_order) == $selector_value));
            $selectors->attach(do_template('PAGINATION_SORTER', ['_GUID' => 'bbf97817fa4f5e744a414b303a3d21fe', 'SELECTED' => $selected, 'NAME' => $text_descending, 'VALUE' => $selector_value]));
        }
    }
    $sort_url = get_self_url(false, false, [$sort_name => null]);
    if ($selectors->is_empty()) {
        $sort = new Tempcode();
    } else {
        $sort = do_template('PAGINATION_SORT', ['_GUID' => '4afa1bae0f447b68e60192c515b13ca2', 'HASH' => $hash, 'SORT' => $sort_name, 'URL' => $sort_url, 'SELECTORS' => $selectors]);
    }
    $GLOBALS['INCREMENTAL_ID_GENERATOR']++;
    return $sort;
}

/**
 * Get the Tempcode for a cell containing a member.
 *
 * @param  AUTO_LINK $member_id The ID of the member being added to the cell
 * @return Tempcode A Tempcode containing the member, a hyperlink to their profile, and a member info tooltip
 */
function results_table_member_cell(int $member_id) : object
{
    $username = $GLOBALS['FORUM_DRIVER']->get_username($member_id, false, USERNAME_DEFAULT_NULL);
    if ($username === null) {
        return do_lang_tempcode('UNKNOWN');
    }

    if (!is_guest($member_id)) {
        $profile_url = $GLOBALS['FORUM_DRIVER']->member_profile_url($member_id, true, $username);
        return do_template('RESULTS_TABLE_MEMBER_CELL', [
            '_GUID' => '289bcaf692854b588f9b1eda3c0c52f4',
            'PROFILE_URL' => $profile_url,
            'USERNAME' => $username,
            'MEMBER_ID' => strval($member_id)
        ]);
    }
    return do_lang_tempcode('GUEST');
}
