<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_cns
 */

/**
 * Get the personal post rows for the current member.
 *
 * @param  ?integer $limit The maximum number of rows to get (gets newest first) (null: no limit)
 * @param  boolean $unread Whether to only get unread ones
 * @param  boolean $include_inline Whether to include inline personal posts
 * @param  ?TIME $time_barrier Only since this date (null: no limit)
 * @return array The personal post rows (with corresponding topic details)
 */
function cns_get_pp_rows(?int $limit = 5, bool $unread = true, bool $include_inline = true, ?int $time_barrier = null) : array
{
    $cache_key = serialize([$limit, $unread, $include_inline, $time_barrier]);

    static $private_post_rows_cache = [];
    if (isset($private_post_rows_cache[$cache_key])) {
        return $private_post_rows_cache[$cache_key];
    }

    if (!addon_installed('cns_forum')) {
        return [];
    }

    $member_id = get_member();

    $query = '';

    $unread_clause = '';
    if ($unread) {
        $unread_clause = '
            t_cache_last_time > ' . strval(time() - 60 * 60 * 24 * intval(get_option('post_read_history_days'))) . ' AND
            (l_time IS NULL OR l_time < p.p_time) AND
        ';
    }

    $time_clause = '';
    if ($time_barrier !== null) {
        $time_clause = '
            t_cache_last_time>' . strval($time_barrier) . ' AND
        ';
    }

    // NB: The "p_intended_solely_for" bit in the PT clauses is because inline private posts do not register as the t_cache_last_post_id even if they are the most recent post. We want to ensure we join to the most recent post.

    // PT from and PT from
    foreach (['t_pt_from', 't_pt_to'] as $pt_target) {
        $query .= 'SELECT t.id AS t_id,t_forum_id,t_cache_first_member_id,t_cache_first_title,t_cache_first_post_id,t_cache_first_time,t_cache_first_member_id,t_cache_first_username,t_cache_last_time,t_cache_last_member_id,t_cache_last_username,t_description,t_cache_num_posts,t_pt_from,t_pt_to,p.id AS p_id,l_time';
        $query .= ' FROM
        ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_topics t
        LEFT JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_read_logs l ON t.id=l_topic_id AND l_member_id=' . strval($member_id) . '
        JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_posts p ON p.id=t.t_cache_last_post_id';
        if (!multi_lang_content()) {
            $query .= ' LEFT JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_posts p2 ON p2.id=t.t_cache_first_post_id';
        }
        $query .= ' WHERE
        ' . $unread_clause . $time_clause . '
        ' . $pt_target . '=' . strval($member_id);

        $query .= ' UNION ';
    }

    // PT invited to
    $query .= 'SELECT t.id AS t_id,t_forum_id,t_cache_first_member_id,t_cache_first_title,t_cache_first_post_id,t_cache_first_time,t_cache_first_member_id,t_cache_first_username,t_cache_last_time,t_cache_last_member_id,t_cache_last_username,t_description,t_cache_num_posts,t_pt_from,t_pt_to,p.id AS p_id,l_time';
    $query .= ' FROM
    ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_topics t
    LEFT JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_special_pt_access i ON i.s_topic_id=t.id
    LEFT JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_read_logs l ON t.id=l_topic_id AND l_member_id=' . strval($member_id) . '
    JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_posts p ON p.id=t.t_cache_last_post_id';
    $query .= ' WHERE
    ' . $unread_clause . $time_clause . '
    i.s_member_id=' . strval($member_id);

    if ($include_inline) {
        $query .= ' UNION ';

        // Inline personal post to
        $query .= 'SELECT t.id AS t_id,t_forum_id,t_cache_first_member_id,t_cache_first_title,t_cache_first_post_id,t_cache_first_time,t_cache_first_member_id,t_cache_first_username,t_cache_last_time,t_cache_last_member_id,t_cache_last_username,t_description,t_cache_num_posts,t_pt_from,t_pt_to,MAX(p.id) AS p_id,l_time';
        $query .= ' FROM
        ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_posts p
        JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_topics t ON p_topic_id=t.id AND p.p_intended_solely_for=' . strval($member_id) . '
        LEFT JOIN ' . $GLOBALS['FORUM_DB']->get_table_prefix() . 'f_read_logs l ON t.id=l_topic_id AND l_member_id=' . strval($member_id);
        $query .= ' WHERE
        ' . $unread_clause . $time_clause . '
        p.p_intended_solely_for=' . strval($member_id) . '
        GROUP BY t.id,t_forum_id,t_cache_first_member_id,t_cache_first_title,t_cache_first_post_id,t_cache_first_time,t_cache_first_member_id,t_cache_first_username,t_cache_last_time,t_cache_last_member_id,t_cache_last_username,t_description,t_cache_num_posts,t_pt_from,t_pt_to,l_time';
    }

    $query .= ' ORDER BY t_cache_last_time DESC';

    $ret = $GLOBALS['FORUM_DB']->query($query, $limit, 0, false, true);

    // We load this late, as otherwise on-disk temporary tables are created by the UNION (the nature of TEXT columns in MySQL)
    foreach ($ret as &$pp_row) {
        $post_rows = $GLOBALS['FORUM_DB']->query_select('f_posts', ['*'], ['id' => $pp_row['p_id']], '', 1);
        $pp_row += $post_rows[0];
    }

    $private_post_rows_cache[$cache_key] = $ret;

    return $ret;
}

/**
 * Acount Conversr notifications.
 *
 * @param  MEMBER $member_id Member to look up for
 * @return integer Number of notifications
 */
function generate_notifications_count(int $member_id) : int
{
    static $notifications_cache = null;
    if (isset($notifications_cache[$member_id])) {
        return $notifications_cache[$member_id];
    }

    $do_caching = has_caching_for('block', '_new_pts');

    $num_unread_pts = null;
    if ($do_caching) {
        $cache_identifier = serialize([]);
        $num_unread_pts = get_cache_entry('_new_pts', $cache_identifier, CACHE_AGAINST_MEMBER, 10000);
    }

    if ($num_unread_pts === null) {
        $unread_pps = cns_get_pp_rows();
        $num_unread_pts = 0;
        foreach ($unread_pps as $unread_pp) {
            if ($unread_pp['t_forum_id'] === null) {
                $num_unread_pts++;
            }
        }

        if ($do_caching) {
            require_code('caches2');
            set_cache_entry('_new_pts', 60 * 24, $cache_identifier, $num_unread_pts, CACHE_AGAINST_MEMBER);
        }
    }

    if ($do_caching) {
        $notifications_cache[$cache_identifier] = $num_unread_pts;
    }

    return $num_unread_pts;
}
