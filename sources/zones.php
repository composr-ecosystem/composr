<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__zones()
{
    global $BLOCK_CACHE_ON_CACHE, $CLASS_CACHE;
    $BLOCK_CACHE_ON_CACHE = null;
    $CLASS_CACHE = [];

    global $ARB_COUNTER;
    $ARB_COUNTER = 1;

    global $DO_NOT_CACHE_THIS;
    $DO_NOT_CACHE_THIS = false;

    global $MODULES_ZONES_CACHE, $MODULES_ZONES_CACHE_DEFAULT;
    $MODULES_ZONES_CACHE = function_exists('persistent_cache_get') ? persistent_cache_get('MODULES_ZONES') : null;

    global $SITE_INFO;
    $hardcoded = (isset($SITE_INFO['hardcode_common_module_zones'])) && ($SITE_INFO['hardcode_common_module_zones'] == '1');
    if (get_forum_type() == 'cns') {
        if ($hardcoded) {
            $MODULES_ZONES_CACHE_DEFAULT = [
                // Breaks redirects etc, but handy optimisation if you have a vanilla layout
                'forumview' => 'forum',
                'topicview' => 'forum',
                'topics' => 'forum',
                'vforums' => 'forum',
                'points' => (get_option('single_public_zone') == '1') ? '' : 'site',
                'members' => (get_option('single_public_zone') == '1') ? '' : 'site',
                'catalogues' => (get_option('single_public_zone') == '1') ? '' : 'site',
                'join' => '',
                'login' => '',
                'recommend' => '',
            ];
        } else {
            $MODULES_ZONES_CACHE_DEFAULT = [
                'join' => '',
                'login' => '',
            ];
        }
    } else {
        $MODULES_ZONES_CACHE_DEFAULT = [
            'join' => '',
        ];
    }

    global $VIRTUALISED_ZONES_CACHE;
    $VIRTUALISED_ZONES_CACHE = null;
    if ($MODULES_ZONES_CACHE === null) {
        foreach ($MODULES_ZONES_CACHE_DEFAULT as $key => $val) {
            if ((!$hardcoded) && (!is_file(get_file_base() . (($val == '') ? '' : ('/' . $val)) . '/pages/modules/' . $key . '.php'))) {
                unset($MODULES_ZONES_CACHE_DEFAULT[$key]);
            }
        }
        $MODULES_ZONES_CACHE = [get_zone_name() => ['modules' => $MODULES_ZONES_CACHE_DEFAULT]];
    }

    global $ALL_ZONES_CACHE, $ALL_ZONES_TITLED_CACHE;
    $ALL_ZONES_CACHE = null;
    $ALL_ZONES_TITLED_CACHE = null;

    global $REDIRECT_CACHE;
    $REDIRECT_CACHE = null;

    global $MODULE_INSTALLED_CACHE;
    $MODULE_INSTALLED_CACHE = [];

    global $HOOKS_CACHE;
    $HOOKS_CACHE = (function_exists('persistent_cache_get') && !in_safe_mode()) ? persistent_cache_get('HOOKS') : [];
    if ($HOOKS_CACHE === null) {
        $HOOKS_CACHE = [];
    }

    if (!defined('FIND_ALL_PAGES__PERFORMANT')) {
        define('FIND_ALL_PAGES__PERFORMANT', 0);
        define('FIND_ALL_PAGES__NEWEST', 1);
        define('FIND_ALL_PAGES__ALL', 2);
    }

    global $BLOCKS_AT_CACHE;
    $BLOCKS_AT_CACHE = (function_exists('persistent_cache_get') && !in_safe_mode()) ? persistent_cache_get('BLOCKS_AT') : [];
    if ($BLOCKS_AT_CACHE === null) {
        $BLOCKS_AT_CACHE = [];
    }

    // "Kid Gloves Modes" tracking
    if (!defined('I_UNDERSTAND_SQL_INJECTION')) {
        define('I_UNDERSTAND_SQL_INJECTION', 1);
        define('I_UNDERSTAND_XSS', 2);
        define('I_UNDERSTAND_PATH_INJECTION', 4);
    }
    global $DECLARATIONS_STACK, $DECLARATIONS_STATE, $DECLARATIONS_STATE_DEFAULT;
    $DECLARATIONS_STACK = [];
    $DECLARATIONS_STATE_DEFAULT = [
        I_UNDERSTAND_SQL_INJECTION => true,
        I_UNDERSTAND_XSS => true,
        I_UNDERSTAND_PATH_INJECTION => true,
    ];
    $DECLARATIONS_STATE = $DECLARATIONS_STATE_DEFAULT;
    array_push($DECLARATIONS_STACK, $DECLARATIONS_STATE);

    if ((function_exists('get_value')) && (get_value('trusted_sites_1') === null)) {
        require_code('caches3');
        regenerate_trusted_sites_cache();
    }
}

/**
 * Pre-load used blocks in bulk.
 */
function preload_block_internal_caching()
{
    global $SMART_CACHE;
    if (has_caching_for('block')) {
        $blocks_needed = $SMART_CACHE->get('blocks_needed');
        if (($blocks_needed !== null) && ($blocks_needed !== false)) {
            $bulk = [];

            foreach ($blocks_needed as $param => $_) {
                $block_details = @unserialize($param);
                if ($block_details !== false) {
                    $bulk[] = $block_details;
                }
            }

            if ($GLOBALS['PERSISTENT_CACHE'] === null) {
                _get_cache_entries($bulk); // Will cache internally so that block loads super-quick
            }
        }
    }
}

/**
 * Declare what security properties the programmer understands. i.e. Self-certification.
 * A good programmer will understand the correct data conversions to undergo in order to write secure/correct/reliable code.
 * A newbie programmer likely will not, sloppiness or a lack of understanding could lead to critical mistakes.
 * If declarations aren't made then extra security precautions are taken, which may interfere with normal processing in limited cases.
 * Declarations should be made whenever entering a custom block or module.
 *
 * @param  integer $declarations Bitmask of declarations (I_UNDERSTAND_* constants)
 */
function i_solemnly_declare(int $declarations)
{
    global $DECLARATIONS_STACK, $DECLARATIONS_STATE_DEFAULT, $DECLARATIONS_STATE;
    array_pop($DECLARATIONS_STACK);
    $new_state = [];
    foreach (array_keys($DECLARATIONS_STATE_DEFAULT) as $property) {
        $new_state[$property] = (($declarations & $property) != 0);
    }
    $DECLARATIONS_STACK[] = $new_state;
    $DECLARATIONS_STATE = $new_state;
}

/**
 * Enter a new security scope (i.e. a custom block or module).
 *
 * @ignore
 */
function _solemnly_enter()
{
    if (in_safe_mode()) {
        // No custom code actually running
        return;
    }

    global $DECLARATIONS_STACK, $DECLARATIONS_STATE_DEFAULT, $DECLARATIONS_STATE;
    $new_state = [];
    foreach (array_keys($DECLARATIONS_STATE_DEFAULT) as $property) {
        $new_state[$property] = false;
    }
    $DECLARATIONS_STACK[] = $new_state;
    $DECLARATIONS_STATE = $new_state;
}

/**
 * Leave the most recent security scope (i.e. a custom block or module).
 *
 * @param  ?string $out Output to filter, if I_UNDERSTAND_XSS is not set (null: nothing to filter)
 *
 * @ignore
 */
function _solemnly_leave(?string &$out = null)
{
    if (in_safe_mode()) {
        // No custom code actually running
        return;
    }

    if ((!has_solemnly_declared(I_UNDERSTAND_XSS)) && ($out !== null)) {
        foreach (array_merge(array_values($_POST), array_values($_GET)) as $before) {
            if (is_string($before)) {
                $after = $before;
                kid_gloves_html_escaping_singular($after);
                if ($after !== $before) {
                    $out = str_replace($before, $after, $out);
                }
            }
        }
    }

    if (!has_solemnly_declared(I_UNDERSTAND_PATH_INJECTION)) {
        foreach ($_GET as $param) {
            if (is_string($param)) {
                filter_naughty($param);
            }
        }
    }

    global $DECLARATIONS_STACK, $DECLARATIONS_STATE;
    array_pop($DECLARATIONS_STACK);
    $DECLARATIONS_STATE = array_pop($DECLARATIONS_STACK);
    array_push($DECLARATIONS_STACK, $DECLARATIONS_STATE);
}

/**
 * Find if a security property has been declared as being understood.
 *
 * @param  integer $declaration The property
 * @return boolean Whether it is understood
 */
function has_solemnly_declared(int $declaration) : bool
{
    if (($declaration == I_UNDERSTAND_XSS) && ($GLOBALS['CSP_ENABLED'])) {
        return true;
    }

    global $DECLARATIONS_STATE;
    return $DECLARATIONS_STATE[$declaration];
}

/**
 * Consider virtual zone merging, where paths are not necessarily where you'd expect for pages in zones.
 *
 * @param  PATH $path The path, assuming in the obvious place
 * @param  boolean $relative Where the passed path is relative
 * @return PATH The fixed path
 */
function zone_black_magic_filterer(string $path, bool $relative = false) : string
{
    static $no_collapse_zones = null;
    if ($no_collapse_zones === null) {
        $no_collapse_zones = (get_option('single_public_zone') !== '1');
    }
    if ($no_collapse_zones) {
        return $path;
    }

    static $zbmf_cache = null;
    if ($zbmf_cache === null) {
        $zbmf_cache = function_exists('persistent_cache_get') ? persistent_cache_get('ZBMF_CACHE') : [];
        if ($zbmf_cache === null) {
            $zbmf_cache = [];
        }
    }

    if (isset($zbmf_cache[$path])) {
        return $zbmf_cache[$path];
    }

    if ($relative) {
        $stripped = $path;
    } else {
        $cfb = get_custom_file_base();
        if (substr($path, 0, strlen($cfb)) === $cfb) {
            $stripped = substr($path, strlen($cfb) + 1);
        } else {
            $fb = get_file_base();
            $stripped = substr($path, strlen($fb) + 1);
        }
    }

    if ($stripped !== '') {
        if ($stripped[0] === '/') {
            $stripped = substr($stripped, 1);
        }

        if (($stripped[0] === 'p') && (substr($stripped, 0, 6) === 'pages/')) { // Ah, need to do some checks as we are looking in the welcome zone
            $full = $relative ? (get_file_base() . '/' . $path) : $path;
            if (!@is_file($full)) {
                $site_equiv = get_file_base() . '/site/' . $stripped;

                if (@is_file($site_equiv)) {
                    $ret = $relative ? ('site/' . $stripped) : $site_equiv;
                    $zbmf_cache[$path] = $ret;
                    if (function_exists('persistent_cache_set')) {
                        persistent_cache_set('ZBMF_CACHE', $zbmf_cache);
                    }
                    return $ret;
                }
            }
        }
    }

    $zbmf_cache[$path] = $path;
    if (function_exists('persistent_cache_set')) {
        persistent_cache_set('ZBMF_CACHE', $zbmf_cache);
    }
    return $path;
}

/**
 * Find the path to a Comcode page on disk.
 *
 * @param  LANGUAGE_NAME $lang The language most preferable
 * @param  ID_TEXT $file The page name
 * @param  ID_TEXT $zone The zone
 * @return array A triple: The file base, The path (blank: not found), Combined path (blank: not found)
 */
function find_comcode_page(string $lang, string $file, string $zone) : array
{
    $file_path = zone_black_magic_filterer(filter_naughty($zone . (($zone == '') ? '' : '/') . 'pages/comcode_custom/' . $lang . '/' . $file . '.txt'), true);

    $file_base = null;
    if (is_file(get_custom_file_base() . '/' . $file_path)) {
        $file_base = get_custom_file_base();
    } elseif (is_file(get_file_base() . '/' . $file_path)) {
        $file_base = get_file_base();
    }

    if ($file_base === null) {
        $page_request = _request_page($file, $zone);
        if ($page_request === false || strpos($page_request[0], 'COMCODE') === false) {
            return [get_file_base(), '', ''];
        }
        $file_path = $page_request[count($page_request) - 1];

        $file_base = get_custom_file_base();
        if (!is_file($file_base . '/' . $file_path)) {
            $file_base = get_file_base();
        }
    }

    return [$file_base, $file_path, ($file_path == '') ? '' : ($file_base . '/' . $file_path)];
}

/**
 * Get the name of the zone the current page request is coming from.
 *
 * @return ID_TEXT The current zone
 */
function get_zone_name() : string
{
    global $ZONE, $RELATIVE_PATH, $SITE_INFO, $VIRTUALISED_ZONES_CACHE;
    if ($ZONE !== null) {
        return $ZONE['zone_name'];
    }
    if ($VIRTUALISED_ZONES_CACHE !== false) {
        $VIRTUALISED_ZONES_CACHE = false;
        $url_path = str_replace('\\', '/', dirname($_SERVER['SCRIPT_NAME']));
        $host = get_request_hostname();
        foreach ($SITE_INFO as $key => $val) {
            if (($key[0] === 'Z') && (substr($key, 0, 13) === 'ZONE_MAPPING_') && (is_array($val))) {
                $VIRTUALISED_ZONES_CACHE = true;
                if (($host === $val[0]) && (preg_match('#^' . (($val[1] === '') ? '' : ('/' . preg_quote($val[1]))) . '(/|$)#', $url_path) != 0)) {
                    return @strval(substr($key, 13));
                }
            }
        }
        if (($VIRTUALISED_ZONES_CACHE) && (substr($host, 0, 4) === 'www.')) {
            $host = substr($host, 4);
            foreach ($SITE_INFO as $key => $val) {
                if (($key[0] === 'Z') && (substr($key, 0, 13) === 'ZONE_MAPPING_') && (is_array($val))) {
                    if (($host === $val[0]) && (preg_match('#^' . (($val[1] === '') ? '' : ('/' . preg_quote($val[1]))) . '(/|$)#', $url_path) != 0)) {
                        require_code('urls');
                        set_http_status_code(301);
                        header('Location: ' . escape_header(str_replace('://www.', '://', get_self_url_easy()))); // assign_refresh not used, as it is a pre-page situation
                        exit();
                    }
                }
            }
        }
    }
    $real_zone = (($RELATIVE_PATH === 'data') || ($RELATIVE_PATH === 'data_custom')) ? get_param_string('zone', '') : $RELATIVE_PATH;

    return $real_zone;
}

/**
 * Load up redirect cache.
 */
function load_redirect_cache()
{
    global $REDIRECT_CACHE;

    if ($REDIRECT_CACHE === null) {
        $REDIRECT_CACHE = [];
    }

    if ((addon_installed('redirects_editor')) && (!$GLOBALS['IN_MINIKERNEL_VERSION'])) {
        $redirect = persistent_cache_get('REDIRECT');
        if ($redirect === null) {
            $redirect = $GLOBALS['SITE_DB']->query_select('redirects', ['*']/*Actually for performance we will load all and cache them , ['r_from_zone' => get_zone_name(])*/);
            persistent_cache_set('REDIRECT', $redirect);
        }
        foreach ($redirect as $r) {
            if (($r['r_from_zone'] == $r['r_to_zone']) && ($r['r_from_page'] == $r['r_to_page'])) {
                continue;
            }

            $REDIRECT_CACHE[$r['r_from_zone']][cms_strtolower_ascii($r['r_from_page'])] = $r;
        }
    }
}

/**
 * Find the zone a module is in.
 *
 * @param  ID_TEXT $module_name The page name to find
 * @param  ID_TEXT $type The type of the page we are looking for
 * @param  ?string $dir2 The special subcategorisation of page we are looking for (e.g. 'EN' for a Comcode page) (null: none)
 * @param  string $ftype The file extension for the page type
 * @param  boolean $error Whether Composr should bomb out if the page was not found
 * @param  boolean $check_redirects Whether to check against redirects
 * @param  ?ID_TEXT $first_zone_to_check First zone to check (used for an optimisation) (null: current zone)
 * @return ?ID_TEXT The zone the page is in (null: not found)
 */
function get_module_zone(string $module_name, string $type = 'modules', ?string $dir2 = null, string $ftype = 'php', bool $error = true, bool $check_redirects = true, ?string $first_zone_to_check = null) : ?string
{
    if ($module_name === '') {
        return null;
    }

    $_zone = get_zone_name();
    if ($first_zone_to_check === null) {
        $first_zone_to_check = $_zone;
    }

    global $MODULES_ZONES_CACHE;
    if ((isset($MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name])) || ((!$error) && (isset($MODULES_ZONES_CACHE[$check_redirects][$_zone][$type])) && (array_key_exists($module_name, $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type])) && ($type === 'modules')/*don't want to look at cached failure for different page type*/)) {
        if (is_string($MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name])/*should always be a string, but possible weird bug*/) {
            return $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name];
        }
    }

    $error = false; // hack for now

    if (($module_name === get_page_name()) && (running_script('index')) && ($module_name !== 'login')) {
        $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $_zone;
        return $_zone;
    }

    if (get_value('allow_admin_in_other_zones') !== '1') {
        if (($type === 'modules') && ($module_name[0] === 'a') && (($module_name == 'admin') || (substr($module_name, 0, 6) === 'admin_'))) {
            $zone = 'adminzone';
            $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
            return $zone;
        }
        if (($type === 'modules') && ($module_name[0] === 'c') && (($module_name == 'cms') || (substr($module_name, 0, 4) === 'cms_'))) {
            $zone = 'cms';
            $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
            return $zone;
        }
    }

    $check_redirects = $check_redirects && (get_value('no_priority_redirects') !== '1');

    $likely_non_custom = ($type == 'minimodules') || ($type == 'html');

    global $REDIRECT_CACHE;
    if ($check_redirects && $REDIRECT_CACHE === null) {
        load_redirect_cache();
    }
    if (($module_name[0] == 'a') && (($module_name == 'admin') || (substr($module_name, 0, 6) === 'admin_'))) {
        $first_zones = ['adminzone'];
    } elseif (($module_name[0] == 'c') && (($module_name == 'cms') || (substr($module_name, 0, 4) === 'cms_'))) {
        $first_zones = ['cms'];
    } else {
        $first_zones = [$first_zone_to_check];
        if ($first_zone_to_check !== '') {
            $first_zones[] = '';
        }
        if (($first_zone_to_check !== 'site') && (get_option('single_public_zone') !== '1')/* && (is_file(get_file_base().'/site/index.php'))*/) {
            $first_zones[] = 'site';
        }
    }
    foreach ($first_zones as $zone) {
        if (($check_redirects) && ((isset($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)])) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_is_transparent'] === 1) || (isset($REDIRECT_CACHE['*'][$module_name])) && ($REDIRECT_CACHE['*'][$module_name]['r_is_transparent'] === 1))) { // Only needs to actually look for redirections in first zones until end due to the way precedences work (we know the current zone will be in the first zones)
            $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('MODULES_ZONES', $MODULES_ZONES_CACHE);
            }
            return $zone;
        }

        $a = zone_black_magic_filterer(get_file_base() . '/' . $zone . (($zone == '') ? '' : '/') . 'pages/' . $type . '/' . (($dir2 === null) ? '' : ($dir2 . '/')) . $module_name . '.' . $ftype);
        $b = zone_black_magic_filterer(get_file_base() . '/' . $zone . (($zone == '') ? '' : '/') . 'pages/' . $type . '_custom/' . (($dir2 === null) ? '' : ($dir2 . '/')) . $module_name . '.' . $ftype);
        if ((($likely_non_custom) && ((is_file($b)) || (is_file($a)))) || ((!$likely_non_custom) && ((is_file($a)) || (is_file($b))))) { // heavily optimised based on most likely path coming first
            if (($check_redirects) && (isset($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)])) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_is_transparent'] === 0) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_to_page'] === $module_name)) {
                $zone = $REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_to_zone'];
            }
            $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('MODULES_ZONES', $MODULES_ZONES_CACHE);
            }
            return $zone;
        }
    }
    $start = 0;
    $max = 50;
    $first_zones_flip = array_flip($first_zones);
    do {
        $zones = find_all_zones(false, false, false, $start, $max);
        foreach ($zones as $zone) {
            if (!array_key_exists($zone, $first_zones_flip)) {
                $a = zone_black_magic_filterer(get_file_base() . '/' . $zone . (($zone == '') ? '' : '/') . 'pages/' . $type . '/' . (($dir2 === null) ? '' : ($dir2 . '/')) . $module_name . '.' . $ftype);
                $b = zone_black_magic_filterer(get_file_base() . '/' . $zone . (($zone == '') ? '' : '/') . 'pages/' . $type . '_custom/' . (($dir2 === null) ? '' : ($dir2 . '/')) . $module_name . '.' . $ftype);
                if ((($likely_non_custom) && ((is_file($b)) || (is_file($a)))) || ((!$likely_non_custom) && ((is_file($a)) || (is_file($b))))) { // heavily optimised based on most likely path coming first
                    if (($check_redirects) && (isset($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)])) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_is_transparent'] === 0) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_to_page'] === $module_name)) {
                        $zone = $REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_to_zone'];
                    }
                    $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
                    if (function_exists('persistent_cache_set')) {
                        persistent_cache_set('MODULES_ZONES', $MODULES_ZONES_CACHE);
                    }
                    return $zone;
                }
            }
        }
        $start += 50;
    } while (count($zones) == $max);

    foreach ($zones as $zone) { // Okay, finally check for redirects
        if (($check_redirects) && (isset($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)])) && ($REDIRECT_CACHE[$zone][cms_strtolower_ascii($module_name)]['r_is_transparent'] === 1)) {
            $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = $zone;
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('MODULES_ZONES', $MODULES_ZONES_CACHE);
            }
            return $zone;
        }
    }

    if (!$error) {
        $MODULES_ZONES_CACHE[$check_redirects][$_zone][$type][$module_name] = null;
        return null;
    }
    warn_exit(do_lang_tempcode('MISSING_MODULE_FILE', escape_html($module_name)), false, true);
    return null;
}

/**
 * Find the zone a Comcode page is in.
 *
 * @param  ID_TEXT $page_name The Comcode page name to find
 * @param  boolean $error Whether Composr should bomb out if the page was not found
 * @param  ?ID_TEXT $first_zone_to_check First zone to check (used for an optimisation) (null: current zone)
 * @return ?ID_TEXT The zone the Comcode page is in (null: missing)
 */
function get_comcode_zone(string $page_name, bool $error = true, ?string $first_zone_to_check = null) : ?string
{
    $test = get_module_zone($page_name, 'comcode', user_lang(), 'txt', false, true, $first_zone_to_check);
    if ($test !== null) {
        return $test;
    }
    if (get_site_default_lang() != user_lang()) {
        $test = get_module_zone($page_name, 'comcode', get_site_default_lang(), 'txt', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
    }
    if (fallback_lang() != get_site_default_lang()) {
        $test = get_module_zone($page_name, 'comcode', fallback_lang(), 'txt', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
    }
    if ($error) {
        warn_exit(do_lang_tempcode('MISSING_MODULE_FILE', escape_html($page_name)), false, true);
    }
    return null;
}

/**
 * Find the zone a page is in.
 *
 * @param  ID_TEXT $page_name The page name to find
 * @param  boolean $error Whether Composr should bomb out if the page was not found
 * @param  ?ID_TEXT $first_zone_to_check First zone to check (used for an optimisation) (null: current zone)
 * @param  ?ID_TEXT $type Page type (null: check all)
 * @return ?ID_TEXT The zone the page is in (null: missing)
 */
function get_page_zone(string $page_name, bool $error = true, ?string $first_zone_to_check = null, ?string $type = null) : ?string
{
    if (($type === null) || ($type == 'comcode')) {
        // Optimisation for pages known to default as Comcode pages
        if (in_array($page_name, ['privacy', 'sitemap', 'feedback', 'panel_top', 'panel_bottom', 'panel_left', 'panel_right', 'rules', 'keymap', DEFAULT_ZONE_PAGE_NAME])) {
            $test = get_comcode_zone($page_name, false);
            if ($test !== null) {
                return $test;
            }
        }
    }

    if (($type === null) || ($type == 'modules')) {
        $test = get_module_zone($page_name, 'modules', null, 'php', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
    }
    if (($type === null) || ($type == 'comcode')) {
        $test = get_module_zone($page_name, 'comcode', get_site_default_lang(), 'txt', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
        if (fallback_lang() != get_site_default_lang()) {
            $test = get_module_zone($page_name, 'comcode', fallback_lang(), 'txt', false, true, $first_zone_to_check);
            if ($test !== null) {
                return $test;
            }
        }
    }
    if (($type === null) || ($type == 'html')) {
        $test = get_module_zone($page_name, 'html', get_site_default_lang(), 'htm', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
        if (fallback_lang() != get_site_default_lang()) {
            $test = get_module_zone($page_name, 'html', fallback_lang(), 'htm', false, true, $first_zone_to_check);
            if ($test !== null) {
                return $test;
            }
        }
    }
    if (($type === null) || ($type == 'minimodules')) {
        $test = get_module_zone($page_name, 'minimodules', null, 'php', false, true, $first_zone_to_check);
        if ($test !== null) {
            return $test;
        }
    }
    if ($error) {
        warn_exit(do_lang_tempcode('MISSING_MODULE_FILE', escape_html($page_name)), false, true);
    }
    return null;
}

/**
 * Runs the specified mini-module.
 * The module result is returned.
 *
 * @param  PATH $string The relative path to the module file
 * @return Tempcode The result of executing the module
 */
function load_minimodule_page(string $string) : object
{
    global $PAGE_STRING;
    if ($PAGE_STRING === null) {
        $PAGE_STRING = $string;
    }

    return _load_mini_code($string);
}

/**
 * Runs the specified mini-module/mini-block (actually, any simply-written PHP code).
 * The returned/output result is returned, in Tempcode form.
 *
 * @param  PATH $string The relative path to the code file
 * @param  array $map The block parameters
 * @return Tempcode The result of executing the code
 *
 * @ignore
 */
function _load_mini_code(string $string, array $map = []) : object
{
    require_code('developer_tools');
    destrictify();

    if (strpos($string, '_custom/') !== false) {
        _solemnly_enter();
    }

    ob_start();
    $test1 = require(get_file_base() . '/' . $string);
    $test2 = ob_get_contents();
    if ($GLOBALS['XSS_DETECT']) {
        ocp_mark_as_escaped($test2);
    }
    ob_end_clean();
    if ($test2 == '') {
        if (is_object($test1)) {
            if (strpos($string, '_custom/') !== false) {
                $_test1 = $test1->evaluate();
                _solemnly_leave($_test1);
                if (!has_solemnly_declared(I_UNDERSTAND_XSS)) {
                    $test1 = make_string_tempcode($_test1);
                }
            }

            $out = $test1;
        } else {
            $out = new Tempcode();
            if ((!is_bool($test1)) && (!is_integer($test1))) { // Not an automatic return code
                $_test1 = is_string($test1) ? $test1 : strval($test1);

                if (strpos($string, '_custom/') !== false) {
                    _solemnly_leave($_test1);
                }

                $out->attach($_test1);
            } else {
                if (strpos($string, '_custom/') !== false) {
                    _solemnly_leave();
                }
            }
        }
    } else {
        if (strpos($string, '_custom/') !== false) {
            _solemnly_leave($test2);
        }

        $out = new Tempcode();
        $out->attach($test2);
    }

    restrictify();

    return $out;
}

/**
 * Runs the specified module, but also update any stats for the module, and check to see if it needs upgrading or reinstalling.
 * The module result is returned.
 *
 * @param  PATH $string The relative path to the module file
 * @param  ID_TEXT $codename The page name to load
 * @return Tempcode The result of executing the module
 */
function load_module_page(string $string, string $codename) : object
{
    global $PAGE_STRING;
    if ($PAGE_STRING === null) {
        $PAGE_STRING = $string;
    }

    if ((strpos($string, '_custom/') !== false) && (!is_file(str_replace('_custom/', '/', $string)))) {
        _solemnly_enter();
    }

    require_code(filter_naughty($string));
    if (class_exists('Mx_' . filter_naughty_harsh($codename))) {
        $object = object_factory('Mx_' . filter_naughty_harsh($codename));
    } else {
        $object = object_factory('Module_' . filter_naughty_harsh($codename));
    }

    _check_module_installation_status($object, $codename);

    if (method_exists($object, 'pre_run')) {
        $exceptional_output = $object->pre_run();
        if ($exceptional_output !== null) {
            if ((strpos($string, '_custom/') !== false) && (!is_file(str_replace('_custom/', '/', $string)))) {
                $_exceptional_output = $exceptional_output->evaluate();
                _solemnly_leave($_exceptional_output);
                if (!has_solemnly_declared(I_UNDERSTAND_XSS)) {
                    $exceptional_output = make_string_tempcode($_exceptional_output);
                }
            }

            return $exceptional_output;
        }
    }

    $ret = $object->run();

    if ((strpos($string, '_custom/') !== false) && (!is_file(str_replace('_custom/', '/', $string)))) {
        $_ret = $ret->evaluate();
        _solemnly_leave($_ret);
        if (!has_solemnly_declared(I_UNDERSTAND_XSS)) {
            $ret = make_string_tempcode($_ret);
        }
    }

    return $ret;
}

/**
 * Find the installed zones, up to the first $max installed.
 *
 * @param  boolean $search Whether to search the file system and return zones that might not be fully in the system (otherwise will just use the database)
 * @param  boolean $get_titles Whether to get titles for the zones as well. Only if !$search
 * @param  boolean $force_all Whether to insist on getting all zones without $start/$max parameters (there could be thousands in theory...)
 * @param  integer $start Start position to get results from (ignored if $force_all is on)
 * @param  integer $max Maximum zones to get
 * @return array A list of zone names / a list of quartets (name, title, default page, zone row)
 */
function find_all_zones(bool $search = false, bool $get_titles = false, bool $force_all = false, int $start = 0, int $max = 50) : array
{
    $single_public_zone = (get_option('single_public_zone') == '1');

    if ($search) {
        if ($start > 0) { // No pagination currently in search mode
            return [];
        }

        $out = [''];

        $dh = opendir(get_file_base());
        while (($file = readdir($dh)) !== false) {
            if (($file != '.') && ($file != '..') && (is_dir($file)) && (is_readable(get_file_base() . '/' . $file)) && (is_file(get_file_base() . '/' . $file . '/index.php')) && (is_dir(get_file_base() . '/' . $file . '/pages/modules'))) {
                if (($single_public_zone) && ($file == 'site')) {
                    continue;
                }

                if ((get_forum_type() != 'cns') && ($file == 'forum')) {
                    continue;
                }

                $out[] = $file;

                if ((!$force_all) && (count($out) == $max)) {
                    break;
                }
            }
        }
        closedir($dh);

        return $out;
    }

    global $ALL_ZONES_CACHE, $ALL_ZONES_TITLED_CACHE, $ZONE_DEFAULT_PAGES_CACHE, $SITE_INFO;

    $using_default_params = (!$force_all) && ($start == 0) && (($max == 50) || (($max > 50) && ($ALL_ZONES_CACHE !== null) && (count($ALL_ZONES_CACHE) < 30)));
    if ($using_default_params) {
        if ($get_titles) {
            if ($ALL_ZONES_TITLED_CACHE === null) {
                $ALL_ZONES_TITLED_CACHE = function_exists('persistent_cache_get') ? persistent_cache_get('ALL_ZONES_TITLED') : null;
            }
            if (!is_array($ALL_ZONES_TITLED_CACHE)) {
                $ALL_ZONES_TITLED_CACHE = null; // Cache corruption?
            }
            if ($ALL_ZONES_TITLED_CACHE !== null) {
                return $ALL_ZONES_TITLED_CACHE;
            }
        } else {
            if ($ALL_ZONES_CACHE === null) {
                $ALL_ZONES_CACHE = function_exists('persistent_cache_get') ? persistent_cache_get('ALL_ZONES') : null;
            }
            if (!is_array($ALL_ZONES_CACHE)) {
                $ALL_ZONES_CACHE = null; // Cache corruption?
            }
            if ($ALL_ZONES_CACHE !== null) {
                return $ALL_ZONES_CACHE;
            }
        }
    }

    $rows = $GLOBALS['SITE_DB']->query_select('zones', ['*'], [], 'ORDER BY zone_name', $force_all ? null : $max, $start);
    if ((!$force_all) && (count($rows) == $max)) {
        $rows = $GLOBALS['SITE_DB']->query_select('zones', ['*'], [], 'ORDER BY zone_title', $max/*reasonable limit; zone_title is sequential for default zones*/);
    }
    $zones_titled = [];
    $zones = [];
    foreach ($rows as $zone) {
        if (($single_public_zone) && ($zone['zone_name'] == 'site')) {
            continue;
        }

        if ((get_forum_type() != 'cns') && ($zone['zone_name'] == 'forum')) {
            continue;
        }

        $zone['_zone_title'] = function_exists('get_translated_text') ? get_translated_text($zone['zone_title']) : $zone['zone_name'];

        if (((isset($SITE_INFO['no_disk_sanity_checks'])) && ($SITE_INFO['no_disk_sanity_checks'] == '1')) || (is_file(get_file_base() . '/' . $zone['zone_name'] . (($zone['zone_name'] == '') ? '' : '/') . 'index.php'))) {
            $zones[] = $zone['zone_name'];
            $zones_titled[$zone['zone_name']] = [$zone['zone_name'], $zone['_zone_title'], $zone['zone_default_page'], $zone];
        }

        $ZONE_DEFAULT_PAGES_CACHE[$zone['zone_name']] = $zone['zone_default_page'];
    }

    if (($using_default_params) && (function_exists('get_translated_text'))) {
        $ALL_ZONES_TITLED_CACHE = $zones_titled;
        if (function_exists('persistent_cache_set')) {
            persistent_cache_set('ALL_ZONES_TITLED', $ALL_ZONES_TITLED_CACHE);
        }
        $ALL_ZONES_CACHE = $zones;
        if (function_exists('persistent_cache_set')) {
            persistent_cache_set('ALL_ZONES', $ALL_ZONES_CACHE);
        }
    }

    return $get_titles ? $zones_titled : $zones;
}

/**
 * Look up and remember what modules are installed.
 */
function cache_module_installed_status()
{
    global $MODULE_INSTALLED_CACHE;
    $rows = $GLOBALS['SITE_DB']->query_select('modules', ['module_the_name']);
    foreach ($rows as $row) {
        $MODULE_INSTALLED_CACHE[$row['module_the_name']] = true;
    }
}

/**
 * Check to see if a module is installed.
 *
 * @param  ID_TEXT $module The module name
 * @return boolean Whether it is
 */
function module_installed(string $module) : bool
{
    global $MODULE_INSTALLED_CACHE;
    if (array_key_exists($module, $MODULE_INSTALLED_CACHE)) {
        return $MODULE_INSTALLED_CACHE[$module];
    }
    $test = $GLOBALS['SITE_DB']->query_select_value_if_there('modules', 'module_the_name', ['module_the_name' => $module]);
    $answer = $test !== null;
    $MODULE_INSTALLED_CACHE[$module] = $answer;
    return $answer;
}

/**
 * Get the path to a module known to be in a certain zone.
 *
 * @param  ID_TEXT $zone The zone name
 * @param  ID_TEXT $module The module name
 * @return PATH The module path
 *
 * @ignore
 */
function _get_module_path(string $zone, string $module) : string
{
    $module_path = zone_black_magic_filterer(($zone == '') ? ('pages/modules_custom/' . filter_naughty_harsh($module) . '.php') : (filter_naughty($zone) . '/pages/modules_custom/' . filter_naughty_harsh($module) . '.php'), true);
    if ((in_safe_mode()) || (!is_file(get_file_base() . '/' . $module_path))) {
        $module_path = zone_black_magic_filterer(($zone == '') ? ('pages/modules/' . filter_naughty_harsh($module) . '.php') : (filter_naughty($zone) . '/pages/modules/' . filter_naughty_harsh($module) . '.php'), true);
    }
    return $module_path;
}

/**
 * Get an array of all the hook implementation objects for a hook sub-type.
 *
 * @param  ID_TEXT $type The type of hook
 * @param  ID_TEXT $subtype The hook sub-type to find hook implementations for (e.g. the name of a module)
 * @param  string $classname_prefix The hook class-name prefix, the classes are named {$classname_prefix}{$hook}
 * @return array A map of hook implementation name to hook object
 */
function find_all_hook_obs(string $type, string $subtype, string $classname_prefix) : array
{
    $hooks = find_all_hooks($type, $subtype);
    ksort($hooks);
    foreach ($hooks as $hook => $hook_dir) {
        require_code('hooks/' . $type . '/' . $subtype . '/' . $hook, false, $hook_dir == 'sources_custom');

        $ob = object_factory(class_exists(str_replace('Hook_', 'Hx_', $classname_prefix) . $hook) ? (str_replace('Hook_', 'Hx_', $classname_prefix) . $hook) : ($classname_prefix . $hook), true);
        if ($ob !== null) {
            $hooks[$hook] = $ob;
        } else {
            unset($hooks[$hook]);
        }
    }
    return $hooks;
}

/**
 * Get the specified hook implementation object and fail if it does not exist.
 *
 * @param  ID_TEXT $type The type of hook
 * @param  ID_TEXT $subtype The hook sub-type to find hook implementations for (e.g. the name of a module)
 * @param  ID_TEXT $hook The name of the hook
 * @param  string $classname_prefix The hook class-name prefix, the classes are named {$classname_prefix}{$hook}
 * @param  boolean $fail_ok Whether to return null opposed to failing if the hook or its object does not exist
 * @return ?object The hook implementation object (null: hook was not found and $fail_ok was true)
 */
function get_hook_ob(string $type, string $subtype, string $hook, string $classname_prefix, bool $fail_ok = false) : ?object
{
    if (($fail_ok) && (!hook_exists($type, $subtype, $hook))) {
        return null;
    }

    require_code('hooks/' . $type . '/' . $subtype . '/' . $hook, !$fail_ok);

    $ob = object_factory(class_exists(str_replace('Hook_', 'Hx_', $classname_prefix) . $hook) ? (str_replace('Hook_', 'Hx_', $classname_prefix) . $hook) : ($classname_prefix . $hook), true);
    if ((!$fail_ok) && ($ob === null)) {
        warn_exit(do_lang_tempcode('INTERNAL_ERROR'));
    }

    return $ob;
}

/**
 * Get an array of all the hook implementation names for a hook sub-type.
 *
 * @param  ID_TEXT $type The type of hook
 * @set blocks endpoints modules systems
 * @param  ID_TEXT $subtype The hook sub-type to find hook implementations for (e.g. the name of a module)
 * @param  boolean $check_custom Whether to consider and prioritise sources_custom hooks
 * @return array A map of hook implementation name to [sources|sources_custom]
 */
function find_all_hooks(string $type, string $subtype, bool $check_custom = true) : array
{
    global $HOOKS_CACHE;
    if (isset($HOOKS_CACHE[$type . '/' . $subtype])) {
        return $HOOKS_CACHE[$type . '/' . $subtype];
    }

    $out = [];

    if (strpos($type, '..') !== false) {
        $type = filter_naughty($type);
    }
    if (strpos($subtype, '..') !== false) {
        $subtype = filter_naughty($subtype);
    }
    $dir = get_file_base() . '/sources/hooks/' . $type . '/' . $subtype;
    $dh = is_dir($dir) ? scandir($dir) : false;
    if ($dh !== false) {
        foreach ($dh as $file) {
            $basename = basename($file, '.php');
            if (($file[0] != '.') && ($file === $basename . '.php')/* && (preg_match('#^[\w\-]*$#', $basename) != 0) Let's trust - performance*/) {
                $out[$basename] = 'sources';
            }
        }
    }

    if ($check_custom) {
        $doing_custom_scan = (!isset($GLOBALS['DOING_USERS_INIT'])) && ((!in_safe_mode()) || (($GLOBALS['RELATIVE_PATH'] === '_tests') && ($subtype === 'addon_registry')));
        if ($doing_custom_scan) { // The !isset is because of if the user init causes a DB query to load sessions which loads DB hooks which checks for safe mode which leads to a permissions check for safe mode and thus a failed user check (as sessions not loaded yet)
            $dir = get_file_base() . '/sources_custom/hooks/' . $type . '/' . $subtype;
            $dh = is_dir($dir) ? scandir($dir) : false;
            if ($dh !== false) {
                foreach ($dh as $file) {
                    $basename = basename($file, '.php');
                    if (($file[0] != '.') && ($file === $basename . '.php')/* && (preg_match('#^[\w\-]*$#', $basename) != 0) Let's trust - performance*/) {
                        $out[$basename] = 'sources_custom';
                    }
                }
            }
        }
    }

    // Optimisation, so that hooks with same name as our page get loaded first
    $page = get_param_string('page', '', INPUT_FILTER_GET_COMPLEX); // Not get_page_name for bootstrap order reasons
    if (array_key_exists($page, $out)) {
        $_out = [$page => $out[$page]];
        unset($out[$page]);
        $out = array_merge($_out, $out);
    }

    if (!isset($GLOBALS['DOING_USERS_INIT'])) {
        $HOOKS_CACHE[$type . '/' . $subtype] = $out;

        if (($doing_custom_scan) && (!running_script('install'))) {
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('HOOKS', $HOOKS_CACHE);
            }
        }
    }

    return $out;
}

/**
 * Check if a given hook exists.
 *
 * @param  ID_TEXT $type The type of hook
 * @set blocks endpoints modules systems
 * @param  ID_TEXT $subtype The hook sub-type to find hook implementations for (e.g. the name of a module)
 * @param  ID_TEXT $hook The name of the hook
 * @return boolean Whether or not the hook exists
 */
function hook_exists(string $type, string $subtype, string $hook) : bool
{
    global $HOOKS_CACHE;
    if (isset($HOOKS_CACHE[$type . '/' . $subtype]) && isset($HOOKS_CACHE[$type . '/' . $subtype][$hook])) {
        return true;
    }

    if ((is_file(get_file_base() . '/sources/hooks/' . $type . '/' . $subtype . '/' . $hook . '.php')) || (is_file(get_file_base() . '/sources_custom/hooks/' . $type . '/' . $subtype . '/' . $hook . '.php'))) {
        return true;
    }

    return false;
}

/**
 * Find the default caching setting for a block.
 *
 * @param  ID_TEXT $codename The block name
 * @return ID_TEXT The default caching setting
 */
function block_cache_default(string $codename) : string
{
    if (cron_installed(true)) {
        if ($codename === 'side_rss' || $codename === 'main_rss') { // Special cases to stop external dependencies causing slowdowns
            return '2';
        }
    }
    return '1'; // NB: If the block doesn't support caching then nothing will be cached even if it is set to 1, UNLESS quick caching is also requested
}

/**
 * Get a unique ID representing a block call.
 *
 * @param  array $map The block parameter map
 * @return ID_TEXT The block ID
 */
function get_block_id(array $map) : string
{
    if (isset($map['block_id'])) {
        return $map['block_id'];
    }
    ksort($map);
    unset($map['raw']);
    unset($map['cache']);
    unset($map['ttl']);
    unset($map['start']);
    unset($map['max']);
    return substr(md5(serialize($map)), 0, 6);
}

/**
 * Get the processed Tempcode for the specified block. Please note that you pass multiple parameters in as an array, but single parameters go in as a string or other flat variable.
 *
 * @param  ID_TEXT $codename The block name
 * @param  array $map The block parameter map
 * @return Tempcode The generated Tempcode
 */
function do_block(string $codename, array $map = []) : object
{
    global $LANGS_REQUESTED, $REQUIRED_ALL_LANG, $JAVASCRIPTS, $CSSS, $DO_NOT_CACHE_THIS, $SMART_CACHE;

    $map['block'] = $codename;

    if (!isset($map['cache'])) {
        $map['cache'] = block_cache_default($codename);
    }

    push_output_state(false, true);

    $DO_NOT_CACHE_THIS = ($map['cache'] === '0');

    if ((isset($map['ttl'])) && ($map['ttl'] != '')) {
        $ttl = intval($map['ttl']);
    } else {
        $ttl = null;
    }

    $object = null;
    $new_security_scope = null;
    if (has_caching_for('block', $codename)) {
        // See if the block may be cached (else cannot, or is yet unknown)
        if ($map['cache'] === '0') {
            $row = null;
        } else { // We may allow it to be cached but not store the cache signature, as it is too complex
            $row = get_block_info_row($codename, $map, $object, $new_security_scope);
        }
        if ($row !== null) {
            $cache_identifier = do_block_get_cache_identifier($codename, $row['cache_on'], $map);
            $special_cache_flags = array_key_exists('special_cache_flags', $row) ? $row['special_cache_flags'] : CACHE_AGAINST_DEFAULT;

            // See if it actually is cached
            if ($cache_identifier !== null) {
                if ($ttl === null) {
                    $ttl = $row['cache_ttl'];
                }
                $cache = get_cache_entry($codename, $cache_identifier, $special_cache_flags, $ttl, true, $map['cache'] === '2', $map);
                if ($cache === null) {
                    if ($object === null) {
                        list($object, $new_security_scope) = do_block_hunt_file($codename, $map);
                    }

                    if (!is_object($object)) {
                        // This probably happened as we uninstalled a block, and now we're getting a "missing block" message back.

                        // Removed outdated cache-on information
                        $GLOBALS['SITE_DB']->query_delete('cache_on', ['cached_for' => $codename], '', 1);
                        persistent_cache_delete('BLOCK_CACHE_ON_CACHE');

                        $out = new Tempcode();
                        $out->attach(@strval($object));
                        restore_output_state(false, true);

                        return $out;
                    }

                    push_query_limiting(false);

                    $out = _check_block_installation_status($object, $codename);
                    if ($out !== null) {
                        restore_output_state(false, true);
                        return $out;
                    }

                    $backup_langs_requested = $LANGS_REQUESTED;
                    $backup_required_all_lang = $REQUIRED_ALL_LANG;
                    $LANGS_REQUESTED = [];
                    $REQUIRED_ALL_LANG = [];
                    if ((isset($map['quick_cache'])) && ($map['quick_cache'] === '1')) { // because we know we will not do this often we can allow this to work as a vector for doing highly complex activity
                        global $MEMORY_OVER_SPEED;
                        $MEMORY_OVER_SPEED = true; // Let this eat up some CPU in order to let it save RAM,
                        disable_php_memory_limit();
                        $old_limit = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLUGGISH);
                    } else {
                        $old_limit = null;
                    }
                    if ($new_security_scope) {
                        _solemnly_enter();
                    }
                    if (isset($SMART_CACHE)) {
                        $SMART_CACHE->paused = true;
                    }
                    $do_inlining_mode = ($codename != 'menu'/*This generates on too many pages and has its own internal optimisation*/);
                    if ($do_inlining_mode) {
                        push_tempcode_parameter_inlining_mode(true);
                    }
                    $cache = $object->run($map);
                    if ($do_inlining_mode) {
                        push_tempcode_parameter_inlining_mode(false);
                    }
                    if ($new_security_scope) {
                        $_cache = $cache->evaluate();
                        _solemnly_leave($_cache);
                        if (!has_solemnly_declared(I_UNDERSTAND_XSS)) {
                            $cache = make_string_tempcode($_cache);
                        }
                    }
                    $cache->evaluate(); // To force lang files to load, etc
                    if (isset($SMART_CACHE)) {
                        $SMART_CACHE->paused = false;
                    }
                    if ($old_limit !== null) {
                        cms_set_time_limit($old_limit);
                    }
                    if (!$DO_NOT_CACHE_THIS) {
                        require_code('caches2');
                        if ((isset($map['quick_cache'])) && ($map['quick_cache'] === '1')/* && (has_cookies())*/) {
                            $cache = apply_quick_caching($cache);
                            $LANGS_REQUESTED = [];
                            $REQUIRED_ALL_LANG = [];
                        }
                        set_cache_entry($codename, $ttl, $cache_identifier, $cache, $special_cache_flags, array_keys($LANGS_REQUESTED), array_keys($JAVASCRIPTS), array_keys($CSSS), true);
                    } elseif (($ttl === null) && ($cache->is_empty())) { // Try again with no TTL, if we currently failed but did impose a TTL
                        $LANGS_REQUESTED += $backup_langs_requested;
                        $REQUIRED_ALL_LANG = $backup_required_all_lang;
                        restore_output_state(false, true);
                        return do_block($codename, ['ttl' => '0'] + $map);
                    }
                    $LANGS_REQUESTED += $backup_langs_requested;
                    $REQUIRED_ALL_LANG += $backup_required_all_lang;

                    pop_query_limiting();
                }
                restore_output_state(false, true);
                return $cache;
            }
        }
    }

    // NB: If we've got this far cache="2" is ignored. But later on (for normal expiries, different contexts, etc) cache_on will be known so not an issue.

    // We will need to load the actual file
    if ($object === null) {
        list($object, $new_security_scope) = do_block_hunt_file($codename, $map);
    }

    if (!is_object($object)) {
        $out = new Tempcode();
        $out->attach(@strval($object));
        restore_output_state(false, true);
        return $out;
    }

    $out = _check_block_installation_status($object, $codename);
    if ($out !== null) {
        restore_output_state(false, true);
        return $out;
    }

    push_query_limiting(false);

    $backup_langs_requested = $LANGS_REQUESTED;
    $backup_required_all_lang = $REQUIRED_ALL_LANG;
    $LANGS_REQUESTED = [];
    $REQUIRED_ALL_LANG = [];
    if ($new_security_scope) {
        _solemnly_enter();
    }
    $cache = $object->run($map);
    if ($new_security_scope) {
        $_cache = $cache->evaluate();
        _solemnly_leave($_cache);
        if (!has_solemnly_declared(I_UNDERSTAND_XSS)) {
            $cache = make_string_tempcode($_cache);
        }
    }

    pop_query_limiting();

    // May it be added to cache_on?
    if ((!$DO_NOT_CACHE_THIS) && (method_exists($object, 'caching_environment')) && (has_caching_for('block', $codename))) {
        $info = $object->caching_environment($map);
        if ($info !== null) {
            if ($ttl === null) {
                $ttl = $info['ttl'];
            }

            $cache_identifier = do_block_get_cache_identifier($codename, $info['cache_on'], $map);
            if ($cache_identifier !== null) {
                $special_cache_flags = array_key_exists('special_cache_flags', $info) ? $info['special_cache_flags'] : CACHE_AGAINST_DEFAULT;

                require_code('caches2');
                set_cache_entry($codename, $ttl, $cache_identifier, $cache, $special_cache_flags, array_keys($LANGS_REQUESTED), array_keys($JAVASCRIPTS), array_keys($CSSS), true);
            }
        }
    }
    $LANGS_REQUESTED += $backup_langs_requested;
    $REQUIRED_ALL_LANG += $backup_required_all_lang;

    restore_output_state(false, true);

    return $cache;
}

/**
 * Simplify some Tempcode (losing dynamicness), for the quick cache option.
 * Includes remove of  contextual URL parameters for neutrality within quick cache.
 *
 * @param  Tempcode $_cache Input Tempcode
 * @return Tempcode Output Tempcode
 */
function apply_quick_caching(object $_cache) : object
{
    $cache = $_cache->evaluate();

    $new_tempcode = new Tempcode();
    $prior_offset = 0;

    $has_keep_parameters = has_keep_parameters();

//    if ($has_keep_parameters) {
//        $keep_first_has_escaping = symbol_tempcode('KEEP', ['0'], [ENTITY_ESCAPED]);
//        $keep_non_first_has_escaping = symbol_tempcode('KEEP', ['1'], [ENTITY_ESCAPED]);
//
//        $keep_first_has_no_escaping = symbol_tempcode('KEEP', ['0'], [NULL_ESCAPED]);
//        $keep_non_first_has_no_escaping = symbol_tempcode('KEEP', ['1'], [NULL_ESCAPED]);
//    }

    $has_escaping = (preg_match('#<a|&\w+;#', $cache) !== 0);

    $matches = [];
    $num_matches = preg_match_all('#(((\?)|(&(amp;)?))keep_[^="\']*=[^\#&"\']*)+#', $cache, $matches, PREG_OFFSET_CAPTURE); // We assume that the keep_* parameters always come last, which holds true in Composr
    for ($i = 0; $i < $num_matches; $i++) {
        $new_offset = $matches[0][$i][1];

        $portion = substr($cache, $prior_offset, $new_offset - $prior_offset);
        if ($GLOBALS['XSS_DETECT'] && ocp_is_escaped($cache)) {
            ocp_mark_as_escaped($portion);
        }

        $new_tempcode->attach($portion);

        if ($has_keep_parameters) { // NB: has_keep_parameters() is in cache signature of 'menu' block, so this is safe for menus, keep_* will still work with this quick caching when both on and off
            if ($matches[0][$i][0][0] === '&') { // Other parameters are non-keep, but as they come first we can just strip the keep_* ones off
                $sym_params = ['0'];
            } else { // All parameters are keep_*
                $sym_params = ['1'];
            }
            $keep = symbol_tempcode('KEEP', $sym_params, $has_escaping ? [ENTITY_ESCAPED] : [NULL_ESCAPED]);
            $new_tempcode->attach($keep);
        }

        $prior_offset = $new_offset + strlen($matches[0][$i][0]);
    }

    $portion = substr($cache, $prior_offset);
    if ($portion !== '') {
        if ($GLOBALS['XSS_DETECT'] && ocp_is_escaped($cache)) {
            ocp_mark_as_escaped($portion);
        }

        $new_tempcode->attach($portion);
    }

    return $new_tempcode;
}

/**
 * Get Comcode used for a block to submit back to itself via AJAX.
 *
 * @param  array $map The parameters
 * @return string Parameters for a Comcode block tag
 */
function get_block_ajax_submit_map(array $map) : string
{
    $map_comcode = '';
    foreach ($map as $key => $val) {
        if ($key != 'defer') {
            $map_comcode .= ' ' . $key . '="' . addslashes($val) . '"';
        }
    }
    return $map_comcode;
}

/**
 * Get the block object for a given block codename.
 *
 * @param  ID_TEXT $codename The block name
 * @param  array $map The block parameter map
 * @return array A pair: Either the block object, or the string output of a miniblock ; and whether we entered a new security scope
 */
function do_block_hunt_file(string $codename, array $map = []) : array
{
    global $BLOCKS_AT_CACHE;

    $codename = filter_naughty_harsh($codename);

    $file_base = get_file_base();

    $new_security_scope = false;

    global $REQUIRED_CODE;
    if ((!in_safe_mode()) && (((isset($BLOCKS_AT_CACHE[$codename])) && ($BLOCKS_AT_CACHE[$codename] === 'sources_custom/blocks')) || ((!isset($BLOCKS_AT_CACHE[$codename])) && (is_file($file_base . '/sources_custom/blocks/' . $codename . '.php'))))) {
        if (!isset($REQUIRED_CODE['blocks/' . $codename])) {
            require_once($file_base . '/sources_custom/blocks/' . $codename . '.php');
        }
        $REQUIRED_CODE['blocks/' . $codename] = true;

        if (!isset($BLOCKS_AT_CACHE[$codename])) {
            $BLOCKS_AT_CACHE[$codename] = 'sources_custom/blocks';
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('BLOCKS_AT', $BLOCKS_AT_CACHE);
            }
        }

        if (!is_file($file_base . '/sources/blocks/' . $codename . '.php')) {
            $new_security_scope = true;
        }
    } elseif (((isset($BLOCKS_AT_CACHE[$codename])) && ($BLOCKS_AT_CACHE[$codename] === 'sources/blocks')) || ((!isset($BLOCKS_AT_CACHE[$codename])) && (is_file($file_base . '/sources/blocks/' . $codename . '.php')))) {
        if (!isset($REQUIRED_CODE['blocks/' . $codename])) {
            require_once($file_base . '/sources/blocks/' . $codename . '.php');
        }
        $REQUIRED_CODE['blocks/' . $codename] = true;

        if (!isset($BLOCKS_AT_CACHE[$codename])) {
            $BLOCKS_AT_CACHE[$codename] = 'sources/blocks';
            if (function_exists('persistent_cache_set')) {
                persistent_cache_set('BLOCKS_AT', $BLOCKS_AT_CACHE);
            }
        }
    } else {
        if ((!in_safe_mode()) && (((isset($BLOCKS_AT_CACHE[$codename])) && ($BLOCKS_AT_CACHE[$codename] === 'sources_custom/miniblocks')) || ((!isset($BLOCKS_AT_CACHE[$codename])) && (is_file($file_base . '/sources_custom/miniblocks/' . $codename . '.php'))))) {
            $object = static_evaluate_tempcode(_load_mini_code('sources_custom/miniblocks/' . $codename . '.php', $map));

            if (!isset($BLOCKS_AT_CACHE[$codename])) {
                $BLOCKS_AT_CACHE[$codename] = 'sources_custom/miniblocks';
                if (function_exists('persistent_cache_set')) {
                    persistent_cache_set('BLOCKS_AT', $BLOCKS_AT_CACHE);
                }
            }

            $new_security_scope = true;
        } elseif (((isset($BLOCKS_AT_CACHE[$codename])) && ($BLOCKS_AT_CACHE[$codename] === 'sources/miniblocks')) || ((!isset($BLOCKS_AT_CACHE[$codename])) && (is_file($file_base . '/sources/miniblocks/' . $codename . '.php')))) {
            $object = static_evaluate_tempcode(_load_mini_code('sources/miniblocks/' . $codename . '.php', $map));

            if (!isset($BLOCKS_AT_CACHE[$codename])) {
                $BLOCKS_AT_CACHE[$codename] = 'sources/miniblocks';
                if (function_exists('persistent_cache_set')) {
                    persistent_cache_set('BLOCKS_AT', $BLOCKS_AT_CACHE);
                }
            }
        } elseif ((!isset($map['failsafe'])) || ($map['failsafe'] !== '1')) {
            $temp = do_template('WARNING_BOX', ['_GUID' => '09f1bd6e117693a85fb69bfb52ea1799', 'WARNING' => do_lang_tempcode('MISSING_BLOCK_FILE', escape_html($codename))]);
            $object = $temp->evaluate();
        } else {
            $object = '';
        }
        return [$object, $new_security_scope];
    }

    $_object = object_factory('Block_' . $codename);
    return [$_object, $new_security_scope];
}

/**
 * Get standardised info about a block.
 *
 * @param  ID_TEXT $codename The block name
 * @param  array $map The block parameter map
 * @param  ?mixed $object Object/string of the block (null: not looked up)
 * @param  ?boolean $new_security_scope Whether the block is in a new security scope (null: not looked up)
 * @return ?array The block info (null: cannot cache for some reason)
 */
function get_block_info_row(string $codename, array $map = [], &$object = null, ?bool &$new_security_scope = null) : ?array
{
    static $cache = [];
    $sz = serialize([$codename, $map]);
    if (isset($cache[$sz])) {
        return $cache[$sz];
    }

    $row = find_cache_on($codename);
    if ($row === null) {
        list($object, $new_security_scope) = do_block_hunt_file($codename, $map);
        if ((is_object($object)) && (method_exists($object, 'caching_environment'))) {
            $info = $object->caching_environment($map);
            if ($info !== null) {
                $special_cache_flags = array_key_exists('special_cache_flags', $info) ? $info['special_cache_flags'] : CACHE_AGAINST_DEFAULT;
                $row = [
                    'cached_for' => $codename,
                    'cache_on' => $info['cache_on'],
                    'special_cache_flags' => $special_cache_flags,
                    'cache_ttl' => $info['ttl'],
                ];

                if (!is_array($info['cache_on'])) {
                    $GLOBALS['SITE_DB']->query_insert('cache_on', $row, false, true); // Allow errors in case of race conditions
                    global $BLOCK_CACHE_ON_CACHE;
                    $BLOCK_CACHE_ON_CACHE[$codename] = $row;
                    persistent_cache_set('BLOCK_CACHE_ON_CACHE', $BLOCK_CACHE_ON_CACHE);
                }
            }
        }
    }
    if (($row === null) && (isset($map['quick_cache'])) && ($map['quick_cache'] === '1')) {
        $row = ['cached_for' => $codename, 'cache_on' => '[$map]', 'cache_ttl' => 60, 'special_cache_flags' => CACHE_AGAINST_DEFAULT | CACHE_AGAINST_PERMISSIVE_GROUPS];
    }

    $cache[$sz] = $row;
    return $row;
}

/**
 * Takes a string which is a PHP expression over $map (parameter map), and returns a derived identifier.
 * We see if we have something cached by looking for a matching identifier.
 *
 * @param  ID_TEXT $codename The block name
 * @param  mixed $cache_on PHP expression over $map (the parameter map of the block) OR a call_user_func specifier that will return a result (which will be used if caching is really very important, even for Hip Hop PHP)
 * @param  array $map The block parameter map
 * @return ?LONG_TEXT The derived cache identifier (null: the identifier is CURRENTLY null meaning cannot be cached)
 */
function do_block_get_cache_identifier(string $codename, $cache_on, array $map) : ?string
{
    static $cache = [];
    $sz = serialize([$cache_on, $map]);
    if (isset($cache[$sz])) {
        return $cache[$sz];
    }

    $_cache_identifier = [];
    if (is_array($cache_on)) {
        $_cache_identifier = call_user_func($cache_on[0], $map);
    } else {
        if ($cache_on != '') {
            $block_id = get_block_id($map);

            $_cache_on = eval('return ' . $cache_on . ';'); // NB: This uses $map, as $map is referenced inside $cache_on
            if ($_cache_on === null) {
                return null;
            }
            foreach ($_cache_on as $on) {
                $_cache_identifier[] = $on;
            }

            $_cache_identifier[] = $block_id;
        }
    }

    if (!empty($map['raw'])) {
        $_cache_identifier[] = $map['raw'];
    }

    $cache_identifier = serialize($_cache_identifier);

    $cache[$sz] = $cache_identifier;

    return $cache_identifier;
}

/**
 * Gets the path to a block code file for a block code name.
 *
 * @param  ID_TEXT $block The name of the block
 * @return PATH The path to the block
 *
 * @ignore
 */
function _get_block_path(string $block) : string
{
    $block_path = get_file_base() . '/sources_custom/blocks/' . filter_naughty($block) . '.php';
    if ((in_safe_mode()) || (!is_file($block_path))) {
        $block_path = get_file_base() . '/sources/blocks/' . filter_naughty($block) . '.php';
        if (!is_file($block_path)) {
            $block_path = get_file_base() . '/sources_custom/miniblocks/' . filter_naughty($block) . '.php';
        }
    }
    return $block_path;
}

/**
 * Check to see if a block is installed.
 *
 * @param  ID_TEXT $block The module name
 * @return boolean Whether it is
 */
function block_installed(string $block) : bool
{
    $test = $GLOBALS['SITE_DB']->query_select_value_if_there('blocks', 'block_name', ['block_name' => $block]);
    return $test !== null;
}

/**
 * Get an array of all the pages everywhere in the zone, limited by the selection algorithm (for small sites everything will be returned, for larger ones it depends on the show method).
 *
 * @param  ID_TEXT $zone The zone name
 * @param  boolean $keep_ext_on Whether to leave file extensions on the page name
 * @param  boolean $consider_redirects Whether to take transparent redirects into account
 * @param  integer $show_method Selection algorithm constant
 * @set 0 1 2
 * @param  ?ID_TEXT $page_type Page type to show (null: all)
 * @set modules comcode html
 * @return array A map of page name to type (modules_custom, etc)
 */
function find_all_pages_wrap(string $zone, bool $keep_ext_on = false, bool $consider_redirects = false, int $show_method = 0, ?string $page_type = null) : array
{
    require_code('zones2');
    return _find_all_pages_wrap($zone, $keep_ext_on, $consider_redirects, $show_method, $page_type);
}

/**
 * Get an array of all the pages of the specified type (module, etc) and extension (for small sites everything will be returned, for larger ones it depends on the show method).
 *
 * @param  ID_TEXT $zone The zone name
 * @param  ID_TEXT $type The page type
 * @set modules modules_custom comcode/EN comcode_custom/EN html/EN html_custom/EN
 * @param  string $ext The file extension to limit us to (without a dot)
 * @param  boolean $keep_ext_on Whether to leave file extensions on the page name
 * @param  ?TIME $cutoff_time Only show pages newer than (null: no restriction)
 * @param  integer $show_method Selection algorithm constant
 * @set 0 1 2
 * @return array A map of page name to type (modules_custom, etc)
 */
function find_all_pages(string $zone, string $type, string $ext = 'php', bool $keep_ext_on = false, ?int $cutoff_time = null, int $show_method = 0) : array
{
    require_code('zones2');
    return _find_all_pages($zone, $type, $ext, $keep_ext_on, $cutoff_time, $show_method);
}

/**
 * Get an array of all the modules.
 *
 * @param  ID_TEXT $zone The zone name
 * @return array A map of page name to type (modules_custom, etc)
 */
function find_all_modules(string $zone) : array
{
    require_code('zones2');
    return _find_all_modules($zone);
}

/**
 * Extract code to execute the requested functions with the requested parameters from the module at the given path.
 * We used to actually load up the module, but it ate all our RAM when we did!
 *
 * @param  PATH $path The path to the module (or any PHP file with a class)
 * @param  array $functions Array of functions to be executing
 * @param  array $params A list of parameters to pass to our functions
 * @param  boolean $prefer_direct_code_call Whether to do this "properly" (via proper OOP), which will consume more memory
 * @param  ?string $class_name Class name to use (null: autodetect, which is a little slower)
 * @return array A list of pieces of code to do the equivalent of executing the requested functions with the requested parameters
 */
function extract_module_functions(string $path, array $functions, array $params = [], bool $prefer_direct_code_call = false, ?string $class_name = null) : array
{
    global $SITE_INFO;
    $prefer_direct_code_call = $prefer_direct_code_call || ((isset($SITE_INFO['prefer_direct_code_call'])) && ($SITE_INFO['prefer_direct_code_call'] === '1'));
    if ($prefer_direct_code_call) {
        global $CLASS_CACHE;
        if (isset($CLASS_CACHE[$path])) {
            $new_classes = $CLASS_CACHE[$path];
        } else {
            if ($class_name === null) {
                $classes_before = get_declared_classes();
            }
            $require_path = preg_replace('#^' . preg_quote(get_file_base()) . '/#', '', preg_replace('#^' . preg_quote(get_file_base()) . '/((sources)|(sources_custom))/(.*)\.php#', '${4}', $path));
            require_code($require_path);
            if ($class_name === null) {
                $classes_after = get_declared_classes();
            }
            if ($class_name === null) {
                $new_classes = array_values(array_diff($classes_after, $classes_before));
                if (count($new_classes) === 0) { // Ah, maybe this module already had require_code run for it
                    $matches = [];
                    if ((running_script('install')) && (file_exists(preg_replace('#(sources|modules|minimodules)_custom#', '${1}', $path)))) {
                        $path = preg_replace('#(sources|modules|minimodules)_custom#', '${1}', $path);
                    }
                    if (preg_match('#^\s*class (\w+)#m', cms_file_get_contents_safe($path), $matches) !== 0) {
                        $new_classes = [$matches[1]];
                    }
                }
            } else {
                $new_classes = [$class_name];
            }
            $CLASS_CACHE[$path] = $new_classes;
        }
        if ((isset($new_classes[0])) && ($new_classes[0] === 'Standard_crud_module')) {
            array_shift($new_classes); // This is not the class we want
        }
        if ((isset($new_classes[0])) && ($new_classes[0] === 'non_overridden__Standard_crud_module')) {
            array_shift($new_classes); // This is not the class we want
        }
        if (isset($new_classes[0])) {
            $c = $new_classes[0];
            $new_ob = new $c();
        } else {
            $new_ob = null;
        }
        $ret = [];
        foreach ($functions as $function) {
            if (method_exists($new_ob, $function)) {
                $ret[] = [[&$new_ob, $function], $params];
            } else {
                $ret[] = null;
            }
        }
        return $ret;
    }

    if (!is_file($path)) {
        $ret = [];
        foreach ($functions as $function) {
            $ret[] = null;
        }
        return $ret;
    }

    $file = cms_file_get_contents_safe($path, FILE_READ_UNIXIFIED_TEXT);
    if ((strpos($path, '/modules_custom/') !== false) && (is_file(str_replace('/modules_custom/', '/modules/', $path))) && (strpos($file, "\nclass ") === false)) {
        // Customised file is not a full class, so go to default file
        $path = str_replace('/modules_custom/', '/modules/', $path);
        $file = cms_file_get_contents_safe($path, FILE_READ_UNIXIFIED_TEXT);
    }

    if (strpos($file, 'class Mx_') !== false) {
        unset($file); // To save memory

        return extract_module_functions($path, $functions, $params, true);
    }

    global $ARB_COUNTER;

    $r = preg_replace('#[^\w]#', '', basename($path, '.php')) . strval(mt_rand(0, mt_getrandmax())) . '_' . strval($ARB_COUNTER);
    $ARB_COUNTER++;
    $out = [];
    $_params = '';
    $pos = strpos($file, "\nclass ");
    if ($pos === false) {
        return array_fill(0, count($functions), null);
    }
    $pre = substr($file, 5, $pos - 5); // FUDGE. We assume any functions we need to pre-load precede any classes in the file
    $pre = preg_replace('#(^|\n)function (\w+)\(.*#s', 'if (!function_exists(\'${1}\')) { ${0} }', $pre); // In case we end up extracting from this file more than once across multiple calls to extract_module_functions
    if ($params !== null) {
        foreach ($params as $param) {
            if ($_params !== '') {
                $_params .= ',';
            }
            if (is_string($param)) {
                $_params .= '\'' . str_replace('\'', '\\\'', $param) . '\'';
            } elseif ($param === null) {
                $_params .= 'null';
            } elseif (is_bool($param)) {
                $_params .= $param ? 'true' : 'false';
            } else {
                $_params .= strval($param);
            }
        }
    }
    foreach ($functions as $function) {
        $start = strpos($file, 'function ' . $function . '(');

        $spaces = 1;
        if ($start === false) {
            $out[] = null;
        } else {
            while ($file[$start - $spaces - 1] !== "\n") {
                $spaces++;
            }
            $spaces -= strlen(ltrim(substr($file, $start - $spaces, $spaces))); // Remove length of stuff like 'public ' in front of 'function'

            $end1 = strpos($file, "\n" . str_repeat(' ', $spaces) . '}' . "\n", $start);
            $end2 = strpos($file, "\n" . str_repeat("\t", $spaces) . '}' . "\n", $start);
            if ($end1 === false) {
                $end1 = $end2;
            }
            if ($end2 === false) {
                $end2 = $end1;
            }
            $end = min($end1, $end2) + 2 + $spaces;
            $func = substr($file, $start, $end - $start);

            $new_func = str_replace('function ' . $function . '(', 'if (!function_exists(\'' . $function . $r . '\')) { function ' . $function . $r . '(', $func) . ' } return ' . filter_naughty_harsh($function) . $r . '(' . $_params . '); ';
            $out[] = $pre . "\n\n" . $new_func;

            if ((strpos($new_func, 'parent::') !== false) || (strpos($new_func, '$this->') !== false)) {
                return extract_module_functions($path, $functions, $params, true, $class_name);
            }

            $parse_error = false;
            try {
                if (@eval('return true;' . $pre . $new_func) === false) {
                    $parse_error = true;
                }
            } catch (ParseError $e) {
                $parse_error = true;
            } catch (Exception $e) {
                $parse_error = true;
            }

            if ($parse_error) {
                return extract_module_functions($path, $functions, $params, true, $class_name);
            }

            $pre = ''; // Can only load that bit once
        }
    }

    unset($file); // To save memory

    return $out;
}

/**
 * Check a module is properly installed/upgraded, and give an error message if it is not.
 *
 * @param  object $object The module object
 * @param  ID_TEXT $codename The block name
 */
function _check_module_installation_status(object $object, string $codename)
{
    // Get info about what is installed and what is on disk
    if (get_value('assume_modules_correct') !== '1') {
        $rows = persistent_cache_get('MODULES');
        if ($rows === null) {
            $rows = list_to_map('module_the_name', $GLOBALS['SITE_DB']->query_select('modules', ['*'], ($GLOBALS['PERSISTENT_CACHE'] === null) ? ['module_the_name' => $codename] : []));
            persistent_cache_set('MODULES', $rows);
        }
        if (array_key_exists($codename, $rows)) {
            $info = $object->info();
            $installed_version = $rows[$codename]['module_version'];
            $installed_hack_version = $rows[$codename]['module_hack_version'];
            $this_version = $info['version'];
            $this_hack_version = $info['hack_version'];

            // See if we need to do an upgrade
            if (
                (($installed_version < $this_version) && (array_key_exists('update_require_upgrade', $info))) ||
                (($installed_hack_version < $this_hack_version) && (array_key_exists('hack_require_upgrade', $info)))
            ) {
                warn_exit(do_lang_tempcode('OUTDATED_ADDON_REMEDIES', escape_html($codename), escape_html(find_script('upgrader'))));
            }
        } else {
            $_error_msg = do_lang('MISSING_MODULE', escape_html($codename));
            $addon_manage_url = build_url(['page' => 'admin_addons'], get_module_zone('admin_addons'));
            $error_msg = do_lang_tempcode('BROKEN_ADDON_REMEDIES', $_error_msg, escape_html(find_script('upgrader')), escape_html(static_evaluate_tempcode($addon_manage_url)));
            warn_exit($error_msg);
        }
    }
}

/**
 * Check a block is properly installed/upgraded, and give an error message if it is not.
 *
 * @param  object $object The block object
 * @param  ID_TEXT $codename The block name
 * @return ?Tempcode The block error output (null: no error)
 */
function _check_block_installation_status(object $object, string $codename) : ?object
{
    // Get info about what is installed and what is on disk
    if (get_value('assume_modules_correct') !== '1') {
        $rows = persistent_cache_get('BLOCKS');
        if ($rows === null) {
            $rows = list_to_map('block_name', $GLOBALS['SITE_DB']->query_select('blocks', ['*'], ($GLOBALS['PERSISTENT_CACHE'] === null) ? ['block_name' => $codename] : []));
            persistent_cache_set('BLOCKS', $rows);
        }
        if (array_key_exists($codename, $rows)) {
            $info = $object->info();
            $installed_version = $rows[$codename]['block_version'];
            $installed_hack_version = $rows[$codename]['block_hack_version'];
            $this_version = $info['version'];
            $this_hack_version = $info['hack_version'];

            // See if we need to do an upgrade
            if (
                (($installed_version < $this_version) && (array_key_exists('update_require_upgrade', $info))) ||
                (($installed_hack_version < $this_hack_version) && (array_key_exists('hack_require_upgrade', $info)))
            ) {
                $error_msg = do_lang_tempcode('OUTDATED_ADDON_REMEDIES', escape_html($codename), escape_html(find_script('upgrader')));
                return do_template('RED_ALERT', ['_GUID' => '7jsfqaeaaf07kawlhnvteul10wm34bcu', 'TEXT' => $error_msg]);
            }
        } else {
            $_error_msg = do_lang('MISSING_BLOCK', escape_html($codename));
            $addon_manage_url = build_url(['page' => 'admin_addons'], get_module_zone('admin_addons'));
            $error_msg = do_lang_tempcode('BROKEN_ADDON_REMEDIES', $_error_msg, escape_html(find_script('upgrader')), escape_html(static_evaluate_tempcode($addon_manage_url)));
            return do_template('RED_ALERT', ['_GUID' => 'bolznyf0jx9omujol6xbmqetlcuo7d6b', 'TEXT' => $error_msg]);
        }
    }

    return null;
}
