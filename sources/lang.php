<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*EXTRA FUNCTIONS: levenshtein*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__lang()
{
    global $COMCODE_LANG_STRING_CACHE;
    $COMCODE_LANG_STRING_CACHE = [];

    global $LANG_LOADED, $LANG_LOADED_LANG, $LANG_REQUESTED_LANG, $LANGS_REQUESTED;
    // Tracks what has already been require'd, although loading may have been deferred.
    /** What language packs ^ files have been requested.
     *
     * @global boolean $LANG_REQUESTED_LANG
     */
    $LANG_REQUESTED_LANG = [];
    /** What language files have been requested.
     *
     * @global boolean $LANGS_REQUESTED
     */
    $LANGS_REQUESTED = [];
    // Tracks what has already been require'd and not deferred. This will not track all require_lang calls, as Composr will try and use the page's own lang cache first.
    $LANG_LOADED_LANG = []; // By lang pack and lang file
    $LANG_LOADED = []; // Just by lang file

    global $LANGUAGE_STRINGS_CACHE;
    $LANGUAGE_STRINGS_CACHE = [];

    global $LANGS_MAP_CACHE;
    $LANGS_MAP_CACHE = null;

    global $USER_LANG_CACHED, $USER_LANG_EARLY_CACHED, $USER_LANG_LOOP, $REQUIRE_LANG_LOOP;
    global $RECORD_LANG_STRINGS, $RECORDED_LANG_STRINGS, $RECORD_CONTENT_LANG_STRINGS, $RECORDED_CONTENT_LANG_STRINGS;
    $RECORD_LANG_STRINGS = false;
    $RECORDED_LANG_STRINGS = [];
    $RECORD_CONTENT_LANG_STRINGS = false;
    $RECORDED_CONTENT_LANG_STRINGS = [];
    $USER_LANG_LOOP = false;
    $USER_LANG_CACHED = null;
    $USER_LANG_EARLY_CACHED = null;
    $REQUIRE_LANG_LOOP = 0;
    global $REQUIRED_ALL_LANG;
    $REQUIRED_ALL_LANG = [];

    // Lazy loading code: learning algorithm to cache strings against different pages without loading all, unless we get a cache miss in the page's pool
    global $PAGE_CACHE_LANG_LOADED, $PAGE_CACHE_LAZY_LOAD, $PAGE_CACHE_LANGS_REQUESTED, $SMART_CACHE;
    $PAGE_CACHE_LANG_LOADED = [];
    $PAGE_CACHE_LAZY_LOAD = false;
    $PAGE_CACHE_LANGS_REQUESTED = [];
    if (((function_exists('get_option')) && (get_option('is_on_lang_cache') == '1') && ((!array_key_exists('page', $_GET)) || ((is_string($_GET['page'])) && (strpos($_GET['page'], '..') === false))))) {
        if ($SMART_CACHE !== null) {
            $contents = $SMART_CACHE->get('lang_strings_' . user_lang());
            if ($contents !== null) {
                $PAGE_CACHE_LANG_LOADED = $contents;
                $LANGUAGE_STRINGS_CACHE = [user_lang() => $contents];
                $PAGE_CACHE_LAZY_LOAD = true;
            }
        }
    }

    /** Used for filtering various things based on the language pack.
     *
     * @global boolean $LANG_FILTER_OB
     */
    global $LANG_FILTER_OB, $LANG_RUNTIME_PROCESSING;
    $lang_stripped = preg_replace('#[\-_].*$#', '', user_lang());
    require_code('lang_filter_' . fallback_lang());
    if (((is_file(get_file_base() . '/sources/lang_filter_' . $lang_stripped . '.php')) || (is_file(get_file_base() . '/sources_custom/lang_filter_' . $lang_stripped . '.php'))) && (!in_safe_mode())) {
        require_code('lang_filter_' . filter_naughty_harsh($lang_stripped, true));
        $LANG_FILTER_OB = object_factory('LangFilter_' . filter_naughty_harsh($lang_stripped, true));
    } else {
        /*$LANG_FILTER_OB = new LangFilter(); Actually it's better to just fall back to the English one, rather than an empty one*/

        $LANG_FILTER_OB = object_factory('LangFilter_' . fallback_lang());
    }
    lang_load_runtime_processing();

    require_lang('critical_error');
    require_lang('global');

    /** Keywords parsed from an active search.
     *
     * @global boolean $SEARCH_QUERY_TERMS
     */
    global $SEARCH_QUERY_TERMS;
    $SEARCH_QUERY_TERMS = null;

    /** Override member ID used for parsing and saving language string Comcode.
     *
     * @global MEMBER $OVERRIDE_MEMBER_ID_COMCODE
     */
    global $OVERRIDE_MEMBER_ID_COMCODE;
    $OVERRIDE_MEMBER_ID_COMCODE = null;

    cms_ini_set('default_charset', get_charset());
}

// ====
// CODE
// ====

/**
 * Load language processing data.
 */
function lang_load_runtime_processing()
{
    global $LANG_RUNTIME_PROCESSING;
    if (function_exists('persistent_cache_get')) {
        $LANG_RUNTIME_PROCESSING = persistent_cache_get('LANG_RUNTIME_PROCESSING');
    }
    if ($LANG_RUNTIME_PROCESSING === null) {
        $needs_compiling = true;

        $path = get_custom_file_base() . '/caches/lang/_runtime_processing.lcd';
        if (is_file($path)) {
            $LANG_RUNTIME_PROCESSING = @unserialize(cms_file_get_contents_safe($path, FILE_READ_LOCK));
            if ($LANG_RUNTIME_PROCESSING !== false) {
                $needs_compiling = false;
            }
        }

        if ($needs_compiling) {
            require_code('lang_compile');
            require_code('files');
            $LANG_RUNTIME_PROCESSING = get_lang_file_section(user_lang(), null, 'runtime_processing');
            cms_file_put_contents_safe($path, serialize($LANG_RUNTIME_PROCESSING), FILE_WRITE_FAILURE_SOFT | FILE_WRITE_FIX_PERMISSIONS);
        }
    }
}

/**
 * Get the human-readable form of a language string codename.
 * There must never be a non-null parameter after a null parameter, and if $parameter3 is an array none of those array elements may be null.
 * Ideally either all parameters are Tempcode, or none are. If the first parameter is Tempcode, we will consider we want to avoid evaluating Tempcode and therefore we will return Tempcode.
 * Further documentation: https://www.youtube.com/watch?v=rinz9Avvq6A.
 *
 * @param  ID_TEXT $codename The language string codename
 * @param  ?mixed $parameter1 The first parameter [string or Tempcode] (replaces {1}) (null: none)
 * @param  ?mixed $parameter2 The second parameter [string or Tempcode] (replaces {2}) (null: none)
 * @param  ?mixed $parameter3 The third parameter (replaces {3}). May be an array of [of string or Tempcode], to allow any number of additional args (null: none)
 * @param  ?LANGUAGE_NAME $lang The language to use (null: user's language)
 * @param  boolean $require_result Whether to cause Composr to exit if the lookup does not succeed
 * @return ?mixed The human-readable content (null: not found). The same type as $parameter1.
 */
function do_lang(string $codename, $parameter1 = null, $parameter2 = null, $parameter3 = null, ?string $lang = null, bool $require_result = true)
{
    return _do_lang($codename, $parameter1, $parameter2, $parameter3, $lang, $require_result);
}

/**
 * This function is called when no other language works, and it will return the original default language - 'EN'. You may change this to another language, but this is not advised, as Composr is being shipped with the EN language complete and unabridged as standard - hence you cannot go wrong if you leave it as EN.
 * In theory, this is the only hook to English that there is.
 *
 * @return LANGUAGE_NAME The fallback language
 */
function fallback_lang() : string
{
    return 'EN';
}

/**
 * Get the user's currently selected language, with support for an override when doing a translation.
 *
 * @param  boolean $post Whether the language setting is a POST parameter (default is a GET parameter)
 * @return LANGUAGE_NAME The user's current language
 */
function user_lang__with__translation_override(bool $post = false) : string
{
    static $running = false;

    if ($running) {
        return user_lang(); // Probably in a failure due to filter_naughty_harsh
    }
    $running = true;

    if ($_SERVER['REQUEST_METHOD'] == 'POST') {
        $lang = $post ? post_param_string('lang', '') : get_param_string('lang', '');
        if (($lang != '') && (!does_lang_exist(filter_naughty_harsh($lang)))) {
            $lang = '';
        }
    } else {
        $lang = '';
    }

    if ($lang == '') {
        $lang = user_lang();
    }

    $running = false;

    return $lang;
}

/**
 * Get the user's currently selected language.
 *
 * @return LANGUAGE_NAME The user's current language
 */
function user_lang() : string
{
    // Quick exit: Cache
    global $USER_LANG_CACHED;
    if ($USER_LANG_CACHED !== null) {
        return $USER_LANG_CACHED;
    }

    global $MEMBER_CACHED, $USER_LANG_LOOP, $IN_MINIKERNEL_VERSION;

    // Quick exit: Mini-kernel is very simple
    if ($IN_MINIKERNEL_VERSION) {
        return get_site_default_lang();
    }

    // Quick exit: No Internationalisation enabled
    if ((function_exists('get_option')) && (get_option('enable_language_selection') !== '1')) {
        $USER_LANG_CACHED = get_site_default_lang();
        return $USER_LANG_CACHED;
    }

    // ---

    // In URL somehow?
    $lang = '';
    $special_page_type = get_param_string('special_page_type', '');
    if ($special_page_type != '' && substr($special_page_type, 0, 5) == 'lang_') {
        if (substr($special_page_type, 0, 13) == 'lang_content_') {
            $lang = substr($special_page_type, 13);
        } else {
            $lang = substr($special_page_type, 5);
        }
    }
    if ($lang == '') {
        $lang = get_param_string('keep_lang', '');
        if ($lang != '') {
            $lang = filter_naughty($lang);
        }
    }
    if (($lang != '') && (!does_lang_exist($lang))) {
        $lang = '';
    }

    // Still booting up somehow, so we need to do a cruder non-cache-setting code branch
    if ((!function_exists('get_member')) || ($USER_LANG_LOOP) || ($MEMBER_CACHED === null)) {
        // Quick exit: Cache
        global $USER_LANG_EARLY_CACHED;
        if ($USER_LANG_EARLY_CACHED !== null) {
            return $USER_LANG_EARLY_CACHED;
        }

        // In browser?
        if ($lang == '') {
            if ((array_key_exists('GET_OPTION_LOOP', $GLOBALS)) && (!$GLOBALS['GET_OPTION_LOOP']) && (function_exists('get_option')) && (get_option('detect_lang_browser') == '1')) {
                $lang = get_lang_browser();
                if ($lang === null) {
                    $lang = '';
                }
            }
        }

        // Ok, just the default
        if ($lang == '') {
            $lang = get_site_default_lang();
        }

        // Return
        $USER_LANG_EARLY_CACHED = $lang;
        return $USER_LANG_EARLY_CACHED;
    }

    // Mark that we're processing, to avoid loops (see above handler for loop avoidance)
    $USER_LANG_LOOP = true;

    // In member or browser?
    if ($lang == '') {
        if (
            (
                (get_forum_type() == 'cns') ||
                (get_option('detect_lang_forum') == '1') ||
                (get_option('detect_lang_browser') == '1')
            ) &&
            (
                (!$GLOBALS['DEV_MODE']) ||
                (get_site_default_lang() != 'Gibb')
            )
        ) {
            // In member?
            if (($lang == '') && (get_option('detect_lang_forum') == '1')) {
                $lang = get_lang_member(get_member());
                if ($lang === null) {
                    $lang = '';
                }
            }

            // In browser?
            if (($lang == '') && (get_option('detect_lang_browser') == '1')) {
                $lang = get_lang_browser();
                if ($lang === null) {
                    $lang = '';
                }
            }
        }
    }

    // Ok, just the default
    if ($lang == '') {
        $lang = get_site_default_lang();
    }

    // Return
    $USER_LANG_CACHED = $lang;
    $USER_LANG_LOOP = false;
    return $USER_LANG_CACHED;
}

/**
 * Get the closest fit language codename to what the browser is requesting.
 *
 * @return ?LANGUAGE_NAME The closest-fit language to what the browser wants (null: browser doesn't ask)
 */
function get_lang_browser() : ?string
{
    // In browser?
    $http_lang = $_SERVER['HTTP_ACCEPT_LANGUAGE'];
    if (strlen($http_lang) > 0) {
        $http_langs = explode(',', $http_lang);
        foreach ($http_langs as $lang) {
            // Clean up
            $lang = cms_strtoupper_ascii(trim($lang));
            $pos = strpos($lang, ';');
            if ($pos !== false) {
                $lang = substr($lang, 0, $pos);
            }
            $pos = strpos($lang, '-');
            if ($pos !== false) {
                $lang = substr($lang, 0, $pos);
            }

            if (does_lang_exist($lang)) {
                return $lang;
            }
        }
    }

    return null;
}

/**
 * Find whether the specified language exists.
 *
 * @param  LANGUAGE_NAME $lang The language
 * @return boolean Whether the language exists
 */
function does_lang_exist(string $lang) : bool
{
    $lang = filter_naughty($lang);

    if ($lang == '') {
        return false;
    }
    if ($lang == 'Gibb') {
        return true; // Test language
    }
    if ($lang == 'xxx') {
        return true; // Test language
    }
    if ($lang == fallback_lang()) {
        return true;
    }

    $file_a = get_file_base() . '/lang/' . $lang;
    $file_b = get_custom_file_base() . '/lang_custom/' . $lang;
    $file_c = get_file_base() . '/lang_custom/' . $lang;

    return is_dir($file_c) || is_dir($file_b) || is_dir($file_a);
}

/**
 * Get the site's default language, with support for URL overrides.
 *
 * @return LANGUAGE_NAME The site's default language
 */
function get_site_default_lang() : string
{
    // Site default then
    global $SITE_INFO;
    if (empty($SITE_INFO['default_lang'])) { // We must be installing
        global $IN_MINIKERNEL_VERSION;
        if ($IN_MINIKERNEL_VERSION) {
            if (array_key_exists('lang', $_POST)) {
                return $_POST['lang'];
            }
            if (array_key_exists('lang', $_GET)) {
                return $_GET['lang'];
            }

            // Auto-detect if not got to selection step yet
            if (get_param_integer('step', 1) == 1) {
                $lang = get_lang_browser();
                if ($lang !== null) {
                    return $lang;
                }
            }
        }
        return fallback_lang();
    }
    return $SITE_INFO['default_lang'];
}

/**
 * Get what language the given member uses. The language is sent through a mapping to ensure it is in the right format, or dumped if it will not map.
 *
 * @param  MEMBER $member_id The member ID
 * @return ?LANGUAGE_NAME The language used by the member (null: the language will not map)
 */
function get_lang_member(int $member_id) : ?string
{
    if (is_guest($member_id)) {
        return get_site_default_lang();
    }

    // In forum?
    $lang = $GLOBALS['FORUM_DRIVER']->forum_get_lang($member_id);
    if (!cms_empty_safe($lang)) {
        $_lang = cms_strtoupper_ascii($lang);
        if (!does_lang_exist($_lang)) {
            require_code('files');
            $map_file_a = get_file_base() . '/lang/map.ini';
            $map_file_b = get_custom_file_base() . '/lang_custom/map.ini';
            if (!is_file($map_file_b)) {
                $map_file_b = $map_file_a;
            }
            $map = cms_parse_ini_file_fast($map_file_b);
            if (!array_key_exists($lang, $map)) {
                //fatal_exit('The specified language (' . $lang . ') is missing. The language needs installing/creating in Composr, or the language map file needs updating (to map this language to a known Composr one), or both.');
                $_lang = null; // Instead of the above, let's just fallback to default! So people's weird forum integration doesn't make Composr die
            } else {
                $_lang = $map[$lang];
                if ((!is_dir(get_file_base() . '/lang/' . $_lang)) && (!is_dir(get_custom_file_base() . '/lang_custom/' . $_lang)) && (!is_dir(get_file_base() . '/lang_custom/' . $_lang))) {
                    $_lang = null;
                }
            }
        }
        if ($_lang !== null) {
            return $_lang;
        }
    }

    return null;
}

/**
 * Get the current language.
 * First it tries to get the GET or POST language values, then it tries the user's language, then site default, then it resorts to EN.
 *
 * @param  ?MEMBER $member_id The member ID (null: site default language, although better just to call get_site_default_lang directly)
 * @return LANGUAGE_NAME The current language
 */
function get_lang(?int $member_id) : string
{
    if ($member_id !== null) {
        if ($member_id == get_member()) {
            return user_lang();
        }

        $lang = get_lang_member($member_id);
        if ($lang !== null) {
            return $lang;
        }
    }

    return get_site_default_lang();
}

/**
 * Includes a language file for use in the script.
 * If $type is not null, then this specifies whether to use 'lang_custom' or 'custom' (otherwise, normal priorities occur).
 *
 * @param  ID_TEXT $codename The language file name
 * @param  ?LANGUAGE_NAME $lang The language (null: uses the current language)
 * @param  ?string $type The language type (lang_custom, or custom) (null: normal priorities are used)
 * @set lang_custom custom
 * @param  boolean $ignore_errors Whether to just return if there was a loading error
 */
function require_lang(string $codename, ?string $lang = null, ?string $type = null, bool $ignore_errors = false) // ?string $type is for efficiency only - to avoid needing to doubly-search when requiring all
{
    // So we can keep track of what code loads what langs
    global $LANGS_REQUESTED, $LANG_REQUESTED_LANG, $REQUIRE_LANG_LOOP, $PAGE_CACHE_LAZY_LOAD, $PAGE_CACHE_LANGS_REQUESTED, $LANG_LOADED_LANG, $LANGUAGE_STRINGS_CACHE;
    $LANGS_REQUESTED[$codename] = true;

    if ($lang === null) {
        $lang = user_lang();
    }

    if (isset($LANG_REQUESTED_LANG[$lang][$codename])) {
        return;
    }
    $LANG_REQUESTED_LANG[$lang][$codename] = true;

    $cfb = get_custom_file_base();
    $fb = get_file_base();
    if (strpos($codename, '..') !== false) {
        $codename = filter_naughty($codename);
    }

    if ($PAGE_CACHE_LAZY_LOAD) {
        $support_smart_decaching = support_smart_decaching(true);
        if ($support_smart_decaching) {
            $cache_path = $cfb . '/caches/lang/' . $lang . '/' . $codename . '.lcd';
            $lang_file_default = $fb . '/lang/' . $lang . '/' . $codename . '.ini';
            if (!is_file($lang_file_default)) {
                $lang_file_default = $fb . '/lang/' . fallback_lang() . '/' . $codename . '.ini';
            }
            $lang_file = $fb . '/lang_custom/' . $lang . '/' . $codename . '.ini';
            if (!is_file($lang_file)) {
                $lang_file = $lang_file_default;
            } else {
                if (!is_file($lang_file_default)) {
                    $lang_file_default = $lang_file;
                }
            }
        }
        if ((!$support_smart_decaching) || ((is_file($cache_path)) && (is_file($lang_file)) && (@/*race conditions*/filemtime($cache_path) > filemtime($lang_file)) && (@/*race conditions*/filemtime($cache_path) > filemtime($lang_file_default)))) {
            if ($lang === null) {
                $lang = user_lang();
            }
            $PAGE_CACHE_LANGS_REQUESTED[] = [$codename, $lang];
            return;
        } else { // Invalidate it, as our smart cache was dirty compared to latest .ini version
            global $SMART_CACHE;
            if ($SMART_CACHE !== null) {
                $SMART_CACHE->invalidate();
            }
            $LANGUAGE_STRINGS_CACHE = [];
            $PAGE_CACHE_LAZY_LOAD = false;
            $LANG_LOADED_LANG = [];
            $PAGE_CACHE_LANGS_REQUESTED[] = [$codename, $lang];

            foreach ($PAGE_CACHE_LANGS_REQUESTED as $request) {
                list($that_codename, $that_lang) = $request;
                unset($LANG_REQUESTED_LANG[$that_lang][$that_codename]);
                require_lang($that_codename, $that_lang, null, $ignore_errors);
            }
        }
    }

    if (isset($LANG_LOADED_LANG[$lang], $LANG_LOADED_LANG[$lang][$codename])) {
        return;
    }

    $REQUIRE_LANG_LOOP++;

    if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] == '1')) {
        $before = memory_get_usage();
    }

    $bad = false;
    $done = false;

    if (!isset($LANGUAGE_STRINGS_CACHE[$lang])) {
        $LANGUAGE_STRINGS_CACHE[$lang] = [];
    }

    $cache_path = $cfb . '/caches/lang/' . $lang . '/' . $codename . '.lcd';

    // Try language cache
    $desire_cache = (function_exists('has_caching_for') && has_caching_for('lang', $codename));
    if ($desire_cache) {
        $cache_path = $cfb . '/caches/lang/' . $lang . '/' . $codename . '.lcd';
        $lang_file_default = $fb . '/lang/' . $lang . '/' . $codename . '.ini';
        if (!is_file($lang_file_default)) {
            $lang_file_default = $fb . '/lang/' . fallback_lang() . '/' . $codename . '.ini';
        }
        $lang_file = $fb . '/lang_custom/' . $lang . '/' . $codename . '.ini';
        if (!is_file($lang_file)) {
            $lang_file = $lang_file_default;
        }
        if (!is_file($lang_file_default)) {
            $lang_file_default = $lang_file;
        }

        if ((is_file($cache_path)) && ((!is_file($lang_file)) || ((@/*race conditions*/filemtime($cache_path) > filemtime($lang_file)) && (@/*race conditions*/filemtime($cache_path) > filemtime($lang_file_default))))) {
            $tmp = @cms_file_get_contents_safe($cache_path, FILE_READ_LOCK);
            if ($tmp != '') {
                $unserialized = @unserialize($tmp);
                if ($unserialized !== false) {
                    $LANGUAGE_STRINGS_CACHE[$lang] += $unserialized;
                    $done = true;
                }
            }
        }
    }
    if (!$done) {
        require_code('lang_compile');
        $bad = $bad || require_lang_compile($codename, $lang, $type, $cache_path, $ignore_errors);

        // Must have been dirty cache, so we need to kill compiled templates too (as lang is compiled into them)
        if (($desire_cache) && (is_file($cache_path)) && (filemtime($cache_path) == time()/*Was successfully rebuilt, no perm error*/)) {
            require_code('caches3');
            global $ERASED_TEMPLATES_ONCE;
            if (!$ERASED_TEMPLATES_ONCE) {
                erase_cached_templates(true, null, TEMPLATE_DECACHE_WITH_LANG);
            }
        }
    }

    global $LANG_LOADED;
    $LANG_LOADED[$codename] = $type;

    if (!isset($LANG_LOADED_LANG[$lang])) {
        $LANG_LOADED_LANG[$lang] = [];
    }
    $LANG_LOADED_LANG[$lang][$codename] = true;

    $REQUIRE_LANG_LOOP--;

    if ((isset($_GET['keep_show_loading'])) && ($_GET['keep_show_loading'] == '1') && ((!function_exists('running_script')) || (!running_script('gd_text')))) {
        $msg = function_exists('clean_file_size') ? clean_file_size(memory_get_usage() - $before) : integer_format(memory_get_usage() - $before);
        if (function_exists('attach_message')) {
            attach_message('require_lang: ' . $codename . ' (' . $msg . ' used)', 'inform');
        } else {
            print('<!-- require_lang: ' . htmlentities($codename) . ' (' . htmlentities($msg) . ' used) -->' . "\n");
            flush();
        }
    }
}

/**
 * Include all the language files for use in the script.
 * NOTE: This may reduce performance, so you should only use it if you really have to.
 *
 * @param  ?LANGUAGE_NAME $lang The language to include files from (null: use current user's language)
 * @param  boolean $only_if_for_lang Only load it up if it is specifically defined for our language
 */
function require_all_lang(?string $lang = null, bool $only_if_for_lang = false)
{
    $support_smart_decaching = support_smart_decaching(true);

    if ($lang === null) {
        $lang = user_lang();
    }

    global $REQUIRED_ALL_LANG;
    if (array_key_exists($lang, $REQUIRED_ALL_LANG)) {
        return;
    }
    $REQUIRED_ALL_LANG[$lang] = true;

    require_code('lang2');

    $lang_files = get_lang_files(fallback_lang());

    foreach (array_keys($lang_files) as $file) {
        if ((!$only_if_for_lang) || (is_file(get_custom_file_base() . '/lang_custom/' . $lang . '/' . $file . '.ini')) || (is_file(get_custom_file_base() . '/lang/' . $lang . '/' . $file . '.ini'))) {
            require_lang($file, $lang, null, true);
        }
    }

    if ($support_smart_decaching && has_caching_for('block')) {
        disable_smart_decaching_temporarily(); // Too many file checks doing this
    }
}

/**
 * Require all the open language files. This doesn't hurt performance a lot.
 *
 * @param  ?LANGUAGE_NAME $lang The language to require open files from (null: uses the current language)
 */
function require_all_open_lang_files(?string $lang = null)
{
    global $PAGE_CACHE_LAZY_LOAD, $LANG_REQUESTED_LANG, $LANGS_REQUESTED;
    $PAGE_CACHE_LAZY_LOAD = false;
    $LANG_REQUESTED_LANG = []; // So require_lang will do a re-load
    $langs_requested_copy = $LANGS_REQUESTED;
    foreach (array_keys($langs_requested_copy) as $toload) {
        require_lang($toload, $lang, null, true);
    }
    // Block caching might have hidden that we loaded these
    require_lang('global', $lang, null, true);
    require_lang('critical_error', $lang, null, true);
}

/**
 * Stop some text being escapable by the Tempcode layer.
 *
 * @param  mixed $in Text
 * @return Tempcode Text that can't be escaped
 */
function protect_from_escaping($in) : object
{
    return do_lang_tempcode('dont_escape_trick', $in);
}

/**
 * Helper for do_lang.
 * See do_lang for more documentation.
 *
 * @param  ID_TEXT $codename The language string codename
 * @param  ?mixed $parameter1 The first parameter [string or Tempcode] (replaces {1}) (null: none)
 * @param  ?mixed $parameter2 The second parameter [string or Tempcode] (replaces {2}) (null: none)
 * @param  ?mixed $parameter3 The third parameter (replaces {3}). May be an array of [of string or Tempcode], to allow any number of additional args (null: none)
 * @param  ?LANGUAGE_NAME $lang The language to use (null: user's language)
 * @param  boolean $require_result Whether to cause Composr to exit if the lookup does not succeed
 * @return ?mixed The human-readable content (null: not found). The same type as $parameter1.
 *
 * @ignore
 */
function _do_lang(string $codename, $parameter1 = null, $parameter2 = null, $parameter3 = null, ?string $lang = null, bool $require_result = true)
{
    global $LANGUAGE_STRINGS_CACHE, $USER_LANG_CACHED, $RECORD_LANG_STRINGS, $XSS_DETECT, $PAGE_CACHE_LANG_LOADED, $PAGE_CACHE_LAZY_LOAD, $SMART_CACHE, $PAGE_CACHE_LANGS_REQUESTED, $LANG_REQUESTED_LANG, $LANG_FILTER_OB, $LANG_RUNTIME_PROCESSING;

    if ($lang === null) {
        $lang = ($USER_LANG_CACHED === null) ? user_lang() : $USER_LANG_CACHED;
    }

    if ($GLOBALS['SEMI_DEV_MODE']) { // Special syntax for easily inlining language strings while coding
        $pos = strpos($codename, '=');
        if ($pos !== false) {
            require_code('lang2');
            inline_language_editing($codename, $lang);
        }
    }

    $there = isset($LANGUAGE_STRINGS_CACHE[$lang][$codename]);

    if (!$there) {
        $pos = strpos($codename, ':');
        if ($pos !== false) {
            $lang_file = substr($codename, 0, $pos);
            $codename = substr($codename, $pos + 1);

            $there = isset($LANGUAGE_STRINGS_CACHE[$lang][$codename]);
            if (!$there) {
                require_lang($lang_file, null, null, !$require_result);
            }
        }

        $there = isset($LANGUAGE_STRINGS_CACHE[$lang][$codename]);
    }

    if ($RECORD_LANG_STRINGS) {
        global $RECORDED_LANG_STRINGS;
        $RECORDED_LANG_STRINGS[$codename] = true;
    }

    if ((!$there) && ((!isset($LANGUAGE_STRINGS_CACHE[$lang])) || (!array_key_exists($codename, $LANGUAGE_STRINGS_CACHE[$lang])))) {
        if ($PAGE_CACHE_LAZY_LOAD) {
            // We're still doing lazy load, so we'll turn off lazy load and do it properly. This code path will only ever run once
            $PAGE_CACHE_LAZY_LOAD = false; // We can't be lazy any more, but we will keep growing our pool so hopefully CAN be lazy the next time
            foreach ($PAGE_CACHE_LANGS_REQUESTED as $request) {
                list($that_codename, $that_lang) = $request;
                unset($LANG_REQUESTED_LANG[$that_lang][$that_codename]);
                require_lang($that_codename, $that_lang, null, true);
            }
            $ret = _do_lang($codename, $parameter1, $parameter2, $parameter3, $lang, $require_result);
            if ($ret === null) {
                $PAGE_CACHE_LANG_LOADED[$lang][$codename] = null;
                if ($SMART_CACHE !== null) {
                    $SMART_CACHE->append('lang_strings_' . $lang, $codename, null);
                }
            }
            return $ret;
        }

        require_all_open_lang_files($lang);
    }

    if ($lang === 'xxx') {
        return 'xxx'; // Helpful for testing language compliancy. We don't expect to see non x's if we're running this language
    }

    if ((!isset($LANGUAGE_STRINGS_CACHE[$lang][$codename])) && (($require_result) || (!isset($LANGUAGE_STRINGS_CACHE[$lang])) || (!array_key_exists($codename, $LANGUAGE_STRINGS_CACHE[$lang])))) {
        if ($lang !== fallback_lang()) {
            $ret = do_lang($codename, $parameter1, $parameter2, $parameter3, fallback_lang(), $require_result);

            if ((!isset($PAGE_CACHE_LANG_LOADED[$lang][$codename])) && (isset($PAGE_CACHE_LANG_LOADED[fallback_lang()][$codename]))) {
                $PAGE_CACHE_LANG_LOADED[$lang][$codename] = $PAGE_CACHE_LANG_LOADED[fallback_lang()][$codename]; // Will have been cached into fallback_lang() from the nested do_lang call, we need to copy it into our cache bucket for this language
                if ($SMART_CACHE !== null) {
                    $SMART_CACHE->append('lang_strings_' . $lang, $codename, $PAGE_CACHE_LANG_LOADED[$lang][$codename]);
                }
            }

            return $ret;
        } else {
            if ($require_result) {
                global $USER_LANG_LOOP, $REQUIRE_LANG_LOOP;
                //print_r(debug_backtrace());
                if ($USER_LANG_LOOP) {
                    critical_error('RELAY', 'Missing language string codename: ' . escape_html($codename) . '. This language string codename is required to produce error messages, and thus a critical error was prompted by the non-ability to show less-critical error messages. It is likely the source language files (lang/' . fallback_lang() . '/*.ini) for Composr on this website have been corrupted.');
                }
                if ($REQUIRE_LANG_LOOP >= 2) {
                    return ''; // Probably failing to load global.ini, so just output with some text missing
                }

                trigger_error(do_lang('MISSING_LANG_STRING', escape_html($codename)), E_USER_NOTICE);
                return '';
            } else {
                if ($SMART_CACHE !== null) {
                    $SMART_CACHE->append('lang_strings_' . $lang, $codename, null);
                }

                return null;
            }
        }
    }

    if ((!isset($PAGE_CACHE_LANG_LOADED[$lang][$codename])) && ((!isset($PAGE_CACHE_LANG_LOADED[$lang])) || (!array_key_exists($codename, $PAGE_CACHE_LANG_LOADED[$lang])))) {
        $PAGE_CACHE_LANG_LOADED[$lang][$codename] = $LANGUAGE_STRINGS_CACHE[$lang][$codename];
        if ($SMART_CACHE !== null) {
            $SMART_CACHE->append('lang_strings_' . $lang, $codename, $LANGUAGE_STRINGS_CACHE[$lang][$codename]);
        }
    }

    // A simple list of parameters will be useful
    $parameters = [$parameter1, $parameter2];
    if (is_array($parameter3)) {
        $parameters = array_merge($parameters, $parameter3);
    } else {
        $parameters[] = $parameter3;
    }

    // Put in parameters; this code is HEAVILY OPTIMISED (and therefore has a lot of copy and pasting)
    static $non_plural_non_vowel = ['1', 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z', '{'/*for no-op param usage*/];
    $out = $LANGUAGE_STRINGS_CACHE[$lang][$codename];
    if ($out === null) {
        return null; // Learning cache pool has told us this string definitely does not exist
    }
    $plural_or_vowel_check = strpos($out, '|') !== false;
    if ($XSS_DETECT) {
        ocp_mark_as_escaped($out);
    }
    if ($parameter1 !== null) {
        // We have AT LEAST one parameter...

        if (isset($parameter1->codename)/*faster than is_object*/) {
            // If the first parameter is Tempcode then we are going to return Tempcode...

            $bits = preg_split('#\{(\d[^\}]*)\}#', $out, -1, PREG_SPLIT_DELIM_CAPTURE);

            $out_tempcode = new Tempcode();
            foreach ($bits as $i => $bit) {
                if ($i % 2 == 1) {
                    // Delimiter part
                    if (is_numeric($bit)) {
                        $parameter_num = intval($bit) - 1;
                        if (isset($parameters[$parameter_num])) {
                            $out_tempcode->attach($parameters[$parameter_num]);
                            continue;
                        }
                    } elseif (($plural_or_vowel_check) && (preg_match('#^\d+\|#', $bit) != 0)) {
                        $exploded = explode('|', $bit);
                        $parameter_num = intval($exploded[0]) - 1;
                        if (isset($parameters[$parameter_num])) {
                            $_parameter = is_object($parameters[$parameter_num]) ? $parameters[$parameter_num]->evaluate($lang) : $parameters[$parameter_num];
                            $numeric = (preg_match('#^([\d,]+|' . implode('|', [do_lang('INTEGER_UNITS_billions', '[\d,]+'), do_lang('INTEGER_UNITS_millions', '[\d,]+'), do_lang('INTEGER_UNITS_thousands', '[\d,]+')]) . ')$#', $_parameter) != 0);
                            $_parameter_denum = $numeric ? str_replace(',', '', $_parameter) : $_parameter;
                            $out_tempcode->attach((in_array($numeric ? $_parameter_denum : cms_mb_strtolower(cms_mb_substr($_parameter, 0, 1)), $non_plural_non_vowel)) ? $exploded[1] : $exploded[2]);
                            continue;
                        }
                    }

                    // Could not bind
                    $bit = '{' . $bit . '}';
                }

                // Non-delimiter part
                if ($XSS_DETECT) {
                    ocp_mark_as_escaped($bit);
                }
                $out_tempcode->attach($bit);
            }

            // Apply some special filtering to the output, based on the language filter
            if (isset($LANG_RUNTIME_PROCESSING[$codename])) {
                $flag = $LANG_RUNTIME_PROCESSING[$codename];
                $_out = $out_tempcode->evaluate();
                $out = $LANG_FILTER_OB->run_time($codename, $_out, $flag, $parameters);
                if ($_out != $out) {
                    $out_tempcode = make_string_tempcode($out);
                }
            }

            return $out_tempcode;
        }

        // We are handling string parameters, and returning a string...

        // Handle $parameter1
        $kg = function_exists('has_solemnly_declared') && !has_solemnly_declared(I_UNDERSTAND_XSS);
        if ($kg) {
            kid_gloves_html_escaping_singular($parameter1);
        }
        $out = str_replace('{1}', $parameter1, $out);
        if ($plural_or_vowel_check) {
            $numeric = (preg_match('#^([\d,]+|' . implode('|', [do_lang('INTEGER_UNITS_billions', '[\d,]+'), do_lang('INTEGER_UNITS_millions', '[\d,]+'), do_lang('INTEGER_UNITS_thousands', '[\d,]+')]) . ')$#', $parameter1) != 0);
            $_parameter_denum = $numeric ? str_replace(',', '', $parameter1) : $parameter1;
            $out = preg_replace('#\{1\|(.*)\|(.*)\}#U', (in_array($numeric ? $_parameter_denum : cms_mb_strtolower(cms_mb_substr($parameter1, 0, 1)), $non_plural_non_vowel)) ? '\\1' : '\\2', $out);
        }
        if (($XSS_DETECT) && (ocp_is_escaped($parameter1))) {
            ocp_mark_as_escaped($out);
        }

        if ($parameter2 !== null) {
            // Handle $parameter2
            if (isset($parameter2->codename)/*faster than is_object*/) {
                $parameter2 = $parameter2->evaluate($lang);
            }
            if ($kg) {
                kid_gloves_html_escaping_singular($parameter2);
            }
            if ($XSS_DETECT) {
                $escaped = ocp_is_escaped($out);
            }
            $out = str_replace('{2}', $parameter2, $out);
            if ($plural_or_vowel_check) {
                $numeric = (preg_match('#^([\d,]+|' . implode('|', [do_lang('INTEGER_UNITS_billions', '[\d,]+'), do_lang('INTEGER_UNITS_millions', '[\d,]+'), do_lang('INTEGER_UNITS_thousands', '[\d,]+')]) . ')$#', $parameter2) != 0);
                $_parameter_denum = $numeric ? str_replace(',', '', $parameter2) : $parameter2;
                $out = preg_replace('#\{2\|(.*)\|(.*)\}#U', (in_array($numeric ? $_parameter_denum : cms_mb_strtolower(cms_mb_substr($parameter2, 0, 1)), $non_plural_non_vowel)) ? '\\1' : '\\2', $out);
            }
            if (($XSS_DETECT) && (ocp_is_escaped($parameter2)) && ($escaped)) {
                ocp_mark_as_escaped($out);
            }

            if ($parameter3 !== null) {
                // Handle $parameter3 (multiple)
                $i = 3;
                if (!is_array($parameter3)) {
                    $parameter3 = [$parameter3];
                }
                foreach ($parameter3 as $parameter) {
                    if (isset($parameter->codename)/*faster than is_object*/) {
                        $parameter = $parameter->evaluate($lang);
                    }

                    if ($kg) {
                        kid_gloves_html_escaping_singular($parameter);
                    }

                    if ($XSS_DETECT) {
                        $escaped = ocp_is_escaped($out);
                    }
                    $out = str_replace('{' . strval($i) . '}', $parameter, $out);
                    if ($plural_or_vowel_check) {
                        $numeric = (preg_match('#^([\d,]+|' . implode('|', [do_lang('INTEGER_UNITS_billions', '[\d,]+'), do_lang('INTEGER_UNITS_millions', '[\d,]+'), do_lang('INTEGER_UNITS_thousands', '[\d,]+')]) . ')$#', $parameter) != 0);
                        $_parameter_denum = $numeric ? str_replace(',', '', $parameter) : $parameter;
                        $out = preg_replace('#\{' . strval($i) . '\|(.*)\|(.*)\}#U', (in_array($numeric ? $_parameter_denum : cms_mb_strtolower(cms_mb_substr($parameter, 0, 1)), $non_plural_non_vowel)) ? '\\1' : '\\2', $out);
                    }
                    if (($XSS_DETECT) && (ocp_is_escaped($parameter)) && ($escaped)) {
                        ocp_mark_as_escaped($out);
                    }
                    $i++;
                }
            }
        }
    }

    // Apply some special filtering to the output, based on the language filter
    if (isset($LANG_RUNTIME_PROCESSING[$codename])) {
        $flag = $LANG_RUNTIME_PROCESSING[$codename];
        $out = $LANG_FILTER_OB->run_time($codename, $out, $flag, $parameters);
    }

    // Done
    return $out;
}

/**
 * Get an array of all the installed languages that can be found in root/lang/ and root/lang_custom/.
 *
 * @param  boolean $even_empty_langs Whether to even find empty languages
 * @return array The installed languages (map, lang=>type)
 */
function find_all_langs(bool $even_empty_langs = false) : array
{
    require_code('lang3');
    return _find_all_langs($even_empty_langs);
}

/**
 * Get a nice formatted HTML listed language selector.
 *
 * @param  ?LANGUAGE_NAME $select_lang The language to have selected by default (null: uses the current language)
 * @param  boolean $show_unset Whether to show languages that have no language details currently defined for them
 * @return Tempcode The language selector
 */
function create_selection_list_langs(?string $select_lang = null, bool $show_unset = false) : object
{
    require_code('lang3');
    return _create_selection_list_langs($select_lang, $show_unset);
}

// =======
// CONTENT
// =======

/**
 * Insert a Comcode content language string into the translation table, and return details of the content language string.
 *
 * @param  ID_TEXT $field_name The field name
 * @param  string $text The text
 * @param  integer $level The level of importance this content language string holds
 * @set 1 2 3 4
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  boolean $insert_as_admin Whether to insert it as an admin (any Comcode parsing will be carried out with admin privileges)
 * @param  ?string $pass_id The special identifier for this content language string on the page it will be displayed on; this is used to provide an explicit binding between languaged elements and greater templated areas (null: none)
 * @param  boolean $preparse_mode Whether to generate a fatal error if there is invalid Comcode
 * @param  boolean $save_as_volatile Whether we are saving as a 'volatile' file extension (used in the XML DB driver, to mark things as being non-syndicated to Git)
 * @return array The content language string save fields
 */
function insert_lang_comcode(string $field_name, string $text, int $level, ?object $db = null, bool $insert_as_admin = false, ?string $pass_id = null, bool $preparse_mode = true, bool $save_as_volatile = false) : array
{
    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }

    if ((strpos($text, '[attachment') !== false) && ($preparse_mode) && ($pass_id === null)) {
        require_code('attachments2');
        return insert_lang_comcode_attachments($field_name, $level, $text, 'null', '', $db, $insert_as_admin);
    }

    return insert_lang($field_name, $text, $level, $db, true, null, null, $insert_as_admin, $pass_id, null, $preparse_mode, $save_as_volatile);
}

/**
 * Insert a content language string into the translation table, and return details of the content language string.
 *
 * @param  ID_TEXT $field_name The field name
 * @param  string $text The text
 * @param  integer $level The level of importance this content language string holds
 * @set 1 2 3 4
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  boolean $comcode Whether it is to be parsed as Comcode
 * @param  ?integer $lang_id The ID to use for the content language string (null: work out next available)
 * @param  ?LANGUAGE_NAME $lang The language (null: uses the current language)
 * @param  boolean $insert_as_admin Whether to insert it as an admin (any Comcode parsing will be carried out with admin privileges)
 * @param  ?string $pass_id The special identifier for this content language string on the page it will be displayed on; this is used to provide an explicit binding between languaged elements and greater templated areas (null: none)
 * @param  ?string $text_parsed Assembled Tempcode portion (null: work it out)
 * @param  boolean $preparse_mode Whether to generate a fatal error if there is invalid Comcode
 * @param  boolean $save_as_volatile Whether we are saving as a 'volatile' file extension (used in the XML DB driver, to mark things as being non-syndicated to Git)
 * @return array The content language string save fields
 */
function insert_lang(string $field_name, string $text, int $level, ?object $db = null, bool $comcode = false, ?int $lang_id = null, ?string $lang = null, bool $insert_as_admin = false, ?string $pass_id = null, ?string $text_parsed = null, bool $preparse_mode = true, bool $save_as_volatile = false) : array
{
    require_code('lang3');
    return _insert_lang($field_name, $text, $level, $db, $comcode, $lang_id, $lang, $insert_as_admin, $pass_id, $text_parsed, $preparse_mode, $save_as_volatile);
}

/**
 * Remap the specified Comcode content language string, and return details of the content language string.
 *
 * @param  ID_TEXT $field_name The field name
 * @param  mixed $lang_id The ID (if multi-lang-content on), or the string itself
 * @param  string $text The text to remap to
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  ?string $pass_id The special identifier for this content language string on the page it will be displayed on; this is used to provide an explicit binding between languaged elements and greater templated areas (null: none)
 * @param  ?MEMBER $source_user The member that owns the content this is for (null: current member)
 * @param  boolean $as_admin Whether to generate Comcode as arbitrary admin
 * @return array The content language string save fields
 */
function lang_remap_comcode(string $field_name, $lang_id, string $text, ?object $db = null, ?string $pass_id = null, ?int $source_user = null, bool $as_admin = false) : array
{
    if ((strpos($text, '[attachment') !== false) && ($pass_id === null)) {
        require_code('attachments3');
        return update_lang_comcode_attachments($field_name, $lang_id, $text, 'null', '', $db);
    }

    return lang_remap($field_name, $lang_id, $text, $db, true, $pass_id, $source_user, $as_admin);
}

/**
 * Remap the specified content language string, and return details of the content language string.
 *
 * @param  ID_TEXT $field_name The field name
 * @param  mixed $lang_id The ID (if multi-lang-content on), or the string itself
 * @param  string $text The text to remap to
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  boolean $comcode Whether it is to be parsed as Comcode
 * @param  ?string $pass_id The special identifier for this content language string on the page it will be displayed on; this is used to provide an explicit binding between languaged elements and greater templated areas (null: none)
 * @param  ?MEMBER $source_user The member that owns the content this is for (null: current member)
 * @param  boolean $as_admin Whether to generate Comcode as arbitrary admin
 * @return array The content language string save fields
 */
function lang_remap(string $field_name, $lang_id, string $text, ?object $db = null, bool $comcode = false, ?string $pass_id = null, ?int $source_user = null, bool $as_admin = false) : array
{
    require_code('lang3');
    return _lang_remap($field_name, $lang_id, $text, $db, $comcode, $pass_id, $source_user, $as_admin);
}

/**
 * Delete the specified content language string from the translation table.
 *
 * @param  mixed $lang_id The ID
 * @param  ?object $db The database connector to use (null: standard site connector)
 */
function delete_lang($lang_id, ?object $db = null)
{
    if (!multi_lang_content()) {
        return;
    }

    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }
    $db->query_delete('translate', ['id' => $lang_id]);
}

/**
 * Wrapper for get_translated_tempcode, which then converts complex Tempcode back to very simple flat Tempcode, as an optimisation.
 * We won't normally call this as it breaks our architecture, but webmaster may request it if they are okay with it.
 *
 * @param  ID_TEXT $table The table name
 * @param  array $row The table row. Must not have aspects of other tables in it (i.e. joins). Pre-filter using 'db_map_restrict' if required
 * @param  ID_TEXT $field_name The field name
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  ?LANGUAGE_NAME $lang The language (null: uses the current language)
 * @param  boolean $force Whether to force it to the specified language
 * @param  boolean $as_admin Whether to force as_admin, even if the content language string isn't stored against an admin (designed for Comcode page caching)
 * @param  boolean $clear_away_from_cache Whether to remove from the Tempcode cache when we're done, for performance reasons (normally don't bother with this, but some code knows it won't be needed again -- esp Comcode cache layer -- and saves RAM by removing it)
 * @return ?Tempcode The parsed Comcode (null: the text couldn't be looked up)
 */
function get_translated_tempcode__and_simplify(string $table, array $row, string $field_name, ?object $db = null, ?string $lang = null, bool $force = false, bool $as_admin = false, bool $clear_away_from_cache = false) : ?object
{
    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }
    $ret = get_translated_tempcode($table, $row, $field_name, $db, $lang, $force, $as_admin, $clear_away_from_cache);
    if ($ret === null) {
        return $ret;
    }
    $ret = make_string_tempcode($ret->evaluate());
    if (multi_lang_content()) {
        $db->query_update('translate', ['text_parsed' => $ret->to_assembly()], ['id' => $row[$field_name], 'language' => $lang], '', 1);
    } else {
        $db->query_update($table, [$field_name . '__text_parsed' => $ret->to_assembly()], $row, '', 1);
    }
    return $ret;
}

/**
 * This function is an offshoot of get_translated_text, it instead returns parsed Comcode that is linked to the specified content language string ID.
 *
 * @param  ID_TEXT $table The table name
 * @param  array $row The table row. Must not have aspects of other tables in it (i.e. joins). Pre-filter using 'db_map_restrict' if required
 * @param  ID_TEXT $field_name The field name
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  ?LANGUAGE_NAME $lang The language (null: uses the current language)
 * @param  boolean $force Whether to force it to the specified language
 * @param  boolean $as_admin Whether to force as_admin, even if the content language string isn't stored against an admin (designed for Comcode page caching)
 * @param  boolean $clear_away_from_cache Whether to remove from the Tempcode cache when we're done, for performance reasons (normally don't bother with this, but some code knows it won't be needed again -- esp Comcode cache layer -- and saves RAM by removing it)
 * @param  boolean $ignore_browser_decaching If we have just re-populated so will not decache
 * @return ?Tempcode The parsed Comcode (null: the text couldn't be looked up)
 */
function get_translated_tempcode(string $table, array $row, string $field_name, ?object $db = null, ?string $lang = null, bool $force = false, bool $as_admin = false, bool $clear_away_from_cache = false, bool $ignore_browser_decaching = false) : ?object
{
    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }

    if ($lang === null) {
        $lang = user_lang__with__translation_override();
    }

    if (multi_lang_content()) {
        $entry = $row[$field_name];

        if ($entry == 0) {
            trigger_error(do_lang('ZERO_CONTENT_LANG_STRING'), E_USER_NOTICE);
            return new Tempcode();
        }

        global $RECORD_CONTENT_LANG_STRINGS;
        if ($RECORD_CONTENT_LANG_STRINGS) {
            global $RECORDED_CONTENT_LANG_STRINGS;
            $RECORDED_CONTENT_LANG_STRINGS[$entry] = $db->is_forum_db();
        }

        if ($lang === 'xxx') {
            return make_string_tempcode('!!!'); // Helpful for testing language compliancy. We don't expect to see non x's/!'s if we're running this language
        }

        if ((isset($db->text_lookup_cache[$entry])) && ($lang === user_lang())) {
            $ret = $db->text_lookup_cache[$entry];
            if ($ret !== '') {
                if (is_string($ret)) {
                    $db->text_lookup_cache[$entry] = new Tempcode();
                    $db->text_lookup_cache[$entry]->from_assembly($ret);
                    $ret = $db->text_lookup_cache[$entry];
                }
                if ($clear_away_from_cache) {
                    unset($db->text_lookup_cache[$entry]);
                    unset($db->text_lookup_original_cache[$entry]);
                }
                return $ret;
            }
        }

        global $SEARCH_QUERY_TERMS;
        if ($SEARCH_QUERY_TERMS !== null) { // Doing a search so we need to reparse, with highlighting on
            $_result = $db->query_select('translate', ['text_original', 'source_user'], ['id' => $entry, 'language' => $lang], '', 1);
            if (array_key_exists(0, $_result)) {
                push_lax_comcode(true);

                $result = $_result[0];

                if (get_value('really_want_highlighting') === '1') {
                    require_code('comcode_from_html');
                    $result['text_original'] = force_clean_comcode($result['text_original']); // Highlighting only works with pure Comcode
                }

                $ret = comcode_to_tempcode($result['text_original'], $result['source_user'], $as_admin, null, $db, COMCODE_NORMAL, $SEARCH_QUERY_TERMS);

                pop_lax_comcode();

                return $ret;
            }
        }

        $_result = $db->query_select('translate', ['text_parsed', 'text_original'], ['id' => $entry, 'language' => $lang], '', 1);
        $result = isset($_result[0]) ? $_result[0]['text_parsed'] : null;
        if (isset($_result[0])) {
            if ($lang === user_lang()) {
                $db->text_lookup_original_cache[$entry] = $_result[0]['text_original'];
            }
        }
    } else {
        global $SEARCH_QUERY_TERMS;
        if ($SEARCH_QUERY_TERMS !== null) { // Doing a search so we need to reparse, with highlighting on
            push_lax_comcode(true);

            if (get_value('really_want_highlighting') === '1') {
                require_code('comcode_from_html');
                $row[$field_name] = force_clean_comcode($row[$field_name]); // Highlighting only works with pure Comcode
            }

            $ret = comcode_to_tempcode($row[$field_name], $row[$field_name . '__source_user'], $as_admin, null, $db, COMCODE_NORMAL, $SEARCH_QUERY_TERMS);

            pop_lax_comcode();

            return $ret;
        }

        $result = $row[$field_name . '__text_parsed'];
    }

    if (($result === null) || ($result == '') || (!$ignore_browser_decaching && is_browser_decaching())) { // Not cached
        require_code('lang3');
        return parse_translated_text($table, $row, $field_name, $db, $lang, $force, $as_admin);
    }

    $parsed = new Tempcode();
    if (!$parsed->from_assembly($result, true)) { // Corrupted
        require_code('lang3');
        return parse_translated_text($table, $row, $field_name, $db, $lang, $force, $as_admin);
    }

    if (multi_lang_content()) {
        if ($lang === user_lang()) {
            $db->text_lookup_cache[$entry] = $parsed;
        }
    }

    return $parsed;
}

/**
 * Try to return the human-readable version of the content language string ID, passed in as $entry.
 *
 * @param  mixed $entry The ID (if multi-lang-content on), or the string itself
 * @param  ?object $db The database connector to use (null: standard site connector)
 * @param  ?LANGUAGE_NAME $lang The language (null: uses the current language)
 * @param  boolean $force Whether to force it to the specified language
 * @return ?string The human-readable version (null: could not look up when $force was on)
 */
function get_translated_text($entry, ?object $db = null, ?string $lang = null, bool $force = false) : ?string
{
    if (!multi_lang_content()) {
        return $entry;
    }

    if ($entry == 0) {
        trigger_error(do_lang('ZERO_CONTENT_LANG_STRING'), E_USER_NOTICE);
        return '';
    }

    if ($entry === null) {
        trigger_error(do_lang('NULL_CONTENT_LANG_STRING'), E_USER_WARNING);
    }

    if ($db === null) {
        $db = $GLOBALS['SITE_DB'];
    }

    global $RECORD_CONTENT_LANG_STRINGS;
    if ($RECORD_CONTENT_LANG_STRINGS) {
        global $RECORDED_CONTENT_LANG_STRINGS;
        $RECORDED_CONTENT_LANG_STRINGS[$entry] = $db->is_forum_db();
    }

    if ($lang === null) {
        $lang = user_lang__with__translation_override();
    }

    if ((isset($db->text_lookup_original_cache[$entry])) && ($lang === user_lang())) {
        return $db->text_lookup_original_cache[$entry];
    }

    if ($lang === 'xxx') {
        return '!!!'; // Helpful for testing language compliancy. We don't expect to see non x's/!'s if we're running this language
    }
    $result = $db->query_select('translate', ['text_original', 'text_parsed'], ['id' => $entry, 'language' => $lang], '', 1);
    if (!isset($result[0])) {
        if ($force) {
            return null;
        }

        $result = $db->query_select('translate', ['*'], ['id' => $entry, 'language' => get_site_default_lang()], '', 1);
        if (!isset($result[0])) {
            $result = $db->query_select('translate', ['*'], ['id' => $entry], '', 1);
        }
        if (isset($result[0])) {
            $db->query_insert('translate', ['broken' => 1, 'language' => $lang] + $result[0]);
        }
    }
    if (!isset($result[0])) {
        $member_id = function_exists('get_member') ? get_member() : $GLOBALS['FORUM_DRIVER']->get_guest_id();
        $db->query_insert('translate', ['id' => $entry, 'source_user' => $member_id, 'broken' => 0, 'importance_level' => 3, 'text_original' => '', 'text_parsed' => '', 'language' => $lang]);
        $msg = do_lang('FIXED_CONTENT_LANG_STRING', strval($entry));
        if ($GLOBALS['DEV_MODE']) {
            fatal_exit($msg);
        }
        require_code('site');
        attach_message(make_string_tempcode($msg), 'warn', false, true);
        return '';
    }
    if ($lang === user_lang()) {
        $db->text_lookup_original_cache[$entry] = $result[0]['text_original'];
        $db->text_lookup_cache[$entry] = $result[0]['text_parsed'];
    }

    return $result[0]['text_original'];
}

/**
 * Convert a language string that is Comcode to Tempcode, with potential caching in the db.
 *
 * @param  ID_TEXT $lang_code The language string codename
 * @return Tempcode The parsed Comcode
 */
function comcode_lang_string(string $lang_code) : object
{
    require_code('lang3');
    return _comcode_lang_string($lang_code);
}

/**
 * UI to choose a language.
 *
 * @param  Tempcode $title Title for the form
 * @param  boolean $tip Whether to give a tip about edit order
 * @param  boolean $allow_all_selection Whether to add an 'all' entry to the list
 * @param  boolean $post Whether to use a POST parameter
 * @return mixed The UI (Tempcode) or the language to use (string/LANGUAGE_NAME)
 */
function choose_language(object $title, bool $tip = false, bool $allow_all_selection = false, bool $post = true)
{
    require_code('lang3');
    return _choose_language($title, $tip, $allow_all_selection, $post);
}

/**
 * Get the ordinal suffix (e.g. nd, rd, st) for a number.
 *
 * @param  integer $index Number to do this for
 * @return string The suffix
 */
function get_ordinal_suffix(int $index) : string
{
    // Based on http://stackoverflow.com/questions/3109978/php-display-number-with-ordinal-suffix
    $ends = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'];
    if (($index % 100) >= 11 && ($index % 100) <= 13) {
        $abbreviation = 'th';
    } else {
        $abbreviation = $ends[$index % 10];
    }
    return $abbreviation;
}

/**
 * Start locking and get faux auto-increment ID for inserting into a table which uses simulated auto-increments due to its need for additional compounded keys. Used alongside table_id_locking_end.
 *
 * @param  object $db Database connector to use
 * @param  ?integer $id ID number (returned by reference) (null: just do normal auto-increment)
 * @param  boolean $lock Whether locking has happened (returned by reference)
 * @param  string $table Translate table
 * @param  string $id_field ID field
 */
function table_id_locking_start(object $db, ?int &$id, bool &$lock, string $table = 'translate', string $id_field = 'id')
{
    $lock = false;

    if (($id === null) && (multi_lang())) {
        if (strpos(get_db_type(), 'mysql') !== false) { // Needed as MySQL auto-increment works separately for each combo of other key values (i.e. language in this case). We can't let a content language string ID get assigned to something entirely different in another language. This MySQL behaviour is not well documented, it may work differently on different versions.
            $db->query('LOCK TABLES ' . $db->get_table_prefix() . $table, null, 0, true); // Suppress errors in case access denied
            $lock = true;
            $id = $db->query_select_value($table, 'MAX(' . $id_field . ')');
            $id = ($id === null) ? null : ($id + 1);
        } elseif (!$db->driver->has_sequential_auto_increment()) { // Needed as on SQL Server we need to choose our own key, as we cannot use an 'identity' column as a part of a shared key.
            $lock = true;
            $id = $db->query_select_value($table, 'MAX(' . $id_field . ')');
            $id = ($id === null) ? db_get_first_id() : ($id + 1);
        }
        // Other databases are probably fine as-is
    }
}

/**
 * End locking for inserting into a table. Used alongside table_id_locking_start.
 *
 * @param  object $db Database connector to use
 * @param  ?integer $id ID number (null: just do normal auto-increment)
 * @param  boolean $lock Whether locking has happened
 * @param  string $table Translate table
 * @param  string $id_field ID field
 */
function table_id_locking_end(object $db, ?int $id, bool $lock, string $table = 'translate', string $id_field = 'id')
{
    if ($lock) {
        if (strpos(get_db_type(), 'mysql') !== false) {
            $db->query('UNLOCK TABLES', null, 0, true); // Suppress errors in case access denied
        }
    }
}

/**
 * Do filtering for a language pack. This is the base class that doesn't actually do anything.
 *
 * @package core
 */
class LangFilter
{
    /**
     * Do a compile-time filter.
     *
     * @param  ?string $key Language string codename (null: not a language string)
     * @param  string $value String value
     * @param  ?LANGUAGE_NAME $lang Language (null: current language)
     * @return string The suffix
     */
    public function compile_time(?string $key, string $value, ?string $lang = null) : string
    {
        return $value;
    }

    /**
     * Do a run-time filter. Only happens for strings marked for processing with a flag.
     *
     * @param  string $key Language string codename
     * @param  string $value Language string value
     * @param  string $flag Flag value assigned to the string
     * @param  array $parameters The parameters
     * @return string The suffix
     */
    public function run_time(string $key, string $value, string $flag, array $parameters) : string
    {
        return $value;
    }
}
