<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    quizzes
 */

/**
 * Show a quiz box.
 *
 * @param  array $row The database row
 * @param  string $zone The zone to show in
 * @param  boolean $give_context Whether to include context (i.e. say WHAT this is, not just show the actual content)
 * @param  ID_TEXT $guid Overridden GUID to send to templates (blank: none)
 * @return Tempcode The rendered quiz link
 */
function render_quiz_box(array $row, string $zone = '_SEARCH', bool $give_context = true, string $guid = '') : object
{
    if ($row === null) { // Should never happen, but we need to be defensive
        return new Tempcode();
    }

    require_lang('quiz');

    $url = build_url(['page' => 'quiz', 'type' => 'do', 'id' => $row['id']], $zone);

    $just_quiz_row = db_map_restrict($row, ['id', 'q_start_text']);

    if ((has_privilege(get_member(), 'bypass_quiz_timer')) && (get_param_integer('keep_timer_display', 0) == 0)) {
        $row['q_timeout'] = null;
    }

    return do_template('QUIZ_BOX', [
        '_GUID' => ($guid != '') ? $guid : '3ba4e19d93eb41f6cf2d472af982116e',
        'GIVE_CONTEXT' => $give_context,
        'TYPE' => do_lang_tempcode($row['q_type']),
        '_TYPE' => $row['q_type'],
        'POINTS' => integer_format($row['q_points_for_passing']),
        '_POINTS' => strval($row['q_points_for_passing']),
        'TIMEOUT' => ($row['q_timeout'] === null) ? '' : display_time_period($row['q_timeout'] * 60),
        '_TIMEOUT' => ($row['q_timeout'] === null) ? '' : strval($row['q_timeout'] * 60),
        'REDO_TIME' => (($row['q_reattempt_hours'] === null) || ($row['q_reattempt_hours'] == 0)) ? '' : display_time_period($row['q_reattempt_hours'] * 60 * 60),
        'DATE' => get_timezoned_date_time_tempcode($row['q_add_date']),
        '_DATE' => strval($row['q_add_date']),
        'URL' => $url,
        'NAME' => get_translated_text($row['q_name']),
        'START_TEXT' => get_translated_tempcode('quizzes', $just_quiz_row, 'q_start_text'),
        'ID' => strval($row['id']),
        'SUBMITTER' => strval($row['q_submitter']),
        'PERCENTAGE' => strval($row['q_percentage']), // Not displayed by default template as maybe secret
        'OPEN_TIME' => strval($row['q_open_time']), // Not displayed by default template as boring
        'CLOSE_TIME' => ($row['q_close_time'] === null) ? '' : strval($row['q_close_time']), // Not displayed by default template as boring
    ]);
}

/**
 * Get quiz data for exporting it as a spreadsheet.
 *
 * @param  array $questions The quiz questions
 * @return Tempcode The rendered quiz
 */
function render_quiz(array $questions) : object
{
    require_lang('quiz');

    require_code('form_templates');

    $GLOBALS['NO_DEV_MODE_FULLSTOP_CHECK'] = true;

    // Sort out qa input
    $fields = new Tempcode();
    foreach ($questions as $i => $q) {
        $name = 'q_' . strval($q['id']);

        $just_quiz_row = db_map_restrict($q, ['id', 'q_question_text', 'q_question_extra_text']);
        $question = protect_from_escaping((is_string($q['q_question_text']) && !isset($q['q_question_text__text_parsed'])) ? comcode_to_tempcode($q['q_question_text']) : get_translated_tempcode('quiz_questions', $just_quiz_row, 'q_question_text'));
        $description = protect_from_escaping((is_string($q['q_question_extra_text']) && !isset($q['q_question_extra_text__text_parsed'])) ? comcode_to_tempcode($q['q_question_extra_text']) : get_translated_tempcode('quiz_questions', $just_quiz_row, 'q_question_extra_text'));

        switch ($q['q_type']) {
            case 'MULTIPLECHOICE':
                $radios = new Tempcode();
                foreach ($q['answers'] as $a) {
                    $answer_text = (is_string($a['q_answer_text']) && !isset($a['q_answer_text__text_parsed'])) ? comcode_to_tempcode($a['q_answer_text']) : get_translated_tempcode('quiz_question_answers', $a, 'q_answer_text');
                    $radios->attach(form_input_radio_entry($name, strval($a['id']), false, protect_from_escaping($answer_text)));
                }
                $fields->attach(form_input_radio($question, $description, $name, $radios, $q['q_required'] == 1));
                break;

            case 'MULTIMULTIPLE':
                $content = [];
                foreach ($q['answers'] as $a) {
                    $content[] = [protect_from_escaping((is_string($a['q_answer_text']) && !isset($a['q_answer_text__text_parsed'])) ? comcode_to_tempcode($a['q_answer_text']) : get_translated_tempcode('quiz_question_answers', $a, 'q_answer_text')), $name . '_' . strval($a['id']), false, ''];
                }
                $fields->attach(form_input_various_ticks($content, $description, null, $question, true));
                break;

            case 'LONG':
                $fields->attach(form_input_text($question, $description, $name, '', $q['q_required'] == 1, false));
                break;

            case 'SHORT':
            case 'SHORT_STRICT':
                $fields->attach(form_input_line($question, $description, $name, '', $q['q_required'] == 1));
                break;

            default:
                warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('78ee7257d9465b1586af0ef1f6e46764')));
        }
    }

    return $fields;
}

/**
 * Score a particular quiz entry.
 *
 * @param  AUTO_LINK $entry_id Entry ID
 * @param  ?AUTO_LINK $quiz_id Quiz ID (null: look up from entry ID)
 * @param  ?array $quiz Quiz row (null: look up from entry ID)
 * @param  ?array $questions Question rows (null: look up from entry ID)
 * @param  boolean $reveal_all Whether to show answers, regardless of whether the quiz is set to do so
 * @return array A tuple of quiz result details
 */
function score_quiz(int $entry_id, ?int $quiz_id = null, ?array $quiz = null, ?array $questions = null, bool $reveal_all = false) : array
{
    if ($quiz_id === null) {
        $quiz_id = $GLOBALS['SITE_DB']->query_select_value('quiz_entries', 'q_quiz_id', ['id' => $entry_id]);
    }
    if ($quiz_id === null) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'quiz'));
    }

    $quizzes = $GLOBALS['SITE_DB']->query_select('quizzes', ['*'], ['id' => $quiz_id], '', 1);
    if (!array_key_exists(0, $quizzes)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', 'quiz'));
    }
    $quiz = $quizzes[0];

    $__given_answers = $GLOBALS['SITE_DB']->query_select('quiz_entry_answer', ['q_question_id', 'q_answer'], ['q_entry_id' => $entry_id]);
    $_given_answers = [];
    foreach ($__given_answers as $_given_answer) {
        if (!isset($_given_answers[$_given_answer['q_question_id']])) {
            $_given_answers[$_given_answer['q_question_id']] = [];
        }
        $_given_answers[$_given_answer['q_question_id']][] = $_given_answer['q_answer'];
    }

    if ($questions === null) {
        $questions = $GLOBALS['SITE_DB']->query_select('quiz_questions', ['*'], ['q_quiz_id' => $quiz_id], 'ORDER BY q_order');
        foreach ($questions as $i => $question) {
            $answers = $GLOBALS['SITE_DB']->query_select('quiz_question_answers', ['*'], ['q_question_id' => $question['id']], 'ORDER BY q_order');
            $questions[$i]['answers'] = $answers;
        }
    }

    $marks = 0.0;
    $potential_extra_marks = 0;
    $out_of = 0;
    $given_answers = [];
    $corrections = [];
    $affirmations = [];
    $unknowns = [];
    foreach ($questions as $i => $question) {
        if (!array_key_exists($question['id'], $_given_answers)) {
            continue; // Question did not exist when this quiz entry was filled
        }
        if ($question['q_marked'] == 0) {
            continue; // Don't count non-marked questions
        }

        $has_an_answer = false;

        $just_question_row = db_map_restrict($question, ['id', 'q_question_text']);
        $question_text = get_translated_tempcode('quiz_questions', $just_question_row, 'q_question_text');

        if ($question['q_type'] == 'SHORT' || $question['q_type'] == 'SHORT_STRICT' || $question['q_type'] == 'LONG') { // Text box ("free question"). May be an actual answer, or may not be
            $given_answer = $_given_answers[$question['id']][0];

            $correct_answer = new Tempcode();
            $correct_explanation = null;
            if (empty($question['answers'])) {
                $potential_extra_marks++;
                $unknowns[] = [$question_text, $given_answer];
                $was_correct = null;
            } else {
                $was_correct = false;
                foreach ($question['answers'] as $a) {
                    if ($a['q_is_correct'] == 1) {
                        $has_an_answer = true;
                        $correct_answer = make_string_tempcode(get_translated_text($a['q_answer_text']));
                    }
                    if (get_translated_text($a['q_answer_text']) == $given_answer) {
                        $correct_explanation = get_translated_text($a['q_explanation']);
                    }
                }
                $was_correct = typed_answer_is_correct($given_answer, $question['answers'], $question['q_type'] == 'SHORT_STRICT');
                if ($was_correct) {
                    $marks++;

                    $affirmation = [$question['id'], $question_text, $correct_answer, $given_answer];
                    if (!cms_empty_safe($correct_explanation)) {
                        $affirmation[] = $correct_explanation;
                    }
                    $affirmations[] = $affirmation;
                } else {
                    $correction = [$question['id'], $question_text, $correct_answer, $given_answer];
                    if (!cms_empty_safe($correct_explanation)) {
                        $correction[] = $correct_explanation;
                    }
                    $corrections[] = $correction;
                }
            }

            $given_answers[] = [
                'QUESTION' => $question_text,
                'GIVEN_ANSWER' => $given_answer,
                'WAS_CORRECT' => $was_correct,
                'CORRECT_ANSWER' => $correct_answer,
                'CORRECT_EXPLANATION' => $correct_explanation,
            ];
        } elseif ($question['q_type'] == 'MULTIMULTIPLE') { // Check boxes
            // Vector distance
            $wrongness = 0.0;
            $accum = new Tempcode();
            $correct_answer = new Tempcode();
            $correct_explanation = null;
            foreach ($question['answers'] as $a) {
                $for_this = in_array(strval($a['id']), $_given_answers[$question['id']]);
                $should_be_this = ($a['q_is_correct'] == 1);

                if ($for_this != $should_be_this) {
                    $wrongness++;
                }

                if ($should_be_this) {
                    $has_an_answer = true;
                    if (!$correct_answer->is_empty()) {
                        $correct_answer->attach(do_lang_tempcode('LIST_SEP'));
                    }
                    $correct_answer->attach(get_translated_text($a['q_answer_text']));
                }

                if ($for_this != $should_be_this) {
                    $exp = get_translated_text($a['q_explanation']);
                    if ($exp != '') {
                        if ($correct_explanation === null) {
                            $correct_explanation = '';
                        } else {
                            $correct_explanation .= ' ';
                        }
                        $correct_explanation .= $exp;
                    }
                }

                if ($for_this) {
                    if (!$accum->is_empty()) {
                        $accum->attach(do_lang_tempcode('LIST_SEP'));
                    }
                    $accum->attach(get_translated_text($a['q_answer_text']));
                }
            }
            // Normalise it
            $wrongness /= count($question['answers']);
            // And get our complement
            $correctness = 1.0 - $wrongness;
            $marks += $correctness;

            if ($correctness != 1.0) {
                $correction = [$question['id'], $question_text, $correct_answer, $accum];
                if (!cms_empty_safe($correct_explanation)) {
                    $correction[] = $correct_explanation;
                }
                $corrections[] = $correction;
            }

            $given_answer = $accum->evaluate();

            $given_answers[] = [
                'QUESTION' => $question_text,
                'GIVEN_ANSWER' => $given_answer,
                'WAS_CORRECT' => $correctness == 1.0,
                'CORRECT_ANSWER' => $correct_answer,
                'CORRECT_EXPLANATION' => $correct_explanation,
            ];
        } elseif ($question['q_type'] == 'MULTIPLECHOICE') { // Radio buttons
            $was_correct = false;
            $correct_answer = new Tempcode();
            $correct_explanation = null;
            $given_answer = '';
            foreach ($question['answers'] as $a) {
                if ($a['q_is_correct'] == 1) {
                    $has_an_answer = true;
                    $correct_answer = make_string_tempcode(get_translated_text($a['q_answer_text']));
                }

                if ($_given_answers[$question['id']][0] == strval($a['id'])) {
                    $given_answer = get_translated_text($a['q_answer_text']);

                    if ($a['q_is_correct'] == 1) {
                        $was_correct = true;

                        $marks++;
                    }

                    $correct_explanation = get_translated_text($a['q_explanation']);
                }
            }

            if (!$was_correct) {
                $correction = [$question['id'], $question_text, $correct_answer, $given_answer];
                if (!cms_empty_safe($correct_explanation)) {
                    $correction[] = $correct_explanation;
                }
                $corrections[] = $correction;
            } else {
                $affirmation = [$question['id'], $question_text, $correct_answer, $given_answer];
                if (!cms_empty_safe($correct_explanation)) {
                    $affirmation[] = $correct_explanation;
                }
                $affirmations[] = $affirmation;
            }

            $given_answers[] = [
                'QUESTION' => $question_text,
                'GIVEN_ANSWER' => $given_answer,
                'WAS_CORRECT' => $was_correct,
                'CORRECT_ANSWER' => $correct_answer,
                'CORRECT_EXPLANATION' => $correct_explanation,
            ];
        }

        if ($has_an_answer) {
            $out_of++;
        }
    }
    if ($out_of == 0) {
        $out_of = 1;
    }
    $minimum_percentage = intval(round(100.0 * $marks / $out_of));
    $maximum_percentage = intval(round(100.0 * ($marks + $potential_extra_marks) / $out_of));
    $marks_range = float_format($marks, 2, true) . (($potential_extra_marks == 0) ? '' : ('-' . float_format($marks + $potential_extra_marks, 2, true)));
    $percentage_range = strval($minimum_percentage) . (($potential_extra_marks == 0) ? '' : ('-' . strval($maximum_percentage)));

    // Prepare results for display
    $corrections_to_staff = new Tempcode();
    $corrections_to_member = new Tempcode();
    $affirmations_to_member = new Tempcode();
    foreach ($corrections as $correction) {
        // For member
        if ((array_key_exists(4, $correction)) || ($quiz['q_reveal_answers'] == 1) || ($reveal_all)) {
            $__correction = do_lang_tempcode(
                array_key_exists(4, $correction) ? 'QUIZ_MISTAKE_EXPLAINED_HTML' : 'QUIZ_MISTAKE_HTML',
                $correction[1],
                comcode_to_tempcode(is_object($correction[3]) ? $correction[3]->evaluate() : $correction[3]),
                [
                    comcode_to_tempcode(is_object($correction[2]) ? $correction[2]->evaluate() : $correction[2]),
                    comcode_to_tempcode(array_key_exists(4, $correction) ? $correction[4] : ''),
                ]
            );
            $corrections_to_member->attach($__correction);
        }

        // For staff
        $_correction = do_lang(
            array_key_exists(4, $correction) ? 'QUIZ_MISTAKE_EXPLAINED_COMCODE' : 'QUIZ_MISTAKE_COMCODE',
            $correction[1],
            comcode_to_tempcode(is_object($correction[3]) ? $correction[3]->evaluate() : $correction[3]),
            [
                comcode_to_tempcode(is_object($correction[2]) ? $correction[2]->evaluate() : $correction[2]),
                comcode_to_tempcode(array_key_exists(4, $correction) ? $correction[4] : ''),
            ]
        );
        $corrections_to_staff->attach($_correction);
    }
    foreach ($affirmations as $affirmation) {
        // For member
        if (array_key_exists(4, $affirmation)) {
            $__affirmation = do_lang_tempcode(
                'QUIZ_AFFIRMATION_HTML', // You could imagine this named as QUIZ_AFFIRMATION_EXPLAINED_HTML if you prefer
                $affirmation[1],
                comcode_to_tempcode(is_object($affirmation[3]) ? $affirmation[3]->evaluate() : $affirmation[3]),
                [
                    comcode_to_tempcode(is_object($affirmation[2]) ? $affirmation[2]->evaluate() : $affirmation[2]),
                    comcode_to_tempcode(array_key_exists(4, $affirmation) ? $affirmation[4] : ''),
                ]
            );
            $affirmations_to_member->attach($__affirmation);
        }

        // For staff
        //  Nothing - they do not need to see what was correct
    }
    $unknowns_to_staff = new Tempcode();
    foreach ($unknowns as $unknown) {
        $_unknown = do_lang('QUIZ_UNKNOWN', comcode_escape($unknown[0]->evaluate()), comcode_escape($unknown[1]));
        $unknowns_to_staff->attach($_unknown);
    }
    $given_answers_to_staff = new Tempcode();
    foreach ($given_answers as $given_answer) {
        $_given_answer = do_lang('QUIZ_RESULT', comcode_escape($given_answer['QUESTION']->evaluate()), comcode_escape($given_answer['GIVEN_ANSWER']));
        $given_answers_to_staff->attach($_given_answer);
    }
    // NB: We don't have a list of what was correct because it's not interesting, only corrections/unknowns/everything.

    $passed = null;
    if ($minimum_percentage >= $quiz['q_percentage']) {
        $passed = true;
    } elseif ($maximum_percentage < $quiz['q_percentage']) {
        $passed = false;
    }

    return [
        $marks,
        $potential_extra_marks,
        $out_of,
        $given_answers,
        $corrections,
        $affirmations,
        $unknowns,
        $minimum_percentage,
        $maximum_percentage,
        $marks_range,
        $percentage_range,
        $corrections_to_staff,
        $corrections_to_member,
        $affirmations_to_member,
        $unknowns_to_staff,
        $given_answers_to_staff,
        $passed,
    ];
}

/**
 * Is a typed quiz answer correct?.
 *
 * @param  string $given_answer The given (typed) answer
 * @param  array $all_answers Answer rows
 * @param  boolean $strict Whether to do a strict check
 * @return boolean Whether it is correct
 */
function typed_answer_is_correct(string $given_answer, array $all_answers, bool $strict = false) : bool
{
    if ($strict) {
        $filtered_given_answer = trim($given_answer);
    } else {
        $filtered_given_answer = preg_replace('#[^\d\w]#', '', cms_mb_strtolower($given_answer));
    }
    if ($filtered_given_answer == '') {
        return false;
    }

    $has_correct = false;
    $has_incorrect = false;
    foreach ($all_answers as $a) {
        if ($strict) {
            $filtered_answer = trim(get_translated_text($a['q_answer_text']));
        } else {
            $filtered_answer = preg_replace('#[^\d\w]#', '', cms_mb_strtolower(get_translated_text($a['q_answer_text'])));
        }

        if (get_translated_text($a['q_answer_text']) === $filtered_given_answer) {
            return ($a['q_is_correct'] == 1); // Match exactly; "===" needed to stop PHPs weird type coercion that happens even for strings
        }

        if ((!$strict) && (levenshtein($filtered_answer, $filtered_given_answer) <= intval(strlen($filtered_answer) * 0.2))) { // Matches inexactly
            if ($a['q_is_correct'] == 1) {
                $has_correct = true;
            } else {
                $has_incorrect = true;
            }
        }
    }
    return $has_correct && !$has_incorrect;
}
