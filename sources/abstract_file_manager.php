<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: ftp_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/*
The abstract file manager allows easy and transparent file system maintenance, even when it has to be piped through FTP.
*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__abstract_file_manager()
{
    require_lang('abstract_file_manager');
    require_lang('installer');
    require_code('files');

    global $AFM_FTP_CONN;
    $AFM_FTP_CONN = null;
}

/**
 * Make sure that the AFM connection details have been posted. If not, get them and loop back.
 *
 * @param  array $writable_paths A list of file or directory paths to check first for writability. Only works for suEXEC-style. Advisable because we don't want to fail in the middle of something. May be glob style, or end in '/*' for recursion.
 */
function force_have_afm_details(array $writable_paths = [])
{
    $no_ftp_conditions = [
        is_suexec_like(), // No need for FTP
        get_file_base() != get_custom_file_base(), // Shared installs are assumed to have the necessary AFM permissions where needed
        (!function_exists('ftp_ssl_connect')) && (!function_exists('ftp_connect')), // FTP not available
    ];
    foreach ($no_ftp_conditions as $no_ftp_condition) {
        if ($no_ftp_condition) {
            foreach (array_unique($writable_paths) as $path) {
                $full_path = get_file_base() . (($path == '') ? ''  : '/') . $path;

                if (substr($full_path, -2) == '/*') {
                    require_code('files2');
                    $_full_path = substr($full_path, 0, strlen($full_path) - 2);
                    $all_full_paths = array_merge([$_full_path], get_directory_contents($_full_path, $_full_path));
                } elseif (preg_match('#\.\w+$#', $path) != 0) {
                    $all_full_paths = glob($full_path);
                } else {
                    $all_full_paths = [$full_path];
                }

                foreach ($all_full_paths as $_full_path) {
                    while (!file_exists($_full_path)) {
                        $_full_path = dirname($_full_path);
                    }

                    if (!cms_is_writable($_full_path)) {
                        warn_exit(do_lang_tempcode('WRITE_ERROR', escape_html(dirname($_full_path))));
                    }
                }
            }

            set_value('uses_ftp', '0');

            return;
        }
    }

    // FTP...

    $got_ftp_details = post_param_integer('got_ftp_details', 0);
    $ftp_password = get_value('ftp_password');
    if ($ftp_password === null) {
        $ftp_password = '';
    }
    //$uses_ftp = get_value('uses_ftp');    We can't use this because there's no reliable way to trust this is always going to be right (permissions change/differ, and we can't accurately run a test and trust the result going forward for everything)
    if (/*($uses_ftp === '0') || */(strlen($ftp_password) > 0)) { // Permanently stored
        return;
    }
    if ($got_ftp_details == 0) { // Get FTP details
        get_afm_form();
    } else {
        // Store them as values
        $uses_ftp = post_param_integer('uses_ftp', 0);
        set_value('uses_ftp', strval($uses_ftp));
        if ($uses_ftp == 1) {
            set_value('ftp_username', post_param_string('ftp_username', false, INPUT_FILTER_POST_IDENTIFIER));
            $ftp_directory = post_param_string('ftp_directory');
            if (substr($ftp_directory, 0, 1) != '/') {
                $ftp_directory = '/' . $ftp_directory;
            }
            set_value('ftp_directory', $ftp_directory);
            set_value('ftp_domain', post_param_string('ftp_domain', false, INPUT_FILTER_POST_IDENTIFIER));
            if (post_param_integer('remember_password', 0) == 1) {
                set_value('ftp_password', post_param_string('ftp_password', false, INPUT_FILTER_PASSWORD));
            }
        }
    }
}

/**
 * Force an AFM login.
 */
function get_afm_form()
{
    $fields = get_afm_form_fields();

    $title = get_screen_title('ABSTRACT_FILE_MANAGEMENT');

    $post_url = get_self_url(true);
    $submit_name = do_lang_tempcode('PROCEED');
    $hidden = build_keep_post_fields();
    $hidden->attach(form_input_hidden('got_ftp_details', '1'));

    $middle = do_template('FORM_SCREEN', [
        '_GUID' => 'c47a31fca47a7b22eeef3a6269cc2407',
        'JS_FUNCTION_CALLS' => ['abstractFileManagerGetAfmForm'],
        'SKIP_WEBSTANDARDS' => true,
        'HIDDEN' => $hidden,
        'SUBMIT_ICON' => 'buttons/proceed',
        'SUBMIT_NAME' => $submit_name,
        'TITLE' => $title,
        'FIELDS' => $fields,
        'URL' => $post_url,
        'TEXT' => paragraph(do_lang_tempcode('TEXT_ABSTRACT_FILE_MANAGEMENT')),
    ]);
    $echo = globalise($middle, null, '', true);
    $echo->evaluate_echo();
    exit();
}

/**
 * Get the fields that need to be filled in to know how to do an AFM connection.
 *
 * @return Tempcode The form fields
 */
function get_afm_form_fields() : object
{
    require_code('form_templates');
    $fields = new Tempcode();

    $ftp_username = get_value('ftp_username');
    $ftp_directory = get_value('ftp_directory');
    $ftp_domain = get_value('ftp_domain');
    $_uses_ftp = running_script('upgrader') ? '0' : get_value('uses_ftp');
    if ($_uses_ftp === null) {
        $uses_ftp = !cms_is_writable(get_file_base() . '/sources/global.php');
    } else {
        $uses_ftp = ($_uses_ftp == '1');
    }

    // Domain
    if ($ftp_domain === null) {
        if (!empty($GLOBALS['SITE_INFO']['ftp_domain'])) {
            $ftp_domain = $GLOBALS['SITE_INFO']['ftp_domain'];
        } else {
            $ftp_domain = get_base_url_hostname();
        }
    }

    // Username
    if ($ftp_username === null) {
        if (!empty($GLOBALS['SITE_INFO']['ftp_username'])) {
            $ftp_username = $GLOBALS['SITE_INFO']['ftp_username'];
        } else {
            if (php_function_allowed('posix_getpwuid')) {
                $u_info = posix_getpwuid(website_file_owner());
                if ($u_info !== false) {
                    $ftp_username = $u_info['name'];
                } else {
                    $ftp_username = '';
                }
            } else {
                $ftp_username = '';
            }
            if ($ftp_username === null) {
                $ftp_username = '';
            }
        }
    }

    // Directory
    if ($ftp_directory === null) {
        if (!empty($GLOBALS['SITE_INFO']['ftp_directory'])) {
            $ftp_directory = $GLOBALS['SITE_INFO']['ftp_directory'];
        } else {
            $pos = strpos($_SERVER['SCRIPT_NAME'], 'adminzone/index.php');
            if (($pos === false) && (get_zone_name() != '')) {
                $pos = strpos($_SERVER['SCRIPT_NAME'], get_zone_name() . '/index.php');
            }
            if ($pos === false) {
                $pos = strpos($_SERVER['SCRIPT_NAME'], 'data/');
            }
            if ($pos === false) {
                $pos = strpos($_SERVER['SCRIPT_NAME'], 'data_custom/');
            }
            if ($pos === false) {
                $pos = strpos($_SERVER['SCRIPT_NAME'], 'cms/index.php');
            }
            if ($pos === false) {
                $pos = strpos($_SERVER['SCRIPT_NAME'], 'site/index.php');
            }
            $dr = $_SERVER['DOCUMENT_ROOT'];
            if (strpos($dr, '/') !== false) {
                $dr_parts = explode('/', $dr);
            } else {
                $dr_parts = explode('\\', $dr);
            }
            $webdir_stub = $dr_parts[count($dr_parts) - 1];
            $ftp_directory = '/' . $webdir_stub . substr($_SERVER['SCRIPT_NAME'], 0, $pos);
        }
    }

    $fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', ['_GUID' => '671ec3d1ffd376766450b36d718f1c60', 'TITLE' => do_lang_tempcode('SETTINGS')]));
    $fields->attach(form_input_tick(do_lang_tempcode('NEED_FTP'), do_lang_tempcode('DESCRIPTION_NEED_FTP'), 'uses_ftp', $uses_ftp));
    $fields->attach(form_input_line(do_lang_tempcode('FTP_DOMAIN'), '', 'ftp_domain', $ftp_domain, false));
    $fields->attach(form_input_line(do_lang_tempcode('FTP_DIRECTORY'), do_lang_tempcode('FTP_FOLDER'), 'ftp_directory', $ftp_directory, false));
    $fields->attach(form_input_line(do_lang_tempcode('FTP_USERNAME'), '', 'ftp_username', $ftp_username, false));
    $fields->attach(form_input_password(do_lang_tempcode('FTP_PASSWORD'), '', 'ftp_password', false));
    $fields->attach(do_template('FORM_SCREEN_FIELD_SPACER', ['_GUID' => '7b2ed7bd1b2869a02e3b3bf40b3f99cd', 'TITLE' => do_lang_tempcode('ACTIONS')]));
    $fields->attach(form_input_tick(do_lang_tempcode('REMEMBER_PASSWORD'), do_lang_tempcode('DESCRIPTION_REMEMBER_PASSWORD'), 'remember_password', false));

    return $fields;
}

/**
 * Return the FTP connection, from stored/posted details.
 *
 * @param  boolean $light_fail Whether to simply echo-out errors
 * @return ~resource The FTP connection (false: not connecting via FTP)
 *
 * @ignore
 */
function _ftp_info(bool $light_fail = false)
{
    global $AFM_FTP_CONN;
    if ($AFM_FTP_CONN !== null) {
        return $AFM_FTP_CONN;
    }

    if (((get_value('uses_ftp') === '1') && (!running_script('upgrader'))) || (post_param_integer('uses_ftp', 0) == 1)) {
        require_lang('installer');

        $conn = false;
        $domain = post_param_string('ftp_domain', get_value('ftp_domain'), INPUT_FILTER_POST_IDENTIFIER);
        $port = 21;
        if (strpos($domain, ':') !== false) {
            list($domain, $_port) = explode(':', $domain, 2);
            $port = intval($_port);
        }
        if (function_exists('ftp_ssl_connect')) {
            $conn = @ftp_ssl_connect($domain, $port);
        }
        $ssl = ($conn !== false);

        $username = post_param_string('ftp_username', get_value('ftp_username'), INPUT_FILTER_POST_IDENTIFIER);
        $password = post_param_string('ftp_password', get_value('ftp_password'), INPUT_FILTER_PASSWORD);

        if (($ssl) && (!@ftp_login($conn, $username, $password))) {
            $conn = false;
            $ssl = false;
        }
        if (($conn === false) && (function_exists('ftp_connect'))) {
            $conn = @ftp_connect($domain, $port);
        }
        if ($conn === false) {
            set_value('ftp_password', '');
            if ($light_fail) {
                $temp = do_lang_tempcode('NO_FTP_CONNECT');
                echo '<strong>';
                $temp->evaluate_echo();
                echo '</strong>';
                return null;
            } else {
                set_value('ftp_password', ''); // Wipe out password, because we need the user to see FTP login screen again
                attach_message(do_lang_tempcode('NO_FTP_CONNECT'), 'warn');
                get_afm_form();
            }
        }

        $username = post_param_string('ftp_username', get_value('ftp_username'), INPUT_FILTER_POST_IDENTIFIER);
        $password = post_param_string('ftp_password', get_value('ftp_password'), INPUT_FILTER_PASSWORD);

        if ((!$ssl) && (@ftp_login($conn, $username, $password) === false)) {
            set_value('ftp_password', '');
            if ($light_fail) {
                $temp = do_lang_tempcode('NO_FTP_LOGIN', cms_error_get_last());
                $temp->evaluate_echo();
                return null;
            } else {
                set_value('ftp_password', ''); // Wipe out password, because we need the user to see FTP login screen again
                attach_message(do_lang_tempcode('NO_FTP_LOGIN', cms_error_get_last()), 'warn');
                get_afm_form();
            }
        }

        $ftp_folder = post_param_string('ftp_folder', get_value('ftp_directory'), INPUT_FILTER_POST_IDENTIFIER);
        if (substr($ftp_folder, -1) != '/') {
            $ftp_folder .= '/';
        }
        if (@ftp_chdir($conn, $ftp_folder) === false) {
            set_value('ftp_password', '');
            if ($light_fail) {
                $temp = do_lang_tempcode('NO_FTP_DIR', cms_error_get_last(), '1');
                $temp->evaluate_echo();
                return null;
            } else {
                set_value('ftp_password', ''); // Wipe out password, because we need the user to see FTP login screen again
                attach_message(do_lang_tempcode('NO_FTP_DIR', cms_error_get_last(), '1'), 'warn');
                get_afm_form();
            }
        }
        $files = @ftp_nlist($conn, '.');
        if ($files === false) { // :(. Weird bug on some systems
            $files = [];
            if (@ftp_rename($conn, '_config.php', '_config.php')) {
                $files = ['_config.php'];
            }
        }
        if (!in_array('_config.php', $files)) {
            set_value('ftp_password', '');
            if ($light_fail) {
                $temp = do_lang_tempcode('NO_FTP_DIR', cms_error_get_last(), '2');
                $temp->evaluate_echo();
                return null;
            } else {
                set_value('ftp_password', ''); // Wipe out password, because we need the user to see FTP login screen again
                attach_message(do_lang_tempcode('NO_FTP_DIR', cms_error_get_last(), '2'), 'warn');
                get_afm_form();
            }
        }

        $AFM_FTP_CONN = $conn;
        return $AFM_FTP_CONN;
    }

    return false;
}

/**
 * Translate truth about needing world write access to a directory to absolute permissions.
 *
 * @param  boolean $world_access Whether world directory access is required
 * @return integer The absolute permission
 *
 * @ignore
 */
function _translate_dir_access(bool $world_access) : int
{
    if (is_suexec_like()) {
        return 0755;
    }

    if (_ftp_info() === false) {
        return 0777; // We want the FTP user to be able to delete.. otherwise it gets awkward for them
    }

    return $world_access ? 0777 : 0755;
}

/**
 * Translate truth about needing world write access to a file to absolute permissions.
 *
 * @param  boolean $world_access Whether world file access is required
 * @param  ID_TEXT $file_type The file type (blank: don't care)
 * @return integer The absolute permission
 *
 * @ignore
 */
function _translate_file_access(bool $world_access, string $file_type = '') : int
{
    $mask = 0;

    if ($file_type == 'php') {
        $php_perms = website_default_php_file_permissions();
        if (($php_perms & 0100) == 0100) { // If PHP files need to be marked user executable
            $mask = $mask | 0100;
        }
        if (($php_perms & 0010) == 0010) { // If PHP files need to be marked group executable
            $mask = $mask | 0010;
        }
        if (($php_perms & 0001) == 0001) { // If PHP files need to be marked other executable
            $mask = $mask | 0001;
        }
    }

    if (is_suexec_like()) {
        return 0644 | $mask;
    }

    if (_ftp_info() === false) {
        return 0666 | $mask; // We want the FTP user to be able to delete.. otherwise it gets awkward for them
    }

    return ($world_access ? 0666 : 0644) | $mask;
}

/**
 * Convert an integer permission to the string version.
 *
 * @param  integer $access_int The integer permission
 * @return string The string version
 *
 * @ignore
 */
function _access_string(int $access_int) : string
{
    return sprintf('%o', $access_int);
}

/**
 * Re-scope a software path to a path suitable for the AFM connection.
 *
 * @param  PATH $path Original path
 * @return PATH Re-scoped path
 *
 * @ignore
 */
function _rescope_path(string $path) : string
{
    if (post_param_string('uses_ftp', running_script('upgrader') ? '0' : get_value('uses_ftp')) == '1') {
        $ftp_folder = post_param_string('ftp_folder', get_value('ftp_directory'), INPUT_FILTER_POST_IDENTIFIER);
        if (substr($ftp_folder, -1) != '/') {
            $ftp_folder .= '/';
        }
        return $ftp_folder . $path;
    }
    return get_custom_file_base() . '/' . $path;
}

/**
 * Make a directory over the open AFM connection.
 *
 * @param  PATH $basic_path The path to and of the directory we are making
 * @param  boolean $world_access Whether world access is required
 * @param  boolean $recursive Whether we should recursively make any directories that are missing in the given path, until we can make the final directory
 */
function afm_make_directory(string $basic_path, bool $world_access, bool $recursive = false)
{
    $access = _translate_dir_access($world_access);
    $path = _rescope_path($basic_path);

    if ($recursive) {
        $parts = explode('/', $basic_path);
        unset($parts[count($parts) - 1]);
    }

    $conn = _ftp_info();
    if ($conn !== false) {
        if ($recursive) {
            $build_up = post_param_string('ftp_folder', get_value('ftp_directory'), INPUT_FILTER_POST_IDENTIFIER);
            foreach ($parts as $part) {
                $build_up .= '/' . $part;
                @ftp_mkdir($conn, $build_up);
                _ftp_chmod($conn, $access, $build_up);
            }
        }
        if (!file_exists(get_custom_file_base() . '/' . $basic_path)) {
            $success = @ftp_mkdir($conn, $path);
            if (!is_string($success)) {
                warn_exit(protect_from_escaping(cms_error_get_last()), false, true);
            }
        }
        _ftp_chmod($conn, $access, $path);

        clearstatcache();

        sync_file(get_custom_file_base() . '/' . $basic_path);
    } else {
        if (!file_exists(get_custom_file_base() . '/' . $basic_path)) {
            @mkdir($path, $access, $recursive) or warn_exit(do_lang_tempcode('WRITE_ERROR_DIRECTORY', escape_html($path), escape_html(dirname($path))), false, true);
        } else {
            @chmod($path, $access);
        }

        sync_file($path);
    }
}

/**
 * Get a list of files under a directory.
 *
 * @param  PATH $base The base directory for the search
 * @param  PATH $at The directory where we are searching under
 * @return array An array of directories found under this recursive level
 *
 * @ignore
 */
function _get_dir_tree(string $base, string $at = '') : array
{
    $out = [['dir', $at]];
    $stub = get_custom_file_base() . '/' . $base . '/' . $at;
    $dh = @opendir($stub);
    if ($dh !== false) {
        while (($file = readdir($dh)) !== false) {
            if (($file != '.') && ($file != '..')) {
                $stub2 = $stub . (($at != '') ? '/' : '') . $file;
                if (is_dir($stub2)) {
                    $out = array_merge($out, _get_dir_tree($base, $at . (($at != '') ? '/' : '') . $file));
                } else {
                    $out[] = ['file', $at . (($at != '') ? '/' : '') . $file];
                }
            }
        }
        closedir($dh);
    } else {
        warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('d4ca8f79d7825c96a101ea06c361b68e')));
    }
    return $out;
}

/**
 * Delete a directory over the open AFM connection.
 *
 * @param  PATH $basic_path The path to and of the directory we are deleting
 * @param  boolean $recursive Whether we should recursively delete any child files and directories
 */
function afm_delete_directory(string $basic_path, bool $recursive = false)
{
    $paths = $recursive ? array_reverse(_get_dir_tree($basic_path)) : [['dir', '']];

    $conn = _ftp_info();

    foreach ($paths as $bits) {
        list($type, $path) = $bits;

        if ($type == 'file') {
            afm_delete_file($basic_path . '/' . $path);
        } else {
            $path = _rescope_path($basic_path . '/' . $path);

            if ($conn !== false) {
                ftp_rmdir($conn, $path);

                clearstatcache();

                sync_file(get_custom_file_base() . '/' . $basic_path);
            } else {
                @rmdir($path) or warn_exit(do_lang_tempcode('WRITE_ERROR_DIRECTORY', escape_html($path), escape_html(dirname($path))), false, true);

                sync_file($path);
            }
        }
    }
}

/**
 * Make a new file over the open AFM connection. Will overwrite if already exists (assuming has access).
 *
 * @param  PATH $basic_path The path to the file we are making
 * @param  string $contents The desired file contents
 * @param  boolean $world_access Whether world access is required
 * @param  boolean $bom Whether to save a byte-order-mark if appropriate to the website character set
 */
function afm_make_file(string $basic_path, string $contents, bool $world_access, bool $bom = false)
{
    $path = _rescope_path($basic_path);
    $access = _translate_file_access($world_access, get_file_extension($basic_path));

    require_code('files');

    $conn = _ftp_info();
    if ($conn !== false) {
        $path2 = cms_tempnam();
        cms_file_put_contents_safe($path2, $contents, $bom ? FILE_WRITE_BOM : 0);

        $h = fopen($path2, 'rb');
        $success = @ftp_fput($conn, $path, $h, FTP_BINARY);
        if (!$success) {
            if (running_script('upgrader')) {
                echo cms_error_get_last();
                return;
            }
            warn_exit(protect_from_escaping(cms_error_get_last()), false, true);
        }
        fclose($h);

        @unlink($path2);

        _ftp_chmod($conn, $access, $path);

        clearstatcache();

        sync_file(get_custom_file_base() . '/' . $basic_path);
    } else {
        cms_file_put_contents_safe($path, $contents, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE | ($bom ? FILE_WRITE_BOM : 0));
        @chmod($path, $access);
    }
}

/**
 * Read a file (not actually over the open AFM connection, but same result: we can do this directly).
 *
 * @param  PATH $path The path to the file we are reading
 * @param  boolean $bom Whether to consider the byte-order-mark and do character set conversions
 * @return string The contents of the file
 */
function afm_read_file(string $path, bool $bom = false) : string
{
    return cms_file_get_contents_safe(get_custom_file_base() . '/' . $path, FILE_READ_LOCK | ($bom ? FILE_READ_BOM : 0));
}

/**
 * Copies a file (NOT a directory) on the open AFM connection.
 *
 * @param  PATH $old_path The path to the file we are copying
 * @param  PATH $new_path The target path
 * @param  boolean $world_access Whether world access is required for the copy
 */
function afm_copy(string $old_path, string $new_path, bool $world_access)
{
    $a = get_custom_file_base() . '/' . $old_path;
    if (!file_exists($a)) {
        $a = get_file_base() . '/' . $old_path;
    }
    $contents = cms_file_get_contents_safe($a, FILE_READ_LOCK);
    afm_make_file($new_path, $contents, $world_access);
}

/**
 * Moves a file on the open AFM connection.
 *
 * @param  PATH $basic_old_path The path to the file we are moving from
 * @param  PATH $basic_new_path The target path
 */
function afm_move(string $basic_old_path, string $basic_new_path)
{
    if (file_exists(get_custom_file_base() . '/' . $basic_new_path)) {
        warn_exit(do_lang_tempcode('ALREADY_EXISTS', escape_html($basic_new_path)));
    }

    if (is_dir(get_custom_file_base() . '/' . $basic_new_path)) {
        $basic_new_path .= substr($basic_old_path, strrpos($basic_old_path, '/')); // If we are moving to a path, add on the filename to that path
    }

    $old_path = _rescope_path($basic_old_path);
    $new_path = _rescope_path($basic_new_path);

    $conn = _ftp_info();
    if ($conn !== false) {
        $success = @ftp_rename($conn, $old_path, $new_path);
        if (!$success) {
            if (running_script('upgrader')) {
                echo cms_error_get_last();
                return;
            }
            warn_exit(protect_from_escaping(cms_error_get_last()), false, true);
        }

        clearstatcache();

        sync_file_move(get_custom_file_base() . '/' . $basic_old_path, get_custom_file_base() . '/' . $basic_new_path);
    } else {
        @rename($old_path, $new_path) or intelligent_write_error($old_path);

        sync_file_move($old_path, $new_path);
    }
}

/**
 * Deletes a file (NOT a directory) on the open AFM connection.
 *
 * @param  PATH $basic_path The path to the file we are deleting
 */
function afm_delete_file(string $basic_path)
{
    $path = _rescope_path($basic_path);

    $conn = _ftp_info();
    if ($conn !== false) {
        $success = @ftp_delete($conn, $path);
        if (!$success) {
            if (running_script('upgrader')) {
                echo cms_error_get_last();
                return;
            }
            warn_exit(protect_from_escaping(cms_error_get_last()), false, true);
        }

        clearstatcache();

        sync_file(get_custom_file_base() . '/' . $basic_path);
    } else {
        if (!file_exists($path)) {
            return;
        }
        @unlink($path) or intelligent_write_error($path);

        sync_file($path);
    }
}

/**
 * Find the default PHP file file permissions of the website.
 *
 * @return TIME Time
 */
function website_default_php_file_permissions() : int
{
    return fileperms(get_file_base() . '/sources/global.php');
}

/**
 * Set permissions on a newly-created path via FTP, assuming an FTP filesystem cache issue if 'No such file or directory' error is thrown.
 * It is implied that the directory/file was created on the same filename prior to calling this and it returned success.
 *
 * @param  mixed $ftp The FTP connection
 * @param  integer $permissions The permissions to set
 * @param  PATH $ftp_path The file path
 * @return ~integer The new file permissions on success (false: error)
 * @ignore
 */
function _ftp_chmod($ftp, int $permissions, string $ftp_path)
{
    $chmod = @ftp_chmod($ftp, $permissions, $ftp_path);

    // If an error occurred, check if it was a file/directory issue. If so, fatal_exit with FTP configuration information.
    if ($chmod === false) {
        $prev_error = error_get_last();
        if (isset($prev_error['message']) && (strpos($prev_error['message'], 'No such file or directory') !== false)) {
            fatal_exit(do_lang_tempcode('FTP_CACHE_ERROR', escape_html($ftp_path)));
        }
    }

    return $chmod;
}
