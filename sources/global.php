<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2022

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: strtoupper|strtolower*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/**
 * This function is a very important one when coding. It allows you to include a source code file (from root/sources/ or root/sources_custom/) through the proper channels.
 * You should remember this function, and not substitute anything else for it, as that will likely make your code unstable.
 * It is key to source code modularity in Composr.
 *
 * @param  string $codename The codename for the source module to load (or a full relative path, ending with .php; if custom checking is needed, this must be the custom version)
 * @param  boolean $light_exit Whether to cleanly fail when a source file is missing
 * @param  ?boolean $has_custom Whether this is going to be from under a custom directory (null: search). This is used for performance to avoid extra searching when we already know where a file is
 */
function require_code(string $codename, bool $light_exit = false, ?bool $has_custom = null)
{
    // Handle if already required...

    global $REQUIRED_CODE, $REQUIRING_CODE, $FILE_BASE, $SITE_INFO;
    if (isset($REQUIRED_CODE[$codename])) {
        return;
    }

    $ok_per_safe_mode = (!function_exists('in_safe_mode')) || ($REQUIRING_CODE) || (!in_safe_mode());
    if (isset($REQUIRED_CODE[$codename])) {
        return; // In case it changed through the above safe mode check
    }
    $REQUIRED_CODE[$codename] = false; // unset means no, false means in-progress, true means done
    $REQUIRING_CODE = true;

    $shorthand = (strpos($codename, '.php') === false);
    if (!$shorthand) {
        $non_custom_codename = str_replace('_custom/', '/', $codename);
        $REQUIRED_CODE[$non_custom_codename] = true;
    }

    // Security...

    if (strpos($codename, '..') !== false) {
        $codename = filter_naughty($codename);
    }

    // Optional process tracking...

    if ((isset($_GET['keep_show_loading_code'])) && ($_GET['keep_show_loading_code'] === '1')) {
        $before = memory_get_usage();
    }

    // Calculate custom/non-custom status...

    $path_custom = $FILE_BASE . '/' . ($shorthand ? ('sources_custom/' . $codename . '.php') : $codename);
    $path_orig = $FILE_BASE . '/' . ($shorthand ? ('sources/' . $codename . '.php') : $non_custom_codename);

    $has_orig = null;
    if (isset($GLOBALS['PERSISTENT_CACHE']) && !in_safe_mode()) {
        global $CODE_OVERRIDES;
        if (!isset($CODE_OVERRIDES)) {
            $CODE_OVERRIDES = persistent_cache_get('CODE_OVERRIDES');
            if ($CODE_OVERRIDES === null) {
                $CODE_OVERRIDES = [];
            }
        }
        if (isset($CODE_OVERRIDES[$codename])) {
            if ($has_custom === null) {
                $has_custom = $CODE_OVERRIDES[$codename];
                if ($has_custom) {
                    $has_custom = is_file($path_custom); // Double-check still there
                }
            }
            $has_orig = $CODE_OVERRIDES['!' . $codename];
            if ($has_orig) {
                $has_orig = is_file($path_orig); // Double-check still there
            }
        } else {
            if ($has_custom === null) {
                $has_custom = is_file($path_custom);
            }
            $has_orig = is_file($path_orig);
            $CODE_OVERRIDES[$codename] = $has_custom;
            $CODE_OVERRIDES['!' . $codename] = $has_orig;
            persistent_cache_set('CODE_OVERRIDES', $CODE_OVERRIDES);
        }
    } else {
        if ($has_custom === null) {
            $has_custom = is_file($path_custom);
        }
    }

    if ((isset($SITE_INFO['safe_mode'])) && ($SITE_INFO['safe_mode'] === '1')) {
        $has_custom = false;
    }

    // Load the code as appropriate...

    if (($has_custom) && (($ok_per_safe_mode) || (!is_file($path_orig)))) {
        $done_init = false;
        $init_func = 'init__' . str_replace('/', '__', str_replace('.php', '', $codename));

        if (!isset($has_orig)) {
            $has_orig = is_file($path_orig);
        }
        if (($path_custom !== $path_orig) && ($has_orig)) {
            // Have a custom and original (i.e. override)...

            $orig = clean_php_file_for_eval(file_get_contents($path_orig), $path_orig);
            $custom = clean_php_file_for_eval(file_get_contents($path_custom), $path_custom);

            if (strpos($custom, '/*FORCE_ORIGINAL_LOAD_FIRST*/') === false/*e.g. Cannot do code rewrite for a module override that includes an Mx, because the extends needs the parent class already defined - in such cases we put this comment in the code*/) {
                // We need to identify the new functions and classes. Ideally we'd use get_defined_functions and get_declared_classes, and do a diff before/after - but this does a massive amount of memory access
                $function_matches = [];
                $possible_new_functions = [];
                $num_function_matches = preg_match_all('#\sfunction\s+(\w+)\(#', $custom, $function_matches);
                for ($i = 0; $i < $num_function_matches; $i++) {
                    $possible_new_function = $function_matches[1][$i];
                    if (!function_exists($possible_new_function)) {
                        $possible_new_functions[] = $possible_new_function;
                    }
                }
                $class_matches = [];
                $possible_new_classes = [];
                $num_class_matches = preg_match_all('#\sclass\s+(\w+)#', $custom, $class_matches);
                for ($i = 0; $i < $num_class_matches; $i++) {
                    $possible_new_class = $class_matches[1][$i];
                    if (!class_exists($possible_new_class)) {
                        $possible_new_classes[] = $possible_new_class;
                    }
                }

                call_included_code($path_custom, $codename, $light_exit); // Include our custom

                $functions_diff = [];
                foreach ($possible_new_functions as $possible_new_function) {
                    if (function_exists($possible_new_function)) {
                        $functions_diff[] = $possible_new_function;
                    }
                }
                $classes_diff = [];
                foreach ($possible_new_classes as $possible_new_class) {
                    if (class_exists($possible_new_class)) {
                        $classes_diff[] = $possible_new_class;
                    }
                }

                $pure = true; // We will set this to false if it does not have all functions the main one has. If it does have all functions we know we should not run the original init, as it will almost certainly just have been the same code copy&pasted through.
                $overlaps = false;
                $strpos_func = 'strpos';
                $str_replace_func = 'str_replace';
                foreach ($functions_diff as $function) { // Go through override's functions and make sure original doesn't have them: rename original's to non_overridden__ equivs.
                    if ($strpos_func($orig, 'function ' . $function . '(') !== false) { // NB: If this fails, it may be that "function\t" is in the file (you can't tell with a three-width proper tab)
                        $orig = $str_replace_func('function ' . $function . '(', 'function non_overridden__' . $function . '(', $orig);
                        $overlaps = true;
                    } else {
                        $pure = false;
                    }
                }
                foreach ($classes_diff as $class) {
                    if (cms_strtolower_ascii(substr($class, 0, 6)) === 'module') {
                        $class = cms_ucfirst_ascii($class);
                    }
                    if (cms_strtolower_ascii(substr($class, 0, 4)) === 'hook') {
                        $class = cms_ucfirst_ascii($class);
                    }

                    if (strpos($orig, 'class ' . $class) !== false) {
                        $orig = str_replace('class ' . $class, 'class non_overridden__' . $class, $orig);
                        $overlaps = true;
                    } else {
                        $pure = false;
                    }
                }

                // See if we can get away with loading init function early. If we can we do a special version of it that supports fancy code modification. Our override isn't allowed to call the non-overridden init function as it won't have been loaded up by PHP in time. Instead though we will call it ourselves if it still exists (hasn't been removed by our own init function) because it likely serves a different purpose to our code-modification init function and copy&paste coding is bad.
                $doing_code_modifier_init = function_exists($init_func);
                if ($doing_code_modifier_init) {
                    $test = call_user_func_array($init_func, [$orig]);
                    if (is_string($test)) {
                        $orig = $test;
                    }
                    $done_init = true;
                    if ((count($functions_diff) === 1) && (count($classes_diff) === 0)) {
                        $pure = false;
                    }
                }

                if (!$doing_code_modifier_init && !$overlaps) { // To make stack traces more helpful and help with opcode caching
                    call_included_code($path_orig, $codename, $light_exit);
                } else {
                    call_included_code($path_orig, $codename, $light_exit, $orig); // Load up modified original
                }

                if ((!$pure) && ($doing_code_modifier_init) && (function_exists('non_overridden__init__' . str_replace('/', '__', str_replace('.php', '', $codename))))) {
                    call_user_func('non_overridden__init__' . str_replace('/', '__', str_replace('.php', '', $codename)));
                }
            } else {
                // Note we load the original and then the override. This is so function_exists can be used in the overrides (as we can't support the re-definition) OR in the case of Mx_ class derivation, so that the base class is loaded first.

                call_included_code($path_orig, $codename, $light_exit);

                call_included_code($path_custom, $codename, $light_exit);
            }
        } else {
            // Have a custom but no original...

            call_included_code($path_custom, $codename, $light_exit);
        }

        if ((isset($_GET['keep_show_loading_code'])) && ($_GET['keep_show_loading_code'] === '1')) {
            if (function_exists('attach_message')) {
                attach_message('require_code: ' . $codename . ' (' . @number_format(memory_get_usage() - $before) . ' bytes used, now at ' . @number_format(memory_get_usage()) . ')', 'inform');
            } else {
                print('<!-- require_code: ' . htmlentities($codename) . ' (' . htmlentities(@number_format(memory_get_usage() - $before)) . ' bytes used, now at ' . htmlentities(@number_format(memory_get_usage())) . ') -->' . "\n");
                cms_flush_safe();
            }
        }

        if (!$done_init) {
            if (function_exists($init_func)) {
                call_user_func($init_func);
            }
        }
    } else {
        // Have an original and no custom (no override)...

        call_included_code($path_orig, $codename, $light_exit);

        // Optional process tracking (has to run before init function called)
        if ((isset($_GET['keep_show_loading_code'])) && ($_GET['keep_show_loading_code'] === '1')) {
            if (function_exists('attach_message')) {
                attach_message('require_code: ' . $codename . ' (' . @number_format(memory_get_usage() - $before) . ' bytes used, now at ' . @number_format(memory_get_usage()) . ')', 'inform');
            } else {
                print('<!-- require_code: ' . htmlentities($codename) . ' (' . htmlentities(@number_format(memory_get_usage() - $before)) . ' bytes used, now at ' . htmlentities(@number_format(memory_get_usage())) . ') -->' . "\n");
                cms_flush_safe();
            }
        }

        $init_func = 'init__' . str_replace(['/', '.php'], ['__', ''], $codename);
        if (function_exists($init_func)) {
            call_user_func($init_func);
        }
    }

    // Done...

    $REQUIRED_CODE[$codename] = true;
    $REQUIRING_CODE = false;
}

/**
 * Require code, but without looking for sources_custom overrides.
 *
 * @param  string $codename The codename for the source module to load
 */
function require_code_no_override(string $codename)
{
    global $REQUIRED_CODE;
    if (array_key_exists($codename, $REQUIRED_CODE)) {
        return;
    }
    $REQUIRED_CODE[$codename] = true;
    require_once(get_file_base() . '/sources/' . filter_naughty($codename) . '.php');
    if (function_exists('init__' . str_replace('/', '__', $codename))) {
        call_user_func('init__' . str_replace('/', '__', $codename));
    }
}

/**
 * Make a PHP file evaluable.
 *
 * @param  string $c File contents
 * @param  ?string $path File path (null: N/A)
 * @return string Cleaned up file
 */
function clean_php_file_for_eval(string $c, ?string $path = null) : string
{
    $reps = [];
    $reps['?' . '>'] = '';
    $reps['<' . '?php'] = '';
    if ($path !== null) {
        $reps['__FILE__'] = "'" . addslashes($path) . "'";
        $reps['__DIR__'] = "'" . addslashes(dirname($path)) . "'";
    }

    return str_replace(array_keys($reps), array_values($reps), $c);
}

/**
 * Run some code that is to be included. Bail out on failure.
 *
 * @param  string $path File path
 * @param  string $codename The codename for the source module to load
 * @param  boolean $light_exit Whether to cleanly fail when a source file is missing
 * @param  ?string $code File contents (null: use include not eval, which we prefer when possible as we benefit from opcode caching)
 */
function call_included_code(string $path, string $codename, bool $light_exit, ?string $code = null)
{
    if ((function_exists('find_all_hook_obs')) && (strpos($codename, 'sources_custom/hooks/systems/contentious_overrides') !== 0)) {
        $override_hooks = find_all_hook_obs('systems', 'contentious_overrides', 'Hook_contentious_overrides_');
        foreach ($override_hooks as $hook_ob) {
            if (method_exists($hook_ob, 'call_included_code')) {
                $hook_ob->call_included_code($path, $codename, /*Passed by reference*/$code);
            }
        }
    }

    $do_sed = function_exists('push_suppress_error_death');
    if ($do_sed) {
        push_suppress_error_death(true);
    }

    if (function_exists('error_clear_last')) {
        error_clear_last();
    }
    $errormsg_before = error_get_last();

    try {
        if ($code === null) {
            $result = include($path);
        } else {
            $result = eval($code);
        }

        if ($result === false) {
            $errormsg = cms_error_get_last();
            if (($errormsg == '') || ($errormsg === $errormsg_before)) {
                $errormsg = '';
            }
            if (stripos($errormsg, 'deprecated') !== false) {
                $errormsg = ''; // Deprecated errors can leak through because even though we return true in our error handler, error handlers won't run recursively, so if this code is loaded during an error it'll stream through deprecated stuff here
            }
        } else {
            $errormsg = '';
        }
    } catch (Exception $e) {
        $result = false;

        $errormsg = $e->getMessage();
    } catch (Error $e) {
        $result = false;

        $errormsg = $e->getMessage();
    }

    if ($do_sed) {
        pop_suppress_error_death();
    }

    if ($errormsg != '') {
        if (!function_exists('do_lang')) {
            if (!is_file($path)) {
                critical_error('MISSING_SOURCE', $codename);
            }
        }

        if ((!function_exists('do_lang')) || (!function_exists('fatal_exit')) || ($codename === 'failure')) {
            critical_error('PASSON', $errormsg . ' in ' . $path);
        }

        $error_lang_str = (is_file($path) ? 'CORRUPT_SOURCE_FILE' : 'MISSING_SOURCE_FILE');
        $error_message = do_lang_tempcode($error_lang_str, escape_html($codename), escape_html($path), $errormsg);
        if ($light_exit) {
            warn_exit($error_message, false, true);
        }
        fatal_exit($error_message);
    }
}

/**
 * Get last error message.
 *
 * @return string Error message (blank: none)
 */
function cms_error_get_last() : string
{
    $error = error_get_last();
    if ($error === null) {
        return '';
    }

    switch ($error['type']) {
        case E_RECOVERABLE_ERROR:
        case E_USER_ERROR:
        case E_CORE_ERROR:
        case E_COMPILE_ERROR:
        case E_ERROR:
        case E_PARSE:
            $type = 'error';
            break;

        case -123: // Hacked in for the memtrack extension, which was buggy
        case E_USER_WARNING:
        case E_CORE_WARNING:
        case E_COMPILE_WARNING:
        case E_WARNING:
            $type = 'warning';
            break;

        case E_USER_NOTICE:
        case E_NOTICE:
            $type = 'notice';
            break;

        case E_STRICT:
        case E_USER_DEPRECATED:
        case E_DEPRECATED:
        default:
            $type = 'deprecated';
            break;
    }

    $ret = '<strong>' . (function_exists('cms_strtoupper_ascii') ? cms_strtoupper_ascii($type) : strtoupper($type)) . '</strong> [' . strval($error['type']) . '] ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . strval($error['line']);
    return $ret;
}

/**
 * Replace a limited number of occurrences of the search string with the replacement string.
 * If there are the wrong number of occurrences (including zero) an error is put out, as this indicates an override is broken.
 * The phrase "<ditto>" will repeat the original $search string back into $replace.
 *
 * @param  mixed $search What's being replaced (string or array)
 * @param  mixed $replace What's being replaced with (string or array)
 * @param  mixed $subject Subject (string or array)
 * @param  integer $times Number of times to replace (to expect to replace)
 * @return mixed Result (string or array)
 */
function override_str_replace_exactly($search, $replace, $subject, int $times = 1)
{
    $cnt = substr_count($subject, $search);

    if ($cnt != $times) {
        $lines = debug_backtrace();
        critical_error('CORRUPT_OVERRIDE', preg_replace('#^' . preg_quote(get_file_base() . '/') . '#', '', $lines[0]['file']) . ':' . strval($lines[0]['line']));
    }

    $replace = str_replace('<ditto>', $search, $replace);

    return str_replace($search, $replace, $subject);
}

/**
 * Find if we are running on a live Google App Engine application.
 *
 * @return boolean If it is running as a live Google App Engine application
 */
function appengine_is_live() : bool
{
    return (GOOGLE_APPENGINE) && (!is_writable(get_file_base() . '/sources/global.php'));
}

/**
 * Are we currently running HTTPS.
 * Also see whole_site_https.
 *
 * @return boolean If we are
 */
function tacit_https() : bool
{
    static $tacit_https = null;
    if ($tacit_https === null) {
        $tacit_https = (($_SERVER['HTTPS'] != '') && ($_SERVER['HTTPS'] != 'off'/*IIS quirk*/));
    }
    return $tacit_https;
}

/**
 * Make an object of the given class.
 *
 * @param  string $class The class name
 * @param  boolean $failure_ok Whether to return null if there is no such class
 * @param  array $parameters Array of parameters
 * @return ?object The object (null: could not create)
 */
function object_factory(string $class, bool $failure_ok = false, array $parameters = []) : ?object
{
    if (!class_exists($class)) {
        if ($failure_ok) {
            return null;
        }
        fatal_exit(escape_html('Missing class: ' . $class));
    }
    return new $class(...$parameters);
}

/**
 * Find whether a particular PHP function is blocked.
 *
 * Note that you still need to put "@" before set_time_limit, as some webhost(s) have their own non-detectable block:
 *  "Cannot set max execution time limit due to system policy".
 *
 * @param  string $function Function name
 * @return boolean Whether it is
 */
function php_function_allowed(string $function) : bool
{
    static $cache = [];
    if (isset($cache[$function])) {
        return $cache[$function];
    }

    if (!in_array($function, /*These are actually language constructs rather than functions*/['eval', 'exit', 'include', 'include_once', 'isset', 'require', 'require_once', 'unset', 'empty', 'print',])) {
        if (!function_exists($function)) {
            $cache[$function] = false;
            return false;
        }
    }
    $blocked = @strval(ini_get('disable_functions') . ',' . ini_get('suhosin.executor.func.blacklist') . ',' . ini_get('suhosin.executor.include.blacklist') . ',' . ini_get('suhosin.executor.eval.blacklist'));
    $cache[$function] = (@preg_match('#(\s|,|^)' . preg_quote($function, '#') . '(\s|$|,)#i', $blocked) == 0);
    return $cache[$function];
}

/**
 * Sets the value of a configuration option, if the PHP environment allows it.
 *
 * @param  string $var Config option
 * @param  string $value New value of option
 * @return ~string Old value of option (false: error)
 */
function cms_ini_set(string $var, string $value)
{
    if (!php_function_allowed('ini_set')) {
        return false;
    }

    return @ini_set($var, $value);
}

/**
 * Flush but only if compression streams are not active.
 */
function cms_flush_safe()
{
    if ((ini_get('output_handler') == '') && (ini_get('brotli.output_compression') !== 'On') && (ini_get('zlib.output_compression') !== 'On') && (ob_get_level()) == 0) {
        flush();
    }
}

/**
 * Get the file base for your installation of Composr.
 *
 * @return PATH The file base, without a trailing slash
 */
function get_file_base() : string
{
    global $FILE_BASE;
    return $FILE_BASE;
}

/**
 * Get the file base for your installation of Composr.  For a shared install, or a GAE-install, this is different to the file-base.
 *
 * @return PATH The file base, without a trailing slash
 */
function get_custom_file_base() : string
{
    global $FILE_BASE, $SITE_INFO;
    if (!empty($SITE_INFO['custom_file_base'])) {
        return $SITE_INFO['custom_file_base'];
    }
    if (!empty($SITE_INFO['custom_file_base_stub'])) {
        require_code('shared_installs');
        $u = current_share_user();
        if ($u !== null) {
            return $SITE_INFO['custom_file_base_stub'] . '/' . $u;
        }
    }
    return $FILE_BASE;
}

/**
 * Get the parameter put into it, with no changes. If it detects that the parameter is naughty (i.e malicious, and probably from a hacker), it will log the hack-attack and output an error message.
 * This function is designed to be called on parameters that will be embedded in a path, and defines malicious as trying to reach a parent directory using '..'. All file paths in Composr should be absolute.
 *
 * @param  string $in String to test
 * @param  boolean $preg Whether to just filter out the naughtiness
 * @return string Same as input string
 */
function filter_naughty(string $in, bool $preg = false) : string
{
    if (strpos($in, "\0") !== false) {
        log_hack_attack_and_exit('PATH_HACK');
    }

    if (strpos($in, '..') !== false) {
        if ($preg) {
            return str_replace('.', '', $in);
        }

        $in = str_replace('...', '', $in);
        if (strpos($in, '..') !== false) {
            log_hack_attack_and_exit('PATH_HACK');
        }
        warn_exit(do_lang_tempcode('INVALID_URL'));
    }
    return $in;
}

/**
 * This function is similar to filter_naughty, except it requires the parameter to be strictly alphanumeric. It is intended for use on text that will be put into an eval.
 *
 * @param  string $in String to test
 * @param  boolean $preg Whether to just filter out the naughtiness
 * @return string Same as input string
 */
function filter_naughty_harsh(string $in, bool $preg = false) : string
{
    if (preg_match('#^[' . URL_CONTENT_REGEXP . ']*$#D', $in) !== 0) {
        return $in;
    }
    if (preg_match('#^[\w\-]*/#', $in) !== 0) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE')); // Probably a relative URL underneath a URL Scheme short URL, should not really happen
    }

    if ($preg) {
        return preg_replace('#[^' . URL_CONTENT_REGEXP . ']#D', '', $in);
    }
    log_hack_attack_and_exit('EVAL_HACK', $in);
    return ''; // trick to make linters happy
}

/**
 * PHP's environment can be a real mess across servers. Cleanup $_SERVER from $_ENV for IIS if needed.
 * Also see fixup_bad_php_env_vars.
 */
function fixup_bad_php_env_vars_pre()
{
    // Variables may be defined in $_ENV on some servers
    $understood = [
        'DOCUMENT_ROOT',
        'HTTP_ACCEPT',
        'HTTP_ACCEPT_CHARSET',
        'HTTP_ACCEPT_LANGUAGE',
        'HTTP_CLIENT_IP',
        'HTTP_HOST',
        'HTTP_IF_MODIFIED_SINCE',
        'HTTP_ORIGIN',
        'PATH_INFO',
        'HTTP_PREFER',
        'HTTP_RANGE',
        'HTTP_REFERER',
        'HTTP_USER_AGENT',
        'HTTP_X_FORWARDED_FOR',
        'HTTP_X_FORWARDED_PROTO',
        'HTTP_CF_CONNECTING_IP',
        'PHP_SELF',
        'QUERY_STRING',
        'REMOTE_ADDR',
        'REQUEST_METHOD',
        'REQUEST_URI',
        'SCRIPT_FILENAME',
        'SCRIPT_NAME',
        'SERVER_ADDR',
        'SERVER_NAME',
        'SERVER_SOFTWARE',
        'HTTP_AUTHORIZATION',
        'REDIRECT_HTTP_AUTHORIZATION',
        'REMOTE_USER',
        'REDIRECT_REMOTE_USER',
        'PHP_AUTH_USER',
        'PHP_AUTH_PW',
    ];
    foreach ($understood as $key) {
        if (!isset($_SERVER[$key])) {
            if (isset($_ENV[$key])) {
                $_SERVER[$key] = $_ENV[$key];
            } else {
                $_SERVER[$key] = '';
            }
        }
    }
}

/**
 * See if we should consider the user admin based on the backdoor_ip setting.
 * If Composr is not fully bootstrapped then it will do simpler checks.
 *
 * @return boolean Whether backdoor is activated
 */
function has_backdoor_ip_triggered() : bool
{
    global $SITE_INFO;

    $backdoor_ip_address = []; // Enable to a real IP address to force login from FTP access (if lost admin password)
    if (!empty($SITE_INFO['backdoor_ip'])) {
        $backdoor_ip_addresses = array_map('trim', explode(',', $SITE_INFO['backdoor_ip']));
    }
    if (!empty($backdoor_ip_addresses)) {
        $user_ip = @strval($_SERVER['REMOTE_ADDR']);
        if (empty($user_ip)) {
            return false;
        }
        $localhost_ips = get_localhost_ips();

        $user_ip = normalise_ip_address($user_ip);

        foreach ($backdoor_ip_addresses as $backdoor_ip) {
            if ($backdoor_ip == '') {
                continue;
            }

            $cidr = (strpos($backdoor_ip, '/') !== false);
            if ($cidr) {
                // CIDR
                if (ip_cidr_check($user_ip, $backdoor_ip)) {
                    return true;
                }
            } else {
                if ((function_exists('is_valid_ip')) && (!is_valid_ip(normalise_ip_address($backdoor_ip))) && (!empty($_GET['keep_check_backdoor_ip_dns']))) {
                    // Host name
                    $backdoor_ip = gethostbyname($backdoor_ip);
                } else {
                    // IP
                    $backdoor_ip = normalise_ip_address($backdoor_ip);
                }

                if (!empty($backdoor_ip)) {
                    if ($backdoor_ip === $user_ip) {
                        return true;
                    }

                    if ((in_array($backdoor_ip, $localhost_ips)) && (in_array($user_ip, $localhost_ips))) {
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

/**
 * Find whether an IP address is valid.
 *
 * @param  IP $ip IP address to check
 * @param  boolean $allow_wildcards Allow wildcards
 * @return boolean Whether the IP address is valid
 */
function is_valid_ip(string $ip, bool $allow_wildcards = false) : bool
{
    $parts = [];

    if (strpos($ip, '.') !== false) {
        // ipv4

        if ($allow_wildcards) {
            if (preg_match('#^(\d+|\*)\.(\d+|\*)\.(\d+|\*)\.(\d+|\*)$#D', $ip, $parts) == 0) {
                return false;
            }

            for ($i = 1; $i <= 4; $i++) {
                if ($parts[$i] == '*') {
                    for ($j = $i + 1; $j <= 4; $j++) {
                        if ($parts[$j] != '*') {
                            return false;
                        }
                    }
                }
            }
        } else {
            if (preg_match('#^(\d+)\.(\d+)\.(\d+)\.(\d+)$#D', $ip, $parts) == 0) {
                return false;
            }
        }

        for ($i = 1; $i <= 4; $i++) {
            if ((is_numeric($parts[$i])) && (intval($parts[$i]) > 255)) {
                return false;
            }
        }

        return true;
    }

    if (strpos($ip, ':') !== false) {
        // ipv6

        if (substr_count($ip, '::') > 1) {
            return false;
        }

        $parts = explode(':', $ip);

        if (count($parts) > 8) {
            return false;
        }

        if ((count($parts) < 8) && (strpos($ip, '::') === false)) {
            return false;
        }

        foreach ($parts as $i => $part) {
            if ($allow_wildcards) {
                if (preg_match('#^(\*|[\dA-F]{0,4})$#iD', $part) == 0) {
                    return false;
                }

                if ($part == '*') {
                    for ($j = $i + 1; $j < count($parts); $j++) {
                        if ($parts[$j] != '*') {
                            return false;
                        }
                    }
                }
            } else {
                if (preg_match('#^[\dA-F]{0,4}$#iD', $part) == 0) {
                    return false;
                }
            }
        }

        return true;
    }

    return false;
}

/**
 * Normalise/fix a provided IP address, including wildcarding part of it if requested.
 *
 * @param  IP $ip The IP address to normalise
 * @param  ?integer $amount The number of groups to include in the IP address (rest will be replaced with *'s). For IP6, this is doubled. (null: wildcards not allowed)
 * @return IP The normalised IP address
 */
function normalise_ip_address(string $ip, ?int $amount = null) : string
{
    if ($ip == '') {
        return '';
    }

    $raw_ip = $ip;

    static $ip_cache = [];
    if (isset($ip_cache[$raw_ip][$amount])) {
        return $ip_cache[$raw_ip][$amount];
    }

    // Bizarro-filter (found "in the wild")
    $pos = strpos($ip, ',');
    if ($pos !== false) {
        $ip = substr($ip, 0, $pos);
    }

    // Normalise
    if (strpos($ip, '.') === false) { // IPv6
        // Strip ipv6 scope ID
        if (strpos($ip, '%') !== false) {
            $ip = preg_replace('#%.*$#', '', $ip);
        }

        if ($amount !== null) {
            $amount += (8 - $amount);
        }

        if (substr_count($ip, ':') < 7) {
            $ip = str_replace('::', str_repeat(':', (7 - substr_count($ip, ':')) + 2), $ip);
        }
        $parts = explode(':', $ip);
        for ($i = 0; $i < (($amount === null) ? 8 : $amount); $i++) {
            if (isset($parts[$i])) {
                if ($parts[$i] != '*') {
                    $parts[$i] = strtoupper(str_pad($parts[$i], 4, '0', STR_PAD_LEFT));
                }
            } else {
                $parts[$i] = '0000';
            }
        }
        if ($amount !== null) {
            for ($i = $amount; $i < 8; $i++) {
                $parts[$i] = '*';
            }
        }
        $ip = implode(':', $parts);
        $ip_cache[$raw_ip][$amount] = $ip;
    } else { // IPv4
        $parts = explode('.', $ip);
        for ($i = 0; $i < (($amount === null) ? 4 : $amount); $i++) {
            if (!array_key_exists($i, $parts)) {
                $parts[$i] = '0';
            }
        }
        if ($amount !== null) {
            for ($i = $amount; $i < 4; $i++) {
                $parts[$i] = '*';
            }
        }
        $ip = implode('.', $parts);
        $ip_cache[$raw_ip][$amount] = $ip;
    }

    if (!is_valid_ip($ip_cache[$raw_ip][$amount], $amount !== null)) {
        // If still not valid after normalisation
        $ip_cache[$raw_ip][$amount] = '';
        return '';
    }

    return $ip_cache[$raw_ip][$amount];
}

/**
 * Get possible IP addresses of a localhost machine.
 * Also see get_server_ips().
 *
 * @return array IP addresses
 */
function get_localhost_ips() : array
{
    return [
        '0000:0000:0000:0000:0000:0000:0000:0001',
        '::1',
        '127.0.0.1',
    ];
}

/**
 * Find if an IP address is within a CIDR range. Based on comment in PHP manual: http://php.net/manual/en/ref.network.php.
 *
 * @param  IP $ip IP address
 * @param  SHORT_TEXT $cidr CIDR range (e.g. 204.93.240.0/24)
 * @return boolean Whether it is
 */
function ip_cidr_check(string $ip, string $cidr) : bool
{
    if ((strpos($ip, ':') === false) !== (strpos($cidr, ':') === false)) {
        return false; // Different IP address type
    }

    if (strpos($ip, ':') === false) {
        // IPv4...

        list($net, $maskbits) = explode('/', $cidr, 2);

        $ip_net = ip2long($net);
        $ip_mask = ~((1 << (32 - intval($maskbits))) - 1);

        $ip_ip = ip2long($ip);

        return (($ip_ip & $ip_mask) == $ip_net);
    }

    // IPv6...

    $unpacked = unpack('A16', _inet_pton($ip));
    $binaryip = '';
    for ($i = 0; $i < strlen($unpacked[1]); $i++) {
        $char = $unpacked[1][$i];
        $binaryip .= str_pad(decbin(ord($char)), 8, '0', STR_PAD_LEFT);
    }

    list($net, $maskbits) = explode('/', $cidr, 2);
    $unpacked = unpack('A16', _inet_pton($net));
    $binarynet = '';
    for ($i = 0; $i < strlen($unpacked[1]); $i++) {
        $char = $unpacked[1][$i];
        $binarynet .= str_pad(decbin(ord($char)), 8, '0', STR_PAD_LEFT);
    }

    $ip_net_bits = substr($binaryip, 0, intval($maskbits));
    $net_bits = substr($binarynet, 0, intval($maskbits));
    return ($ip_net_bits == $net_bits);
}

/**
 * Normalise an IPv6 address.
 *
 * @param  IP $ip IP address
 * @return IP Normalised address
 *
 * @ignore
 */
function _inet_pton(string $ip) : string
{
    $_ip = explode(':', $ip);
    $normalised_ip = '';
    $normalised_ip .= str_pad('', (4 * (8 - count($_ip))), '0000', STR_PAD_LEFT); // Fill out trimmed 0's on left
    foreach ($_ip as $seg) { // Copy rest in
        $normalised_ip .= str_pad($seg, 4, '0', STR_PAD_LEFT); // Pad out each component in full, building up $normalised_ip
    }
    return $normalised_ip;
}

/**
 * Do what we need, if anything, to allow exiting without any extraneous output messing up a non-HTML request.
 * It is a hard assumption that if this function returns, exit will happen via a natural flow.
 */
function cms_safe_exit_flow()
{
    $aaf = @ini_get('auto_append_file');
    if (!empty($aaf)) {
        // Necessary to stop it corrupting our XML if it contains ad-crap
        exit();
    }
}

// Useful for basic profiling
global $PAGE_START_TIME;
$PAGE_START_TIME = microtime(true);

// Are we in a special version of PHP?
define('GOOGLE_APPENGINE', isset($_SERVER['APPLICATION_ID']));

define('URL_CONTENT_REGEXP', '\w\-\x80-\xFF'); // PHP is done using ASCII (don't use the 'u' modifier). Note this doesn't include dots, this is intentional as they can cause problems in filenames
define('URL_CONTENT_REGEXP_JS', '\w\-\u0080-\uFFFF'); // JavaScript is done using Unicode

// Sanitise the PHP environment some more
if (!GOOGLE_APPENGINE) {
    cms_ini_set('include_path', '');
    cms_ini_set('allow_url_fopen', '0');
}
cms_ini_set('allow_url_include', '0');
cms_ini_set('display_errors', '0');
cms_ini_set('suhosin.executor.disable_emodifier', '1'); // Extra security if suhosin is available
cms_ini_set('suhosin.executor.multiheader', '1'); // Extra security if suhosin is available
cms_ini_set('suhosin.executor.disable_eval', '0');
cms_ini_set('suhosin.executor.eval.whitelist', '');
cms_ini_set('suhosin.executor.func.whitelist', '');
cms_ini_set('auto_detect_line_endings', '0'); // LEGACY: Remove when only supporting PHP 8.1+
cms_ini_set('default_socket_timeout', '60');
cms_ini_set('html_errors', '1');
cms_ini_set('docref_root', 'http://php.net/manual/en/');
cms_ini_set('docref_ext', '.php');
cms_ini_set('pcre.jit', '0'); // Compatibility issue in PHP 7.3, "JIT compilation failed: no more memory"
@header_remove('x-powered-by'); // Security

fixup_bad_php_env_vars_pre();

$script_name = isset($_SERVER['SCRIPT_NAME']) ? $_SERVER['SCRIPT_NAME'] : '';
if ((strpos($script_name, '/sources/') !== false) || (strpos($script_name, '/sources_custom/') !== false)) {
    header('Content-Type: text/plain; charset=utf-8');
    exit('May not be included directly');
}

// Get ready for some global variables
global $REQUIRED_CODE, $REQUIRING_CODE, $CURRENT_SHARE_USER, $PURE_POST, $IN_MINIKERNEL_VERSION;
/** Details of what code files have been loaded up.
 *
 * @global array $REQUIRED_CODE
 */
$REQUIRED_CODE = [];
$REQUIRING_CODE = false;
/** If running on a shared-install, this is the identifying name of the site that is being called up.
 *
 * @global ?ID_TEXT $CURRENT_SHARE_USER
 */
if ((!isset($CURRENT_SHARE_USER)) || (isset($_SERVER['REQUEST_METHOD']))) {
    $CURRENT_SHARE_USER = null;
}
/** A copy of the POST parameters, as passed initially to PHP (needed for hash checks with some IPN systems).
 *
 * @global array $PURE_POST
 */
$PURE_POST = $_POST;
$IN_MINIKERNEL_VERSION = false;

// Critical error reporting system
global $FILE_BASE;
if (is_file($FILE_BASE . '/sources_custom/critical_errors.php')) {
    require($FILE_BASE . '/sources_custom/critical_errors.php');
} else {
    if (function_exists('error_clear_last')) {
        error_clear_last();
    }
    $errormsg_before = error_get_last();
    $result = @include($FILE_BASE . '/sources/critical_errors.php');
    $errormsg = error_get_last();
    if ((!$result) && ($errormsg !== null) && ($errormsg !== $errormsg_before)) {
        exit('<!DOCTYPE html>' . "\n" . '<html lang="EN"><head><title>Critical startup error</title></head><body><h1>Composr startup error</h1><p>The third most basic Composr startup file, sources/critical_errors.php, could not be loaded (error: ' . $errormsg['message'] . '). This is almost always due to an incomplete upload of the Composr system, so please check all files are uploaded correctly.</p><p>Once all Composr files are in place, Composr must actually be installed by running the installer. You must be seeing this message either because your system has become corrupt since installation, or because you have uploaded some but not all files from our manual installer package: the quick installer is easier, so you might consider using that instead.</p><p>ocProducts maintains full documentation for all procedures and tools, especially those for installation. These may be found on the <a href="https://compo.sr">Composr website</a>. If you are unable to easily solve this problem, we may be contacted from our website and can help resolve it for you.</p><hr /><p style="font-size: 0.8em">Composr is a website engine created by ocProducts.</p></body></html>');
    }
}

// Load up config file
global $SITE_INFO;
/** Site base configuration settings.
 *
 * @global array $SITE_INFO
 */
$SITE_INFO = [];
@include($FILE_BASE . '/_config.php');
if (empty($SITE_INFO)) {
    // LEGACY
    if ((!is_file($FILE_BASE . '/_config.php')) && (is_file($FILE_BASE . '/info.php'))) {
        @copy($FILE_BASE . '/info.php', $FILE_BASE . '/_config.php');
        if (is_file($FILE_BASE . '/_config.php')) {
            $new_config_file = file_get_contents($FILE_BASE . '/_config.php');
            $new_config_file = str_replace(['ocf_table_prefix', 'use_mem_cache', 'ocp_member_id', 'ocp_member_hash', 'ocf', 'admin_password'], ['cns_table_prefix', 'use_persistent_cache', 'cms_member_id', 'cms_member_hash', 'cns', 'master_password'], $new_config_file);
            $new_config_file = str_replace(']=\'', '] = \'', $new_config_file); // Clean up formatting to new convention
            file_put_contents($FILE_BASE . '/_config.php', $new_config_file, LOCK_EX);
        } else {
            exit('Error, cannot rename info.php to _config.php: check the Composr upgrade instructions');
        }
        @include($FILE_BASE . '/_config.php');
    }
}
if (empty($SITE_INFO)) {
    if (!is_file($FILE_BASE . '/_config.php')) {
        critical_error('_CONFIG.PHP_MISSING');
    } elseif (strlen(trim(file_get_contents($FILE_BASE . '/_config.php'))) == 0) {
        critical_error('_CONFIG.PHP_EMPTY');
    } else {
        critical_error('_CONFIG.PHP_CORRUPTED');
    }
}

// Make sure we have the correct IP address in REMOTE_ADDR
if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    if (empty($SITE_INFO['trusted_proxies'])) {
        $trusted_proxies = '173.245.48.0/20,103.21.244.0/22,103.22.200.0/22,103.31.4.0/22,141.101.64.0/18,108.162.192.0/18,190.93.240.0/20,188.114.96.0/20,197.234.240.0/22,198.41.128.0/17,162.158.0.0/15,104.16.0.0/13,104.24.0.0/14,172.64.0.0/13,131.0.72.0/22,2400:cb00::/32,2606:4700::/32,2803:f800::/32,2405:b500::/32,2405:8100::/32,2a06:98c0::/29,2c0f:f248::/32';
        $might_be_cloudflare = true;
    } else {
        $trusted_proxies = $SITE_INFO['trusted_proxies'];
        $might_be_cloudflare = false;
    }
    foreach (explode(',', $trusted_proxies) as $proxy) {
        if (((strpos($proxy, '/') !== false) && (ip_cidr_check($_SERVER['REMOTE_ADDR'], $proxy))) || ($_SERVER['REMOTE_ADDR'] == $proxy)) {
            if (ip_cidr_check($_SERVER['REMOTE_ADDR'], $proxy)) {
                $_SERVER['REMOTE_ADDR'] = (($might_be_cloudflare) && (isset($_SERVER['HTTP_CF_CONNECTING_IP']))) ? $_SERVER['HTTP_CF_CONNECTING_IP'] : $_SERVER['HTTP_X_FORWARDED_FOR'];
                $_SERVER['HTTP_X_FORWARDED_FOR'] = '';
                if ($might_be_cloudflare) {
                    unset($_SERVER['HTTP_CF_CONNECTING_IP']);
                }
                if ((isset($_SERVER['HTTP_X_FORWARDED_PROTO'])) && ($_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https')) {
                    $_SERVER['HTTPS'] = 'on';
                    $_SERVER['SERVER_PORT'] = '443';
                }
                break;
            }
        }
    }
}

// Rate limiter, to stop aggressive bots
global $SITE_INFO;
$rate_limiting = !empty($SITE_INFO['rate_limiting']);
if ($rate_limiting) {
    if ((!empty($_SERVER['REMOTE_ADDR'])) && (basename($_SERVER['SCRIPT_NAME']) == 'index.php')) {
        // Basic context
        $ip = $_SERVER['REMOTE_ADDR'];
        $time = time();

        if (!(((!empty($_SERVER['SERVER_ADDR'])) && ($ip == $_SERVER['SERVER_ADDR'])) || ((!empty($_SERVER['LOCAL_ADDR'])) && ($ip == $_SERVER['LOCAL_ADDR'])))) {
            global $RATE_LIMITING_DATA;
            $RATE_LIMITING_DATA = [];

            // Read in state
            $rate_limiter_path = dirname(__DIR__) . '/data_custom/rate_limiter.php';
            if (is_file($rate_limiter_path)) {
                $fp = fopen($rate_limiter_path, 'rb');
                flock($fp, LOCK_SH);
                include($rate_limiter_path);
                flock($fp, LOCK_UN);
                fclose($fp);
            }

            // Filter to just times within our window
            $pertinent = [];
            $rate_limit_time_window = empty($SITE_INFO['rate_limit_time_window']) ? 10 : intval($SITE_INFO['rate_limit_time_window']);
            if (isset($RATE_LIMITING_DATA[$ip])) {
                foreach ($RATE_LIMITING_DATA[$ip] as $i => $old_time) {
                    if ($old_time >= $time - $rate_limit_time_window) {
                        $pertinent[] = $old_time;
                    }
                }
            }

            // Do we have to block?
            $rate_limit_hits_per_window = empty($SITE_INFO['rate_limit_hits_per_window']) ? 5 : intval($SITE_INFO['rate_limit_hits_per_window']);
            if (count($pertinent) >= $rate_limit_hits_per_window) {
                http_response_code(429);
                header('Content-Type: text/plain');
                exit('We only allow ' . strval($rate_limit_hits_per_window - 1) . ' page hits every ' . strval($rate_limit_time_window) . ' seconds. You\'re at ' . strval(count($pertinent)) . '.');
            }

            // Remove any old hits from other IPs
            foreach ($RATE_LIMITING_DATA as $_ip => $times) {
                if ($_ip != $ip) {
                    foreach ($times as $i => $old_time) {
                        if ($old_time < $time - $rate_limit_time_window) {
                            unset($RATE_LIMITING_DATA[$_ip][$i]);
                        }
                    }
                    if (empty($RATE_LIMITING_DATA[$_ip])) {
                        unset($RATE_LIMITING_DATA[$_ip]);
                    }
                }
            }

            // Write out new state
            $RATE_LIMITING_DATA[$ip] = $pertinent;
            $RATE_LIMITING_DATA[$ip][] = $time;
            file_put_contents($rate_limiter_path, '<' . '?php' . "\n\n" . '$RATE_LIMITING_DATA=' . var_export($RATE_LIMITING_DATA, true) . ';' . "\n", LOCK_EX);
            //sync_file($rate_limiter_path); Not done. Each server should rate limit separately. Synching this data across servers would be too slow and not scalable

            // Save some memory
            unset($RATE_LIMITING_DATA);
        }
    }
}

get_custom_file_base(); // Make sure $CURRENT_SHARE_USER is set if it is a shared site, so we can use CURRENT_SHARE_USER as an indicator of it being one.

// Pass on to next bootstrap level
if (GOOGLE_APPENGINE) {
    require_code('google_appengine');
}
require_code('global2');
