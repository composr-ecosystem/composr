<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    actionlog
 */

/*
RevisionsEngineDatabase is normally used, but for some very special actions RevisionEngineFiles will be used instead.
This only works for some pre-specified actions that are hard-coded into this class: EDIT_TEMPLATE, etc.

RevisionsEngineDatabase and RevisionEngineFiles are not API-compatible but are designed to work similarly.
*/

/**
 * Revisions via very simple file management.
 *
 * @package actionlog
 */
class RevisionEngineFiles
{
    /**
     * Find whether revisions are enabled for the current user.
     *
     * @param  boolean $check_privilege Whether to check privileges
     * @return boolean Whether revisions are enabled
     */
    public function enabled(bool $check_privilege) : bool
    {
        if (get_option('store_revisions') == '0') {
            return false;
        }

        if ($check_privilege) {
            if (!has_privilege(get_member(), 'view_revisions')) {
                return false;
            }
        }

        return true;
    }

    /**
     * Add a revision.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what is being revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @param  ?string $original_text Text before revision (null: work out from disk)
     * @param  ?TIME $original_timestamp The creation timestamp for what was just replaced (null: work out from disk)
     */
    public function add_revision(string $directory, string $filename_id, string $ext, ?string $original_text, ?int $original_timestamp)
    {
        if (!$this->enabled(false)) {
            return;
        }

        if (($original_text === null) || ($original_timestamp === null)) {
            $existing_path = get_custom_file_base() . '/' . filter_naughty($directory . '/' . $filename_id . '.' . $ext);
            $existing_path = zone_black_magic_filterer($existing_path);
            if (!is_file($existing_path)) {
                $existing_path = get_file_base() . '/' . filter_naughty($directory . '/' . $filename_id . '.' . $ext);
                $existing_path = zone_black_magic_filterer($existing_path);
            }
            if (!is_file($existing_path)) {
                return;
            }

            if ($original_text === null) {
                $original_text = cms_file_get_contents_safe($existing_path, FILE_READ_LOCK | FILE_READ_BOM);
            }

            if ($original_timestamp === null) {
                $original_timestamp = filemtime($existing_path);
            }
        }

        $stub = get_custom_file_base() . '/';

        if (substr($directory, 0, strlen($stub)) == $stub) {
            $directory = substr($directory, strlen($stub));
        }

        $revision_path = $stub . filter_naughty($directory . '/' . $filename_id . '.' . $ext . '.' . strval($original_timestamp));
        $revision_path = zone_black_magic_filterer($revision_path);

        @unlink($revision_path);
        require_code('files');
        cms_file_put_contents_safe($revision_path, $original_text, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE | FILE_WRITE_BOM);
    }

    /**
     * Delete a particular revision.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what is being revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @param  TIME $id Revision ID
     */
    public function delete_revision(string $directory, string $filename_id, string $ext, int $id)
    {
        $revisions = $this->find_revisions($directory, $filename_id, $ext, null, $id);
        if (!isset($revisions[0])) {
            warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
        }

        $revision_path = get_custom_file_base() . '/' . $directory . '/' . $filename_id . '.' . $ext . '.' . strval($revisions[0]['r_time']);
        if (!is_file($revision_path)) {
            warn_exit(do_lang_tempcode('MISSING_RESOURCE'));
        }
        unlink($revision_path);
        sync_file($revision_path);
    }

    /**
     * Retrieve revisions of something.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what was revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @param  ?string $action The action the revision is for, a language string (null: no filter)
     * @param  ?TIME $revision_time The creation timestamp for a particular revision to retrieve (null: no filter)
     * @param  ?integer $max Maximum to return (null: no limit)
     * @param  integer $start Start offset
     * @param  boolean $limited_data Whether to only collect IDs and other simple low-bandwidth data
     * @return array List of revision maps
     */
    public function find_revisions(string $directory, string $filename_id, string $ext, ?string $action = null, ?int $revision_time = null, ?int $max = 100, int $start = 0, bool $limited_data = false) : array
    {
        if (!$this->enabled(true)) {
            return [];
        }

        $base = get_custom_file_base() . '/' . $directory;

        $times = [];
        $quick_match = @glob(get_custom_file_base() . '/' . $directory . '/' . $filename_id . '.' . $ext . '.*', GLOB_NOSORT);
        if ($quick_match === false) {
            $quick_match = [];
        }
        foreach ($quick_match as $f) {
            $_ext = get_file_extension($f);
            if (is_numeric($_ext)) {
                $time = intval($_ext);
                if (($revision_time !== null) && ($revision_time != $time)) {
                    continue;
                }

                $times[] = $time;
            }
        }

        rsort($times); // Sort into reverse time order
        array_splice($times, 0, $start, []); // Remove before start
        if ($max !== null) {
            array_splice($times, $max, count($times), []); // Remove after max
        }

        $ret = [];
        foreach ($times as $time) {
            $full_path = $base . '/' . $filename_id . '.' . $ext . '.' . strval($time);

            if ($limited_data) {
                $ret[$time] = [
                    'id' => $time,
                    'r_time' => $time,
                ];

                continue;
            }

            $original_text = cms_file_get_contents_safe($full_path, FILE_READ_LOCK | FILE_READ_BOM);

            $ret[$time] = [
                'id' => $time,
                'r_original_text' => $original_text,
                'r_time' => $time,

                'revision_type' => serialize([$directory, $filename_id, $ext]),

                'r_actionlog_id' => null,

                'log_action' => $action,
                'log_param_a' => null,
                'log_param_b' => null,
                'log_member_id' => null,
                'log_ip' => null,
                //'log_time' => null, Same as id
                'log_reason' => '',
            ];

            if ($action !== null) {
                $test = $GLOBALS['SITE_DB']->query_select('actionlogs', ['*'], ['date_and_time' => $time, 'the_type' => $action], '', 1);
                if (array_key_exists(0, $test)) {
                    $ret[$time] = [
                        'r_actionlog_id' => $test[0]['id'],

                        'log_action' => $test[0]['the_type'],
                        'log_param_a' => $test[0]['param_a'],
                        'log_param_b' => $test[0]['param_b'],
                        'log_member_id' => $test[0]['member_id'],
                        'log_ip' => $test[0]['ip'],
                        //'log_time' => $test[0]['date_and_time'], Same as id
                        'log_reason' => '',
                    ] + $ret[$time];
                }
            }
        }

        return array_values($ret);
    }

    /**
     * Find if there are revisions of something.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what was revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @return boolean Whether there are revisions
     */
    public function has_revisions(string $directory, string $filename_id, string $ext) : bool
    {
        if (!$this->enabled(true)) {
            return false;
        }

        $revisions = $this->find_revisions($directory, $filename_id, $ext, null, null, 1, 0, true);
        return !empty($revisions);
    }

    /**
     * Find number of revisions of something.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what was revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @return integer Number of revisions
     */
    public function total_revisions(string $directory, string $filename_id, string $ext) : int
    {
        if (!$this->enabled(true)) {
            return 0;
        }

        $revisions = $this->find_revisions($directory, $filename_id, $ext, null, null, null, 0, true);
        return count($revisions);
    }

    /**
     * Retrieve revisions for a particular action log entry.
     *
     * @param  AUTO_LINK $actionlog_id The action log entry's ID
     * @return ?array A revision map (null: not found)
     */
    public function find_revision_for_log(int $actionlog_id) : ?array
    {
        if (!$this->enabled(true)) {
            return null;
        }

        $rows = $GLOBALS['SITE_DB']->query_select('actionlogs', ['date_and_time', 'the_type', 'param_a', 'param_b'], ['id' => $actionlog_id], '', 1);
        if (!array_key_exists(0, $rows)) {
            return null;
        }

        $row = $rows[0];

        $revision_time = $row['date_and_time'];

        switch ($row['the_type']) {
            case 'COMCODE_PAGE_EDIT':
                $directory = $row['param_b'] . (($row['param_b'] == '') ? '' : '/') . 'pages/comcode_custom/' . get_site_default_lang();
                $filename_id = $row['param_a'];
                $ext = 'txt';
                break;

            case 'EDIT_TEMPLATE':
                $directory = 'themes/' . $row['param_b'] . '/' . dirname($row['param_a']);
                $ext = get_file_extension($row['param_a']);
                $filename_id = basename($row['param_a'], '.' . $ext);
                break;

            default:
                return null;
        }

        $logs = $this->find_revisions($directory, $filename_id, $ext, null, $revision_time);
        if (!array_key_exists(0, $logs)) {
            return null;
        }

        $logs[0]['r_actionlog_id'] = $actionlog_id;

        return $logs[0];
    }

    /**
     * Browse revisions to undo one.
     * More details are shown in the actionlog, which is linked from here.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what was revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @param  string $action The action the revision is for, a language string
     * @param  string $text Current resource text (may be altered by reference)
     * @param  ?boolean $revision_loaded Whether a revision was loaded, passed by reference (null: initial value)
     * @return Tempcode UI
     */
    public function ui_revisions_controller(string $directory, string $filename_id, string $ext, string $action, string &$text, ?bool &$revision_loaded = null) : object
    {
        $revision_loaded = false;

        if (!$this->enabled(true)) {
            return new Tempcode();
        }

        if (get_param_integer('diffing', 0) == 1) {
            $diff_more_recent_revision = get_param_integer('more_recent_revision', null);
            $diff_revision = get_param_integer('revision');
            return $this->render_diff_between($directory, $filename_id, $ext, $diff_more_recent_revision, $diff_revision);
        }

        require_lang('actionlog');

        // Revisions...

        $undo_revision = get_param_integer('undo_revision', null);
        $restore_from_path = get_param_string('restore_from_path', null, INPUT_FILTER_GET_COMPLEX);

        require_code('files');
        require_code('diff');
        require_code('templates_results_table');

        $start = get_param_integer('revisions_start', 0);
        $max = get_param_integer('revisions_max', 5);

        $sortables = ['r_time' => do_lang_tempcode('DATE')];
        $test = explode(' ', get_param_string('revisions_sort', 'r_time DESC', INPUT_FILTER_GET_COMPLEX), 2);
        if (count($test) == 1) {
            $test[1] = 'DESC';
        }
        list($sortable, $sort_order) = $test;
        if (((cms_strtoupper_ascii($sort_order) != 'ASC') && (cms_strtoupper_ascii($sort_order) != 'DESC')) || (!array_key_exists($sortable, $sortables))) {
            log_hack_attack_and_exit('ORDERBY_HACK');
        }

        $max_rows = $this->total_revisions($directory, $filename_id, $ext);

        $revisions = $this->find_revisions($directory, $filename_id, $ext, $action, null, $max, $start);

        $do_actionlog = has_actual_page_access(get_member(), 'admin_actionlog');

        $_header_row = [
            do_lang_tempcode('DATE_TIME'),
            do_lang_tempcode('MEMBER'),
            do_lang_tempcode('SIZE_CHANGE'),
            do_lang_tempcode('CHANGE_MICRO'),
            do_lang_tempcode('UNDO'),
        ];
        if ($do_actionlog) {
            $_header_row[] = do_lang_tempcode('LOG');
        }

        $more_recent_revision = null;
        $more_recent_text = $text;
        $field_rows = new Tempcode();
        foreach ($revisions as $revision) {
            $date = get_timezoned_date_time($revision['id']);

            $size_change = strlen($more_recent_text) - strlen($revision['r_original_text']);

            if ($revision['log_member_id'] === null) {
                $member_link = do_lang_tempcode('UNKNOWN_EM');
            } else {
                $member_link = $GLOBALS['FORUM_DRIVER']->member_profile_hyperlink($revision['log_member_id']);
            }

            if (function_exists('diff_simple_text')) {
                $rendered_diff_immediately_after = diff_simple_text($revision['r_original_text'], $more_recent_text, false, false);
                $rendered_diff_everything_after = diff_simple_text($revision['r_original_text'], $text, false, false);

                if (get_page_name() == 'admin_themes') {
                    // FUDGE
                    $diff_immediately_after_url = build_url(['page' => 'admin_themes', 'type' => 'diff', 'directory' => $directory, 'filename' => $filename_id, 'ext' => $ext, 'more_recent_revision' => $more_recent_revision, 'revision' => $revision['id']], get_module_zone('admin_themes'));
                    $diff_everything_after_url = build_url(['page' => 'admin_themes', 'type' => 'diff', 'directory' => $directory, 'filename' => $filename_id, 'ext' => $ext, 'revision' => $revision['id']]);
                } else {
                    $diff_immediately_after_url = get_self_url(false, false, ['diffing' => 1, 'more_recent_revision' => $more_recent_revision, 'revision' => $revision['id']]);
                    $diff_everything_after_url = get_self_url(false, false, ['diffing' => 1, 'revision' => $revision['id']]);
                }

                $diff_icon = do_template('REVISIONS_DIFF_ICON', [
                    '_GUID' => '9ea39609ba90f5f756b53df5269d036d',
                    'MORE_RECENT_REVISION' => ($more_recent_revision === null) ? '' : strval($more_recent_revision),
                    'REVISION' => strval($revision['id']),
                    'RENDERED_DIFF_IMMEDIATELY_AFTER' => $rendered_diff_immediately_after,
                    'RENDERED_DIFF_EVERYTHING_AFTER' => $rendered_diff_everything_after,
                    'DIFF_IMMEDIATELY_AFTER_URL' => $diff_immediately_after_url,
                    'DIFF_EVERYTHING_AFTER_URL' => $diff_everything_after_url,
                ]);
            } else {
                $diff_icon = new Tempcode();
            }

            if (get_page_name() == 'admin_themes') {
                // FUDGE
                $undo_link = do_template('THEME_TEMPLATE_EDITOR_RESTORE_REVISION', ['_GUID' => '5a1466ae2d0df6804132ac63381a5f64', 'DATE' => $date, 'FILE' => get_param_string('file'), 'REVISION_ID' => strval($revision['id'])]);
            } else {
                $undo_url = get_self_url(false, false, ['undo_revision' => $revision['id']]);
                $undo_link = hyperlink($undo_url, do_lang_tempcode('UNDO'), false, false, $date);
            }

            if ($revision['r_actionlog_id'] === null) {
                $actionlog_link = do_lang_tempcode('UNKNOWN_EM');
            } else {
                $actionlog_url = build_url(['page' => 'admin_actionlog', 'type' => 'view', 'id' => $revision['r_actionlog_id'], 'mode' => 'cms'], get_module_zone('admin_actionlog'));
                $actionlog_link = hyperlink($actionlog_url, do_lang_tempcode('LOG'), false, false, '#' . strval($revision['r_actionlog_id']));
            }

            $_revision = [
                escape_html($date),
                $member_link,
                escape_html(clean_file_size($size_change)),
                $diff_icon,
                $undo_link,
            ];
            if ($do_actionlog) {
                $_revision[] = $actionlog_link;
            }
            $field_rows->attach(results_entry($_revision, false));

            // For next iteration
            $more_recent_revision = $revision['id'];
            $more_recent_text = $revision['r_original_text'];
        }

        if ($field_rows->is_empty()) {
            return new Tempcode();
        }

        $header_row = results_header_row($_header_row, $sortables, 'revisions_sort', $sortable . ' ' . $sort_order);
        $results = results_table(
            do_lang_tempcode('REVISIONS'),
            $start,
            'revisions_start',
            $max,
            'revisions_max',
            $max_rows,
            $header_row,
            $field_rows,
            $sortables,
            $sortable,
            $sort_order,
            'revisions_sort',
            null,
            [],
            null,
            null,
            '13243t34tj349tmdfg4d',
            false,
            'revisions'
        );

        $revisions_tpl = do_template('REVISIONS_WRAP', [
            '_GUID' => '2fc38d9d7ec57af110759352446e533d',
            'RESULTS' => $results,
        ]);

        if ($restore_from_path !== null) {
            $has_access = (dirname(filter_naughty($restore_from_path)) == $directory) || ((has_actual_page_access(get_member(), 'cms_comcode_pages')) && (strpos($restore_from_path, 'pages/comcode') !== false));
            $full_path = get_custom_file_base() . '/' . filter_naughty($restore_from_path);
            $exists = file_exists($full_path);
            if ($has_access && $exists) {
                $text = cms_file_get_contents_safe($full_path, FILE_READ_LOCK | FILE_READ_BOM);
                $revision_loaded = true;

                if (substr($full_path, -4) == '.txt') {
                    $revisions_tpl = new Tempcode(); // Cloning a page, not undoing a revision
                } else {
                    $revisions_tpl->attach(do_template('REVISION_UNDO'));
                }
            } else {
                // Should not happen
            }
        }

        if ($undo_revision !== null) {
            $revisions = $this->find_revisions($directory, $filename_id, $ext, $action, $undo_revision);
            if (array_key_exists(0, $revisions)) {
                $text = $revisions[0]['r_original_text'];
                $revision_loaded = true;

                $revisions_tpl->attach(do_template('REVISION_UNDO'));
            } else {
                // Should not happen
            }
        }

        return $revisions_tpl;
    }

    /**
     * Show a full-screen diff.
     *
     * @param  PATH $directory Directory where revisions are stored
     * @param  string $filename_id ID of what was revised (=base filename, no extension)
     * @param  string $ext File extension for revisable files
     * @param  ?integer $more_recent_revision Revision to diff to (null: current version)
     * @param  integer $revision Revision to diff from
     * @return Tempcode UI
     */
    public function render_diff_between(string $directory, string $filename_id, string $ext, ?int $more_recent_revision, int $revision) : object
    {
        $without_whitespace = (post_param_integer('without_whitespace', 0) == 1);
        $without_html_tags = (post_param_integer('without_html_tags', 0) == 1);
        $unified_diff = (post_param_integer('unified_diff', 0) == 1);

        require_lang('actionlog');

        $path_recent = get_custom_file_base() . '/' . $directory . '/' . $filename_id . '.' . $ext;
        if (!is_file($path_recent)) {
            $path_recent = get_file_base() . '/' . str_replace('_custom', '', $directory) . '/' . $filename_id . '.' . $ext;
        }
        if ($more_recent_revision !== null) {
            $path_recent .= '.' . strval($more_recent_revision);
        }
        $path_older = get_custom_file_base() . '/' . $directory . '/' . $filename_id . '.' . $ext . '.' . strval($revision);

        $text_recent = cms_file_get_contents_safe($path_recent);
        $text_older = cms_file_get_contents_safe($path_older);

        if ($without_whitespace) {
            $text_recent = preg_replace('#(^|\n)[ \t]+#', '$1', preg_replace('#[\t ]+#', ' ', $text_recent));
            $text_older = preg_replace('#(^|\n)[ \t]+#', '$1', preg_replace('#[\t ]+#', ' ', $text_older));
        }
        if ($without_html_tags) {
            $text_recent = strip_html(str_replace('&nbsp;', ' ', $text_recent));
            $text_older = strip_html(str_replace('&nbsp;', ' ', $text_older));
        }

        $date_recent = get_timezoned_date(($more_recent_revision === null) ? time() : $more_recent_revision, false);
        $date_older = get_timezoned_date($revision, false);

        $title = get_screen_title('DIFF_BETWEEN', true, [$filename_id, $date_older, $date_recent]);

        require_code('diff');
        $rendered_diff = diff_simple_text($text_older, $text_recent, $unified_diff, true);

        return do_template('DIFF_SCREEN', [
            '_GUID' => 'b9a081d9a785d874d89c2766b7de5c68',
            'TITLE' => $title,
            'DIFF' => $rendered_diff,
            'WITHOUT_WHITESPACE' => $without_whitespace,
            'WITHOUT_HTML_TAGS' => $without_html_tags,
            'UNIFIED_DIFF' => $unified_diff,
        ]);
    }
}
