<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: openssl_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Determine whether the necessary PHP extensions to support encryption are available. For normal use, you should probably use is_encryption_enabled() instead.
 *
 * @return boolean Encryption available?
 */
function is_encryption_available() : bool
{
    return function_exists('openssl_pkey_get_public');
}

/**
 * Determine whether encryption support is available and enabled in the site's preferences, and the keys are in place.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key = str_replace('{file_base}', get_file_base(), get_option('encryption_key'));
        $private_key = str_replace('{file_base}', get_file_base(), get_option('decryption_key'));
        $enabled = ((function_exists('openssl_pkey_get_public')) && ($public_key != '') && ($private_key != '') && (file_exists($public_key)) && (file_exists($private_key)));
    }
    return $enabled;
}

/**
 * Encrypt some data using asymmetric encryption and the site's public key. This will return the original data if encryption is disabled. It will add a magic marker to the start of the returned string to show it's been encrypted.
 * A fatal error will occur if the public key cannot be found, or if encryption fails for whatever reason.
 * Note that this will blindly re-encrypt data which has already been encrypted. You should check data with is_data_encrypted() first.
 *
 * @param  string $data Data to be encrypted
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Encrypted data, with magic marker
 */
function encrypt_data(string $data, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if (!is_encryption_enabled()) {
        return $data;
    }
    if ($data == '') {
        return $data;
    }
    if (is_data_encrypted($data)) {
        return $data;
    }

    if (!function_exists('openssl_pkey_get_public')) {
        return $data;
    }
    if (!function_exists('openssl_public_encrypt')) {
        return $data;
    }

    // See http://php.net/manual/en/function.openssl-pkey-get-public.php
    $key = openssl_pkey_get_public('file://' . str_replace('{file_base}', get_file_base(), get_option('encryption_key')));
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $maxlength = 117;
    $output = '';
    while (strlen($data) > 0) {
        $input = substr($data, 0, $maxlength);
        $data = (strlen($input) <= $maxlength) ? '' : substr($data, $maxlength);
        $encrypted = '';
        if (!openssl_public_encrypt($input, $encrypted, $key)) {
            if ($error_msg === null) {
                attach_message(do_lang_tempcode('ENCRYPTION_ERROR'), 'warn');
            } else {
                $error_msg = do_lang('ENCRYPTION_ERROR');
            }
            return '';
        }

        $output .= $encrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return '(Encrypted!)' . base64_encode($output);
}

/**
 * Determine if some data has already been encrypted: i.e. if it has a magic encryption marker.
 *
 * @param  mixed $data Data to check
 * @return boolean Encrypted?
 */
function is_data_encrypted($data) : bool
{
    if (!is_string($data)) {
        return false;
    }
    return (substr($data, 0, 12) == '(Encrypted!)');
}

/**
 * Remove the magic encryption marker from some data. This should be used if the data is to be displayed or presented for editing, but not if it's to be put in the database.
 * If the data does not have a magic encryption marker, the original string will be returned.
 *
 * @param  string $data Data
 * @return string Data, without the magic marker
 */
function remove_magic_encryption_marker(string $data) : string
{
    if (!is_data_encrypted($data)) {
        return $data;
    }
    return substr($data, 12);
}

/**
 * Decrypt data using asymmetric encryption, and the site's private key (as unlocked by the given passphrase).
 * A fatal error will occur if the passphrase is empty, the key cannot be found, or if decryption fails for whatever reason.
 *
 * @param  string $data Data to be decrypted
 * @param  string $passphrase Passphrase to unlock the site's private key
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Decrypted data
 */
function decrypt_data(string $data, string $passphrase, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if ($data == '') {
        return '';
    }

    if (!function_exists('openssl_pkey_get_private')) {
        return '';
    }
    if (!function_exists('openssl_private_decrypt')) {
        return '';
    }

    // Check the passphrase isn't empty (if it is legitimately empty, we're doing the site a favour by bailing out)
    if ($passphrase == '') {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    // Remove the magic encryption marker and base64-decode it first
    $data = base64_decode(remove_magic_encryption_marker(str_replace('<br />', '', $data)));

    $key = openssl_pkey_get_private(['file://' . str_replace('{file_base}', get_file_base(), get_option('decryption_key')), $passphrase]);
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $decrypted = '';
    if (!openssl_private_decrypt($data, $decrypted, $key)) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('DECRYPTION_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('DECRYPTION_ERROR');
        }
        return $decrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return $decrypted;
}

/**
 * Get the contents of the software's public key file.
 *
 * @param  ?float $version The version of the software of which to return the public key (null: return the key bundled with this version)
 * @return ~string File contents (false: error)
 */
function cms_get_public_key(float $version = null)
{
    if ($version === null) {
        return cms_file_get_contents_safe(get_file_base() . '/data/keys/key.pub', FILE_READ_LOCK);
    }
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/build-' . strval($version) . '.pub', FILE_READ_LOCK);
}

/**
 * Get the contents of the software's private key file.
 *
 * @param  float $version The version of the software of which to return the private key
 * @return ~string File contents (false: error)
 */
function cms_get_private_key(float $version)
{
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/build-' . strval($version) . '.key', FILE_READ_LOCK);
}

/**
 * Encrypt some data using symmetric encryption and the software's public key.
 * This is different from encrypt_data such that it uses the software's bundled public key instead of the site's key and is symmetric.
 *
 * @param  string $data The data to encrypt
 * @return array Map of parameters for the JSON payload
 */
function encrypt_data_symmetric(string $data) : array
{
    // Get and decode the public key
    $_public_key = cms_get_public_key();
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PUBLIC_KEY'));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PUBLIC_KEY'));
    }

    // Encrypt the message
    $session_key = random_bytes(SODIUM_CRYPTO_SECRETBOX_KEYBYTES);
    $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES);
    $encrypted_data = sodium_crypto_secretbox($data, $nonce, $session_key);

    // Encrypt the session key
    $encrypted_session_key = sodium_crypto_box_seal($session_key, $public_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($encrypted_data);
    $encrypted_session_key_base64 = base64_encode($encrypted_session_key);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'encrypted_session_key' => $encrypted_session_key_base64
    ];
}

/**
 * Decrypt some data using symmetric decryption and the software's private keys.
 * This is different from decrypt_data such that it uses the software's private keys instead of the site's key and is symmetric. You must have the version's private key in data_custom/keys.
 *
 * @param  string $nonce_base64 The base64-encoded nonce
 * @param  string $encrypted_data_base64 The base64-encoded encrypted data
 * @param  string $encrypted_session_key_base64 The base64-encoded encrypted session key
 * @param  float $version The version of the software which encrypted the data
 * @return string The decrypted data
 */
function decrypt_data_symmetric(string $nonce_base64, string $encrypted_data_base64, string $encrypted_session_key_base64, float $version) : string
{
    // Get and decode the private key
    $_private_key = cms_get_private_key($version);
    if ($_private_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    $private_key = base64_decode($_private_key);
    if ($private_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    // Get and decode the public key
    $_public_key = cms_get_public_key($version);
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('_MISSING_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('_CORRUPT_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }

    // Make a key pair from our keys
    $key_pair = sodium_crypto_box_keypair_from_secretkey_and_publickey($private_key, $public_key);

    // Decode base64-encoded data
    $encrypted_data = base64_decode($encrypted_data_base64);
    $encrypted_session_key = base64_decode($encrypted_session_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_data === false) || ($encrypted_session_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_SYMMETRIC_DATA'));
    }

    // Decrypt the session key using the recipient's private key
    $session_key = sodium_crypto_box_seal_open($encrypted_session_key, $key_pair);
    if ($session_key === false) {
        warn_exit(do_lang_tempcode('INVALID_SYMMETRIC_DATA'));
    }

    // Decrypt the data using the session key and nonce
    $data = sodium_crypto_secretbox_open($encrypted_data, $nonce, $session_key);
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_SYMMETRIC_DATA'));
    }

    return $data;
}
