<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: openssl_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Determine whether the necessary PHP extensions to support encryption are available. For normal use, you should probably use is_encryption_enabled() instead.
 *
 * @return boolean Encryption available?
 */
function is_encryption_available() : bool
{
    return function_exists('openssl_pkey_get_public');
}

/**
 * Determine whether encryption support is available and enabled in the site's preferences, and the keys are in place.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key = str_replace('{file_base}', get_file_base(), get_option('encryption_key'));
        $private_key = str_replace('{file_base}', get_file_base(), get_option('decryption_key'));
        $enabled = ((function_exists('openssl_pkey_get_public')) && ($public_key != '') && ($private_key != '') && (file_exists($public_key)) && (file_exists($private_key)));
    }
    return $enabled;
}

/**
 * Determine whether encryption support is available for telemetry, and the key is in place.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled_telemetry() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key_exists = file_exists(get_file_base() . '/data/keys/telemetry.pub');
        $available = function_exists('sodium_crypto_box_seal');
        $enabled = (($public_key_exists) && ($available));
    }
    return $enabled;
}

/**
 * Encrypt some data using asymmetric encryption and the site's public key. This will return the original data if encryption is disabled. It will add a magic marker to the start of the returned string to show it's been encrypted.
 * A fatal error will occur if the public key cannot be found, or if encryption fails for whatever reason.
 * Note that this will blindly re-encrypt data which has already been encrypted. You should check data with is_data_encrypted() first.
 *
 * @param  string $data Data to be encrypted
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Encrypted data, with magic marker
 */
function encrypt_data(string $data, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if (!is_encryption_enabled()) {
        return $data;
    }
    if ($data == '') {
        return $data;
    }
    if (is_data_encrypted($data)) {
        return $data;
    }

    if (!function_exists('openssl_pkey_get_public')) {
        return $data;
    }
    if (!function_exists('openssl_public_encrypt')) {
        return $data;
    }

    // See http://php.net/manual/en/function.openssl-pkey-get-public.php
    $key = openssl_pkey_get_public('file://' . str_replace('{file_base}', get_file_base(), get_option('encryption_key')));
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $maxlength = 117;
    $output = '';
    while (strlen($data) > 0) {
        $input = substr($data, 0, $maxlength);
        $data = (strlen($input) <= $maxlength) ? '' : substr($data, $maxlength);
        $encrypted = '';
        if (!openssl_public_encrypt($input, $encrypted, $key)) {
            if ($error_msg === null) {
                attach_message(do_lang_tempcode('ENCRYPTION_ERROR'), 'warn');
            } else {
                $error_msg = do_lang('ENCRYPTION_ERROR');
            }
            return '';
        }

        $output .= $encrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return '(Encrypted!)' . base64_encode($output);
}

/**
 * Determine if some data has already been encrypted: i.e. if it has a magic encryption marker.
 *
 * @param  mixed $data Data to check
 * @return boolean Encrypted?
 */
function is_data_encrypted($data) : bool
{
    if (!is_string($data)) {
        return false;
    }
    return (substr($data, 0, 12) == '(Encrypted!)');
}

/**
 * Remove the magic encryption marker from some data. This should be used if the data is to be displayed or presented for editing, but not if it's to be put in the database.
 * If the data does not have a magic encryption marker, the original string will be returned.
 *
 * @param  string $data Data
 * @return string Data, without the magic marker
 */
function remove_magic_encryption_marker(string $data) : string
{
    if (!is_data_encrypted($data)) {
        return $data;
    }
    return substr($data, 12);
}

/**
 * Decrypt data using asymmetric encryption, and the site's private key (as unlocked by the given passphrase).
 * A fatal error will occur if the passphrase is empty, the key cannot be found, or if decryption fails for whatever reason.
 *
 * @param  string $data Data to be decrypted
 * @param  string $passphrase Passphrase to unlock the site's private key
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Decrypted data
 */
function decrypt_data(string $data, string $passphrase, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if ($data == '') {
        return '';
    }

    if (!function_exists('openssl_pkey_get_private')) {
        return '';
    }
    if (!function_exists('openssl_private_decrypt')) {
        return '';
    }

    // Check the passphrase isn't empty (if it is legitimately empty, we're doing the site a favour by bailing out)
    if ($passphrase == '') {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    // Remove the magic encryption marker and base64-decode it first
    $data = base64_decode(remove_magic_encryption_marker(str_replace('<br />', '', $data)));

    $key = openssl_pkey_get_private(['file://' . str_replace('{file_base}', get_file_base(), get_option('decryption_key')), $passphrase]);
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $decrypted = '';
    if (!openssl_private_decrypt($data, $decrypted, $key)) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('DECRYPTION_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('DECRYPTION_ERROR');
        }
        return $decrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return $decrypted;
}

/**
 * Get the contents of the software's public key file for telemetry use.
 *
 * @param  ?float $version The version of the software of which to return the public key (null: return the key bundled with this version)
 * @return ~string File contents (false: error)
 */
function get_public_key_telemetry(?float $version = null)
{
    if ($version === null) {
        return cms_file_get_contents_safe(get_file_base() . '/data/keys/telemetry.pub', FILE_READ_LOCK);
    }
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true) . '.pub', FILE_READ_LOCK);
}

/**
 * Get the contents of the software's private key file.
 *
 * @param  float $version The version of the software of which to return the private key
 * @return ~string File contents (false: error)
 */
function get_private_key_telemetry(float $version)
{
    // NB: private keys should always exist in data_custom and never data
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true) . '.key', FILE_READ_LOCK);
}

/**
 * Encrypt some data for telemetry using symmetric encryption and the software's public key.
 *
 * @param  string $data The data to encrypt
 * @return array Map of parameters for the JSON payload
 */
function encrypt_data_telemetry(string $data) : array
{
    require_code('version');

    // Get and decode the public key
    $_public_key = get_public_key_telemetry();
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PUBLIC_KEY'));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PUBLIC_KEY'));
    }

    // Encrypt the message
    $session_key = random_bytes(SODIUM_CRYPTO_SECRETBOX_KEYBYTES);
    $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES);
    $encrypted_data = sodium_crypto_secretbox($data, $nonce, $session_key);

    // Encrypt the session key
    $encrypted_session_key = sodium_crypto_box_seal($session_key, $public_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($encrypted_data);
    $encrypted_session_key_base64 = base64_encode($encrypted_session_key);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'encrypted_session_key' => $encrypted_session_key_base64,
        'version' => cms_version_number(),
    ];
}

/**
 * Decrypt some data for telemetry using symmetric decryption and the software's private key.
 *
 * @param  string $nonce_base64 The base64-encoded nonce
 * @param  string $encrypted_data_base64 The base64-encoded encrypted data
 * @param  string $encrypted_session_key_base64 The base64-encoded encrypted session key
 * @param  float $version The version of the software which encrypted the data
 * @return string The decrypted data
 */
function decrypt_data_telemetry(string $nonce_base64, string $encrypted_data_base64, string $encrypted_session_key_base64, float $version) : string
{
    // Get and decode the private key
    $_private_key = get_private_key_telemetry($version);
    if ($_private_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    $private_key = base64_decode($_private_key);
    if ($private_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    // Get and decode the public key
    $_public_key = get_public_key_telemetry($version);
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('_MISSING_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('_CORRUPT_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }

    // Make a key pair from our keys
    $key_pair = sodium_crypto_box_keypair_from_secretkey_and_publickey($private_key, $public_key);

    // Decode base64-encoded data
    $encrypted_data = base64_decode($encrypted_data_base64);
    $encrypted_session_key = base64_decode($encrypted_session_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_data === false) || ($encrypted_session_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the session key using the recipient's private key
    $session_key = sodium_crypto_box_seal_open($encrypted_session_key, $key_pair);
    if ($session_key === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the data using the session key and nonce
    $data = sodium_crypto_secretbox_open($encrypted_data, $nonce, $session_key);
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    return $data;
}

/**
 * Generate a public and private key pair for this version of the software and save it into the data_custom/keys directory.
 * You should copy the public key to data/key.pub during the build process.
 *
 * @param  float $version The major.minor version for which we are generating a key pair
 * @param  boolean $overwrite_existing Whether to overwrite an existing key pair
 * @throws SodiumException
 */
function generate_telemetry_key_pair(float $version, bool $overwrite_existing = false)
{
    require_code('files2');

    $key_path = get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true);

    if (!$overwrite_existing) {
        // Key already exists, so nothing to do
        if (file_exists($key_path . '.key')) {
            return;
        }

        // Try calling homesite to retrieve this version's public key in case we accidentally deleted it
        require_code('global3');
        $homesite_call = cms_http_request(get_brand_base_url() . '/data/endpoint.php/cms_homesite/telemetry/' . float_to_raw_string($version, 2, true) . '?type=key', ['convert_to_internal_encoding' => true, 'timeout' => 10.0, 'trigger_error' => false]);
        if ($homesite_call->data !== null) {
            $data = @json_decode($homesite_call->data, true);
            if (($data !== false) && ($data['success'] === true)) {
                cms_file_put_contents_safe($key_path . '.pub', $data['response_data']['key'], FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
                return;
            }
        }
    }

    $key_pair = sodium_crypto_box_keypair();

    // Extract the public and private keys
    $public_key = sodium_crypto_box_publickey($key_pair);
    $private_key = sodium_crypto_box_secretkey($key_pair);

    // Convert keys to base64
    $public_key_base64 = base64_encode($public_key);
    $private_key_base64 = base64_encode($private_key);

    // Save our keys
    cms_file_put_contents_safe($key_path . '.pub', $public_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
    cms_file_put_contents_safe($key_path . '.key', $private_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
}

/**
 * Script to encrypt some data (with telemetry keys) and output the encrypted payload (from encrypt_data_telemetry) in JSON formatted base64.
 *
 */
function encrypt_data_script() {
    require_code('global2');

    prepare_backend_response('text/plain');

    cms_ini_set('ocproducts.xss_detect', '0');

    $data = post_param_string('data');

    $data = encrypt_data_telemetry($data);
    echo base64_encode(json_encode($data));
}
