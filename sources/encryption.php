<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/*EXTRA FUNCTIONS: openssl_.**/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Determine whether the necessary PHP extensions to support encryption are available. For normal use, you should probably use is_encryption_enabled() instead.
 *
 * @return boolean Encryption available?
 */
function is_encryption_available() : bool
{
    return function_exists('openssl_pkey_get_public');
}

/**
 * Determine whether encryption support is available and enabled in the site's preferences, and the keys are in place.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key = str_replace('{file_base}', get_file_base(), get_option('encryption_key'));
        $private_key = str_replace('{file_base}', get_file_base(), get_option('decryption_key'));
        $enabled = ((function_exists('openssl_pkey_get_public')) && ($public_key != '') && ($private_key != '') && (file_exists($public_key)) && (file_exists($private_key)));
    }
    return $enabled;
}

/**
 * Determine whether encryption support is available for telemetry.
 * This also checks if all keys are in place including the software key and the site keys.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_enabled_telemetry() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $available = is_encryption_available_telemetry();
        $site_public_key_exists = file_exists(get_file_base() . '/data_custom/keys/telemetry-site.pub');
        $site_private_key_exists = file_exists(get_file_base() . '/data_custom/keys/telemetry-site.key');
        $site_s_public_key_exists = file_exists(get_file_base() . '/data_custom/keys/telemetry-site-sign.pub');
        $site_s_private_key_exists = file_exists(get_file_base() . '/data_custom/keys/telemetry-site-sign.key');
        $enabled = (($available) && ($site_public_key_exists) && ($site_private_key_exists) && ($site_s_public_key_exists) && ($site_s_private_key_exists));
    }
    return $enabled;
}

/**
 * Determine whether encryption support is available for telemetry.
 * This does not check if the site keys are in place, but it will check if the software key is.
 *
 * @return boolean Encryption enabled?
 */
function is_encryption_available_telemetry() : bool
{
    static $enabled = null;
    if ($enabled === null) {
        $public_key_exists = file_exists(get_file_base() . '/data/keys/telemetry.pub');
        $available = function_exists('sodium_crypto_box_seal');
        $enabled = (($available) && ($public_key_exists));
    }
    return $enabled;
}

/**
 * Encrypt some data using asymmetric encryption and the site's public key. This will return the original data if encryption is disabled. It will add a magic marker to the start of the returned string to show it's been encrypted.
 * A fatal error will occur if the public key cannot be found, or if encryption fails for whatever reason.
 * Note that this will blindly re-encrypt data which has already been encrypted. You should check data with is_data_encrypted() first.
 *
 * @param  string $data Data to be encrypted
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Encrypted data, with magic marker
 */
function encrypt_data(string $data, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if (!is_encryption_enabled()) {
        return $data;
    }
    if ($data == '') {
        return $data;
    }
    if (is_data_encrypted($data)) {
        return $data;
    }

    if (!function_exists('openssl_pkey_get_public')) {
        return $data;
    }
    if (!function_exists('openssl_public_encrypt')) {
        return $data;
    }

    // See http://php.net/manual/en/function.openssl-pkey-get-public.php
    $key = openssl_pkey_get_public('file://' . str_replace('{file_base}', get_file_base(), get_option('encryption_key')));
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $maxlength = 117;
    $output = '';
    while (strlen($data) > 0) {
        $input = substr($data, 0, $maxlength);
        $data = (strlen($input) <= $maxlength) ? '' : substr($data, $maxlength);
        $encrypted = '';
        if (!openssl_public_encrypt($input, $encrypted, $key)) {
            if ($error_msg === null) {
                attach_message(do_lang_tempcode('ENCRYPTION_ERROR'), 'warn');
            } else {
                $error_msg = do_lang('ENCRYPTION_ERROR');
            }
            return '';
        }

        $output .= $encrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return '(Encrypted!)' . base64_encode($output);
}

/**
 * Determine if some data has already been encrypted: i.e. if it has a magic encryption marker.
 *
 * @param  mixed $data Data to check
 * @return boolean Encrypted?
 */
function is_data_encrypted($data) : bool
{
    if (!is_string($data)) {
        return false;
    }
    return (substr($data, 0, 12) == '(Encrypted!)');
}

/**
 * Remove the magic encryption marker from some data. This should be used if the data is to be displayed or presented for editing, but not if it's to be put in the database.
 * If the data does not have a magic encryption marker, the original string will be returned.
 *
 * @param  string $data Data
 * @return string Data, without the magic marker
 */
function remove_magic_encryption_marker(string $data) : string
{
    if (!is_data_encrypted($data)) {
        return $data;
    }
    return substr($data, 12);
}

/**
 * Decrypt data using asymmetric encryption, and the site's private key (as unlocked by the given passphrase).
 * A fatal error will occur if the passphrase is empty, the key cannot be found, or if decryption fails for whatever reason.
 *
 * @param  string $data Data to be decrypted
 * @param  string $passphrase Passphrase to unlock the site's private key
 * @param  ?string $error_msg Error message returned (null: do not return an error message) (blank: fill in error message if there is one)
 * @return string Decrypted data
 */
function decrypt_data(string $data, string $passphrase, ?string &$error_msg = null) : string
{
    require_lang('encryption');

    if ($data == '') {
        return '';
    }

    if (!function_exists('openssl_pkey_get_private')) {
        return '';
    }
    if (!function_exists('openssl_private_decrypt')) {
        return '';
    }

    // Check the passphrase isn't empty (if it is legitimately empty, we're doing the site a favour by bailing out)
    if ($passphrase == '') {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    // Remove the magic encryption marker and base64-decode it first
    $data = base64_decode(remove_magic_encryption_marker(str_replace('<br />', '', $data)));

    $key = openssl_pkey_get_private(['file://' . str_replace('{file_base}', get_file_base(), get_option('decryption_key')), $passphrase]);
    if ($key === false) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('ENCRYPTION_KEY_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('ENCRYPTION_KEY_ERROR');
        }
        return '';
    }

    $decrypted = '';
    if (!openssl_private_decrypt($data, $decrypted, $key)) {
        if ($error_msg === null) {
            attach_message(do_lang_tempcode('DECRYPTION_ERROR'), 'warn');
        } else {
            $error_msg = do_lang('DECRYPTION_ERROR');
        }
        return $decrypted;
    }

    if (function_exists('openssl_free_key')) {
        @openssl_free_key($key); // LEGACY (deprecated in PHP 8)
    }

    return $decrypted;
}

/**
 * Get the contents of the software's public key file for telemetry use.
 *
 * @param  ?float $version The version of the software of which to return the public key (null: return the key bundled with this version)
 * @return ~string File contents (false: error)
 */
function get_public_key_telemetry(?float $version = null)
{
    if ($version === null) {
        return cms_file_get_contents_safe(get_file_base() . '/data/keys/telemetry.pub', FILE_READ_LOCK);
    }
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true) . '.pub', FILE_READ_LOCK);
}

/**
 * Get the contents of the software's private key file.
 *
 * @param  float $version The version of the software of which to return the private key
 * @return ~string File contents (false: error)
 */
function get_private_key_telemetry(float $version)
{
    // NB: private keys should always exist in data_custom and never data
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true) . '.key', FILE_READ_LOCK);
}

/**
 * Get the contents of the site's public key file for telemetry use.
 *
 * @return ~string File contents (false: error)
 */
function get_public_key_site_telemetry()
{
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-site.pub', FILE_READ_LOCK);
}

/**
 * Get the contents of the site's private key file for telemetry use.
 *
 * @return ~string File contents (false: error)
 */
function get_private_key_site_telemetry()
{
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-site.key', FILE_READ_LOCK);
}

/**
 * Get the contents of the site's public signing key file for telemetry use.
 *
 * @return ~string File contents (false: error)
 */
function get_public_sign_key_site_telemetry()
{
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-site-sign.pub', FILE_READ_LOCK);
}

/**
 * Get the contents of the site's private signing key file for telemetry use.
 *
 * @return ~string File contents (false: error)
 */
function get_private_sign_key_site_telemetry()
{
    return cms_file_get_contents_safe(get_file_base() . '/data_custom/keys/telemetry-site-sign.key', FILE_READ_LOCK);
}

/**
 * Encrypt some data for telemetry using symmetric encryption and the software's public key.
 *
 * @param  string $data The data to encrypt
 * @return array Map of parameters for the JSON payload
 */
function encrypt_data_telemetry(string $data) : array
{
    require_code('version');

    // Get and decode the public key
    $_public_key = get_public_key_telemetry();
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PUBLIC_KEY'));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PUBLIC_KEY'));
    }

    // Encrypt the message
    $session_key = random_bytes(SODIUM_CRYPTO_SECRETBOX_KEYBYTES);
    $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES);
    $encrypted_data = sodium_crypto_secretbox($data, $nonce, $session_key);

    // Encrypt the session key
    $encrypted_session_key = sodium_crypto_box_seal($session_key, $public_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($encrypted_data);
    $encrypted_session_key_base64 = base64_encode($encrypted_session_key);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'encrypted_session_key' => $encrypted_session_key_base64,
        'version' => cms_version_number(),
    ];
}

/**
 * Decrypt some data for telemetry using symmetric decryption and the software's private key.
 *
 * @param  string $nonce_base64 The base64-encoded nonce
 * @param  string $encrypted_data_base64 The base64-encoded encrypted data
 * @param  string $encrypted_session_key_base64 The base64-encoded encrypted session key
 * @param  float $version The version of the software which encrypted the data
 * @return string The decrypted data
 */
function decrypt_data_telemetry(string $nonce_base64, string $encrypted_data_base64, string $encrypted_session_key_base64, float $version) : string
{
    // Get and decode the private key
    $_private_key = get_private_key_telemetry($version);
    if ($_private_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    $private_key = base64_decode($_private_key);
    if ($private_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    // Get and decode the public key
    $_public_key = get_public_key_telemetry($version);
    if ($_public_key === false) {
        warn_exit(do_lang_tempcode('_MISSING_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        warn_exit(do_lang_tempcode('_CORRUPT_PUBLIC_KEY', escape_html(float_to_raw_string($version))));
    }

    // Make a key pair from our keys
    $key_pair = sodium_crypto_box_keypair_from_secretkey_and_publickey($private_key, $public_key);

    // Decode base64-encoded data
    $encrypted_data = base64_decode($encrypted_data_base64);
    $encrypted_session_key = base64_decode($encrypted_session_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_data === false) || ($encrypted_session_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the session key using the recipient's private key
    $session_key = sodium_crypto_box_seal_open($encrypted_session_key, $key_pair);
    if ($session_key === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Decrypt the data using the session key and nonce
    $data = sodium_crypto_secretbox_open($encrypted_data, $nonce, $session_key);
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    return $data;
}

/**
 * Encrypt some data using the site and software keys for sending in telemetry.
 *
 * @param string $data The data to encrypt
 * @return ?array Map of parameters for the JSON payload
 */
function encrypt_data_site_telemetry(string $data) : ?array
{
    // Load the software public key
    $_s_public_key = get_public_key_telemetry();
    if ($_s_public_key === false) {
        return null;
    }
    $s_public_key = base64_decode($_s_public_key);
    if ($s_public_key === false) {
        return null;
    }

    // Get and decode the site private key
    $_private_key = get_private_key_site_telemetry();
    if ($_private_key === false) {
        return null;
    }
    $private_key = base64_decode($_private_key);
    if ($private_key === false) {
        return null;
    }

    // Get and decode the site public key
    $_public_key = get_public_key_site_telemetry();
    if ($_public_key === false) {
        return null;
    }
    $public_key = base64_decode($_public_key);
    if ($public_key === false) {
        return null;
    }

    $shared_key = sodium_crypto_box_keypair_from_secretkey_and_publickey(
        $private_key,
        $s_public_key
    );

    // Encrypt the message
    $nonce = random_bytes(SODIUM_CRYPTO_BOX_NONCEBYTES);
    $encrypted = sodium_crypto_box(
        $data,
        $nonce,
        $shared_key,
    );

    // Get and decode the site signing private key
    $_sign_private_key = get_private_sign_key_site_telemetry();
    if ($_sign_private_key === false) {
        return null;
    }
    $sign_private_key = base64_decode($_sign_private_key);
    if ($sign_private_key === false) {
        return null;
    }
    // Get and decode the site signing public key
    $_sign_public_key = get_public_sign_key_site_telemetry();
    if ($_sign_public_key === false) {
        return null;
    }
    $sign_public_key = base64_decode($_sign_public_key);
    if ($sign_public_key === false) {
        return null;
    }

    $signed_message = sodium_crypto_sign($encrypted, $sign_private_key);

    // Convert binary data to base64 for transmission
    $nonce_base64 = base64_encode($nonce);
    $encrypted_data_base64 = base64_encode($signed_message);

    return [
        'nonce' => $nonce_base64,
        'encrypted_data' => $encrypted_data_base64,
        'website_url' => get_base_url(),
        'version' => cms_version_number(),
    ];
}

/**
 * Decrypt data encrypted with encrypt_data_site_telemetry.
 *
 * @param string $nonce_base64 The base64-encoded nonce
 * @param string $encrypted_data_base64 The base64-encoded encrypted and signed data
 * @param string $public_key_base64 The base64-encoded sender's public key
 * @param string $sign_public_key_base64 The base64-encoded sender's signing public key
 * @param float $version The software version used
 * @return string The decrypted data
 */
function decrypt_data_site_telemetry(string $nonce_base64, string $encrypted_data_base64, string $public_key_base64, string $sign_public_key_base64, float $version) : string
{
    // Decode base64-encoded data
    $encrypted_signed_data = base64_decode($encrypted_data_base64);
    $public_key = base64_decode($public_key_base64);
    $sign_public_key = base64_decode($sign_public_key_base64);
    $nonce = base64_decode($nonce_base64);
    if (($encrypted_signed_data === false) || ($public_key === false) || ($sign_public_key === false) || ($nonce === false)) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Verify the signed message
    $encrypted_data = sodium_crypto_sign_open($encrypted_signed_data, $sign_public_key);
    if ($encrypted_data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    // Get and decode the private key
    $_s_private_key = get_private_key_telemetry($version);
    if ($_s_private_key === false) {
        warn_exit(do_lang_tempcode('MISSING_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    $s_private_key = base64_decode($_s_private_key);
    if ($s_private_key === false) {
        warn_exit(do_lang_tempcode('CORRUPT_PRIVATE_KEY', escape_html(float_to_raw_string($version))));
    }
    $shared_key = sodium_crypto_box_keypair_from_secretkey_and_publickey(
        $s_private_key,
        $public_key
    );

    // Decrypt the message
    $data = sodium_crypto_box_open(
        $encrypted_data,
        $nonce,
        $shared_key
    );
    if ($data === false) {
        warn_exit(do_lang_tempcode('INVALID_TELEMETRY_DATA'));
    }

    return $data;
}

/**
 * Generate a public and private key pair for this version of the software and save it into the data_custom/keys directory.
 * You should copy the public key to data/key.pub during the build process.
 *
 * @param  float $version The major.minor version for which we are generating a key pair
 * @param  boolean $overwrite_existing Whether to overwrite an existing key pair
 * @throws SodiumException
 */
function generate_telemetry_key_pair(float $version, bool $overwrite_existing = false)
{
    require_code('files2');

    $key_path = get_file_base() . '/data_custom/keys/telemetry-' . float_to_raw_string($version, 2, true);

    if (!$overwrite_existing) {
        // Key already exists, so nothing to do
        if (file_exists($key_path . '.key')) {
            return;
        }

        // Try calling homesite to retrieve this version's public key in case we accidentally deleted it
        require_code('global3');
        $homesite_call = cms_http_request(get_brand_base_url() . '/data/endpoint.php/cms_homesite/telemetry/' . float_to_raw_string($version, 2, true) . '?type=key', ['convert_to_internal_encoding' => true, 'timeout' => 10.0, 'trigger_error' => false]);
        if ($homesite_call->data !== null) {
            $data = @json_decode($homesite_call->data, true);
            if (($data !== false) && ($data['success'] === true)) {
                cms_file_put_contents_safe($key_path . '.pub', $data['response_data']['key'], FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
                return;
            }
        }
    }

    $key_pair = sodium_crypto_box_keypair();

    // Extract the public and private keys
    $public_key = sodium_crypto_box_publickey($key_pair);
    $private_key = sodium_crypto_box_secretkey($key_pair);

    // Convert keys to base64
    $public_key_base64 = base64_encode($public_key);
    $private_key_base64 = base64_encode($private_key);

    // Save our keys
    cms_file_put_contents_safe($key_path . '.pub', $public_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
    cms_file_put_contents_safe($key_path . '.key', $private_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
}

/**
 * Generate a site key-pair for use in signing messages to the homesite telemetry service.
 * This function will always overwrite existing public and private keys, so use with care!
 *
 * @return array Public key, private key, signing public key, signing private key
 * @throws SodiumException
 */
function generate_site_telemetry_key_pair() : array
{
    require_code('files2');

    /* Encryption keys */

    $key_path = get_file_base() . '/data_custom/keys/telemetry-site';

    $key_pair = sodium_crypto_box_keypair();

    // Extract the public and private keys
    $private_key = sodium_crypto_box_secretkey($key_pair);
    $public_key = sodium_crypto_box_publickey($key_pair);

    // Convert keys to base64
    $public_key_base64 = base64_encode($public_key);
    $private_key_base64 = base64_encode($private_key);

    // Save our keys
    cms_file_put_contents_safe($key_path . '.pub', $public_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
    cms_file_put_contents_safe($key_path . '.key', $private_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);

    /* Signing keys */

    $s_key_path = get_file_base() . '/data_custom/keys/telemetry-site-sign';

    $s_key_pair = sodium_crypto_sign_keypair();

    // Extract the public and private keys
    $s_private_key = sodium_crypto_sign_secretkey($s_key_pair);
    $s_public_key = sodium_crypto_sign_publickey($s_key_pair);

    // Convert keys to base64
    $s_public_key_base64 = base64_encode($s_public_key);
    $s_private_key_base64 = base64_encode($s_private_key);

    // Save our keys
    cms_file_put_contents_safe($s_key_path . '.pub', $s_public_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);
    cms_file_put_contents_safe($s_key_path . '.key', $s_private_key_base64, FILE_WRITE_FIX_PERMISSIONS | FILE_WRITE_SYNC_FILE);

    return [$public_key_base64, $private_key_base64, $s_public_key_base64, $s_private_key_base64];
}

/**
 * Script to encrypt some data (with telemetry keys) and output the encrypted payload (from encrypt_data_telemetry) in JSON formatted base64.
 *
 */
function encrypt_data_script() {
    require_code('global2');

    prepare_backend_response('text/plain');

    cms_ini_set('ocproducts.xss_detect', '0');

    $data = post_param_string('data');

    $data = encrypt_data_telemetry($data);
    echo base64_encode(json_encode($data));
}

/**
 * Register this site with the homesite telemetry service if options and server environment permit.
 * This should also be called when we need to update the homesite with this site's name, version, or may feature setting.
 *
 * @param  boolean $skip_creation Whether to skip creating a site key-pair and registering if one does not exist; this should be true when calling from an error handler
 * @return boolean Whether the site has been registered or is already registered
 */
function register_site_telemetry(bool $skip_creation = false) : bool
{
    // Is telemetry disabled?
    $telemetry = get_option('telemetry');
    if ($telemetry == '0') {
        return false;
    }

    // Are we not able to support telemetry?
    if (!is_encryption_available_telemetry()) {
        return false;
    }

    // If we are skipping creation, but we do not have a site key-pair, this is a failure
    if (!is_encryption_enabled_telemetry() && $skip_creation) {
        return false;
    }

    // Get or create the key-pairs for this site
    if (is_encryption_enabled_telemetry()) {
        $public_key = get_public_key_site_telemetry();
        $sign_public_key = get_public_sign_key_site_telemetry();
    } else {
        list($public_key, $private_key, $sign_public_key, $sign_private_key) = generate_site_telemetry_key_pair();
    }

    require_code('version');

    // We must send the data encrypted using the software keys, not the site keys, because the homesite does not yet know this site's public key
    $__payload = [
        'website_url' => get_base_url(),
        'website_name' => get_site_name(),
        'may_feature' => (get_option('telemetry_may_feature') == '1') ? 1 : 0,
        'version' => cms_version_pretty(),
        'public_key' => $public_key,
        'sign_public_key' => $sign_public_key,
    ];
    $_payload = encrypt_data_telemetry(serialize($__payload));
    $payload = json_encode($_payload);

    // Register the site
    $url = (($GLOBALS['DEV_MODE']) ? get_base_url() : get_brand_base_url()) . '/data/endpoint.php/cms_homesite/telemetry?type=register';
    $error_code = null;
    $error_message = '';
    $response = cms_fsock_request($payload, $url, $error_code, $error_message);

    // No success?
    if (($response === null) || (strpos($response, '"success":true') === false)) {
        return false;
    }

    return true;
}
