<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2023

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*
This file provides some detection of possible security vulnerabilities at development time, so code can be hardened before delivery.
*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__database_security_filter()
{
    global $DB_ESCAPE_STRING_LIST;
    $DB_ESCAPE_STRING_LIST = [];
}

/**
 * Find if a query is a simple one involving 'AND' maps.
 *
 * @param  string $query The query
 * @return boolean Whether it is simple
 */
function is_simple_query(string $query) : bool
{
    if (strpos($query, get_table_prefix()) === false) {
        return false;
    }

    $complex_keywords = ['ORDER' => true, 'GROUP' => true, 'AS' => true, 'OR' => true, 'NOT' => true, 'LIKE' => true, 'IN' => true, 'BETWEEN' => true, 'UNION' => true, 'HAVING' => true];
    $complex_operators = ['<', '>', '!', '+', '-', '/', '*'];
    $query = _trim_quoted_substrings($query);
    $query_parts = explode(' ', $query);
    if (in_array(cms_strtolower_ascii(trim($query_parts[0])), ['select', 'update', 'delete'])) {
        foreach ($query_parts as $part) {
            if (array_key_exists(cms_strtoupper_ascii(trim($part)), $complex_keywords)) {
                return false;
            }
        }
        foreach ($complex_operators as $operator) {
            if (strpos($query, $operator) !== false) {
                return false;
            }
        }
        if (preg_match('/[a-z]\(/', cms_strtolower_ascii($query))) {
            return false; // SQL functions
        }
        return true;
    }
    return false;
}

/**
 * Check all strings within a query were properly escaped (by checking log of what we escaped).
 *
 * @param  string $query The query
 * @return boolean Whether it is all good
 */
function has_escaped_dynamic_sql(string $query) : bool
{
    if (strpos(get_db_type(), 'mysql') === false) {
        // Our scanning may not work right on non-MySQL
        return true;
    }

    $query_call_strings = ['query(', 'query_value_if_there('];

    $strings = array_keys(_get_quoted_substrings($query));
    foreach ($strings as $str) {
        if (!is_string($str)) {
            $str = strval($str);
        }

        if (!isset($GLOBALS['DB_ESCAPE_STRING_LIST'][$str])) { // Not explicitly escaped, so we scan the code to see if it was hard-coded in there
            $ok = false;

            $full_trace = debug_backtrace();
            foreach ($full_trace as $backtrace_depth => $backtrace) {
                if ((isset($backtrace['file'])) && (file_exists($backtrace['file']))) {
                    $file = cms_file_safe($backtrace['file']);
                    foreach ($query_call_strings as $query_call_string) {
                        $loc = $file[$backtrace['line'] - 1];
                        $offset = strpos($loc, $query_call_string);

                        if ($offset !== false) { // First do a fast check on the line itself
                            $_strings = _get_quoted_substrings(substr($loc, $offset), true);
                            if (isset($_strings[$str])) {
                                $ok = true;
                                break 2;
                            }
                        }
                    }
                }
            }

            if (!$ok) {
                // Oh, maybe the string was somewhere escaped in the same file at least
                $done_files = [];
                foreach ($full_trace as $backtrace_depth => $backtrace) {
                    if ((isset($backtrace['file'])) && (file_exists($backtrace['file'])) && (!isset($done_files[$backtrace['file']]))) {
                        $done_files[$backtrace['file']] = true;

                        $file = cms_file_safe($backtrace['file']);
                        foreach ($file as $line) {
                            $_strings = _get_quoted_substrings($line, true);
                            if (isset($_strings[$str])) {
                                $ok = true;
                                break 2;
                            }
                        }
                    }
                }
            }

            if (!$ok) {
                //@var_dump($strings);@var_dump($GLOBALS['DB_ESCAPE_STRING_LIST']);@var_dump($full_trace);@var_dump($str);@var_dump($query);exit(); // Useful for debugging

                return false; // :-(.
            }
        }
    }
    return true; // :-)
}

/**
 * Find the quoted substrings within a query.
 *
 * @param  string $string The query
 * @param  boolean $recurse Whether to recurse (for double escaping)
 * @return array List of substrings (inverse map)
 *
 * @ignore
 */
function _get_quoted_substrings(string $string, bool $recurse = false) : array
{
    $buffer = '';
    $output = [];
    $found_start = null;
    $ignore = false;
    $len = strlen($string);
    for ($i = 0; $i < $len; $i++) {
        if ($found_start === null) {
            if ($string[$i] == "'" || $string[$i] == '"') {
                $found_start = $string[$i];
                continue;
            }
        }
        if ($found_start !== null) {
            if (($ignore !== $i/*If not escaped*/) && ($string[$i] == $found_start)) { // We've found a string
                $output[$buffer] = true;
                $output[trim($buffer, ' %')] = true;
                $output[trim($buffer, $found_start)] = true;
                $buffer = '';
                $found_start = null; // We've closed our string, ready ourselves for next
                continue;
            }
            if (($ignore !== $i) && ($string[$i] == '\\')) {
                $ignore = $i + 1;
            }
            $buffer .= $string[$i];
        }
    }
    if ($recurse) {
        foreach (array_keys($output) as $str) {
            if (!is_string($str)) {
                $str = strval($str);
            }

            $output += _get_quoted_substrings(stripcslashes($str));
        }
    }
    return $output;
}

/**
 * Blank out substrings within a query, which makes it easier to analyse (no need to consider escapings).
 *
 * @param  string $string Input string
 * @return string Simplified substring
 *
 * @ignore
 */
function _trim_quoted_substrings(string $string) : string
{
    $found_start = false;
    $ignore = null;
    $len = strlen($string);
    for ($i = 0; $i < $len; $i++) {
        if (!$found_start && ($string[$i] == '\'')) { // We've found a string
            $found_start = true;
            continue;
        }
        if ($found_start) {
            if (($ignore !== $i/*If not escaped*/) && ($string[$i] == '\'')) {
                $found_start = false; // We've closed our string, ready ourselves for next
                continue;
            }
            if (($ignore !== $i) && ($string[$i] == '\\')) {
                $ignore = $i + 1;
            }
            $string[$i] = ' ';
        }
    }
    return $string;
}
