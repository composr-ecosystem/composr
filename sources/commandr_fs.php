<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    commandr
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__commandr_fs()
{
    if (!defined('COMMANDR_FS_FILE')) {
        define('COMMANDR_FS_FILE', 0);
        define('COMMANDR_FS_DIR', 1);
    }
}

/**
 * Virtual filesystems.
 *
 * @package commandr
 */
class Commandr_fs
{
    public $commandr_fs;
    public $pwd;
    public $current_meta = null;
    public $current_meta_pwd = null;

    /**
     * Constructor function. Setup a virtual filesystem, but do nothing with it.
     */
    public function __construct()
    {
        // Initialise a new virtual filesystem; setup the vfs array, and fetch the pwd from a cookie

        /*
        The pwd is stored in a flat array, each value holds the key for each level in the $this->commandr_fs array that is in the pwd:
            $this->pwd=['blah2','foo3','bar'];

        The virtual filesystem is a nested directory structure, where terminals mapping to strings represent Commandr-fs hooks
            $this->commandr_fs = [
                'blah' => [],
            *** 'blah2' => [
                    'foo' => [],
                    'foo2' => [],
                *** 'foo3' => [
                    *** 'bar' => 'members', // 'members' hook is tied into 'bar', rather than an explicit array
                        'bar2' => [],
                    ],
                    'foo4' => [],
                    ],
                'blah3' => [],
            ];
        */

        // Build up the filesystem structure
        $commandr_fs_hooks = find_all_hooks('systems', 'commandr_fs');
        $this->commandr_fs = [];
        $cma_hooks = find_all_hooks('systems', 'content_meta_aware') + find_all_hooks('systems', 'resource_meta_aware');
        require_code('content');
        $var = [];
        foreach (array_keys($cma_hooks) as $hook) { // Find 'var' hooks, for content
            $cma_ob = get_content_object($hook);
            $cma_info = $cma_ob->info();
            if ($cma_info !== null) {
                $commandr_fs_hook = $cma_info['commandr_filesystem_hook'];
                if ($commandr_fs_hook !== null) {
                    unset($commandr_fs_hooks[$commandr_fs_hook]); // It's under 'var', don't put elsewhere
                    $var[$commandr_fs_hook] = $commandr_fs_hook;
                }
            }
        }
        foreach (array_keys($commandr_fs_hooks) as $hook) { // Other filesystems go directly under the root (not 'root', which is different)
            if (($hook == 'members') && (get_forum_type() != 'cns')) {
                continue;
            }

            $this->commandr_fs[$hook] = $hook;
        }
        $this->commandr_fs['var'] = $var;

        $this->pwd = $this->_start_pwd();
        $this->current_meta = null;
        $this->current_meta_pwd = null;
    }

    /**
     * Fetch the current directory from a cookie, or the default.
     *
     * @return array Current directory
     */
    protected function _start_pwd() : array
    {
        // Fetch the pwd from a cookie, or generate a new one
        if (array_key_exists('commandr_dir', $_COOKIE)) {
            return $this->_pwd_to_array(base64_decode($_COOKIE['commandr_dir']));
        }

        $default_dir = [];
        cms_setcookie('commandr_dir', base64_encode($this->pwd_to_string($default_dir)), false, false);
        return $default_dir;
    }

    /**
     * Return the contents of the given directory in $this->commandr_fs (i.e. ls without the fancy bits).
     *
     * @param  ?array $dir Directory (null: current directory is used)
     * @param  boolean $full_paths Whether to use full paths
     * @return ~array Directory contents (false: failure)
     */
    protected function _get_current_dir_contents(?array $dir = null, bool $full_paths = false)
    {
        if ($dir === null) {
            $dir = $this->pwd;
        }

        if (strpos(implode('/', $dir), '*') !== false) { // Handle wildcards
            $end_bit = array_pop($dir); // Remove last element
            $dir_remaining = implode('/', $dir);
            if ($dir_remaining == '') {
                $dir_remaining = '/';
            }

            $ret = [];
            if (strpos($dir_remaining, '*') !== false) { // Showing everything underneath any outcome of the wildcards of directories paths
                $before = $this->_get_current_dir_contents($dir, true);
                foreach ($before as $entry) {
                    $_ret = $this->_get_current_dir_contents(array_merge(explode('/', $entry[0]), [$end_bit]), $full_paths);
                    if ($_ret !== false) {
                        $ret = array_merge($ret, $_ret);
                    }
                }
            } else { // Filtering everything under a directory by a wildcard
                $before = $this->_get_current_dir_contents($dir, $full_paths);

                foreach ($before as $entry) {
                    if (simulated_wildcard_match($entry[0], $end_bit, true)) {
                        $entry[0] = preg_replace('#^.*/#', '', $entry[0]);
                        $ret[] = $entry;
                    }
                }
            }
            return $ret;
        }

        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $current_dir = $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $dir);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            $current_dir = $object->listing($meta_dir, $meta_root_node, $this);

            if ($full_paths) {
                foreach ($current_dir as $i => $d) {
                    $current_dir[$i][0] = implode('/', $dir) . '/' . $d[0];
                }
            }
        }
        return $current_dir;
    }

    /**
     * Convert a string-form path to an array.
     *
     * @param  string $pwd Path
     * @return array Array-form path
     */
    public function _pwd_to_array(string $pwd) : array
    {
        // Convert a string-form pwd to an array-form pwd, and sanitise it
        if ($pwd == '') {
            return [];
        }
        $absolute = ($pwd[0] == '/');
        $_pwd = explode('/', $pwd);
        if ($absolute) {
            $target_directory = [];
        } else {
            $target_directory = $this->pwd;
        }
        return $this->_merge_pwds($target_directory, $_pwd);
    }

    /**
     * Merge an absolute array-form path with a non-absolute array-form path, with support for "."/".." resolution.
     *
     * @param  array $pwd1 Absolute path
     * @param  array $pwd2 Non-absolute path
     * @return array Merged path
     */
    protected function _merge_pwds(array $pwd1, array $pwd2) : array
    {
        // Merge two array-form pwds, assuming the former is absolute and the latter isn't
        $target_directory = $pwd1;
        foreach ($pwd2 as $section) {
            if (($section != '.') && ($section != '..') && ($section != '') && ($section !== null)) {
                $target_directory[] = $section;
            } elseif ($section == '..') {
                array_pop($target_directory);
            }
        }
        return $target_directory;
    }

    /**
     * Convert an array-form path to a string.
     *
     * @param  ?array $pwd Path (null: use $this->pwd)
     * @return string String-form path
     */
    public function pwd_to_string(?array $pwd = null) : string
    {
        if ($pwd === null) {
            $pwd = $this->pwd;
        }
        $output = '';
        foreach ($pwd as $section) {
            $output .= '/' . $section;
        }
        if ($this->_is_dir($pwd)) {
            $output .= '/';
        }
        return $output;
    }

    /**
     * Return filename from a path.
     *
     * @param  string $filename Path
     * @return string Filename
     */
    protected function _get_filename(string $filename) : string
    {
        // Make sure no directories are included with the filename
        $parts = explode('/', $filename);
        return $parts[count($parts) - 1];
    }

    /**
     * Is it a directory?.
     *
     * @param  ?array $dir Path to check (null: current dir is used)
     * @return boolean Directory?
     */
    public function _is_dir(?array $dir = null) : bool
    {
        if ($dir === null) {
            $dir = $this->pwd;
        }

        if (empty($dir)) {
            return true;
        }
        $filename = array_pop($dir);

        $contents = $this->_get_current_dir_contents($dir); // Look at contents of parent directory
        if ($contents === false) {
            return false;
        }

        foreach ($contents as $entry) {
            if ($entry[0] == $filename) {
                return $entry[1] == COMMANDR_FS_DIR;
            }
        }

        if (count($contents) == 1000) {
            return true; // We can assume it's a dir, it's just there's too much to list here
        }

        return false;
    }

    /**
     * Is it a file?.
     *
     * @param  array $dir Path (with filename) to use
     * @return boolean Directory?
     */
    public function _is_file(array $dir) : bool
    {
        $filename = array_pop($dir);

        $contents = $this->_get_current_dir_contents($dir); // Look at contents of parent directory
        if ($contents === false) {
            return false;
        }

        foreach ($contents as $entry) {
            if ($entry[0] == $filename) {
                return $entry[1] == COMMANDR_FS_FILE;
            }
        }

        return false;
    }

    /**
     * Get details of the current meta directory.
     *
     * @param  array $meta_dir Meta directory result: returned by reference
     * @param  string $meta_root_node Meta root node result: returned by reference
     * @param  string $meta_root_node_type Meta root node type result: returned by reference
     * @param  ?array $target_dir Directory (null: current directory is used)
     * @return ~array Current directory contents (false: error)
     */
    protected function _discern_meta_dir(array &$meta_dir, string &$meta_root_node, string &$meta_root_node_type, ?array $target_dir = null)
    {
        // Get the details of the current meta dir (re: object creation) and where the pwd is in relation to it
        $inspected_dir = $this->_convert_meta_dir_to_detailed_dir($this->commandr_fs); // Start at the root
        if ($target_dir === null) {
            $target_dir = $this->pwd;
        }
        $meta_dir = $target_dir;
        $meta_root_node = null;
        $meta_root_node_type = null;

        foreach ($target_dir as $section_no => $section) { // For each component in our path
            unset($meta_dir[$section_no]); // Okay so we're still not under the meta-dir, so actually this $section_no is not a part of the meta-dir

            if (!array_key_exists($section, $inspected_dir)) {
                return false; // Cannot find the directory
            }

            if (is_array($inspected_dir[$section][4])) { // Hard-coded known directory, so we can scan it
                $inspected_dir = $this->_convert_meta_dir_to_detailed_dir($inspected_dir[$section][4]); // We will continue on through more possible hard-coded directories, or to find a deeper meta-dir
            } else { // Known directory, and we've not got to a meta-dir yet -- must therefore be the meta-dir
                $meta_root_node = $section;
                $meta_root_node_type = $inspected_dir[$section][4];
                $inspected_dir = [];
                break; // We've found the meta-dir we're under, so we can stop going through now
            }
        }

        $meta_dir = array_values($meta_dir); // Everything left over needs re-indexing

        return $inspected_dir;
    }

    /**
     * Fill out a hardcoded meta-dir to use our more detailed internal format.
     *
     * @param  array $_inspected_dir Simple list of directories under here
     * @return array Full detailed directory contents
     */
    protected function _convert_meta_dir_to_detailed_dir(array $_inspected_dir) : array
    {
        $inspected_dir = [];
        foreach ($_inspected_dir as $dir_name => $contents) {
            $inspected_dir[$dir_name/*only here for hard-coded dirs*/] = [
                $dir_name,
                COMMANDR_FS_DIR,
                null,
                null,
                $contents, // This is only here for hard-coded dirs; it will either be a string (i.e. hook name) or an array (more hard-coded depth to go)
            ];
        }
        return $inspected_dir;
    }

    /**
     * Convert a directory contents structure into a template parameter structure.
     *
     * @param  array $entries Structure
     * @return array Template parameter structure
     */
    public function prepare_dir_contents_for_listing(array $entries) : array
    {
        $out = [];
        require_code('files');
        foreach ($entries as $entry) {
            $out[] = [
                'FILENAME' => $entry[0],
                'FILESIZE' => ($entry[2] === null) ? '' : clean_file_size($entry[2]),
                '_FILESIZE' => ($entry[2] === null) ? '' : strval($entry[2]),
                'MTIME' => ($entry[3] === null) ? '' : date('Y-m-d H:i', $entry[3]),
                '_MTIME' => ($entry[3] === null) ? '' : strval($entry[3]),
            ];
        }
        return $out;
    }

    /**
     * Return the current working directory of the virtual filesystem. Equivalent to Unix "pwd".
     *
     * @param  boolean $array_form Return the pwd in array form?
     * @return mixed The current working directory (array or string)
     */
    public function print_working_directory(bool $array_form = false)
    {
        // Return the current working directory
        if ($array_form) {
            return $this->pwd;
        }

        return $this->pwd_to_string();
    }

    /**
     * Return a directory and file listing of the current working directory. Equivalent to Unix "ls".
     *
     * @param  ?array $dir An alternate directory in which to perform the action (null: current directory is used)
     * @return array Directories and files in the current working directory
     */
    public function listing(?array $dir = null) : array
    {
        // Return an array list of all the directories and files in the pwd
        $current_dir_contents = $this->_get_current_dir_contents($dir);
        if ($current_dir_contents === false) {
            return [[], []];
        }

        $directories = [];
        $files = [];

        foreach ($current_dir_contents as $entry) {
            if ($entry[1] == COMMANDR_FS_DIR) {
                // Directory
                $directories[$entry[0]] = $entry;
            } elseif ($entry[1] == COMMANDR_FS_FILE) {
                // File
                $files[$entry[0]] = $entry;
            }
        }

        // Sort them nicely and neatly ;-)
        asort($directories);
        asort($files);

        return [$directories, $files];
    }

    /**
     * Return a listing of all the files/directories found matching the specified pattern. Equivalent to Unix "find".
     *
     * @param  string $pattern The search pattern (PRCE regexp or plain)
     * @param  boolean $regexp Is the search pattern a regexp?
     * @param  boolean $recursive Should the search be recursive?
     * @param  boolean $files Should files be included in the results?
     * @param  boolean $directories Should directories be included in the results?
     * @param  ?array $dir Directory (null: current directory is used)
     * @return array The search results
     */
    public function search(string $pattern, bool $regexp = false, bool $recursive = false, bool $files = true, bool $directories = false, ?array $dir = null) : array
    {
        // Search!
        $current_dir_contents = $this->listing($dir);
        $dir_string = $this->pwd_to_string($dir);
        $output_directories = [];
        $output_files = [];

        if ($regexp) {
            if (($pattern == '') || (($pattern[0] != '#') && ($pattern[0] != '/'))) {
                $pattern = '#' . $pattern . '#';
            }
        }

        foreach ($current_dir_contents[0/*directories*/] as $directory) {
            if ($directories) {
                if (($regexp) && (preg_match($pattern, $directory[0]))) {
                    $output_directories[] = $dir_string . $directory[0] . '/';
                } elseif ((!$regexp) && ($pattern == $directory[0])) {
                    $output_directories[] = $dir_string . $directory[0] . '/';
                }
            }
            if ($recursive) {
                $temp_dir = $dir;
                $temp_dir[] = $directory[0];
                $temp = $this->search($pattern, $regexp, $recursive, $files, $directories, $temp_dir);
                $output_directories = array_merge($output_directories, $temp[0]);
                $output_files = array_merge($output_files, $temp[1]);
            }
        }

        if ($files) {
            foreach ($current_dir_contents[1/*files*/] as $file) {
                if (($regexp) && (preg_match($pattern, $file[0]))) {
                    $output_files[] = $dir_string . $file[0];
                } elseif ((!$regexp) && ($pattern == $file[0])) {
                    $output_files[] = $dir_string . $file[0];
                }
            }
        }

        // Sort them nicely and neatly ;-)
        asort($output_directories);
        asort($output_files);

        return [$output_directories, $output_files];
    }

    /**
     * Change the current working directory. Equivalent to Unix "cd".
     *
     * @param  array $target_directory The target directory path
     * @return boolean Success?
     */
    public function change_directory(array $target_directory) : bool
    {
        // Change the current directory
        if ($this->_is_dir($target_directory)) {
            $this->pwd = $target_directory;
            cms_setcookie('commandr_dir', base64_encode($this->pwd_to_string($target_directory)), false, false);

            return true;
        }

        return false;
    }

    /**
     * Create a directory under the current working directory. Equivalent to Unix "mkdir".
     *
     * @param  array $directory The new directory's path and name
     * @return boolean Success?
     */
    public function make_directory(array $directory) : bool
    {
        $directory_name = array_pop($directory);
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $directory);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            return $object->make_directory($meta_dir, $meta_root_node, $directory_name, $this);
        }

        return false;
    }

    /**
     * Remove a directory under the current working directory. Equivalent to Unix "rmdir".
     *
     * @param  array $directory The directory-to-remove's path and name
     * @return boolean Success?
     */
    public function remove_directory(array $directory) : bool
    {
        $directory_name = $directory[count($directory) - 1];
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $directory);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            $listing = $object->listing($meta_dir, $meta_root_node, $this);

            // Remove contents
            foreach ($listing as $value) {
                switch ($value[1]) {
                    case COMMANDR_FS_FILE:
                        $object->remove_file($directory, $meta_root_node, $value[0], $this);
                        break;
                    case COMMANDR_FS_DIR:
                        $this->remove_directory(array_merge($directory, [$value[0]])); // Recurse
                        break;
                }
            }

            array_pop($meta_dir);

            // Remove directory itself
            return $object->remove_directory($meta_dir, $meta_root_node, $directory_name, $this);
        }

        return false;
    }

    /**
     * Copy a directory. Equivalent to Unix "cp".
     *
     * @param  array $to_copy The directory to copy
     * @param  array $destination The destination path
     * @return boolean Success?
     */
    public function copy_directory(array $to_copy, array $destination) : bool
    {
        $directory_contents = $this->_get_current_dir_contents($to_copy);
        $success = true;

        $dir_name = $to_copy[count($to_copy) - 1];
        $_destination = $destination;
        $_destination[] = $dir_name;

        if (!$this->make_directory($_destination)) {
            return false;
        }

        foreach ($directory_contents as $entry) {
            $_to_copy_path = $to_copy;
            $_destination = $destination;
            $_destination[] = $dir_name;

            if ($entry[1] == COMMANDR_FS_DIR) {
                $_to_copy_path[] = $entry[0];
                $success = ($success) ? $this->copy_directory($_to_copy_path, $_destination) : false;
            } elseif ($entry[1] == COMMANDR_FS_FILE) {
                $_to_copy_path[] = $entry[0];
                $success = ($success) ? $this->copy_file($_to_copy_path, $_destination) : false;
            }
        }

        return $success;
    }

    /**
     * Move a directory. Equivalent to Unix "mv".
     *
     * @param  array $to_move The directory to move
     * @param  array $destination The destination path
     * @return boolean Success?
     */
    public function move_directory(array $to_move, array $destination) : bool
    {
        $to_move_meta_dir = [];
        $to_move_meta_root_node = '';
        $to_move_meta_root_node_type = '';
        $this->_discern_meta_dir($to_move_meta_dir, $to_move_meta_root_node, $to_move_meta_root_node_type, $to_move);
        require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($to_move_meta_root_node_type));
        $to_move_object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($to_move_meta_root_node_type));

        $destination_meta_dir = [];
        $destination_meta_root_node = '';
        $destination_meta_root_node_type = '';
        $this->_discern_meta_dir($destination_meta_dir, $destination_meta_root_node, $destination_meta_root_node_type, $destination);
        require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($destination_meta_root_node_type));
        $destination_object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($destination_meta_root_node_type));

        if ($destination_meta_root_node == $to_move_meta_root_node_type) {
            if (method_exists($to_move_object, 'folder_save')) { // Resource-fs wants a better renaming technique
                $new_label = array_pop($destination_meta_dir);
                return $to_move_object->folder_save(array_pop($to_move_meta_dir), implode('/', $destination_meta_dir), ['label' => $new_label]);
            }
        }

        $success = $this->copy_directory($to_move, $destination);
        if ($success) {
            return $this->remove_directory($to_move);
        }

        return false;
    }

    /**
     * Copy a file. Equivalent to Unix "cp".
     *
     * @param  array $to_copy The file to copy
     * @param  array $destination The destination path
     * @return boolean Success?
     */
    public function copy_file(array $to_copy, array $destination) : bool
    {
        $contents = $this->read_file($to_copy);
        $destination[] = $to_copy[count($to_copy) - 1];
        return $this->write_file($destination, $contents) !== false;
    }

    /**
     * Move a file. Equivalent to Unix "mv".
     *
     * @param  array $to_move The file to move
     * @param  array $destination The destination path
     * @return boolean Success?
     */
    public function move_file(array $to_move, array $destination) : bool
    {
        $to_move_meta_dir = [];
        $to_move_meta_root_node = '';
        $to_move_meta_root_node_type = '';
        $this->_discern_meta_dir($to_move_meta_dir, $to_move_meta_root_node, $to_move_meta_root_node_type, $to_move);
        require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($to_move_meta_root_node_type));
        $to_move_object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($to_move_meta_root_node_type));

        $destination_meta_dir = [];
        $destination_meta_root_node = '';
        $destination_meta_root_node_type = '';
        $this->_discern_meta_dir($destination_meta_dir, $destination_meta_root_node, $destination_meta_root_node_type, $destination);
        require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($destination_meta_root_node_type));
        $destination_object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($destination_meta_root_node_type));

        if ($destination_meta_root_node == $to_move_meta_root_node_type) {
            if (method_exists($to_move_object, 'file_save')) { // Resource-fs wants a better renaming technique
                $new_label = basename(array_pop($destination_meta_dir), '.' . RESOURCE_FS_DEFAULT_EXTENSION);
                return $to_move_object->file_save(array_pop($to_move_meta_dir), implode('/', $destination_meta_dir), ['label' => $new_label]);
            }
        }

        $success = $this->copy_file($to_move, $destination);
        if ($success) {
            return $this->remove_file($to_move);
        }
        return false;
    }

    /**
     * Remove a file. Equivalent to Unix "rm".
     *
     * @param  array $to_remove The file to remove
     * @return boolean Success?
     */
    public function remove_file(array $to_remove) : bool
    {
        $filename = array_pop($to_remove);
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $to_remove);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            return $object->remove_file($meta_dir, $meta_root_node, $filename, $this);
        }

        return false;
    }

    /**
     * Read a file and return the contents.
     *
     * @param  array $to_read The file to read
     * @return ~string The file contents (false: failure)
     */
    public function read_file(array $to_read)
    {
        $filename = array_pop($to_read);
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $to_read);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            return $object->read_file($meta_dir, $meta_root_node, $filename, $this);
        }

        return false;
    }

    /**
     * Write to a file; create the file if it doesn't exist.
     *
     * @param  array $to_write The file to write
     * @param  string $contents The contents to write
     * @return boolean Success?
     */
    public function write_file(array $to_write, string $contents) : bool
    {
        $filename = array_pop($to_write);
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $to_write);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            return $object->write_file($meta_dir, $meta_root_node, $filename, $contents, $this) !== false;
        }

        return false;
    }

    /**
     * Append to a file.
     *
     * @param  array $to_append The file to which to append
     * @param  string $contents The contents to append
     * @return boolean Success?
     */
    public function append_file(array $to_append, string $contents) : bool
    {
        $filename = array_pop($to_append);
        $meta_dir = [];
        $meta_root_node = '';
        $meta_root_node_type = '';
        $this->_discern_meta_dir($meta_dir, $meta_root_node, $meta_root_node_type, $to_append);

        if ($meta_root_node !== null) {
            // We're underneath a meta root node (a directory which is generated dynamically)
            require_code('hooks/systems/commandr_fs/' . filter_naughty_harsh($meta_root_node_type));
            $object = object_factory('Hook_commandr_fs_' . filter_naughty_harsh($meta_root_node_type));
            $old_contents = $object->read_file($meta_dir, $meta_root_node, $filename, $this);
            return $object->write_file($meta_dir, $meta_root_node, $filename, $old_contents . $contents, $this);
        }

        return false;
    }
}
