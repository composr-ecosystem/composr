<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2020

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    search
 */

/*EXTRA FUNCTIONS: CRC24*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__search()
{
    if (!defined('MINIMUM_AUTOCOMPLETE_LENGTH')) {
        define('MINIMUM_AUTOCOMPLETE_LENGTH', intval(get_option('minimum_autocomplete_length')));
        define('MINIMUM_AUTOCOMPLETE_PAST_SEARCH', 0);
        define('MAXIMUM_AUTOCOMPLETE_SUGGESTIONS', intval(get_option('maximum_autocomplete_suggestions')));

        define('APPEARANCE_CONTEXT_TITLE', 1);
        define('APPEARANCE_CONTEXT_META', 2);
        define('APPEARANCE_CONTEXT_BODY', 3); // Nothing will be indexed in here that is indexed in one of the above, to avoid duplicated content records when doing non-appearance-filtered searches
    }
}

/*
Introduces the Composr fast custom index, which will be a bundled part of the search addon in version 11. Designed to significantly improve the speed of most slow searches. Currently being prototyped on active pre-v11 websites.

---

[title=\"2\"]Composr fast custom index[/title]

When searching large amounts of content it is important for the content to be pre-indexed for search, as searching through all the bytes is too slow. Composr traditionally makes uses of \"fulltext search\" capabilities present in most database software, i.e. the database software's own search engine. For the sake of simplicity in this documentation we will assume all users are using MySQL.

As of version 11, Composr now features its own search engine, which can run as a separate option triggered to run instead of MySQL fulltext search in a number of configurable situations (by default it does not run). The search engine is implemented for forum posts (public and private), catalogue entries, and Comcode pages. For simplicity we'll just talk about public forum post search.

The problem with MySQL fulltext search is 2-fold:
1) The search index is totally separated out from other indexing. If you want to do a search, and then filter it down to say a particular forum, or a particular poster, then it has to cleave a big chunk out of the search index and then cross-reference that with other index(es). It can be very inefficient.
2) If there are common terms on a website that are not so common/irrelevant as to be filtered out by standard, e.g. 'car' on a car website, then when someone searches for those words it means an enormous amount is going to be cleaved out of the search index.
And the worst is when these things combine. Let's say 40% of your forum posts contain the word 'car', and the user is searching for 'car maintenance' but the user is filtering to a forum with only 5% of the posts in it. Basically MySQL would cleave out 40% of its search index, calculate the ranking from all those rows and sort by that, and then cursor through almost all those rows until it gets just the top 30 that cross-reference with the forum index.

There's no real way around this with MySQL fulltext search indexing.

The Composr fast custom index takes a totally different approach. The forum posts database table gets a matching search indexing table, which indexes all the common search filters (poster ID, forum ID, etc) directly against individual keywords extracted from the posts.

So basically a row in that search indexing table might be like (keyword=car, forum_id=4, poster_id=300). The search indexing table is then also database-indexed against all the fields so that the database can very efficiently query out stuff from it.

Of course searches may have multiple keywords, so it revisits the table for each keyword, basically, and it has a ranking algorithm. There's a lot more to it than that, but I'm keeping it simple here. It basically ranks by how prevalent the most obscure word in the search query is in the forum post.

In terms of performance, the end result is the Composr fast custom index search system is a bit slower for most \"straight\" searches (searches with no additional filtering), but immensely faster for searches with additional filtering.

There are a few minor downsides to the Composr fast custom index:
 - If you want to allow multi-word quoted phrases it will use a lot more disk space because it has to separately store each combination of adjacent keywords, up to the limit you configure. That's due to how Composr fast custom index is designed: it is not building a data structure for the keywords in a document, it's separately indexing each keyword against all possible search filters.
 - 'Fuzzy' searching' for large databases (basically analogous to the 'natural' MySQL fulltext search) is very slow. Without fuzzy searching every keyword in the search will either be ANDed, ignored (stop words like 'is'), or excluded (if preceded with '-'). i.e. it doesn't take individual words as suggestions for match ranking, they all have to be taken into account.
 - Ranking accuracy isn't going to be as good, as the Composr fast custom index ranks based on just the most obscure keyword, not a blend of all keywords. This is necessary to avoid having to do cross-computation between each keyword, instead it can rank rows using direct indexing. Actually you can configure all-keyword ranking, but it is not recommended.
 - You cannot do 'blank' searches.
 - There will be a short lag before new content is indexed.

And some upsides:
 - Radically better performance for filtered queries, as discussed. While MySQL fulltext performance [i]degrades[/i] as filters are added, the Composr fast custom index performance is radically [i]improved[/i] with additional filtering.
 - Configurable stop word list without requring server admin access.
 - No minimum or maximum word sizes. So you can search for numbers, for example.
 - Great multilingual support.
 - Some database backends may not even provide fulltext search of their own, so Composr fast custom index would fill the gap.

[title=\"3\"]Stop words[/title]

Stop words are words that will be ignored by the search engine because they convey no meaning and just add noise to the search.
A default list is provided for English, and can be edited by copying the [tt]text/EN/too_common_words.txt[/tt] file to [tt]text_custom/EN/too_common_words.txt[/tt] and customising it.

[title=\"3\"]Index generation[/title]

There's a background task within the system scheduler that populates the indexing tables.
The first time it runs it:
1) Indexes all existing data.
2) Builds up a database table of ngram frequency (keyword frequency, basically) across all the supported searchable data (the [tt]<table-prefix>ft_index_commonality[/tt] table). This frequency data is used for ranking purposes.
Subsequently it just adds indexing for new content created/changed since the last indexing run.

If you want to reindex (perhaps you have changed some settings, or changed stop words, or want to regenerate commonality data to reflect the current status of your site), you need to manually wipe out the contents of the following database tables:
 - [tt]<table-prefix>ce_fulltext_index[/tt]
 - [tt]<table-prefix>cpages_fulltext_index[/tt]
 - [tt]<table-prefix>f_posts_fulltext_index[/tt]
 - [tt]<table-prefix>f_pposts_fulltext_index[/tt]
Composr will automatically see this as a signal that they need rebuilding.

[title=\"3\"]Internationalisation[/title]

Content is indexed against each language, according to translations of that language. So for example if you search for 'gift' in German you'd get results for the German meaning of that character string (very different to the English meaning!).

When translating content, you need to either edit the content in the language you are translating to -- of if you use the translation queue you'll need to force reindexing for those changes to show up.

Programmers can add grammar rules for different languages a lot more easily than they can to MySQL. Look at [tt]sources/lang_stemmer_EN.php[/tt] and [tt]sources/lang_tokeniser_EN.php[/tt] and just make equivalent files for your language.

[title=\"3\"]Special considerations[/title]

The PHP mbstring extension is significantly faster than the iconv extension. If you use iconv then you may find search indexing is very slow.


TODO when integrating into v11...

1)
Grep for:
$_content_bits = explode(' ', str_replace('"', '', cms_preg_replace_safe('#(^|\s)\+#', '', cms_preg_replace_safe('#(^|\s)\-#', '', $content))));
And change to use query_to_search_tokens

2) Move all to bundled

3) Move new table creation code to modules, and add uninstallation code

4) Call 'delete_from_index' throughout any delete actualiser functions

5) Turn hidden options into real ones, and also...
 Checkboxes for when to use nusearch
  Particular languages flagged to prefer it
  Heavy filtered queries
  If database driver does not have fulltext search
  Any simple search query
  Queries matching a particular regular expression
  Searches with more than a certain number of words

6) Make 'search_do_days_fallback' hidden option official

7) Leave our old get_search_rows implementation as a non-Cron or hidden-value activated fallback

8) Make boolean search support implicit with no boolean tickbox and no conjunctive operator option, with simple support for only [+-"], and generally tidy up the API to just pass through queries to hooks unaltered

9) Alter get_search_rows parameter naming and order to be sane and consistent with Composr_fulltext_engine->get_search_rows

10) Change db_meta_indices primary key:
$GLOBALS['SITE_DB']->change_primary_key('db_meta_indices', ['i_table', 'i_name']);
$GLOBALS['SITE_DB']->alter_table_field('db_meta_indices', 'i_fields', 'LONG_TEXT');
And change create_table code

11) Documentation for Composr fast custom index:
 Generally review existing documentation
 Overview of all the config options
 Clearly explain the boolean search syntax supported, including:
  + and -
  ", including how quote grabs phrases which may include stop words, how maximum ngram length affects quoting, and how stemming happens but only for ngrams that are singular (so quoted phrased will not be stemmed but +/- operators do operate on stemmed ngrams)
  How anything else is 'fuzzy' for a relevance search with highest relevance first, unless fuzziness is disabled - and otherwise just works like '+'

12) active_search_has_special_filtering needs to be able to distinguish between tick boxes supported in index, and fully custom filtering -- and then can_use_composr_fulltext_engine can make use of this to infer which engine to use based on configuration

13) Add future ideas to tracker
 Synomym support
 Automatic reindexing of content edited via translation queue
*/

/**
 * Find if we can use the Composr fast custom index.
 *
 * @param  string $hook The hook it is for (assumption that this hook is at least capable in some situations)
 * @param  ?string $query Query to run for (null: no query to check at this point)
 * @param  ?boolean $has_heavy_filtering Whether there is heavy filtering (which suggests to use Composr fast custom index) (null: unknown at this point)
 * @return boolean Whether we can
 */
function can_use_composr_fulltext_engine($hook, $query = null, $has_heavy_filtering = null)
{
    if ($query !== null) {
        $only_singular_ngrams = (intval(get_value('fulltext_max_ngram_size', '1', true)) <= 1);

        $_trigger_words = get_value('fulltext_trigger_words', '', true);
        $trigger_words = ($_trigger_words == '') ? [] : array_map('cms_mb_strtolower', array_map('trim', explode(',', $_trigger_words)));

        if (($only_singular_ngrams) || (!empty($trigger_words))) {
            $tokeniser = Composr_fulltext_engine::get_tokeniser(user_lang());
            $ngrams = $tokeniser->query_to_search_tokens($query);
        }
    }

    // Negative, cannot use for these reasons...

    if (($query !== null) && ($query == '')) {
        return false; // Blank queries not supported
    }

    if (($query !== null) && ($only_singular_ngrams)) {
        if (array_unique(array_values($ngrams[0] + $ngrams[1] + $ngrams[2])) !== [true]) {
            return false; // Quoted text not supported in this configuration
        }
    }

    if (!cron_installed()) {
        return false; // No indexing working
    }

    // Positive, must use for these reasons...

    if (($query !== null) && (!empty($trigger_words))) {
        if (!empty(array_intersect(array_map('cms_mb_strtolower', array_keys($ngrams)), $trigger_words))) {
            return true; // We will use Composr fast custom index if there's certain stop words
        }
    }

    if ($has_heavy_filtering === true) {
        return true; // We will use Composr fast custom index if there's heavy filtering as there'll be a big speed boost
    }

    // Explicit choice...

    $by_url = get_param_integer('keep_composr_fulltext_engine', null);
    if ($by_url !== null) {
        return ($by_url == 1); // Explicitly specified by URL
    }

    $default_choice = get_value('composr_fulltext_engine__' . $hook, '', true);
    if ($default_choice != '') {
        return ($default_choice == '1'); // Explicitly specified by config
    }

    // -

    return false; // Default to use traditional search
}

/**
 * The Composr fast custom index fulltext search engine.
 *
 * @package search
 */
class Composr_fulltext_engine
{
    // Querying...

    /**
     * Get some rows, queried from the database according to the search parameters, using the Composr fast custom index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  string $content_table The content table to query (may contain JOIN components)
     * @param  array $key_transfer_map A map to show how keys relate between the index table and the content table, used to construct a JOIN
     * @param  string $where_clause Special WHERE clause querying things from content table (i.e. stuff not covered in our index)
     * @param  string $extra_join_clause Extra SQL to insert into the JOIN clauses of each keyword, used to enforce query constraints handled within our indexing
     * @param  string $content Search string
     * @param  boolean $boolean_search Whether to do a boolean search
     * @param  boolean $only_search_meta Whether to only do a META (tags) search
     * @param  boolean $only_titles Whether to only search titles (as opposed to both titles and content)
     * @param  integer $max Start position in total results
     * @param  integer $start Maximum results to return in total
     * @param  ID_TEXT $order What to order by
     * @param  ID_TEXT $direction Order direction
     * @param  ?string $permissions_module The permission module to check category access for (null: none)
     * @param  ?string $index_permissions_field The field that specifies the permissions ID to check category access for (null: none)
     * @param  boolean $permissions_field_is_string Whether the permissions field is a string
     * @return array The rows found
     */
    public function get_search_rows($db, $index_table, $content_table, $key_transfer_map, $where_clause, $extra_join_clause, $content, $boolean_search, $only_search_meta, $only_titles, $max, $start, $order, $direction, $permissions_module = null, $index_permissions_field = null, $permissions_field_is_string = false)
    {
        if ($only_search_meta) {
            $appearance_context = APPEARANCE_CONTEXT_META;
        } elseif ($only_titles) {
            $appearance_context = APPEARANCE_CONTEXT_TITLE;
        } else {
            $appearance_context = null;
        }

        if (preg_match('#_fulltext_index$#', $index_table) == 0) {
            fatal_exit('By convention any Composr full-text index table must end with _fulltext_index');
        }

        // Load configuration
        global $SEARCH_CONFIG_OVERRIDE;
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_allow_fuzzy_search'])) {
            $allow_fuzzy_search = ($SEARCH_CONFIG_OVERRIDE['fulltext_allow_fuzzy_search'] == '1');
        } else {
            $allow_fuzzy_search = (get_value('fulltext_allow_fuzzy_search', '0', true) == '1');
        }
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_scale_by_commonality'])) {
            $scale_by_commonality = ($SEARCH_CONFIG_OVERRIDE['fulltext_scale_by_commonality'] == '1');
        } else {
            $scale_by_commonality = (get_value('fulltext_scale_by_commonality', '1', true) == '1');
        }
        if (isset($SEARCH_CONFIG_OVERRIDE['fulltext_use_imprecise_ordering'])) {
            $use_imprecise_ordering = ($SEARCH_CONFIG_OVERRIDE['fulltext_use_imprecise_ordering'] == '1');
        } else {
            $use_imprecise_ordering = (get_value('fulltext_use_imprecise_ordering', '1', true) == '1');
        }

        $lang = user_lang();

        $tokeniser = self::get_tokeniser($lang);
        $stemmer = self::get_stemmer($lang);

        // We start with the content table, which is needed for things like validation checks, or other stuff that basically won't be a dominant index culling factor
        $join = $content_table;

        if (($order == '') || ($order == 'relevance')) {
            $order = 'contextual_relevance';
        }

        // Work out our search terms
        list($fuzzy_and, $and, $not) = $tokeniser->query_to_search_tokens($content, $boolean_search);
        if (($order != 'contextual_relevance') || ($direction == 'ASC') || (!$allow_fuzzy_search)) {
            // We only allow fuzzy search when returning results in relevance order, with most relevant first
            //  - this is because it makes no sense for any other orders
            // We also allow it to be disabled as it could have major performance slow-down for large data-sets, it's a lot to pull out from the index, join, and sort.
            $and = $and + $fuzzy_and;
            $fuzzy_and = [];
        }
        $search_token_sets = [
            'fuzzy_and' => $fuzzy_and,
            'and' => $and,
            'not' => $not,
        ];

        // Load commonalities so we can scale by them
        if (((!empty($fuzzy_and)) || (!empty($and))) && ($scale_by_commonality)) {
            $commonalities = $this->load_commonalities($db, array_keys($fuzzy_and + $and));

            // Order search terms by commonality
            $_fuzzy_and = [];
            foreach ($commonalities as $ngram => $commonality) {
                if (isset($fuzzy_and[$ngram])) {
                    $_fuzzy_and[$ngram] = $fuzzy_and[$ngram];
                }
            }
            $fuzzy_and = $_fuzzy_and;
            $_and = [];
            foreach ($commonalities as $ngram => $commonality) {
                if (isset($and[$ngram])) {
                    $_and[$ngram] = $and[$ngram];
                }
            }
            $and = $_and;
        } else {
            $commonalities = null;
        }

        // Code for considering permissions
        if (($permissions_module !== null) && (!$GLOBALS['FORUM_DRIVER']->is_super_admin(get_member()))) {
            $g_or = get_permission_where_clause_groups(get_member());

            // this destroys mysqls query optimiser by forcing complexed OR's into the join, so we'll do this in PHP code
            /*$table .= ' LEFT JOIN ' . $db->get_table_prefix() . 'group_category_access z ON (' . db_string_equal_to('z.module_the_name', $permissions_module) . ' AND z.category_name=' . $permissions_field . (($g_or != '') ? (' AND ' . str_replace('group_id', 'z.group_id', $g_or)) : '') . ')';
            $where_clause .= ' AND ';
            $where_clause .= 'z.category_name IS NOT NULL';*/

            $cat_sql = '';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'group_category_access WHERE (' . $g_or . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_sql .= ' UNION ALL ';
            $cat_sql .= 'SELECT DISTINCT category_name FROM ' . $db->get_table_prefix() . 'member_category_access WHERE (member_id=' . strval(get_member()) . ' AND active_until>' . strval(time()) . ') AND ' . db_string_equal_to('module_the_name', $permissions_module);
            $cat_access = array_keys(list_to_map('category_name', $db->query($cat_sql, null, null, false, true)));

            if (empty($cat_access)) {
                return [];
            }

            $extra_join_clause .= ' AND ixxx.' . $index_permissions_field . ' IN (';
            foreach ($cat_access as $i => $cat) {
                if ($i != 0) {
                    $extra_join_clause .= ',';
                }
                if ($permissions_field_is_string) {
                    $extra_join_clause .= '\'' . db_escape_string($cat) . '\'';
                } else {
                    if (is_numeric($cat)) {
                        $extra_join_clause .= $cat;
                    }
                    // else should not be possible
                }
            }
            $extra_join_clause .= ')';
        }

        // Code for querying against each ngram
        $order_by_total_ngrams_matched = '';
        $order_by_occurrence_rates = '';
        $is_all_hard_joins = true;
        $i = 0;
        $open_brackets = 0;
        foreach ($search_token_sets as $set_type => $search_tokens) {
            foreach ($search_tokens as $ngram => $is_singular_ngram) {
                if ($is_singular_ngram) {
                    if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                        continue;
                    }

                    if (is_object($stemmer)) {
                        $ngram = $stemmer->stem($ngram);
                    }
                }

                $join_condition = '';
                $key_i = 0;
                foreach ($key_transfer_map as $content_table_field => $index_table_field) {
                    if ($key_i != 0) {
                        $join_condition .= ' AND ';
                    }
                    if ($i == 0) {
                        $join_condition .= 'i' . strval($i) . '.' . $index_table_field . '=r.' . $content_table_field;
                    } else {
                        $join_condition .= 'i' . strval($i) . '.' . $index_table_field . '=i0.' . $index_table_field;
                    }
                    $key_i++;
                }
                $join_condition .= ' AND i' . strval($i) . '.i_ngram=' . strval($this->crc($ngram));
                if (strpos(get_db_type(), 'mysql') !== false) {
                    $join_condition .= '/*' . str_replace('/', '\\', $ngram) . '*/';
                }
                $join_condition .= str_replace('ixxx.', 'i' . strval($i) . '.', $extra_join_clause);
                $join_condition .= ' AND ' . db_string_equal_to('i' . strval($i) . '.i_lang', $lang);
                if ($appearance_context !== null) {
                    $join_condition .= ' AND i_ac=' . strval($appearance_context);
                }

                if (($i == 0) || (!$use_imprecise_ordering) || ($set_type == 'fuzzy_and')) {
                    if ($set_type == 'and') {
                        $join_type = 'JOIN'; // Will enforce the AND implicitly
                    } else {
                        $join_type = 'LEFT JOIN';
                        $is_all_hard_joins = false;
                    }
                    $join .= ' ' . $join_type . ' ' . $db->get_table_prefix() . $index_table . ' i' . strval($i) . ' ON ' . $join_condition;

                    if ($set_type == 'not') {
                        $where_clause .= ' AND i' . strval($i) . '.i_ngram IS NULL';
                    }
                } else {
                    $where_clause .= ' AND ' . (($set_type == 'and') ? 'EXISTS' : 'NOT EXISTS') . ' (SELECT * FROM ' . $db->get_table_prefix() . $index_table . ' i' . strval($i) . ' WHERE ' . $join_condition;
                    $open_brackets++; // We keep opening up more brackets to stop the MySQL query optimiser doing whacky things, partly executing random sub-queries into temporary tables before the first join
                }

                if (($set_type != 'not') && ($order_by_total_ngrams_matched != '')) {
                    $order_by_total_ngrams_matched .= '+';

                    if (!$use_imprecise_ordering) {
                        $order_by_occurrence_rates .= '+';
                    }
                }

                if ($set_type != 'not') {
                    $order_by_total_ngrams_matched .= db_function('IFF', ['i' . strval($i) . '.i_ngram IS NULL', '0', '1']);

                    if (!$use_imprecise_ordering) {
                        $scaler = (isset($commonalities[$ngram]) ? float_to_raw_string($commonalities[$ngram], 10) : '1');
                        $order_by_occurrence_rates .= db_function('COALESCE', ['i' . strval($i) . '.i_occurrence_rate', '0']) . '*' . $scaler;
                    } elseif ($order_by_occurrence_rates == '') {
                        $order_by_occurrence_rates = 'i' . strval($i) . '.i_occurrence_rate';
                    }
                }

                $i++;
            }
        }
        while ($open_brackets > 0) {
            $open_brackets--;
            $where_clause .= ')';
        }

        if ($i == 0) {
            // This is important - if there are no words to index against, then security will not have run either
            return [];
        }

        if (!$is_all_hard_joins) {
            $where_clause .= ' AND ' . $order_by_total_ngrams_matched . '>0';
        }

        // Do querying...

        if ($use_imprecise_ordering) {
            $contextual_relevance_sql = $order_by_occurrence_rates; // Will just be the occurrence rate of the least common term
        } else {
            $contextual_relevance_sql = $order_by_total_ngrams_matched . ((($order_by_total_ngrams_matched == '') || ($order_by_occurrence_rates == '')) ? '' : '+') . $order_by_occurrence_rates; // $order_by_total_ngrams_matched will be the dominant factor (intended!) as it is an integer while $order_by_occurrence_rates cannot add to more than 1
        }
        if ($contextual_relevance_sql == '') {
            $contextual_relevance_sql = '1';
        }
        $select = 'r.*,' . $contextual_relevance_sql . ' AS contextual_relevance';

        // Rating ordering, via special encoding
        if (strpos($order, 'compound_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT SUM(rating-1) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS compound_rating';
            $order = 'compound_rating';
        }
        if (strpos($order, 'average_rating:') !== false) {
            list(, $rating_type, $meta_rating_id_field) = explode(':', $order);
            $select .= ',(SELECT AVG(rating) FROM ' . $db->get_table_prefix() . 'rating WHERE ' . db_string_equal_to('rating_for_type', $rating_type) . ' AND rating_for_id=' . db_cast($meta_rating_id_field, 'CHAR') . ') AS average_rating';
            $order = 'average_rating';
        }

        $t_rows_sql = 'SELECT ' . $select . ' FROM ' . $join . ' WHERE 1=1' . $where_clause . ' ORDER BY ' . $order . ' ' . $direction;

        if (get_param_integer('keep_show_query', 0) == 1) {
            attach_message($t_rows_sql, 'inform');
        }
        if (get_param_integer('keep_just_show_query', 0) == 1) {
            cms_ini_set('ocproducts.xss_detect', '0');
            header('Content-type: text/plain; charset=' . get_charset());
            exit($t_rows_sql);
        }

        // Useful for automated testing
        global $LAST_SEARCH_QUERY, $LAST_COUNT_QUERY;

        $LAST_SEARCH_QUERY = $t_rows_sql;
        $t_rows = $db->query($t_rows_sql, $max, $start);

        $t_count_sql = '(SELECT COUNT(*) FROM (';
        $t_count_sql .= 'SELECT 1 FROM ' . $join . ' WHERE 1=1' . $where_clause;
        $t_count_sql .= ' LIMIT 1000) counter)';
        $LAST_COUNT_QUERY = $t_count_sql;
        $t_count = $db->query_value_if_there($t_count_sql);
        $GLOBALS['TOTAL_SEARCH_RESULTS'] += $t_count;

        if ((get_param_integer('keep_show_query', 0) == 1) && (($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())) || ($GLOBALS['IS_ACTUALLY_ADMIN']))) {
            if ((array_key_exists(0, $t_rows)) && (array_key_exists('id', $t_rows[0]))) {
                $results = var_export(array_unique(collapse_1d_complexity('id', $t_rows)), true);
            } else {
                $results = var_export($t_rows, true);
            }
            attach_message(do_lang('COUNT_RESULTS') . ': ' . $results, 'inform');
        }

        return $t_rows;
    }

    /**
     * Find if we have to join in custom fields due to filtering.
     *
     * @return boolean Whether we have special filtering
     */
    public function active_search_has_special_filtering()
    {
        foreach ($_GET as $key => $val) {
            if ((substr($key, 0, 7) == 'option_') && ($val != '')) {
                return true;
            }
        }
        return false;
    }

    /**
     * Helper function for hooks, used to get catalogue entry data (useful also for custom fields).
     *
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  string $c_name Catalogue codename
     * @param  integer $id Catalogue entry ID
     * @param  ?LANGUAGE_NAME $lang Language codename (null: default)
     */
    public function get_content_fields_from_catalogue_entry(&$content_fields, &$fields_to_index, $c_name, $id, $lang = null)
    {
        require_code('catalogues');

        $map = get_catalogue_entry_field_values($c_name, $id, null, null, false, 'PAGE', $lang);
        $i = 0;
        foreach ($map as $field) {
            if (is_string($field['effective_value_pure'])) {
                $fields_to_index['field_' . strval($i)] = ($i == 0) ? APPEARANCE_CONTEXT_TITLE : APPEARANCE_CONTEXT_BODY;
                $content_fields['field_' . strval($i)] = $field['effective_value_pure'];
            }
            $i++;
        }
    }

    /**
     * Helper function for hooks, used to generate SQL for filtering rows by timestamp.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $since_index_fields List of fields which contain timestamps that we use for recency checks
     * @param  ?TIME $since Filter to records with recency since this timestamp (null: no limit)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return string Extra SQL
     */
    public function generate_since_where_clause($db, $index_table, $since_index_fields, $since, &$statistics_map = null)
    {
        $where_clauses = [];

        if ($since !== null) {
            $test = $db->query_select_value_if_there($index_table, '1 AS test');
            if ($test !== null) {
                foreach ($since_index_fields as $field => $may_be_null) {
                    if ($may_be_null) {
                        $where_clause = $field . ' IS NOT NULL AND ' . $field . '>' . strval($since);
                    } else {
                        $where_clause = $field . '>' . strval($since);
                    }
                    $where_clauses[] = $where_clause;
                }

                // We nullify $statistics_map as it's useless if we're not doing a full indexing
                $statistics_map = null;
            }
            // else: If the table has been truncated we treat that as a signal to do a full regeneration
        }

        if (empty($where_clauses)) {
            return '';
        }

        return ' AND (' . implode(' OR ', $where_clauses) . ')';
    }

    // Indexing...

    /**
     * Index a content resource.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_transfer_map A map between content field keys to index field keys, so we can clear out old indexing for the content resource
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @param  ?LANGUAGE_NAME $lang Passed content is for this specific language only (null: lookup for all installed languages)
     * @param  boolean $clean_scan If we are doing a clean scan and hence do not need to clean up old records
     */
    public function index_for_search($db, $index_table, $content_fields, $fields_to_index, $key_transfer_map, $filter_field_transfer_map, &$total_singular_ngram_tokens = null, &$statistics_map = null, $lang = null, $clean_scan = false)
    {
        // Clear out any previous indexing for this content resource
        $key_map = [];
        foreach ($key_transfer_map as $content_table_field => $index_table_field) {
            $key_map[$index_table_field] = $content_fields[$content_table_field];
        }
        if (!$clean_scan) {
            if ($lang === null) {
                $db->query_delete($index_table, $key_map);
            } else {
                $db->query_delete($index_table, $key_map + ['i_lang' => $lang]); // We're calling this method language-by-language
            }
        }

        if ($lang === null) {
            $langs = multi_lang_content() ? array_keys(find_all_langs()) : [get_site_default_lang()];
        } else {
            $langs = [$lang];
        }

        foreach ($langs as $lang) {
            if ($statistics_map !== null) {
                if (!array_key_exists($lang, $statistics_map)) {
                    $statistics_map[$lang] = [];
                }
            }

            $ngrams_for = [];
            foreach ([APPEARANCE_CONTEXT_TITLE, APPEARANCE_CONTEXT_META, APPEARANCE_CONTEXT_BODY] as $appearance_context) {
                $_fields_to_index = [];
                foreach ($fields_to_index as $field => $_appearance_context) {
                    if ($_appearance_context == $appearance_context) {
                        $_fields_to_index[] = $field;
                    }
                }

                if ($appearance_context == APPEARANCE_CONTEXT_BODY) {
                    $ngrams_exclude = $ngrams_for[APPEARANCE_CONTEXT_TITLE] + $ngrams_for[APPEARANCE_CONTEXT_META];
                } else {
                    $ngrams_exclude = [];
                }

                $ngrams_for[$appearance_context] = $this->index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $_fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);
            }
        }
    }

    /**
     * Index a content resource, specifically for a particular language and appearance context.
     *
     * @param  object $db Database connection
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  string $index_table Table containing our custom index
     * @param  array $content_fields Map of content fields, field name to data (may contain fake fields)
     * @param  integer $appearance_context An APPEARANCE_CONTEXT_* constant
     * @param  array $fields_to_index List of field names from $content_fields that should be indexed for ngram tokens
     * @param  array $key_map A map of keys for the index
     * @param  array $filter_field_transfer_map A map between content field keys to index field keys, so we can fill out some of the filtering that goes inside the index
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function index_for_search__lang__appearance_context($db, $lang, $index_table, $content_fields, $appearance_context, $fields_to_index, $key_map, $filter_field_transfer_map, $ngrams_exclude, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        $combined_text = '';
        foreach ($fields_to_index as $field) {
            $text = is_integer($content_fields[$field]) ? get_translated_text($content_fields[$field], $db, $lang) : $content_fields[$field];
            $combined_text .= ' ' . $text;
        }

        $ngrams = $this->tokenise_text($combined_text, $lang, $ngrams_exclude, $total_singular_ngram_tokens, $statistics_map);

        $fields = $key_map;

        // Add indexing row for each ngram
        foreach ($filter_field_transfer_map as $content_table_field => $index_table_field) {
            $fields[$index_table_field] = $content_fields[$content_table_field];
        }
        $insert_arr = [];
        $ngrams_crc = [];
        foreach ($ngrams as $ngram => $count) {
            $crc = $this->crc($ngram);
            if (isset($ngrams_crc[$crc])) {
                // CRC hash collision. Happens about 1 in 200,000 -- so we can ignore it from a UX perspective but we have to stop key collisions!s
                $ngrams_crc[$crc] += $count;
            } else {
                $ngrams_crc[$crc] = $count;
            }
        }
        foreach ($ngrams_crc as $crc => $count) {
            $fields_for_ngram = [
                'i_lang' => $lang,
                'i_ngram' => $crc,
                'i_ac' => $appearance_context,
                'i_occurrence_rate' => floatval($count) / floatval($total_singular_ngram_tokens),
            ] + $fields;

            // We are bulk-inserting, for speed
            if (empty($insert_arr)) {
                foreach ($fields_for_ngram as $key => $val) {
                    $insert_arr[$key] = [];
                }
            }
            foreach ($fields_for_ngram as $key => $val) {
                $insert_arr[$key][] = $val;
            }
        }

        if (!empty($insert_arr)) {
            $db->query_insert($index_table, $insert_arr);
        }

        return $ngrams;
    }

    /**
     * Clear out a content resource from the index.
     *
     * @param  object $db Database connection
     * @param  string $index_table Table containing our custom index
     * @param  array $index_key_map Map of index keys, defining what to delete
     */
    public function delete_from_index($db, $index_table, $index_key_map)
    {
        $db->query_delete($index_table, $index_key_map);
    }

    /**
     * Tokenise some text, so it can be indexed by token.
     *
     * @param  string $text The text
     * @param  LANGUAGE_NAME $lang Language codename
     * @param  ?array $ngrams_exclude A list of ngrams to explicitly exclude (used internally to stop repetitions across multiple APPEARANCE_CONTEXTs, ultimately required to stop row repetition in output) (null: none)
     * @param  ?integer $total_singular_ngram_tokens Maintain a count of singular ngrams (typically words) in here (null: do not maintain)
     * @param  ?array $statistics_map Write into this map of singular ngram (typically, words) to number of occurrences (null: do not maintain a map)
     * @return array Map between ngrams and number of occurrences
     */
    protected function tokenise_text($text, $lang, $ngrams_exclude = null, &$total_singular_ngram_tokens = null, &$statistics_map = null)
    {
        if (strpos($text, '&') !== false) {
            $text = html_entity_decode($text, ENT_QUOTES, get_charset());
        }

        static $max_ngram_size = null;
        if ($max_ngram_size === null) {
            $max_ngram_size = intval(get_value('fulltext_max_ngram_size', '1', true));
        }

        $tokeniser = self::get_tokeniser($lang);
        $stemmer = self::get_stemmer($lang);

        $ngrams = [];

        $_ngrams = $tokeniser->text_to_ngrams($text, $max_ngram_size, $total_singular_ngram_tokens);
        foreach ($_ngrams as $ngram => $is_singular_ngram) {
            if ($is_singular_ngram) {
                if ($statistics_map !== null) {
                    if (!isset($statistics_map[$lang][$ngram])) {
                        $statistics_map[$lang][$ngram] = 0;
                    }
                    $statistics_map[$lang][$ngram]++;
                }
            }

            if ($is_singular_ngram) {
                if ($this->singular_ngram_is_stop_word($ngram, $lang)) {
                    continue;
                }
            }

            if ($ngrams_exclude !== null) {
                if (isset($ngrams_exclude[$ngram])) {
                    continue;
                }
            }

            if ($is_singular_ngram) {
                if (is_object($stemmer)) {
                    $ngram = $stemmer->stem($ngram);
                }
            }

            if (!isset($ngrams[$ngram])) {
                $ngrams[$ngram] = 0;
            }
            $ngrams[$ngram]++;
        }

        return $ngrams;
    }

    /**
     * Find whether a singular ngram (typically a word) is a stop word (i.e. too banal to be indexed).
     *
     * @param  string $ngram Singular ngram
     * @param  LANGUAGE_NAME $lang Language codename
     * @return boolean Whether it is
     */
    protected function singular_ngram_is_stop_word($ngram, $lang)
    {
        static $stop_list = [];
        if (!array_key_exists($lang, $stop_list)) {
            require_code('textfiles');
            $stop_list[$lang] = array_flip(explode("\n", read_text_file('too_common_words', $lang)));
            unset($stop_list[$lang]['']);
        }
        return isset($stop_list[$lang][$ngram]);
    }


    /**
     * Load up the commonalities for some ngrams, with caching.
     *
     * @param  object $db Database connection
     * @param  array $ngrams List of ngrams
     * @return array Map between ngram and commonality
     */
    protected function load_commonalities($db, $ngrams)
    {
        static $cache = [];

        $commonality_query = 'SELECT * FROM ' . get_table_prefix() . 'ft_index_commonality WHERE ';
        $commonalities = [];
        $where = '';
        foreach ($ngrams as $ngram) {
            if (isset($cache[$ngram])) {
                $commonalities[$ngram] = $cache[$ngram];
            } else {
                if ($where != '') {
                    $where .= ' OR ';
                }
                $where .= db_string_equal_to('c_ngram', $ngram);
            }
        }
        if ($where != '') {
            $commonality_query .= $where;
            $results = collapse_2d_complexity('c_ngram', 'c_commonality', $db->query($commonality_query . ' ORDER BY c_commonality'));
            $commonalities += $results;
            $cache += $results;
        }
        return $commonalities;
    }

    /**
     * Get a tokeniser for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return object Tokeniser
     */
    public static function get_tokeniser($lang)
    {
        static $tokeniser = [];
        if (!array_key_exists($lang, $tokeniser)) {
            if (((is_file(get_file_base() . '/sources/lang_tokeniser_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/tokeniser_' . $lang . '.php'))) && (!in_safe_mode())) {
                require_code('lang_tokeniser_' . $lang);
                $tokeniser[$lang] = object_factory('LangTokeniser_' . $lang);
            } else {
                require_code('lang_tokeniser_' . fallback_lang());
                $tokeniser[$lang] = object_factory('LangTokeniser_' . fallback_lang());
            }
        }
        return $tokeniser[$lang];
    }

    /**
     * Get a stemmer for a language.
     *
     * @param  LANGUAGE_NAME $lang Language codename
     * @return ?object Stemmer (null: none)
     */
    public static function get_stemmer($lang)
    {
        static $stemmer = [];
        if (!array_key_exists($lang, $stemmer)) {
            $stemmer[$lang] = null;
            if (((is_file(get_file_base() . '/sources/lang_stemmer_' . $lang . '.php')) || (is_file(get_file_base() . '/sources_custom/lang_stemmer_' . $lang . '.php'))) && (!in_safe_mode())) {
                if (get_value('fulltext_do_stemming', '1', true) === '1') {
                    require_code('lang_stemmer_' . $lang);
                    $stemmer[$lang] = object_factory('Stemmer_' . $lang);
                }
            }
        }
        return $stemmer[$lang];
    }

    /**
     * Calculate a CRC, effectively converting a string ngram to an integer hash of it.
     * CRC-24 algorithm, to avoid compatibility issues with PHP's crc32.
     *
     * @param  string $str String
     * @return integer CRC
     */
    protected function crc($str)
    {
        static $ob = null;
        if ($ob === null) {
            require_code('crc24');
            $ob = new CRC24();
        }
        return $ob->calculate($str);
    }
}

/**
 * Base class for catalogue search / custom content fields search.
 *
 * @package search
 */
abstract class FieldsSearchHook
{
    /**
     * Get a list of extra sort fields.
     *
     * @param  string $catalogue_name Catalogue we are searching in in (may be a special custom content fields catalogue)
     * @return array A map between parameter name and string label
     */
    protected function _get_extra_sort_fields($catalogue_name)
    {
        static $EXTRA_SORT_FIELDS_CACHE = [];
        if (array_key_exists($catalogue_name, $EXTRA_SORT_FIELDS_CACHE)) {
            return $EXTRA_SORT_FIELDS_CACHE[$catalogue_name];
        }

        $extra_sort_fields = [];

        if (addon_installed('catalogues')) {
            require_code('fields');

            $rows = $GLOBALS['SITE_DB']->query_select('catalogue_fields', ['id', 'cf_name', 'cf_type', 'cf_default', 'cf_order'], ['c_name' => $catalogue_name, 'cf_is_sortable' => 1, 'cf_visible' => 1], 'ORDER BY cf_order,' . $GLOBALS['SITE_DB']->translate_field_ref('cf_name'));
            foreach ($rows as $i => $row) {
                $ob = get_fields_hook($row['cf_type']);
                $temp = $ob->inputted_to_sql_for_search($row, $i);
                if ($temp === null) { // Standard direct 'substring' search
                    $extra_sort_fields['f' . strval($i) . '_actual_value'] = get_translated_text($row['cf_name']);
                }
            }
        }

        $EXTRA_SORT_FIELDS_CACHE[$catalogue_name] = $extra_sort_fields;

        return $extra_sort_fields;
    }

    /**
     * Get a list of extra fields to ask for.
     *
     * @param  string $catalogue_name Catalogue to search in (may be a special custom content fields catalogue)
     * @return array A list of maps specifying extra fields
     */
    protected function _get_fields($catalogue_name)
    {
        if (!addon_installed('catalogues')) {
            return [];
        }

        $fields = [];
        $rows = $GLOBALS['SITE_DB']->query_select('catalogue_fields', ['*'], ['c_name' => $catalogue_name, 'cf_allow_template_search' => 1, 'cf_visible' => 1], 'ORDER BY cf_order,' . $GLOBALS['SITE_DB']->translate_field_ref('cf_name'));
        require_code('fields');
        foreach ($rows as $row) {
            $ob = get_fields_hook($row['cf_type']);
            $temp = $ob->get_search_inputter($row);
            if ($temp === null) {
                $type = '_TEXT';
                $special = get_param_string('option_' . strval($row['id']), '', INPUT_FILTER_GET_COMPLEX);
                $extra = '';
                $display = get_translated_text($row['cf_name']);
                $fields[] = ['NAME' => strval($row['id']) . $extra, 'DISPLAY' => $display, 'TYPE' => $type, 'SPECIAL' => $special];
            } else {
                $fields[] = $temp;
            }
        }
        return $fields;
    }

    /**
     * Get details needed (SQL etc) to perform an advanced field search.
     *
     * @param  string $catalogue_name Catalogue we are searching in in (may be a special custom content fields catalogue)
     * @param  string $table_alias Table alias for main content table
     * @return ?array A big tuple of details used to search with (null: no fields)
     */
    protected function _get_search_parameterisation_advanced($catalogue_name, $table_alias = 'r')
    {
        if (!addon_installed('catalogues')) {
            return null;
        }

        $where_clause = '';

        $fields = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . get_table_prefix() . 'catalogue_fields WHERE ' . db_string_equal_to('c_name', $catalogue_name) . ' AND (cf_include_in_main_search = 1 OR cf_allow_template_search = 1) ORDER BY cf_order,' . $GLOBALS['SITE_DB']->translate_field_ref('cf_name'), null, 0, false, false, ['cf_name' => 'SHORT_TRANS']);
        if (empty($fields)) {
            return null;
        }

        $table = '';
        $trans_fields = ['!' => '!'];
        $nontrans_fields = [];
        $title_field = null;
        require_code('fields');
        foreach ($fields as $i => $field) {
            $ob = get_fields_hook($field['cf_type']);
            $include_in_main_search = $field['cf_include_in_main_search'] == 1;
            $allow_template_search = $field['cf_allow_template_search'] == 1;
            $temp = null;
            if ($allow_template_search) {
                $temp = $ob->inputted_to_sql_for_search($field, $i, $table_alias);
            }
            if ($temp === null) { // Standard direct 'substring' search
                list(, , $row_type) = $ob->get_field_value_row_bits($field);
                switch ($row_type) {
                    case 'long_trans':
                        if ($include_in_main_search) {
                            $trans_fields['f' . strval($i) . '.cv_value'] = 'LONG_TRANS__COMCODE';
                        }
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_long_trans f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        if (multi_lang_content()) {
                            $search_field = 't' . strval(count($trans_fields) - 1) . '.text_original';
                        } else {
                            $search_field = 'f' . strval($i) . '.cv_value';
                        }
                        break;
                    case 'short_trans':
                        if ($include_in_main_search) {
                            $trans_fields['f' . strval($i) . '.cv_value'] = 'SHORT_TRANS__COMCODE';
                        }
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_short_trans f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        if (multi_lang_content()) {
                            $search_field = 't' . strval(count($trans_fields) - 1) . '.text_original';
                        } else {
                            $search_field = 'f' . strval($i) . '.cv_value';
                        }
                        break;
                    case 'long':
                        if ($include_in_main_search) {
                            $nontrans_fields[] = 'f' . strval($i) . '.cv_value';
                        }
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_long f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        if (multi_lang_content()) {
                            $search_field = 't' . strval(count($trans_fields) - 1) . '.text_original';
                        } else {
                            $search_field = 'f' . strval($i) . '.cv_value';
                        }
                        break;
                    case 'short':
                        if ($include_in_main_search) {
                            $nontrans_fields[] = 'f' . strval($i) . '.cv_value';
                        }
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_short f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        $search_field = 'f' . strval($i) . '.cv_value';
                        break;
                    case 'float':
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_float f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        $search_field = 'f' . strval($i) . '.cv_value';
                        break;
                    case 'integer':
                        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_efv_integer f' . strval($i) . ' ON f' . strval($i) . '.ce_id=' . $table_alias . '.id AND f' . strval($i) . '.cf_id=' . strval($field['id']);
                        $search_field = 'f' . strval($i) . '.cv_value';
                        break;
                }

                if ($allow_template_search) {
                    $range_search = (option_value_from_field_array($field, 'range_search', 'off') == 'on');
                    if ($range_search) {
                        if (method_exists($ob, 'get_search_filter_from_env')) {
                            list($from, $to) = explode(';', $ob->get_search_filter_from_env($field));
                        } else {
                            $from = get_param_string('option_' . strval($field['id']) . '_from', '');
                            $to = get_param_string('option_' . strval($field['id']) . '_to', '');
                        }
                        if ($from != '' || $to != '') {
                            if ($from == '') {
                                $from = $to;
                            }
                            if ($to == '') {
                                $to = $from;
                            }

                            $where_clause .= ' AND ';

                            if (is_numeric($from) && is_numeric($to)) {
                                $where_clause .= $search_field . '>=' . $from . ' AND ' . $search_field . '<=' . $to;
                            } else {
                                $where_clause .= $search_field . '>=\'' . db_escape_string($from) . '\' AND ' . $search_field . '<=\'' . db_escape_string($to) . '\'';
                            }
                        }
                    } else {
                        if (method_exists($ob, 'get_search_filter_from_env')) {
                            $param = $ob->get_search_filter_from_env($field);
                        } else {
                            $param = get_param_string('option_' . strval($field['id']), '', INPUT_FILTER_GET_COMPLEX);
                        }

                        if ($param != '') {
                            $where_clause .= ' AND ';

                            if (substr($param, 0, 1) == '=') {
                                $where_clause .= db_string_equal_to($search_field, substr($param, 1));
                            } elseif ($row_type == 'integer' || $row_type == 'float') {
                                if (is_numeric($param)) {
                                    $where_clause .= $search_field . '=' . $param;
                                } else {
                                    $where_clause .= db_string_equal_to($search_field, $param);
                                }
                            } else {
                                if (($GLOBALS['SITE_DB']->has_full_text()) && ($GLOBALS['SITE_DB']->has_full_text_boolean()) && (!is_under_radar($param))) {
                                    $temp = $GLOBALS['SITE_DB']->full_text_assemble($param, true);
                                } else {
                                    list($temp,) = db_like_assemble($param);
                                }
                                $where_clause .= preg_replace('#\?#', $search_field, $temp);
                            }
                        }
                    }
                }
            } else {
                $table .= $temp[2];
                $search_field = $temp[3];
                if ($temp[4] != '') {
                    $where_clause .= ' AND ';
                    $where_clause .= $temp[4];
                } else {
                    $trans_fields = array_merge($trans_fields, $temp[0]);
                    $nontrans_fields = array_merge($nontrans_fields, $temp[1]);
                }
            }
            if ($i == 0) {
                $title_field = $search_field;
            }
        }

        $where_clause .= ' AND ';
        if ($catalogue_name[0] == '_') {
            $where_clause .= '(' . db_string_equal_to($table_alias . '.c_name', $catalogue_name) . ' OR ' . $table_alias . '.c_name IS NULL' . ')';
        } else {
            $where_clause .= db_string_equal_to($table_alias . '.c_name', $catalogue_name);
        }

        return [$table, $where_clause, $trans_fields, $nontrans_fields, $title_field];
    }

    /**
     * Get details needed (SQL etc) to perform an advanced field search for custom content fields (builds on _get_search_parameterisation_advanced).
     *
     * @param  string $catalogue_name Catalogue we are searching in in (may be a special custom content fields catalogue)
     * @param  string $table Table clause to add to
     * @param  string $where_clause Where clause to add to
     * @param  array $trans_fields Translatable fields to add to
     * @param  array $nontrans_fields Non-translatable fields to add to
     * @param  ?string $content_id_field Content-ID field (null: default r.id field)
     */
    protected function _get_search_parameterisation_advanced_for_content_type($catalogue_name, &$table, &$where_clause, &$trans_fields, &$nontrans_fields, $content_id_field = null)
    {
        $advanced = $this->_get_search_parameterisation_advanced($catalogue_name, 'ce');
        if ($advanced === null) {
            return;
        }

        if ($content_id_field === null) {
            $content_id_field = db_cast('r.id', 'CHAR');
        }

        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_entry_linkage l ON l.content_id=' . $content_id_field . ' AND ' . db_string_equal_to('content_type', substr($catalogue_name, 1));
        $table .= ' LEFT JOIN ' . $GLOBALS['SITE_DB']->get_table_prefix() . 'catalogue_entries ce ON ce.id=l.catalogue_entry_id';

        list($sup_table, $sup_where_clause, $sup_trans_fields, $sup_nontrans_fields) = $advanced;
        $table .= $sup_table;
        $where_clause .= $sup_where_clause;
        $trans_fields = array_merge($trans_fields, $sup_trans_fields);
        $nontrans_fields = array_merge($nontrans_fields, $sup_nontrans_fields);
    }

    /**
     * Insert a date range check into a WHERE clause.
     *
     * @param  mixed $cutoff Cutoff date (TIME or a pair representing the range)
     * @param  string $field The field name of the timestamp field in the database
     * @param  string $where_clause Additional where clause will be written into here
     */
    protected function _handle_date_check($cutoff, $field, &$where_clause)
    {
        if ($cutoff !== null) {
            if (is_integer($cutoff)) {
                $where_clause .= ' AND ' . $field . '>' . strval($cutoff);
            } elseif (is_array($cutoff)) {
                if ($cutoff[0] !== null) {
                    $where_clause .= ' AND ' . $field . '>=' . strval($cutoff[0]);
                }
                if ($cutoff[1] !== null) {
                    $where_clause .= ' AND ' . $field . '<=' . strval($cutoff[1]);
                }
            }
        }
    }

    /**
     * Do a date range check for a known timestamp.
     *
     * @param  mixed $cutoff Cutoff date (TIME or a pair representing the range)
     * @param  TIME $compare Timestamp to compare to
     * @return boolean Whether the date matches the requirements of $cutoff
     */
    protected function _handle_date_check_runtime($cutoff, $compare)
    {
        if ($cutoff !== null) {
            if (is_integer($cutoff)) {
                if ($compare < $cutoff) {
                    return false;
                }
            } elseif (is_array($cutoff)) {
                if ((($cutoff[0] !== null) && ($compare < $cutoff[0])) || (($cutoff[1] !== null) && ($compare > $cutoff[1]))) {
                    return false;
                }
            }
        }
        return true;
    }
}

/**
 * Find whether a phrase is too small for fulltext search.
 *
 * @param  string $test The phrase
 * @return boolean Whether it is
 */
function is_under_radar($test)
{
    if (get_option('enable_boolean_search') == '0') {
        return false;
    }

    return (strlen($test) < $GLOBALS['SITE_DB']->get_minimum_search_length()) && ($test != '');
}

/**
 * Find autocomplete suggestions to complete a partially-typed search request.
 *
 * @param  string $request Search request
 * @param  ID_TEXT $search_type The search type it is for (blank: N/A)
 * @return array List of suggestions
 */
function find_search_suggestions($request, $search_type = '')
{
    $suggestions = [];

    if (strlen($request) < MINIMUM_AUTOCOMPLETE_LENGTH) {
        return $suggestions;
    }

    // NB: We only bind to string starts for our matches, as this is indexable in the DB. Mid-match is too slow due to non-indexed.

    // Based on past searches
    if (has_privilege(get_member(), 'autocomplete_past_search')) {
        $q = 'SELECT s_primary AS search FROM ' . get_table_prefix() . 'searches_logged WHERE ';
        if (($GLOBALS['SITE_DB']->has_full_text()) && ($GLOBALS['SITE_DB']->has_full_text_boolean()) && (!is_under_radar($request))) {
            $q .= preg_replace('#\?#', 's_primary', $GLOBALS['SITE_DB']->full_text_assemble($request, false));
        } else {
            $q .= 's_primary LIKE \'' . db_encode_like($request . '%') . '\'';
        }
        $q .= ' AND s_primary NOT LIKE \'' . db_encode_like('%<' . '%') . '\'';
        $q .= ' AND ' . db_string_not_equal_to('s_primary', '');
        $q .= ' GROUP BY s_primary HAVING COUNT(*)>' . strval(MINIMUM_AUTOCOMPLETE_PAST_SEARCH);
        $q .= ' ORDER BY COUNT(*) DESC';
        $rows = $GLOBALS['SITE_DB']->query($q, MAXIMUM_AUTOCOMPLETE_SUGGESTIONS);
        foreach ($rows as $search) {
            if (count($suggestions) < MAXIMUM_AUTOCOMPLETE_SUGGESTIONS) {
                $suggestions[$search['search']] = true;
            }
        }
    }

    if ($search_type != '') {
        require_code('content');
        $feedback_type = convert_composr_type_codes('search_hook', $search_type, 'feedback_type_code');

        if ($feedback_type != '') {
            $content_type = convert_composr_type_codes('search_hook', $search_type, 'content_type');

            // Based on keywords
            if ((has_privilege(get_member(), 'autocomplete_keyword_' . $content_type)) && (count($suggestions) < MAXIMUM_AUTOCOMPLETE_SUGGESTIONS)) {
                $q = 'SELECT ' . $GLOBALS['SITE_DB']->translate_field_ref('meta_keyword') . ' FROM ' . get_table_prefix() . 'seo_meta_keywords';
                $q .= ' WHERE ' . $GLOBALS['SITE_DB']->translate_field_ref('meta_keyword') . ' LIKE \'' . db_encode_like($request . '%') . '\'';
                $q .= ' AND ' . db_string_equal_to('meta_for_type', $feedback_type);
                $q .= ' GROUP BY ' . $GLOBALS['SITE_DB']->translate_field_ref('meta_keyword');
                $q .= ' ORDER BY COUNT(*) DESC';
                $rows = $GLOBALS['SITE_DB']->query($q, MAXIMUM_AUTOCOMPLETE_SUGGESTIONS, 0, false, false, ['meta_keyword' => 'SHORT_TRANS']);
                foreach ($rows as $search) {
                    if (count($suggestions) < MAXIMUM_AUTOCOMPLETE_SUGGESTIONS) {
                        $suggestions[$search['meta_keyword']] = true;
                    }
                }
            }

            // Based on content titles
            if ((has_privilege(get_member(), 'autocomplete_title_' . $content_type)) && (count($suggestions) < MAXIMUM_AUTOCOMPLETE_SUGGESTIONS)) {
                $cma_ob = get_content_object($content_type);
                $cma_info = $cma_ob->info();

                $title_field = $cma_info['title_field'];
                if (is_array($title_field)) {
                    $title_field = array_pop($title_field); // Anything ahead is just stuff we need to preload for the "CALL:" to work
                }

                if (strpos($title_field, 'CALL:') === false) {
                    if ($cma_info['title_field_dereference']) {
                        $q = 'SELECT ' . $GLOBALS['SITE_DB']->translate_field_ref($title_field) . ' AS search FROM ' . get_table_prefix() . $cma_info['table'];
                        if ($GLOBALS['SITE_DB']->has_full_text()) {
                            $q .= ' WHERE ' . preg_replace('#\?#', $GLOBALS['SITE_DB']->translate_field_ref($title_field), $GLOBALS['SITE_DB']->full_text_assemble(str_replace('?', '', $request), false));
                        } else {
                            $q .= ' WHERE ' . $GLOBALS['SITE_DB']->translate_field_ref($title_field) . ' LIKE \'' . db_encode_like($request . '%') . '\'';
                        }
                        $q .= ' GROUP BY ' . $GLOBALS['SITE_DB']->translate_field_ref($title_field);
                        $q .= ' ORDER BY COUNT(*) DESC';
                        $rows = $GLOBALS['SITE_DB']->query($q, MAXIMUM_AUTOCOMPLETE_SUGGESTIONS, 0, false, false, [$title_field => 'SHORT_TRANS']);
                    } else {
                        $q = 'SELECT ' . $title_field . ' AS search FROM ' . get_table_prefix() . $cma_info['table'];
                        if ($GLOBALS['SITE_DB']->has_full_text()) {
                            $q .= ' WHERE ' . preg_replace('#\?#', $title_field, $GLOBALS['SITE_DB']->full_text_assemble(str_replace('?', '', $request), false));
                        } else {
                            $q .= ' WHERE ' . $title_field . ' LIKE \'' . db_encode_like($request . '%') . '\'';
                        }
                        $q .= ' GROUP BY ' . $title_field;
                        $q .= ' ORDER BY COUNT(*) DESC';
                        $rows = $GLOBALS['SITE_DB']->query($q, MAXIMUM_AUTOCOMPLETE_SUGGESTIONS);
                    }
                    foreach ($rows as $search) {
                        if (count($suggestions) < MAXIMUM_AUTOCOMPLETE_SUGGESTIONS) {
                            $suggestions[$search['search']] = true;
                        }
                    }
                } else {
                    // Cannot do for catalogues. Would need to analyse the catalogue and focus only on a single one.
                    // Recommendation is to write custom content types if you need advanced features like autocomplete.
                }
            }
        }
    }

    return array_keys($suggestions);
}

/**
 * Generate a search block.
 *
 * @param  array $map Search block parameters
 * @return array Search block template parameters
 */
function do_search_block($map)
{
    require_lang('search');
    require_css('search');
    require_javascript('ajax_people_lists');

    $zone = array_key_exists('zone', $map) ? $map['zone'] : get_module_zone('search');

    $title = array_key_exists('title', $map) ? $map['title'] : null;
    if ($title === null) {
        $title = do_lang('SEARCH');
    }

    $sort = array_key_exists('sort', $map) ? $map['sort'] : 'relevance';
    $author = array_key_exists('author', $map) ? $map['author'] : '';
    $days = array_key_exists('days', $map) ? intval($map['days']) : -1;
    $direction = array_key_exists('direction', $map) ? $map['direction'] : 'DESC';
    $only_titles = (array_key_exists('only_titles', $map) ? $map['only_titles'] : '') == '1';
    $only_search_meta = (array_key_exists('only_search_meta', $map) ? $map['only_search_meta'] : '0') == '1';
    $boolean_search = (array_key_exists('boolean_search', $map) ? $map['boolean_search'] : '0') == '1';
    $conjunctive_operator = array_key_exists('conjunctive_operator', $map) ? $map['conjunctive_operator'] : 'AND';
    $_extra = array_key_exists('extra', $map) ? $map['extra'] : '';

    $map2 = ['page' => 'search', 'type' => 'results'];
    if (array_key_exists('search_under', $map)) {
        $map2['search_under'] = $map['search_under'];
    }
    $url = build_url($map2, $zone, [], false, true);

    $extra = [];
    foreach (explode(',', $_extra) as $_bits) {
        $bits = explode('=', $_bits, 2);
        if (count($bits) == 2) {
            $extra[$bits[0]] = $bits[1];
        }
    }

    $input_fields = ['content' => do_lang('SEARCH_TITLE')];
    if (array_key_exists('input_fields', $map)) {
        $input_fields = [];
        foreach (explode(',', $map['input_fields']) as $_bits) {
            $bits = explode('=', $_bits, 2);
            if (count($bits) == 2) {
                $input_fields[$bits[0]] = $bits[1];
            }
        }
    }

    $search_types = [];

    $limit_to = ['all_defaults'];
    $extrax = [];
    if ((array_key_exists('limit_to', $map)) && ($map['limit_to'] != 'all_defaults')) {
        $limit_to = [];
        $map['limit_to'] = str_replace('|', ',', $map['limit_to']); // "|" looks cleaner in templates
        foreach (explode(',', $map['limit_to']) as $key) {
            $limit_to[] = 'search_' . $key;
            if (strpos($map['limit_to'], ',') !== false) {
                $extrax['search_' . $key] = '1';
                $search_types[] = $key;
            }
        }
        $hooks = find_all_hooks('modules', 'search');
        foreach (array_keys($hooks) as $key) {
            if (!array_key_exists('search_' . $key, $extrax)) {
                $extrax['search_' . $key] = '0';
            }
        }
        if (strpos($map['limit_to'], ',') === false) {
            $extra['id'] = $map['limit_to'];
        }
    }

    $url_map = $map;
    unset($url_map['input_fields']);
    unset($url_map['extra']);
    unset($url_map['zone']);
    unset($url_map['title']);
    unset($url_map['limit_to']);
    unset($url_map['block']);
    $full_url = build_url(['page' => 'search', 'type' => 'browse'] + $url_map + $extra + $extrax, $zone);

    if ((!array_key_exists('content', $input_fields)) && (count($input_fields) != 1)) {
        $extra['content'] = '';
    }

    $options = [];
    if ((count($limit_to) == 1) && ($limit_to[0] != 'all_defaults')) { // If we are doing a specific hook
        $id = preg_replace('#^search_#', '', $limit_to[0]);

        require_code('hooks/modules/search/' . filter_naughty_harsh($id, true));
        $object = object_factory('Hook_search_' . filter_naughty_harsh($id, true));
        $info = $object->info();
        if (($info !== null) && ($info !== false)) {
            if (array_key_exists('special_on', $info)) {
                foreach ($info['special_on'] as $name => $display) {
                    $_name = 'option_' . $id . '_' . $name;
                    $options[$_name] = ['SEARCH_FOR_SEARCH_DOMAIN_OPTION', ['CHECKED' => (get_param_string('content', null, INPUT_FILTER_GET_COMPLEX) === null) || (get_param_integer($_name, 0) == 1), 'DISPLAY' => $display]];
                }
            }
            if (array_key_exists('special_off', $info)) {
                foreach ($info['special_off'] as $name => $display) {
                    $_name = 'option_' . $id . '_' . $name;
                    $options[$_name] = ['SEARCH_FOR_SEARCH_DOMAIN_OPTION', ['CHECKED' => (get_param_integer($_name, 0) == 1), 'DISPLAY' => $display]];
                }
            }
            if (method_exists($object, 'get_fields')) {
                $fields = $object->get_fields();
                foreach ($fields as $field) {
                    $_name = 'option_' . $field['NAME'];
                    $options[$_name] = ['SEARCH_FOR_SEARCH_DOMAIN_OPTION' . $field['TYPE'], ['DISPLAY' => $field['DISPLAY'], 'SPECIAL' => $field['SPECIAL'], 'CHECKED' => array_key_exists('checked', $field) ? $field['CHECKED'] : false]];
                }
            }
        }
    }

    $_input_fields = [];
    foreach ($input_fields as $key => $val) {
        $input = new Tempcode();
        if (isset($options['option_' . $key])) { // If there is an input option for this particular $key
            $tpl_params = $options['option_' . $key][1];
            $tpl_params['NAME'] = 'option_' . $key;
            if ($val != '') {
                $tpl_params['DISPLAY'] = $val;
            }
            $input = do_template($options['option_' . $key][0], $tpl_params);
        }
        $_input_fields[$key] = [
            'LABEL' => $val,
            'INPUT' => $input,
        ];
    }

    return [
        'TITLE' => $title,
        'INPUT_FIELDS' => $_input_fields,
        'EXTRA' => $extra,
        'SORT' => $sort,
        'AUTHOR' => $author,
        'DAYS' => strval($days),
        'DIRECTION' => $direction,
        'ONLY_TITLES' => $only_titles ? '1' : '0',
        'ONLY_SEARCH_META' => $only_search_meta ? '1' : '0',
        'BOOLEAN_SEARCH' => $boolean_search ? '1' : '0',
        'CONJUNCTIVE_OPERATOR' => $conjunctive_operator,
        'LIMIT_TO' => $limit_to,
        'URL' => $url,
        'FULL_SEARCH_URL' => $full_url,
        'SEARCH_TYPE' => (count($search_types) != 1) ? null : $search_types[0],
    ];
}
