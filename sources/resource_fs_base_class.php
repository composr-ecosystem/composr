<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    commandr
 */

/**
 * Resource-fs base class.
 *
 * @package commandr
 */
abstract class Resource_fs_base
{
    /*
    FINDING INFORMATION ABOUT HOOK STRUCTURE
    */

    public $folder_resource_type = null;
    public $file_resource_type = null;
    public $_cma_object = [];

    /**
     * Get the file resource info for this Commandr-fs resource hook.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @return array The info map
     */
    protected function _get_cma_info(string $resource_type) : array
    {
        if (!array_key_exists($resource_type, $this->_cma_object)) {
            require_code('content');
            $this->_cma_object[$resource_type] = get_content_object($resource_type);
        }
        return $this->_cma_object[$resource_type]->info();
    }

    /**
     * Find whether a resource type is of a folder-type.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @return boolean Whether it is
     */
    public function is_folder_type(string $resource_type) : bool
    {
        $folder_types = is_array($this->folder_resource_type) ? $this->folder_resource_type : (($this->folder_resource_type === null) ? [] : [$this->folder_resource_type]);
        return in_array($resource_type, $folder_types);
    }

    /**
     * Find whether a resource type is of a file-type.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @return boolean Whether it is
     */
    public function is_file_type(string $resource_type) : bool
    {
        $file_types = is_array($this->file_resource_type) ? $this->file_resource_type : (($this->file_resource_type === null) ? [] : [$this->file_resource_type]);
        return in_array($resource_type, $file_types);
    }

    /*
    HOOKS MUST DEFINE
    */

    /**
     * Standard Commandr-fs function for seeing how many resources are. Useful for determining whether to do a full rebuild.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @return integer How many resources there are
     */
    abstract public function get_resources_count(string $resource_type) : int;


    /**
     * Standard Commandr-fs function for searching for a resource by label.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  LONG_TEXT $label The resource label
     * @return array A list of resource IDs
     */
    abstract public function find_resource_by_label(string $resource_type, string $label) : array;


    /**
     * Standard Commandr-fs add function for resource-fs hooks. Adds some resource with the given label and properties.
     *
     * @param  LONG_TEXT $filename Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @param  ?ID_TEXT $force_type Resource type to try to force (null: do not force)
     * @return ~ID_TEXT The resource ID (false: error)
     */
    public function folder_add(string $filename, string $path, array $properties, ?string $force_type = null)
    {
        return false;
    }

    /**
     * Standard Commandr-fs load function for resource-fs hooks. Finds the properties for some resource.
     *
     * @param  SHORT_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable). It may be a wildcarded path, as the path is used for content-type identification only. Filenames are globally unique across a hook; you can calculate the path using ->search.
     * @return ~array Details of the resource (false: error)
     */
    public function folder_load(string $filename, string $path)
    {
        return false;
    }

    /**
     * Standard Commandr-fs edit function for resource-fs hooks. Edits the resource to the given properties.
     *
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @param  boolean $explicit_move Whether we are definitely moving (as opposed to possible having it in multiple positions)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function folder_edit(string $filename, string $path, array $properties, bool $explicit_move = false)
    {
        return false;
    }

    /**
     * Standard Commandr-fs delete function for resource-fs hooks. Deletes the resource.
     *
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @return boolean Success status
     */
    public function folder_delete(string $filename, string $path) : bool
    {
        return false;
    }

    /**
     * Standard Commandr-fs date fetch function for resource-fs hooks. Defined when getting an edit date is not easy.
     *
     * @param  array $row Resource row (not full, but does contain the ID)
     * @param  ID_TEXT $category Parent category (blank: root / not applicable)
     * @return ?TIME The edit date or add date, whichever is higher (null: could not find one)
     */
    protected function _get_file_edit_date(array $row, string $category = '') : ?int
    {
        return null;
    }

    /**
     * Standard Commandr-fs add function for resource-fs hooks. Adds some resource with the given label and properties.
     *
     * @param  LONG_TEXT $filename Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @param  ?ID_TEXT $force_type Resource type to try to force (null: do not force)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    abstract public function file_add(string $filename, string $path, array $properties, ?string $force_type = null);


    /**
     * Standard Commandr-fs load function for resource-fs hooks. Finds the properties for some resource.
     *
     * @param  SHORT_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable). It may be a wildcarded path, as the path is used for content-type identification only. Filenames are globally unique across a hook; you can calculate the path using ->search.
     * @return ~array Details of the resource (false: error)
     */
    abstract public function file_load(string $filename, string $path);


    /**
     * Standard Commandr-fs edit function for resource-fs hooks. Edits the resource to the given properties.
     *
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @param  boolean $explicit_move Whether we are definitely moving (as opposed to possible having it in multiple positions)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    abstract public function file_edit(string $filename, string $path, array $properties, bool $explicit_move = false);


    /**
     * Standard Commandr-fs delete function for resource-fs hooks. Deletes the resource.
     *
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @return boolean Success status
     */
    abstract public function file_delete(string $filename, string $path) : bool;


    /*
    HOOKS MAY OVERRIDE THESE AS REQUIRED, TO ENCODE IMPLEMENTATION COMPLEXITIES
    */

    /**
     * Whether the filesystem hook is active.
     *
     * @return boolean Whether it is
     */
    public function is_active() : bool
    {
        return true;
    }

    /**
     * Standard Commandr-fs date fetch function for resource-fs hooks. Defined when getting an edit date is not easy.
     *
     * @param  array $row Resource row (not full, but does contain the ID)
     * @param  ID_TEXT $category Parent category (blank: root / not applicable)
     * @return ?TIME The edit date or add date, whichever is higher (null: could not find one)
     */
    protected function _get_folder_edit_date(array $row, string $category = '') : ?int
    {
        return null;
    }

    /**
     * Whether the filesystem hook can handle a particular file type.
     *
     * @param  string $filetype The file type (no file extension)
     * @return array List of our resource types that can
     */
    public function can_accept_filetype(string $filetype) : array
    {
        if ($filetype != RESOURCE_FS_DEFAULT_EXTENSION) {
            return [];
        }

        $ret = [];
        if ($this->folder_resource_type !== null) {
            $ret = array_merge($ret, is_array($this->folder_resource_type) ? $this->folder_resource_type : [$this->folder_resource_type]);
        }
        if ($this->file_resource_type !== null) {
            $ret = array_merge($ret, is_array($this->file_resource_type) ? $this->file_resource_type : [$this->file_resource_type]);
        }
        return $ret;
    }

    /**
     * Find whether a kind of resource handled by this hook (folder or file) can be under a particular kind of folder.
     *
     * @param  ?ID_TEXT $above Folder resource type (null: root)
     * @param  ID_TEXT $under Resource type (may be file or folder)
     * @return ?array A map: The parent referencing field, the table it is in, and the ID field of that table (null: cannot be under)
     */
    protected function _has_parent_child_relationship(?string $above, string $under) : ?array
    {
        $sub_info = $this->_get_cma_info($under);
        if ($sub_info === null) {
            return null;
        }

        $is_file = $this->is_file_type($under);

        if ($is_file) {
            // If no folder types, files are top level
            if (($this->folder_resource_type === null) && ($above === null)) {
                return [
                    'cat_field' => null,
                    'linker_table' => null,
                    'id_field' => $sub_info['id_field'],
                    'id_field_linker' => $sub_info['id_field'],
                    'cat_field_numeric' => null,
                ];
            }

            // If there are folder types, files can not be top level
            if (($this->folder_resource_type !== null) && ($above === null)) {
                return null;
            }
        }

        if (array_key_exists('parent_category_field__resource_fs', $sub_info)) {
            $sub_info['parent_category_field'] = $sub_info['parent_category_field__resource_fs'];
        }
        if (!$is_file) {
            if (($sub_info['parent_category_field'] === null) && ($sub_info['parent_spec__field_name'] !== null)) { // Some fiddling, as we are smart enough to detect need for linker table
                $sub_info['parent_category_field'] = $sub_info['parent_spec__parent_name'];
            }
        }

        // If there is no category for $under, then it can only be top-level
        if ((!array_key_exists('parent_category_field', $sub_info)) || ($sub_info['parent_category_field'] === null)) {
            if ($above !== null) {
                return null;
            }
        }

        $folder_info = ($above === null) ? $sub_info : $this->_get_cma_info($above);

        if ($folder_info === null) {
            return null;
        }

        return [
            'cat_field' => $sub_info['parent_category_field'],
            'linker_table' => $is_file ? null : $sub_info['parent_spec__table_name'],
            'id_field' => $sub_info['id_field'],
            'id_field_linker' => $is_file ? null : $sub_info['parent_spec__field_name'],
            'cat_field_numeric' => $folder_info['id_field_numeric'],
        ];
    }

    /**
     * Load function for resource-fs (for files). Finds the data for some resource from a resource-fs file.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @return ~string Resource data (false: error)
     */
    public function file_load__flat(string $filename, string $path)
    {
        if ([] == $this->can_accept_filetype(get_file_extension($filename))) {
            return false;
        }
        return $this->file_load_json($filename, $path); // By default, only defer to the inbuilt JSON implementation (hooks may override this with support for other kinds of interchange file formats)
    }

    /**
     * Load function for resource-fs (for folders). Finds the data for some resource from a resource-fs folder.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @return ~string Resource data (false: error)
     */
    public function folder_load__flat(string $filename, string $path)
    {
        $ext = get_file_extension($filename);
        if ($ext != '') {
            if ([] == $this->can_accept_filetype($ext)) {
                return false;
            }
        }
        return $this->folder_load_json($filename, $path); // By default, only defer to the inbuilt JSON implementation (hooks may override this with support for other kinds of interchange file formats)
    }

    /**
     * Save function for resource-fs (for files). Parses the data for some resource to a resource-fs file.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  string $data Resource data
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function file_save__flat(string $filename, string $path, string $data)
    {
        // Files other stuff makes, we don't want auto-created junk files creating site/software content
        $all_disallowed = [
            '__macosx',
            'thumbs.db:encryptable',
            'thumbs.db',
            '.ds_store',
        ];
        foreach ($all_disallowed as $disallowed) {
            if (cms_strtolower_ascii($filename) == $disallowed) {
                return false;
            }
        }
        if (substr($filename, 0, 1) == '.') {
            return false;
        }

        if ([] == $this->can_accept_filetype(get_file_extension($filename))) {
            return false;
        }
        return $this->file_save_json($filename, $path, $data); // By default, only defer to the inbuilt JSON implementation (hooks may override this with support for other kinds of interchange file formats)
    }

    /**
     * Save function for resource-fs (for folders). Parses the data for some resource to a resource-fs folder.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  string $data Resource data
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function folder_save__flat(string $filename, string $path, string $data)
    {
        $ext = get_file_extension($filename);
        if ($ext != '') {
            if ([] == $this->can_accept_filetype($ext)) {
                return false;
            }
        }
        return $this->folder_save_json($filename, $path, $data); // By default, only defer to the inbuilt JSON implementation (hooks may override this with support for other kinds of interchange file formats)
    }

    /**
     * Reinterpret the input of a file, into a way we can understand it to add/edit. Hooks may override this with special import code.
     *
     * @param  LONG_TEXT $filename Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties
     * @param  ID_TEXT $resource_type The resource type
     * @return array A pair: the resource label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     */
    protected function _file_magic_filter(string $filename, string $path, array $properties, string $resource_type) : array
    {
        $label = basename($filename, '.' . RESOURCE_FS_DEFAULT_EXTENSION); // Default implementation is simply to assume the stub of the filename (or may be a raw label already, with no file type) is the resource label
        if (array_key_exists('label', $properties)) {
            $label = $properties['label']; // ...unless the label was explicitly given
        }

        $this->_resource_save_extend_pre($properties, $resource_type, $filename, $label);

        return [$properties, $label]; // Leave properties alone
    }

    /**
     * Reinterpret the input of a folder, into a way we can understand it to add/edit. Hooks may override this with special import code.
     *
     * @param  LONG_TEXT $filename Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties
     * @return array A pair: the resource label, Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     */
    protected function _folder_magic_filter(string $filename, string $path, array $properties) : array
    {
        return [$properties, $filename]; // Default implementation is simply to assume the filename is the resource label, and leave properties alone
    }

    /**
     * Get the filename for a resource ID. Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @return ?ID_TEXT The filename (null: could not find)
     */
    public function file_convert_id_to_filename(string $resource_type, string $resource_id) : ?string
    {
        $moniker = find_moniker_via_id($resource_type, $resource_id);
        if ($moniker === null) {
            return null;
        }
        return $moniker . '.' . RESOURCE_FS_DEFAULT_EXTENSION;
    }

    /**
     * Get the filename for a resource ID. Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @return ?ID_TEXT The filename (null: could not find)
     */
    public function folder_convert_id_to_filename(string $resource_type, string $resource_id) : ?string
    {
        return find_moniker_via_id($resource_type, $resource_id);
    }

    /**
     * Get the resource ID for a filename (of file). Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $filename The filename, or filepath
     * @param  ?ID_TEXT $resource_type The resource type (null: assumption of only one folder resource type for this hook; only passed as non-null from overridden functions within hooks that are calling this as a helper function)
     * @return ?array A pair: The resource type, the resource ID (null: could not find)
     */
    public function file_convert_filename_to_id(string $filename, ?string $resource_type = null) : ?array
    {
        if ($resource_type === null) {
            $resource_type = $this->file_resource_type;
        }

        $filename = preg_replace('#^.*/#', '', $filename); // Paths not needed, as filenames are globally unique; paths would not be in alternative_ids table

        $moniker = basename($filename, '.' . RESOURCE_FS_DEFAULT_EXTENSION); // Remove file extension from filename
        $resource_id = find_id_via_moniker($resource_type, $moniker);
        if ($resource_id === null) {
            $resource_id = find_id_via_label($resource_type, $moniker);
        }
        return [$resource_type, $resource_id];
    }

    /**
     * Get the resource ID for a filename (of folder). Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $filename The filename, or filepath
     * @param  ?ID_TEXT $resource_type The resource type (null: assumption of only one folder resource type for this hook; only passed as non-null from overridden functions within hooks that are calling this as a helper function)
     * @return array A pair: The resource type, the resource ID
     */
    public function folder_convert_filename_to_id(string $filename, ?string $resource_type = null) : array
    {
        if ($resource_type === null) {
            $resource_type = $this->folder_resource_type;
        }

        $moniker = preg_replace('#^.*/#', '', $filename); // Paths not needed, as filenames are globally unique; paths would not be in alternative_ids table

        $resource_id = find_id_via_moniker($resource_type, $moniker);
        return [$resource_type, $resource_id];
    }

    /*
    JUGGLING PROPERTIES
    */

    /**
     * Find a default string property, defaulting to blank.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?string The value (null: null value)
     */
    protected function _default_property_str(array $properties, string $property) : ?string
    {
        return array_key_exists($property, $properties) ? $properties[$property] : '';
    }

    /**
     * Find a default string property, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?string The value (null: null value)
     */
    protected function _default_property_str_null(array $properties, string $property) : ?string
    {
        return array_key_exists($property, $properties) ? $properties[$property] : null;
    }

    /**
     * Find an integer default property, defaulting to 0.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_int(array $properties, string $property) : ?int
    {
        if (!array_key_exists($property, $properties)) {
            return 0;
        }
        if ($properties[$property] === null) {
            return 0;
        }
        if (is_integer($properties[$property])) {
            return $properties[$property];
        }
        return intval($properties[$property]);
    }

    /**
     * Find an integer default property, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_int_null(array $properties, string $property) : ?int
    {
        if (!array_key_exists($property, $properties)) {
            return null;
        }
        if ($properties[$property] === null) {
            return null;
        }
        if (is_integer($properties[$property])) {
            return $properties[$property];
        }
        return intval($properties[$property]);
    }

    /**
     * Find a float default property, defaulting to 0.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?float The value (null: null value)
     */
    protected function _default_property_float(array $properties, string $property) : ?float
    {
        if (!array_key_exists($property, $properties)) {
            return 0.0;
        }
        if ($properties[$property] === null) {
            return 0.0;
        }
        if (is_float($properties[$property])) {
            return $properties[$property];
        }
        return floatval($properties[$property]);
    }

    /**
     * Find a default float property, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?float The value (null: null value)
     */
    protected function _default_property_float_null(array $properties, string $property) : ?float
    {
        if (!array_key_exists($property, $properties)) {
            return null;
        }
        if ($properties[$property] === null) {
            return null;
        }
        if (is_float($properties[$property])) {
            return $properties[$property];
        }
        return floatval($properties[$property]);
    }

    /**
     * Convert a category to an integer, defaulting to null if it is blank.
     *
     * @param  ?ID_TEXT $category The category value (blank: root) (null: root)
     * @return ?integer The category (null: root)
     */
    protected function _integer_category(?string $category) : ?int
    {
        if ($category === null) {
            return null;
        }
        return ($category == '') ? null : intval($category);
    }

    /**
     * Find a default property, defaulting to the average of what is there already, or the given default if really necessary.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @param  ID_TEXT $table The table to average within
     * @param  integer $default The last-resort default
     * @param  ?ID_TEXT $db_property The database property (null: same as $property)
     * @return integer The value
     */
    protected function _default_property_int_modeavg(array $properties, string $property, string $table, int $default, ?string $db_property = null) : int
    {
        if ($db_property === null) {
            $db_property = $property;
        }

        if (array_key_exists($property, $properties)) {
            if (is_integer($properties[$property])) {
                return $properties[$property];
            }
            return intval($properties[$property]);
        }

        static $cache = [];
        if (isset($cache[$property][$table][$default][$db_property])) {
            return $cache[$property][$table][$default][$db_property];
        }

        $db = get_db_for($table);
        $val = $db->query_value_if_there('SELECT ' . $db_property . ',count(' . $db_property . ') AS qty FROM ' . get_table_prefix() . $table . ' GROUP BY ' . $db_property . ' ORDER BY qty DESC', false, true); // We need the mode here, not the mean
        $ret = $default;
        if ($val !== null) {
            $ret = $val;
        }

        $cache[$property][$table][$default][$db_property] = $ret;

        return $ret;
    }

    /**
     * Find a default property for a timestamp, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_time_null(array $properties, string $property) : ?int
    {
        if (!isset($properties[$property])) {
            return null;
        }

        return $this->_default_property_time($properties, $property);
    }

    /**
     * Find a default property for a timestamp, defaulting to current time.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return integer The value
     */
    protected function _default_property_time(array $properties, string $property) : int
    {
        if (!isset($properties[$property])) {
            return time();
        }

        if (is_integer($properties[$property])) {
            return $properties[$property];
        }

        return remap_portable_as_time($properties[$property]);
    }

    /**
     * Find a default property for a member, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_member_null(array $properties, string $property) : ?int
    {
        if (!isset($properties[$property])) {
            return null;
        }

        return $this->_default_property_member($properties, $property);
    }

    /**
     * Find a default property for a member.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_member(array $properties, string $property) : ?int
    {
        if (!isset($properties[$property])) {
            return get_member();
        }

        if (is_integer($properties[$property])) {
            return $properties[$property];
        }

        $test = remap_portable_as_resource_id('member', $properties[$property]);
        if ($test === null) {
            return $test;
        }
        return intval($test);
    }

    /**
     * Find a default property for a usergroup, defaulting to null.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_group_null(array $properties, string $property) : ?int
    {
        if (!isset($properties[$property])) {
            return null;
        }

        return $this->_default_property_group($properties, $property);
    }

    /**
     * Find a default property for a usergroup.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?integer The value (null: null value)
     */
    protected function _default_property_group(array $properties, string $property) : ?int
    {
        if (!isset($properties[$property])) {
            $properties[$property] = db_get_first_id();
        }

        if (is_integer($properties[$property])) {
            return $properties[$property];
        }

        $test = remap_portable_as_resource_id('group', $properties[$property]);
        if ($test === null) {
            return $test;
        }
        return intval($test);
    }

    /**
     * Find a default property for a URL.
     *
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @param  boolean $ignore_conflicts Whether to ignore conflicts with existing files (=edit op, basically)
     * @return string The value
     */
    protected function _default_property_urlpath(array $properties, string $property, bool $ignore_conflicts = false) : string
    {
        if (empty($properties[$property])) {
            return '';
        }

        return remap_portable_as_urlpath($properties[$property], $ignore_conflicts);
    }

    /**
     * Find a default property for a foreign key, defaulting to null.
     *
     * @param  array $_table_referenced The table the key is to
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?mixed The value (null: null value)
     */
    protected function _default_property_foreign_key_null(array $_table_referenced, array $properties, string $property)
    {
        if (!isset($properties[$property])) {
            return null;
        }

        return $this->_default_property_foreign_key($_table_referenced, $properties, $property);
    }

    /**
     * Find a default property for a foreign key.
     *
     * @param  array $_table_referenced The table the key is to
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return mixed The value
     */
    protected function _default_property_foreign_key(array $_table_referenced, array $properties, string $property)
    {
        return remap_portable_as_foreign_key($_table_referenced, $properties[$property]);
    }

    /**
     * Find a default property for a resource, defaulting to null.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return ?mixed The value (null: null value)
     */
    protected function _default_property_resource_id_null(string $resource_type, array $properties, string $property)
    {
        if (!isset($properties[$property])) {
            return null;
        }

        return $this->_default_property_resource_id($resource_type, $properties, $property);
    }

    /**
     * Find a default property for a resource.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  array $properties The properties
     * @param  ID_TEXT $property The property
     * @return mixed The value
     */
    protected function _default_property_resource_id(string $resource_type, array $properties, string $property)
    {
        return remap_portable_as_resource_id($resource_type, $properties[$property]);
    }

    /**
     * Turn a label into a name.
     *
     * @param  LONG_TEXT $label The label
     * @return ID_TEXT The name
     */
    protected function _create_name_from_label(string $label) : string
    {
        $name = cms_strtolower_ascii($label);
        $name = preg_replace('#[^\w\.\-]#', '_', $name);
        $name = preg_replace('#_+\$#', '', $name);
        if ($name == '') {
            $name = 'unnamed';
        }
        require_code('urls2');
        $max_moniker_length = min(80, intval(get_option('max_moniker_length')));
        return substr($name, 0, $max_moniker_length);
    }

    /**
     * Helper function: detect if a resource did not save all the properties it was given.
     *
     * @param  ?ID_TEXT $resource_type The resource type (null: unknown)
     * @param  ~ID_TEXT $resource_id The resource ID (false: was not added/edited)
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties
     */
    protected function _log_if_save_matchup(?string $resource_type, $resource_id, string $path, array $properties)
    {
        if ($resource_type === null) {
            return; // Too difficult to check, don't bother; only expert coding would lead to this scenario anyway
        }
        if ($resource_id === false) {
            return;
        }

        global $RESOURCE_FS_LOGGER;
        if ($RESOURCE_FS_LOGGER === null) {
            return; // Too much unnecessarily work if the logger is not on
        }

        $ok = true;

        static $similar_ok_before = [];
        if ((isset($similar_ok_before[$resource_type][$path])) && ($similar_ok_before[$resource_type][$path] > 10)) {
            return;
        }

        $found_filename = $this->convert_id_to_filename($resource_type, $resource_id);
        $found_path = $this->search($resource_type, $resource_id, true);
        if ($found_path !== $path) {
            resource_fs_logging('Path mismatch for what was saved (actual ' . $found_path . ' vs intended ' . $path . ')', 'warn');
            $ok = false;
        }

        $actual_properties = $this->resource_load($resource_type, $found_filename, $found_path);
        foreach (array_keys($properties) as $p) {
            if (array_key_exists($p, $actual_properties)) {
                if (str_replace(do_lang('NA'), '', @strval($actual_properties[$p])) != str_replace(do_lang('NA'), '', @strval($properties[$p]))) {
                    resource_fs_logging('Property (' . $p . ') value mismatch for ' . $found_filename . ' (actual ' . str_replace(do_lang('NA'), '', @strval($actual_properties[$p])) . ' vs intended ' . str_replace(do_lang('NA'), '', @strval($properties[$p])) . ').', 'warn');
                    $ok = false;
                }
            } else {
                resource_fs_logging('Property (' . $p . ') not applicable for ' . $found_filename . '.', 'warn');
                $ok = false;
            }
        }

        if ($ok) {
            if (!isset($similar_ok_before[$resource_type][$path])) {
                $similar_ok_before[$resource_type][$path] = 0;
            }
            $similar_ok_before[$resource_type][$path]++;
        }
    }

    /*
        ABSTRACT/AGNOSTIC RESOURCE-FS API FOR INTERNAL SOFTWARE USE
    */

    /**
     * Find the foldername/subpath to a resource.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @param  boolean $full_subpath Whether to include the full subpath
     * @return ?string The foldername/subpath (null: not found)
     */
    public function search(string $resource_type, string $resource_id, bool $full_subpath = false) : ?string
    {
        // Find resource
        require_code('content');
        list(, , $cma_info, $content_row) = content_get_details($resource_type, $resource_id, true);
        if ($content_row === null) {
            return null;
        }

        // Okay, exists, but what if no categories for this?
        if ($this->folder_resource_type === null) {
            return '';
        }

        // For each folder type, see if we can find a position for this resource
        $cat_resource_types = is_array($this->folder_resource_type) ? $this->folder_resource_type : [$this->folder_resource_type];
        $cat_resource_types = array_reverse($cat_resource_types); // Need to look from deepest outward, i.e. maximum specificity first
        $cat_resource_types[] = null;
        foreach ($cat_resource_types as $cat_resource_type) {
            $relationship = $this->_has_parent_child_relationship($cat_resource_type, $resource_type);
            if ($relationship === null) {
                continue;
            }

            if ($cat_resource_type === null) {
                return ''; // Exists in root
            }

            // Do we need to load up a linker table for getting the category?
            if (($relationship['linker_table'] !== null) && ($cma_info['table'] != $relationship['linker_table'])) {
                $where = [$relationship['id_field_linker'] => $content_row[$cma_info['id_field']]];
                $categories = $cma_info['db']->query_select($relationship['linker_table'], [$relationship['cat_field']], $where);
            } else {
                $categories = [$content_row];
            }

            foreach ($categories as $category) {
                // Find category
                $_category_id = $category[$relationship['cat_field']];
                $category_id = is_string($_category_id) ? $_category_id : (($_category_id === null) ? '' : strval($_category_id));

                // Convert category to path
                $subpath = $this->folder_convert_id_to_filename($cat_resource_type, $category_id);
                if ($subpath === null) {
                    continue; // Weird, some kind of broken category. We'll have to say we cannot find, as it won't be linked into the folder tree.
                }

                // Full subpath requested?
                if ($full_subpath) {
                    $above_subpath = $this->search($cat_resource_type, $category_id, $full_subpath);
                    if ($above_subpath != '') {
                        $subpath = $above_subpath . '/' . $subpath;
                    }
                }

                return $subpath;
            }
        }

        return null;
    }

    /**
     * Convert a label to a filename, possibly with auto-creating if needed. This is useful for the software-side resource-agnostic API.
     *
     * @param  LONG_TEXT $label Resource label
     * @param  string $subpath The path (blank: root / not applicable). It may end in "/*" if you want to look for a match under a certain directory
     * @param  ID_TEXT $resource_type Resource type
     * @param  boolean $must_already_exist Whether the content must already exist
     * @param  ?ID_TEXT $use_guid_for_new GUID to auto-create with (null: either not auto-creating, or not specifying the GUID if we are)
     * @return ?ID_TEXT The filename (null: not found)
     */
    public function convert_label_to_filename(string $label, string $subpath, string $resource_type, bool $must_already_exist = false, ?string $use_guid_for_new = null) : ?string
    {
        $label = cms_mb_substr($label, 0, 255);
        $resource_id = $this->convert_label_to_id($label, $subpath, $resource_type, $must_already_exist, $use_guid_for_new);
        if ($resource_id === null) {
            return null;
        }
        return find_commandr_fs_filename_via_id($resource_type, $resource_id);
    }

    /**
     * Convert a label to an ID, possibly with auto-creating if needed. This is useful for the software-side resource-agnostic API.
     *
     * @param  SHORT_TEXT $_label Resource label
     * @param  string $subpath The path (blank: root / not applicable). It may end in "/*" if you want to look for a match under a certain directory
     * @param  ID_TEXT $resource_type Resource type
     * @param  boolean $must_already_exist Whether the content must already exist
     * @param  ?ID_TEXT $use_guid_for_new GUID to auto-create with (null: either not auto-creating, or not specifying the GUID if we are)
     * @return ?ID_TEXT The ID (null: not found)
     */
    public function convert_label_to_id(string $_label, string $subpath, string $resource_type, bool $must_already_exist = false, ?string $use_guid_for_new = null) : ?string
    {
        $label = cms_mb_substr($_label, 0, 255);

        $resource_id = find_id_via_label($resource_type, $label, $subpath);
        if ($resource_id === null) {
            if (!$must_already_exist) {
                // Not found, create...
                resource_fs_logging('Auto-creating an unmatched ' . $resource_type . ' label reference, "' . $_label . '", under "' . $subpath . '"', 'notice');

                // Create subpath
                if ($subpath != '') {
                    if (substr($subpath, -2) == '/*') {
                        $subpath = substr($subpath, 0, strlen($subpath) - 2);
                    }

                    $subpath_bits = explode('/', $subpath);
                    $subpath_above = '';
                    foreach ($subpath_bits as $i => $subpath_bit) {
                        if (is_array($this->folder_resource_type)) {
                            $folder_resource_type = $this->folder_resource_type[array_key_exists($i, $this->folder_resource_type) ? $i : (count($this->folder_resource_type) - 1)];
                        } else {
                            $folder_resource_type = $this->folder_resource_type;
                        }

                        list(, $subpath_id) = $this->folder_convert_filename_to_id($subpath_bit);
                        if ($subpath_id === null) { // Missing, find via moniker that doesn't match a label due to prefixing
                            if (preg_match('#^[A-Z]+-#', $subpath_bit) != 0) {
                                $_subpath_bit = preg_replace('#^[A-Z]+-#', '', $subpath_bit);
                                $detected_resource_type = cms_strtolower_ascii(preg_replace('#-.*$#', '', $subpath_bit));
                                $subpath_id = find_id_via_label($detected_resource_type, $_subpath_bit, $subpath_above);
                            }
                        }
                        if ($subpath_id === null) { // Missing, find via monikerised label
                            $_subpath_bit = $this->_create_name_from_label($subpath_bit);
                            list(, $subpath_id) = $this->folder_convert_filename_to_id($_subpath_bit);
                        }
                        if ($subpath_id === null) { // Missing, find via label
                            $subpath_id = find_id_via_label($folder_resource_type, $subpath_bit, $subpath_above);
                        }
                        if ($subpath_id === null) { // Still missing, create folder
                            $subpath_id = $this->folder_add($subpath_bit, $subpath_above, []);
                        }

                        if ($subpath_above != '') {
                            $subpath_above .= '/';
                        }
                        $subpath_above .= $this->folder_convert_id_to_filename($folder_resource_type, $subpath_id);
                    }
                }

                // Create main resource
                $resource_id = $this->resource_add($resource_type, ($_label === null) ? uniqid('arbitrary', true) : $_label, $subpath, []);
                if ($resource_id === false) {
                    return null;
                }
                if ($use_guid_for_new !== null) {
                    generate_resource_fs_moniker($resource_type, $resource_id, $label, $use_guid_for_new);
                }
            }
        }
        return $resource_id;
    }

    /**
     * Get the filename for a resource ID (of file or folder). Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @return ?ID_TEXT The filename (null: not found)
     */
    public function convert_id_to_filename(string $resource_type, string $resource_id) : ?string
    {
        if ($this->is_file_type($resource_type)) {
            return $this->file_convert_id_to_filename($resource_type, $resource_id);
        }
        if ($this->is_folder_type($resource_type)) {
            return $this->folder_convert_id_to_filename($resource_type, $resource_id);
        }
        return null;
    }

    /**
     * Get the resource ID for a filename (of file or folder). Note that filenames are unique across all folders in a filesystem.
     *
     * @param  ID_TEXT $filename The filename, or filepath
     * @param  ID_TEXT $resource_type The resource type
     * @return ?array A pair: The resource type, the resource ID (null: could not find)
     */
    public function convert_filename_to_id(string $filename, string $resource_type) : ?array
    {
        if ($this->is_file_type($resource_type)) {
            return $this->file_convert_filename_to_id($filename, $resource_type);
        }
        if ($this->is_folder_type($resource_type)) {
            return $this->folder_convert_filename_to_id($filename, $resource_type);
        }
        return null;
    }

    /**
     * Save function for resource-fs. Parses the data for some resource to a resource-fs JSON file. Wraps file_save/folder_save.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $label Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties
     * @param  ?ID_TEXT $search_label_as Whether to look for existing records using $filename as a label and this resource type (null: $filename is a strict file name)
     * @param  ?ID_TEXT $search_path Search path (null: the same as the path saving at)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function resource_save(string $resource_type, string $label, string $path, array $properties = [], ?string $search_label_as = null, ?string $search_path = null)
    {
        if ($this->is_folder_type($resource_type)) {
            $resource_id = $this->folder_save($label, $path, $properties, $search_label_as, $search_path);
        } else {
            $resource_id = $this->file_save($label, $path, $properties, $search_label_as, $search_path);
        }
        return $resource_id;
    }

    /**
     * Adds some resource with the given label and properties. Wraps file_add/folder_add.
     *
     * @param  ID_TEXT $resource_type Resource type
     * @param  LONG_TEXT $label Filename OR Resource label
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function resource_add(string $resource_type, string $label, string $path, array $properties = [])
    {
        if ($this->is_folder_type($resource_type)) {
            $resource_id = $this->folder_add($label, $path, $properties, $resource_type);
            $this->_log_if_save_matchup($resource_type, $resource_id, $path, $properties);
        } else {
            $resource_id = $this->file_add($label, $path, $properties, $resource_type);
            $this->_log_if_save_matchup($resource_type, $resource_id, $path, $properties);
        }
        return $resource_id;
    }

    /**
     * Finds the properties for some resource. Wraps file_load/folder_load.
     *
     * @param  ID_TEXT $resource_type Resource type
     * @param  SHORT_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @return ~array Details of the resource (false: error)
     */
    public function resource_load(string $resource_type, string $filename, string $path)
    {
        if ($this->is_folder_type($resource_type)) {
            $properties = $this->folder_load($filename, $path);
        } else {
            $properties = $this->file_load($filename, $path);
        }
        return $properties;
    }

    /**
     * Edits the resource to the given properties. Wraps file_edit/folder_edit.
     *
     * @param  ID_TEXT $resource_type Resource type
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties (may be empty, properties given are open to interpretation by the hook but generally correspond to database fields)
     * @param  boolean $explicit_move Whether we are definitely moving (as opposed to possible having it in multiple positions)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function resource_edit(string $resource_type, string $filename, string $path, array $properties, bool $explicit_move = false)
    {
        if ($this->is_folder_type($resource_type)) {
            $resource_id = $this->folder_edit($filename, $path, $properties, $explicit_move);
            $this->_log_if_save_matchup($resource_type, $resource_id, $path, $properties);
        } else {
            $resource_id = $this->file_edit($filename, $path, $properties, $explicit_move);
            $this->_log_if_save_matchup($resource_type, $resource_id, $path, $properties);
        }
        return $resource_id;
    }

    /**
     * Deletes the resource. Wraps file_delete/folder_delete.
     *
     * @param  ID_TEXT $resource_type Resource type
     * @param  ID_TEXT $filename The filename
     * @param  string $path The path (blank: root / not applicable)
     * @return boolean Success status
     */
    public function resource_delete(string $resource_type, string $filename, string $path) : bool
    {
        if ($this->is_folder_type($resource_type)) {
            resource_fs_logging('Deleted the ' . $path . '/' . $filename . ' folder as requested', 'notice');

            $status = $this->folder_delete($filename, $path);
        } else {
            resource_fs_logging('Deleted the ' . $path . '/' . $filename . ' file as requested', 'notice');

            $status = $this->file_delete($filename, $path);
        }
        return $status;
    }

    /**
     * Reset view access permissions on the resource for all usergroups.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function reset_resource_access(?string $filename, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('bf4adbe5d4cc59a5a6582db067e7e088')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        switch ($resource_type) {
            case 'comcode_page':
                list($zone_name, $page_name) = explode(':', $category);
                $cma_info['db']->query_delete('group_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name]);
                $cma_info['db']->query_delete('member_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name]);
                break;

            case 'zone':
                $cma_info['db']->query_delete('group_zone_access', ['zone_name' => $category]);
                $cma_info['db']->query_delete('member_zone_access', ['zone_name' => $category]);
                break;

            default:
                $cma_info['db']->query_delete('group_category_access', ['module_the_name' => $permission_module, 'category_name' => $category]);
                $cma_info['db']->query_delete('member_category_access', ['module_the_name' => $permission_module, 'category_name' => $category]);
                break;
        }
    }

    /**
     * Set resource view access on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $groups A mapping from group ID to view access
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_access(?string $filename, array $groups, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('a8d2bedc445856ac956b304d7d645a50')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $admin_groups = $GLOBALS['FORUM_DRIVER']->get_super_admin_groups();

        // Cleanup
        foreach (array_keys($groups) as $group_id) {
            switch ($resource_type) {
                case 'comcode_page':
                    list($zone_name, $page_name) = explode(':', $category);
                    $cma_info['db']->query_delete('group_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name, 'group_id' => $group_id]);
                    break;

                case 'zone':
                    $cma_info['db']->query_delete('group_zone_access', ['zone_name' => $category, 'group_id' => $group_id]);
                    break;

                default:
                    $cma_info['db']->query_delete('group_category_access', ['module_the_name' => $permission_module, 'category_name' => $category, 'group_id' => $group_id]);
                    break;
            }
        }

        // Insert
        foreach ($groups as $group_id => $value) {
            if (in_array($group_id, $admin_groups)) {
                continue;
            }

            if (($value == '1') || ($value == 'true')) {
                switch ($resource_type) {
                    case 'comcode_page':
                        list($zone_name, $page_name) = explode(':', $category);
                        $cma_info['db']->query_insert('group_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name, 'group_id' => $group_id], false, true); // Race/corruption condition
                        break;

                    case 'zone':
                        $cma_info['db']->query_insert('group_zone_access', ['zone_name' => $category, 'group_id' => $group_id], false, true); // Race/corruption condition
                        break;

                    default:
                        $cma_info['db']->query_insert('group_category_access', ['module_the_name' => $permission_module, 'category_name' => $category, 'group_id' => $group_id], false, true); // Race/corruption condition
                        break;
                }
            }
        }
    }

    /**
     * Get resource view access on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     * @return array A mapping from group ID to view access
     */
    public function get_resource_access(?string $filename, ?string $resource_type = null, ?string $category = null) : array
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('dc59ea947bc553d7b1a442ae98ddb23d')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return [];
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $admin_groups = $GLOBALS['FORUM_DRIVER']->get_super_admin_groups();
        $groups = $GLOBALS['FORUM_DRIVER']->get_usergroup_list(false, true);

        $ret = [];
        foreach (array_keys($groups) as $group_id) {
            $ret[$group_id] = '0';
        }
        foreach ($admin_groups as $group_id) {
            $ret[$group_id] = '1';
        }
        switch ($resource_type) {
            case 'comcode_page':
                list($zone_name, $page_name) = explode(':', $category);
                $groups = $cma_info['db']->query_select('group_zone_access', ['group_id'], ['zone_name' => $zone_name, 'page_name' => $page_name]);
                break;

            case 'zone':
                $groups = $cma_info['db']->query_select('group_page_access', ['group_id'], ['page_name' => $category]);
                break;

            default:
                $groups = $cma_info['db']->query_select('group_category_access', ['group_id'], ['module_the_name' => $permission_module, 'category_name' => $category]);
                break;
        }
        foreach ($groups as $group) {
            $ret[$group['group_id']] = '1';
        }
        return $ret;
    }

    /**
     * Set member resource view access on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $members A mapping from member ID to view access
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_access__members(?string $filename, array $members, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('c844ee20bcb159e7afc74cda820b8daa')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        // Cleanup
        foreach (array_keys($members) as $member_id) {
            switch ($resource_type) {
                case 'comcode_page':
                    list($zone_name, $page_name) = explode(':', $category);
                    $cma_info['db']->query_delete('member_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name, 'member_id' => $member_id, 'active_until' => null]);
                    break;

                case 'zone':
                    $cma_info['db']->query_delete('member_zone_access', ['page_name' => $category, 'member_id' => $member_id, 'active_until' => null]);
                    break;

                default:
                    $cma_info['db']->query_delete('member_category_access', ['module_the_name' => $permission_module, 'category_name' => $category, 'member_id' => $member_id, 'active_until' => null]);
                    break;
            }
        }

        // Insert
        foreach ($members as $member_id => $value) {
            if (($value == '1') || ($value == 'true')) {
                switch ($resource_type) {
                    case 'comcode_page':
                        list($zone_name, $page_name) = explode(':', $category);
                        $cma_info['db']->query_insert('member_page_access', ['zone_name' => $zone_name, 'page_name' => $page_name, 'member_id' => $member_id, 'active_until' => null], false, true); // Race/corruption condition
                        break;

                    case 'zone':
                        $cma_info['db']->query_insert('member_zone_access', ['page_name' => $category, 'member_id' => $member_id, 'active_until' => null], false, true); // Race/corruption condition
                        break;

                    default:
                        $cma_info['db']->query_insert('member_category_access', ['module_the_name' => $permission_module, 'category_name' => $category, 'member_id' => $member_id, 'active_until' => null], false, true); // Race/corruption condition
                        break;
                }
            }
        }
    }

    /**
     * Get resource member view access on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     * @return array A mapping from member ID to view access
     */
    public function get_resource_access__members(?string $filename, ?string $resource_type = null, ?string $category = null) : array
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('179b492cc36355ab82f92798e5a385a6')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return [];
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        switch ($resource_type) {
            case 'comcode_page':
                list($zone_name, $page_name) = explode(':', $category);
                $members = $cma_info['db']->query_select('member_page_access', ['member_id'], ['zone_name' => $zone_name, 'page_name' => $page_name, 'active_until' => null]);
                break;

            case 'zone':
                $members = $cma_info['db']->query_select('member_zone_access', ['member_id'], ['zone_name' => $category, 'active_until' => null]);
                break;

            default:
                $members = $cma_info['db']->query_select('member_category_access', ['member_id'], ['module_the_name' => $permission_module, 'category_name' => $category, 'active_until' => null]);
                break;
        }
        $ret = [];
        foreach ($members as $member) {
            $ret[$member['member_id']] = '1';
        }
        return $ret;
    }

    /**
     * Reset resource privileges on the resource for all usergroups.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function reset_resource_privileges(?string $filename, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('1a5ef818ec285f54a05d84cd89da8b6f')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $cma_info['db']->query_delete('group_privileges', ['module_the_name' => $permission_module, 'category_name' => $category]);
        $cma_info['db']->query_delete('member_privileges', ['module_the_name' => $permission_module, 'category_name' => $category]);
    }

    /**
     * Work out what a privilege preset means for a kind of resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     * @return ?array A mapping from privilege to minimum preset level required for privilege activation (null: unworkable)
     */
    protected function _compute_privilege_preset_scheme(?string $filename, ?string $resource_type = null, ?string $category = null) : ?array
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('c5eeaa99a704559494080b1aa0bd19c8')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return null; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return null; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return null;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $page = $cma_info['cms_page'];
        require_code('zones2');
        $zone = get_module_zone($page, 'modules', null, 'php', true, false);
        $_overridables = extract_module_functions_page($zone, $page, ['get_privilege_overrides']);
        if ($_overridables[0] === null) {
            $overridables = [];
        } else {
            $overridables = is_array($_overridables[0]) ? call_user_func_array($_overridables[0][0], $_overridables[0][1]) : cms_eval($_overridables[0], $zone . ':' . $page);
        }

        // Work out what privileges we need to work with
        $privileges_scheme = [];
        foreach ($overridables as $override => $cat_support) {
            $usual_suspects = ['bypass_validation_.*range_content', 'edit_.*range_content', 'edit_own_.*range_content', 'delete_.*range_content', 'delete_own_.*range_content', 'submit_.*range_content'];
            $access = [2, 3, 2, 3, 2, 1]; // The minimum access level that turns on each of the above permissions   NB: Also defined in permissions.js, so keep that in-sync
            foreach ($usual_suspects as $i => $privilege) {
                if (preg_match('#' . $privilege . '#', $override) != 0) {
                    $min_level = $access[$i];
                    $privileges_scheme[$override] = $min_level;
                }
            }
        }

        return $privileges_scheme;
    }

    /**
     * Set resource privileges from a preset on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $group_presets A mapping from group ID to preset value. Preset values are 0 (read only) to 3 (moderation)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_privileges_from_preset(?string $filename, array $group_presets, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('fdb731433a625ca8aea1adb15073a675')));
        }

        $privileges_scheme = $this->_compute_privilege_preset_scheme($filename, $resource_type, $category);
        if ($privileges_scheme === null) {
            return;
        }

        // Set the privileges
        $group_settings = [];
        foreach ($group_presets as $group_id => $level) {
            $group_settings[$group_id] = [];
            foreach ($privileges_scheme as $privilege => $min_level) {
                $setting = ($level < $min_level) ? '0' : '1';
                $group_settings[$group_id][$privilege] = $setting;
            }
        }
        $this->set_resource_privileges($filename, $group_settings);
    }

    /**
     * Set resource privileges on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $group_settings A map between group ID, and a map of privilege to setting
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_privileges(?string $filename, array $group_settings, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('f09bbc28ee2950a19a5a9eafa35fb7a1')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $admin_groups = $GLOBALS['FORUM_DRIVER']->get_super_admin_groups();

        // Insert
        foreach ($group_settings as $group_id => $value) {
            if (in_array($group_id, $admin_groups)) {
                continue;
            }

            foreach ($value as $privilege => $setting) {
                if ($setting != '') {
                    $cma_info['db']->query_delete('group_privileges', ['module_the_name' => $permission_module, 'category_name' => $category, 'group_id' => $group_id, 'privilege' => $privilege, 'the_page' => '']);
                    $cma_info['db']->query_insert('group_privileges', ['module_the_name' => $permission_module, 'category_name' => $category, 'group_id' => $group_id, 'privilege' => $privilege, 'the_page' => '', 'the_value' => intval($setting)], false, true); // Race/corruption condition
                }
            }
        }
    }

    /**
     * Get the resource privileges for the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     * @return array A map between group ID, and a map of privilege to setting
     */
    public function get_resource_privileges(?string $filename, ?string $resource_type = null, ?string $category = null) : array
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('85a58b21e9cf5c42a06d1fb4ce5b64df')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return []; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return []; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return [];
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $page = $cma_info['cms_page'];
        require_code('zones2');
        $zone = get_module_zone($page, 'modules', null, 'php', true, false);
        $_overridables = extract_module_functions_page($zone, $page, ['get_privilege_overrides']);
        if ($_overridables[0] === null) {
            $overridables = [];
        } else {
            $overridables = is_array($_overridables[0]) ? call_user_func_array($_overridables[0][0], $_overridables[0][1]) : cms_eval($_overridables[0], $zone . ':' . $page);
        }

        $admin_groups = $GLOBALS['FORUM_DRIVER']->get_super_admin_groups();
        $groups = $GLOBALS['FORUM_DRIVER']->get_usergroup_list(false, true);

        $ret = [];
        foreach (array_keys($groups) as $group_id) {
            $ret[$group_id] = [];
            foreach ($overridables as $override => $cat_support) {
                if ($cat_support) {
                    if (in_array($group_id, $admin_groups)) {
                        $ret[$group_id][$override] = '1';
                    } else {
                        $ret[$group_id][$override] = '1';
                    }
                }
            }
        }
        $groups = $cma_info['db']->query_select('group_privileges', ['group_id', 'privilege', 'the_value'], ['module_the_name' => $permission_module, 'category_name' => $category, 'the_page' => '']);
        foreach ($groups as $group) {
            $ret[$group['group_id']][$group['privilege']] = strval($group['the_value']);
        }
        return $ret;
    }

    /**
     * Set resource privileges from a preset so that a member has custom privileges on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $member_presets A mapping from member ID to preset value. Preset values are 0 (read only) to 3 (moderation)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_privileges_from_preset__members(?string $filename, array $member_presets, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('95712a98ddc7558f92f2beea81e4c051')));
        }

        $privileges_scheme = $this->_compute_privilege_preset_scheme($filename, $resource_type, $category);
        if ($privileges_scheme === null) {
            return;
        }

        // Set the privileges
        $member_settings = [];
        foreach ($member_presets as $member_id => $level) {
            $member_settings[$member_id] = [];
            foreach ($privileges_scheme as $privilege => $min_level) {
                $setting = ($level < $min_level) ? '0' : '1';
                $member_settings[$member_id][$privilege] = $setting;
            }
        }
        $this->set_resource_privileges__members($filename, $member_settings);
    }

    /**
     * Set a resource privilege so that a member has a custom privilege on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  array $member_settings A map between member ID, and a map of privilege to setting
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     */
    public function set_resource_privileges__members(?string $filename, array $member_settings, ?string $resource_type = null, ?string $category = null)
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('dead6d33696a5dce856686f24db3bbec')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        foreach ($member_settings as $member_id => $value) {
            foreach ($value as $privilege => $setting) {
                if ($setting != '') {
                    $cma_info['db']->query_delete('member_privileges', ['module_the_name' => $permission_module, 'category_name' => $category, 'member_id' => $member_id, 'privilege' => $privilege, 'the_page' => '']);
                    $cma_info['db']->query_insert('member_privileges', ['module_the_name' => $permission_module, 'category_name' => $category, 'member_id' => $member_id, 'privilege' => $privilege, 'the_page' => '', 'the_value' => intval($setting), 'active_until' => null], false, true); // Race/corruption condition
                }
            }
        }
    }

    /**
     * Get the resource privileges for all members that have custom privileges on the resource.
     *
     * @param  ?ID_TEXT $filename Resource filename (assumed to be of a folder type) (null: $resource_type & $category specified instead)
     * @param  ?ID_TEXT $resource_type The resource type (null: $filename specified instead)
     * @param  ?ID_TEXT $category The resource ID (null: $filename specified instead)
     * @return array A map between member ID, and a map of privilege to setting
     */
    public function get_resource_privileges__members(?string $filename, ?string $resource_type = null, ?string $category = null) : array
    {
        if (($filename === null) && (($resource_type === null) || ($category === null))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('b127294fe9d7533db6ad4acea4195c38')));
        }

        if ($resource_type === null) {
            list($resource_type, $category) = $this->folder_convert_filename_to_id($filename);
        }

        if ($resource_type == 'zone') {
            return []; // Can not be done
        }
        if ($resource_type == 'comcode_page') {
            return []; // Can not be done
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return [];
        }
        $permission_module = $cma_info['permission_module'];
        if (is_array($permission_module)) {
            $permission_module = array_pop($permission_module);
        }

        $members = $cma_info['db']->query_select('member_privileges', ['member_id', 'privilege', 'the_value'], ['module_the_name' => $permission_module, 'category_name' => $category, 'the_page' => '', 'active_until' => null]);
        $ret = [];
        foreach ($members as $member) {
            $ret[$member['member_id']][$member['privilege']] = strval($member['the_value']);
        }
        return $ret;
    }

    /*
    JSON FILE HANDLING: OUR DEFAULT PROPERTY LIST SERIALISATION/DESERIALISATION
    */

    /**
     * Load function for resource-fs (for files). Finds the data for some resource from a resource-fs JSON file.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @return ~string Resource data (false: error)
     */
    public function file_load_json(string $filename, string $path)
    {
        $properties = $this->file_load($filename, $path);
        if ($properties === null) {
            return false;
        }
        return json_encode($properties);
    }

    /**
     * Load function for resource-fs (for folders). Finds the data for some resource from a resource-fs JSON folder.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @return ~string Resource data (false: error)
     */
    public function folder_load_json(string $filename, string $path)
    {
        $properties = $this->folder_load($filename, $path);
        if ($properties === null) {
            return false;
        }
        return json_encode($properties);
    }

    /**
     * Save function for resource-fs (for files). Parses the data for some resource to a resource-fs JSON file.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  string $data Resource data
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function file_save_json(string $filename, string $path, string $data)
    {
        $properties = ($data == '') ? [] : @json_decode($data, true);
        if ($properties === null) {
            return false;
        }
        return $this->file_save($filename, $path, $properties);
    }

    /**
     * Save function for resource-fs (for files).
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path to save at (blank: root / not applicable)
     * @param  array $properties Properties
     * @param  ?ID_TEXT $search_label_as Whether to look for existing records using $filename as a label and this resource type (null: $filename is a strict file name)
     * @param  ?ID_TEXT $search_path Search path (null: the same as the path saving at)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function file_save(string $filename, string $path, array $properties, ?string $search_label_as = null, ?string $search_path = null)
    {
        if ($search_path === null) {
            $search_path = $path;
        }

        $label = $filename;
        if ($search_label_as !== null) {
            $filename = $this->convert_label_to_filename($label, $search_path, $search_label_as, true);
        }

        if (($GLOBALS['RESOURCE_FS_ADD_ONLY']) && ($filename !== null)) {
            $resource_parts = $this->file_convert_filename_to_id($filename);
            if ($resource_parts !== null) {
                return $resource_parts[1];
            }
        }

        $existing = mixed();
        $existing = ($filename === null) ? false : $this->file_load($filename, $search_path); // NB: Even if it has a wildcard path, it should be acceptable to file_load, as the path is not used for search, only for identifying resource type
        if ($existing === false) {
            resource_fs_logging('Added a new ' . $path . '/' . $label . ' file record (i.e. not an edit)', 'inform');

            $resource_id = $this->file_add($label, $path, $properties, $search_label_as);
            $this->_log_if_save_matchup($search_label_as, $resource_id, $path, $properties);
            return $resource_id;
        }

        $resource_id = $this->file_edit($filename, $path, $properties + $existing);
        $this->_log_if_save_matchup($search_label_as, $resource_id, $path, $properties);
        return $resource_id;
    }

    /**
     * Save function for resource-fs (for folders). Parses the data for some resource to a resource-fs JSON folder.
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  string $data Resource data
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function folder_save_json(string $filename, string $path, string $data)
    {
        $properties = @json_decode($data, true);
        if ($properties === null) {
            return false;
        }
        return $this->folder_save($filename, $path, $properties);
    }

    /**
     * Save function for resource-fs (for folders).
     *
     * @param  ID_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     * @param  array $properties Properties
     * @param  ?ID_TEXT $search_label_as Whether to look for existing records using $filename as a label and this resource type (null: $filename is a strict file name)
     * @param  ?ID_TEXT $search_path Search path (null: the same as the path saving at)
     * @return ~ID_TEXT The resource ID (false: error, could not create via these properties / here)
     */
    public function folder_save(string $filename, string $path, array $properties, ?string $search_label_as = null, ?string $search_path = null)
    {
        if ($search_path === null) {
            $search_path = $path;
        }

        $label = $filename;
        if ($search_label_as !== null) {
            $filename = $this->convert_label_to_filename($label, $search_path, $search_label_as, true);
        }

        if (($GLOBALS['RESOURCE_FS_ADD_ONLY']) && ($filename !== null)) {
            $resource_parts = $this->folder_convert_filename_to_id($filename);
            if ($resource_parts !== null) {
                return $resource_parts[1];
            }
        }

        $existing = mixed();
        $existing = ($filename === null) ? false : $this->folder_load($filename, $search_path); // NB: Even if it has a wildcard path, it should be acceptable to file_load, as the path is not used for search, only for identifying resource type
        if ($existing === false) {
            resource_fs_logging('Added a new ' . $path . '/' . $label . ' folder record (i.e. not an edit)', 'inform');

            $resource_id = $this->folder_add($label, $path, $properties, $search_label_as);
            $this->_log_if_save_matchup($search_label_as, $resource_id, $path, $properties);
            return $resource_id;
        }

        $resource_id = $this->folder_edit($filename, $path, $properties + $existing);
        $this->_log_if_save_matchup($search_label_as, $resource_id, $path, $properties);
        return $resource_id;
    }

    /*
    STANDARD FEATURE INCORPORATION
    */

    /**
     * Extend a resource with extra properties from standard features a resource type supports.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @param  array $properties Details of properties
     * @param  SHORT_TEXT $filename Filename
     * @param  string $path The path (blank: root / not applicable)
     */
    protected function _resource_load_extend(string $resource_type, string $resource_id, array &$properties, string $filename, string $path)
    {
        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $db = $cma_info['db'];

        $reserved_fields = [
            'alternative_ids',
            'url_id_monikers',
            'attachments',
            'content_privacy',
            'content_privacy__members',
            'content_reviews',
            'comments',
            'reviews',
            'ratings',
            'trackbacks',
            'access',
            'access__members',
            'privileges',
            'privileges__members',
        ];
        if (!empty(array_intersect(array_keys($properties), $reserved_fields))) {
            warn_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('474ca4570b555be9be92589226f437dc')));
        }

        // Alternative IDs
        $properties['alternative_ids'] = table_to_portable_rows('alternative_ids', /*skip*/['resource_moniker', 'resource_label'], ['resource_type' => $resource_type, 'resource_id' => $resource_id], $db);

        // URL monikers
        if ($cma_info['support_url_monikers']) {
            $page_bits = explode(':', $cma_info['view_page_link_pattern']);
            $properties['url_id_monikers'] = table_to_portable_rows('url_id_monikers', /*skip*/['id'], ['m_resource_page' => $page_bits[1], 'm_resource_type' => isset($page_bits[2]) ? $page_bits[2] : '', 'm_resource_id' => $resource_id], $db);
        }

        // Attachments
        if ($cma_info['attachment_hook'] !== null) {
            $attachment_refs_rows = collapse_1d_complexity('a_id', $db->query_select('attachment_refs', ['a_id'], ['r_referer_type' => $cma_info['attachment_hook'], 'r_referer_id' => $resource_id]));
            $properties['attachments'] = [];
            foreach ($attachment_refs_rows as $attachment_id) {
                $attachment_rows = table_to_portable_rows('attachments', /*skip*/[], ['id' => $attachment_id], $db);
                if (isset($attachment_rows[0])) {
                    $properties['attachments'][] = $attachment_rows[0] + ['_foreign_id' => $attachment_id];
                }
            }
        }

        // Content privacy
        if ($cma_info['support_privacy']) {
            $properties['content_privacy'] = table_to_portable_rows('content_privacy', /*skip*/[], ['content_type' => $resource_type, 'content_id' => $resource_id], $db);
            $properties['content_privacy__members'] = table_to_portable_rows('content_privacy__members', /*skip*/[], ['content_type' => $resource_type, 'content_id' => $resource_id], $db);
        }

        // Content reviews (by staff)
        if ($cma_info['support_content_reviews'] && addon_installed('content_reviews')) {
            $properties['content_reviews'] = table_to_portable_rows('content_reviews', /*skip*/[], ['content_type' => $resource_type, 'content_id' => $resource_id], $db);
        }

        if ($cma_info['feedback_type_code'] !== null) {
            if (get_forum_type() == 'cns') {
                // Comments & Reviews
                require_code('feedback');
                $topic_id = $GLOBALS['FORUM_DRIVER']->find_topic_id_for_topic_identifier(find_overridden_comment_forum($cma_info['feedback_type_code']), $cma_info['feedback_type_code'] . '_' . $resource_id, do_lang('COMMENT'));
                if ($topic_id !== null) {
                    $comments = get_resource_fs_record('topic', strval($topic_id));
                    if ($comments !== null) {
                        $properties['comments'] = json_decode($comments[0], true);

                        $properties['comments']['posts'] = [];
                        $posts = $GLOBALS['FORUM_DB']->query_select('f_posts', ['id', 'p_time'], ['p_topic_id' => $topic_id], 'ORDER BY p_time ASC,id ASC');
                        foreach ($posts as $_post) {
                            $post = get_resource_fs_record('post', strval($_post['id']));
                            $properties['comments']['posts'][] = json_decode($post[0], true);
                        }
                    }
                }

                $properties['reviews'] = table_to_portable_rows('review_supplement', /*skip*/['id'], ['r_rating_type' => $cma_info['feedback_type_code'], 'r_rating_for_id' => $resource_id], $db);
                // NB: r_topic_id and r_post_id will automatically be made portable, so associated with the correct comment
            }

            // Ratings
            $properties['ratings'] = table_to_portable_rows('rating', /*skip*/['id'], ['rating_for_type' => $cma_info['feedback_type_code'], 'rating_for_id' => $resource_id], $db);

            // Trackbacks
            $properties['trackbacks'] = table_to_portable_rows('trackbacks', /*skip*/['id'], ['trackback_for_type' => $cma_info['feedback_type_code'], 'trackback_for_id' => $resource_id], $db);
        }

        // Custom fields
        if ($cma_info['support_custom_fields']) {
            $properties += $this->_custom_fields_load($resource_type, $resource_id);
        }

        // Permissions
        if (($cma_info['permission_module'] !== null) && $cma_info['is_category'] && $cma_info['category_field'] == $cma_info['id_field']) {
            $properties['access'] = $this->get_resource_access(null, $resource_type, $resource_id);

            $properties['access__members'] = $this->get_resource_access__members(null, $resource_type, $resource_id);

            $properties['privileges'] = $this->get_resource_privileges(null, $resource_type, $resource_id);

            $properties['privileges__members'] = $this->get_resource_privileges__members(null, $resource_type, $resource_id);
        }

        // Properties not used for anything, but interesting
        $properties['comment__resource_type'] = $resource_type;
        $properties['comment__resource_id'] = $resource_id;
        $properties['comment__path'] = $path;
        $properties['comment__filename'] = $filename;
        //$properties['comment__generation_time'] = remap_time_as_portable(time()); Would break Git history
        if (isset($properties['edit_date'])) {
            $properties['comment__edit_date_note'] = 'You may remove the edit_date if you want it to auto-generate to the current-time when saving';
        }
    }

    /**
     * Modify standard properties as may be needed by implications of extra properties.
     *
     * @param  array $properties Details of properties (returned by reference)
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $filename Filename
     * @param  LONG_TEXT $label Resource label
     */
    protected function _resource_save_extend_pre(array &$properties, string $resource_type, string $filename, string $label)
    {
        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $db = $cma_info['db'];

        // New Attachment IDs need generating and substituting
        if ($cma_info['attachment_hook'] !== null) {
            if (isset($properties['attachments'])) {
                $new_id = $db->query_select_value_if_there('attachments', 'MAX(id)');
                if ($new_id === null) {
                    $new_id = db_get_first_id();
                } else {
                    $new_id++;
                }

                $attachments = &$properties['attachments'];
                foreach ($attachments as &$attachment) {
                    $foreign_id = $attachment['_foreign_id'];

                    foreach ($properties as &$val) {
                        if (is_string($val)) {
                            $val = preg_replace('#(\[attachment( .*)?\])' . strval($foreign_id) . '(\[/attachment\])#U', '$1' . strval($new_id) . '$3', $val);
                            $val = preg_replace('#(\[attachment_safe( .*)?\])' . strval($foreign_id) . '(\[/attachment_safe\])#U', '$1' . strval($new_id) . '$3', $val);
                        }
                    }

                    $attachment['_new_id'] = $new_id;
                    $new_id++;
                }
            }
        }
    }

    /**
     * Save extra properties from standard features a resource type supports.
     *
     * @param  ID_TEXT $resource_type The resource type
     * @param  ID_TEXT $resource_id The resource ID
     * @param  ID_TEXT $filename Filename
     * @param  LONG_TEXT $label Resource label
     * @param  array $properties Details of properties
     */
    protected function _resource_save_extend(string $resource_type, string $resource_id, string $filename, string $label, array $properties)
    {
        if (cms_mb_strlen($filename) > 80) { // Filename has may just have been the label from an add operation, in which case we must chop it down
            $filename = cms_mb_substr($filename, 0, 80);
        }

        $cma_info = $this->_get_cma_info($resource_type);
        if ($cma_info === null) {
            return;
        }
        $db = $cma_info['db'];

        // Alternative IDs
        if (isset($properties['alternative_ids'])) {
            foreach ($properties['alternative_ids'] as &$alternative_id) {
                $alternative_id['resource_moniker'] = basename($filename, '.' . RESOURCE_FS_DEFAULT_EXTENSION);
                $alternative_id['resource_label'] = $label;
            }
            table_from_portable_rows('alternative_ids', $properties['alternative_ids'], ['resource_type' => $resource_type, 'resource_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
        }

        // URL monikers
        if ($cma_info['support_url_monikers']) {
            if (isset($properties['url_id_monikers'])) {
                $page_bits = explode(':', $cma_info['view_page_link_pattern']);
                table_from_portable_rows('url_id_monikers', $properties['url_id_monikers'], ['m_resource_page' => $page_bits[1], 'm_resource_type' => $page_bits[2], 'm_resource_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }
        }

        // Attachments
        if ($cma_info['attachment_hook'] !== null) {
            if (isset($properties['attachments'])) {
                $attachments = $properties['attachments'];

                // Delete old attachments
                require_code('attachments3');
                delete_comcode_attachments($cma_info['attachment_hook'], $resource_id, $db, true);

                // Metadata
                $db_fields = collapse_2d_complexity('m_name', 'm_type', $db->query_select('db_meta', ['m_name', 'm_type'], ['m_table' => 'attachments']));
                $relation_map = get_relation_map_for_table('attachments');

                // Insert new attachments
                foreach ($attachments as $attachment) {
                    $foreign_id = $attachment['_foreign_id'];
                    unset($attachment['_foreign_id']);
                    $new_attachment_id = $attachment['_new_id'];
                    unset($attachment['_new_id']);

                    $attachment_row = table_row_from_portable_row($attachment, $db_fields, $relation_map);
                    $attachment_row['id'] = $new_attachment_id;
                    $db->query_insert('attachments', $attachment_row);
                    $db->query_insert('attachment_refs', ['r_referer_type' => $cma_info['attachment_hook'], 'r_referer_id' => $resource_id, 'a_id' => $new_attachment_id]);
                }
            }
        }

        // Content privacy
        if ($cma_info['support_privacy']) {
            if (isset($properties['content_privacy'])) {
                table_from_portable_rows('content_privacy', $properties['content_privacy'], ['content_type' => $resource_type, 'content_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }

            if (isset($properties['content_privacy__members'])) {
                table_from_portable_rows('content_privacy__members', $properties['content_privacy__members'], ['content_type' => $resource_type, 'content_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }
        }

        // Content reviews (by staff)
        if ($cma_info['support_content_reviews']) {
            if (isset($properties['content_reviews'])) {
                table_from_portable_rows('content_reviews', $properties['content_reviews'], ['content_type' => $resource_type, 'content_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }
        }

        if ($cma_info['feedback_type_code'] !== null) {
            if (get_forum_type() == 'cns') {
                // Comments & Reviews
                if (isset($properties['comments'])) {
                    $comments = $properties['comments'];
                    $comments['description'] = preg_replace('#^(.*: ) .*$#', '$1 ' . $cma_info['feedback_type_code'] . '_' . $resource_id, $comments['description']);

                    $forum_name = find_overridden_comment_forum($cma_info['feedback_type_code']);
                    require_code('feedback');
                    $topic_id = $GLOBALS['FORUM_DRIVER']->find_topic_id_for_topic_identifier($forum_name, $cma_info['feedback_type_code'] . '_' . $resource_id, do_lang('COMMENT'));
                    if ($topic_id === null) {
                        $forum_id = $GLOBALS['FORUM_DRIVER']->forum_id_from_name($forum_name);
                        $resource_fs_path = $comments['comment__path'] . '/' . $comments['comment__filename'];
                    } else {
                        $resource_fs_path = find_commandr_fs_filename_via_id('topic', strval($topic_id), true);
                    }

                    // Save topic
                    $resource_fs_ob = get_resource_commandr_fs_object('topic');
                    $_topic_id = $resource_fs_ob->resource_save('topic', basename($resource_fs_path), dirname($resource_fs_path), $comments);
                    if ($_topic_id === false) {
                        fatal_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('29c3496e69fc59da82a58b39fbfaa223')));
                    }
                    $resource_fs_path_topic = find_commandr_fs_filename_via_id('topic', $_topic_id, true);

                    // Save each post
                    $resource_fs_ob = get_resource_commandr_fs_object('post');
                    foreach ($comments['posts'] as $post) {
                        $resource_fs_path_post = $resource_fs_path_topic . '/' . $post['comment__filename'];
                        $test = $resource_fs_ob->resource_save('post', basename($resource_fs_path_post), dirname($resource_fs_path_post), $post);
                        if ($test === false) {
                            fatal_exit(do_lang_tempcode('INTERNAL_ERROR', escape_html('df09a84f9c8052c7a01f2b16b9f66940')));
                        }
                    }
                }
                if (isset($properties['reviews'])) {
                    table_from_portable_rows('review_supplement', $properties['reviews'], ['r_rating_type' => $cma_info['feedback_type_code'], 'r_rating_for_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
                }
            }

            // Ratings
            if (isset($properties['ratings'])) {
                table_from_portable_rows('rating', $properties['ratings'], ['rating_for_type' => $cma_info['feedback_type_code'], 'rating_for_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }

            // Trackbacks
            if (isset($properties['trackbacks'])) {
                table_from_portable_rows('trackbacks', $properties['trackbacks'], ['trackback_for_type' => $cma_info['feedback_type_code'], 'trackback_for_id' => $resource_id], TABLE_REPLACE_MODE_BY_EXTRA_FIELD_DATA, $db);
            }
        }

        // Custom fields
        if ($cma_info['support_custom_fields']) {
            $this->_custom_fields_save($resource_type, $resource_id, $filename, $label, $properties);
        }

        // Permissions
        if (($cma_info['permission_module'] !== null) && $cma_info['is_category'] && $cma_info['category_field'] == $cma_info['id_field']) {
            if (isset($properties['access'])) {
                $groups = $properties['access'];
                $this->set_resource_access(null, $groups, $resource_type, $resource_id);
            }

            if (isset($properties['access__members'])) {
                $members = $properties['access__members'];
                $this->set_resource_access__members(null, $members, $resource_type, $resource_id);
            }

            if (isset($properties['privileges'])) {
                $group_settings = $properties['privileges'];
                $this->set_resource_privileges(null, $group_settings, $resource_type, $resource_id);
            }

            if (isset($properties['privileges__members'])) {
                $member_settings = $properties['privileges__members'];
                $this->set_resource_privileges__members(null, $member_settings, $resource_type, $resource_id);
            }
        }
    }

    /**
     * Find details of custom properties.
     *
     * @param  ID_TEXT $type The resource type
     * @return array Details of properties
     */
    protected function _custom_fields_enumerate_properties(string $type) : array
    {
        static $cache = [];
        if (array_key_exists($type, $cache)) {
            return $cache[$type];
        }

        $cma_info = $this->_get_cma_info($type);
        if ($cma_info === null) {
            return [];
        }
        $db = $cma_info['db'];

        require_code('fields');
        if (!has_tied_catalogue($type)) {
            return [];
        }

        $props = [];

        $fields = get_catalogue_fields('_' . $type);
        foreach ($fields as $field_bits) {
            $cf_name = get_translated_text($field_bits['cf_name'], $db);
            $fixed_id = 'custom__' . fix_id($cf_name);
            if (!array_key_exists($fixed_id, $props)) {
                $key = $fixed_id;
            } else {
                $key = 'custom__field_' . strval($field_bits['id']);
            }

            require_code('fields');
            $ob = get_fields_hook($field_bits['cf_type']);
            list(, , $storage_type) = $ob->get_field_value_row_bits(['id' => null, 'cf_type' => $field_bits['cf_type'], 'cf_default' => '']);
            $_type = 'SHORT_TEXT';
            switch ($storage_type) {
                case 'short_trans':
                    $_type = 'SHORT_TRANS';
                    break;
                case 'long_trans':
                    $_type = 'LONG_TRANS';
                    break;
                case 'long':
                    $_type = 'LONG_TEXT';
                    break;
                case 'integer':
                    $_type = 'INTEGER';
                    break;
                case 'float':
                    $_type = 'REAL';
                    break;
            }
            $props[$key] = $_type;
        }

        $cache[$type] = $props;

        return $props;
    }

    /**
     * Load custom properties.
     *
     * @param  ID_TEXT $type The resource type
     * @param  ID_TEXT $id The content ID
     * @return array Loaded properties
     */
    protected function _custom_fields_load(string $type, string $id) : array
    {
        if (!addon_installed('catalogues')) {
            return [];
        }

        require_code('fields');
        if (!has_tied_catalogue($type)) {
            return [];
        }

        $cma_info = $this->_get_cma_info($type);
        if ($cma_info === null) {
            return [];
        }
        $db = $cma_info['db'];

        $properties = [];

        require_code('catalogues');

        $catalogue_entry_id = get_bound_content_entry($type, $id);
        if ($catalogue_entry_id !== null) {
            $special_fields = get_catalogue_entry_field_values('_' . $type, $catalogue_entry_id);
        } else {
            $special_fields = $db->query_select('catalogue_fields', ['*'], ['c_name' => '_' . $type], 'ORDER BY cf_order,' . $GLOBALS['SITE_DB']->translate_field_ref('cf_name'));
        }

        $prop_names = array_keys($this->_custom_fields_enumerate_properties($type));
        foreach ($special_fields as $i => $field) {
            $default = $field['cf_default'];
            if (array_key_exists('effective_value_pure', $field)) {
                $default = $field['effective_value_pure'];
            } elseif (array_key_exists('effective_value', $field)) {
                $default = $field['effective_value'];
            }

            $prop_name = $prop_names[$i];
            $properties[$prop_name] = $default;
        }

        return $properties;
    }

    /**
     * Save custom properties.
     *
     * @param  ID_TEXT $type The resource type
     * @param  ID_TEXT $id The content ID
     * @param  ID_TEXT $filename Filename
     * @param  LONG_TEXT $label Resource label
     * @param  array $properties Properties to save
     */
    protected function _custom_fields_save(string $type, string $id, string $filename, string $label, array $properties)
    {
        if (!addon_installed('catalogues')) {
            return;
        }

        require_code('fields');
        if (!has_tied_catalogue($type)) {
            return;
        }

        $cma_info = $this->_get_cma_info($type);
        if ($cma_info === null) {
            return;
        }
        $db = $cma_info['db'];

        $existing = get_bound_content_entry($type, $id);

        require_code('catalogues');

        // Get field values
        $fields = $db->query_select('catalogue_fields', ['*'], ['c_name' => '_' . $type], 'ORDER BY cf_order,' . $GLOBALS['SITE_DB']->translate_field_ref('cf_name'));
        $map = [];
        require_code('fields');
        $prop_names = array_keys($this->_custom_fields_enumerate_properties($type));
        foreach ($fields as $i => $field) {
            $prop_name = $prop_names[$i];
            if (!array_key_exists($prop_name, $properties)) {
                $properties[$prop_name] = '';
            }
            $map[$field['id']] = $properties[$prop_name];
        }

        $first_cat = $db->query_select_value('catalogue_categories', 'MIN(id)', ['c_name' => '_' . $type]);

        require_code('catalogues2');

        if ($existing !== null) {
            actual_edit_catalogue_entry($existing, $first_cat, 1, '', 0, 0, 0, $map);
        } else {
            $catalogue_entry_id = actual_add_catalogue_entry($first_cat, 1, '', 0, 0, 0, $map);

            $db->query_insert('catalogue_entry_linkage', [
                'catalogue_entry_id' => $catalogue_entry_id,
                'content_type' => $type,
                'content_id' => $id,
            ]);
        }
    }

    /*
    COMMANDR-FS BINDING
    */

    /**
     * Standard Commandr-fs listing function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return ~array The final directory listing (false: failure)
     */
    public function listing(array $meta_dir, string $meta_root_node, object &$commandr_fs)
    {
        if (!$this->is_active()) {
            return false;
        }

        $listing = [];

        $folder_types = is_array($this->folder_resource_type) ? $this->folder_resource_type : (($this->folder_resource_type === null) ? [] : [$this->folder_resource_type]);
        $file_types = is_array($this->file_resource_type) ? $this->file_resource_type : (($this->file_resource_type === null) ? [] : [$this->file_resource_type]);

        // Find where we're at
        $cat_id = '';
        $cat_resource_type = null;
        if (!empty($meta_dir)) {
            if ($this->folder_resource_type === null) {
                return false; // Should not be possible
            }

            list($cat_resource_type, $cat_id) = $this->folder_convert_filename_to_id(implode('/', $meta_dir));
        }

        $parent_folder = end($meta_dir);
        if ($parent_folder === false) {
            $parent_folder = '';
        }

        // Find folders
        foreach ($folder_types as $resource_type) {
            $folder_info = $this->_get_cma_info($resource_type);
            if ($folder_info === null) {
                continue;
            }

            $relationship = $this->_has_parent_child_relationship($cat_resource_type, $resource_type);
            if ($relationship === null) {
                continue;
            }

            $_cat_id = ($relationship['cat_field_numeric'] ? (($cat_id == '') ? null : intval($cat_id)) : $cat_id);

            $select = [];
            $table = $folder_info['table'] . ' main';
            if (($relationship['linker_table'] !== null) && ($relationship['linker_table'] != $folder_info['table'])) {
                if (($_cat_id !== null) && ($_cat_id !== '')) {
                    $table = $folder_info['table'] . ' main JOIN ' . $folder_info['db']->get_table_prefix() . $relationship['linker_table'] . ' cats ON cats.' . $relationship['id_field_linker'] . '=main.' . $relationship['id_field'];
                }
            }
            if ($folder_info['add_time_field'] !== null) {
                $select[] = 'main.' . $folder_info['add_time_field'];
            }
            if ($folder_info['edit_time_field'] !== null) {
                $select[] = 'main.' . $folder_info['edit_time_field'];
            }
            if (!is_array($folder_info['id_field'])) {
                $select[] = 'main.' . $folder_info['id_field'];
            } else {
                foreach ($folder_info['id_field'] as $id_field) {
                    $select[] = 'main.' . $id_field;
                }
            }
            $extra = 'ORDER BY main.' . $relationship['id_field'];
            if ($relationship['cat_field'] === null) {
                $where = [];
            } else {
                if ((($_cat_id === null) || ($_cat_id === '')) && ($relationship['linker_table'] != $folder_info['table'])) {
                    $where = [$relationship['id_field'] => ($folder_info['id_field_numeric'] ? db_get_first_id() : '')]; // Don't go through the linker table for the root category
                } else {
                    $where = [$relationship['cat_field'] => $_cat_id];
                }
            }
            $select = array_unique($select);
            $child_folders = $folder_info['db']->query_select($table, $select, $where, $extra, 10000/*Reasonable limit*/);
            foreach ($child_folders as $folder) {
                $str_id = extract_content_str_id_from_data($folder, $folder_info);
                $filename = $this->folder_convert_id_to_filename($resource_type, $str_id);

                $filetime = $this->_get_folder_edit_date($folder, $parent_folder);
                if ($filetime === null) {
                    if ($folder_info['edit_time_field'] !== null) {
                        $filetime = $folder[$folder_info['edit_time_field']];
                    }
                    if ($filetime === null) {
                        if ($folder_info['add_time_field'] !== null) {
                            $filetime = $folder[$folder_info['add_time_field']];
                        }
                    }
                }

                $listing[] = [
                    $filename,
                    COMMANDR_FS_DIR,
                    null/*don't calculate a filesize*/,
                    $filetime,
                ];
            }
        }

        // Find files
        foreach ($file_types as $resource_type) {
            $file_info = $this->_get_cma_info($resource_type);
            if ($file_info === null) {
                continue;
            }

            $relationship = $this->_has_parent_child_relationship($cat_resource_type, $resource_type);
            if ($relationship === null) {
                continue;
            }

            $where = [];
            if ($this->folder_resource_type !== null) {
                $_cat_id = ($relationship['cat_field_numeric'] ? (($cat_id == '') ? null : intval($cat_id)) : $cat_id);
                $where[$relationship['cat_field']] = $_cat_id;
            }

            $select = [];
            append_content_select_for_fields($select, $file_info, ['id', 'add_time', 'edit_time'], 'main');
            $files = $file_info['db']->query_select($file_info['table'] . ' main', $select, $where, '', 10000/*Reasonable limit*/);
            foreach ($files as $file) {
                $str_id = extract_content_str_id_from_data($file, $file_info);
                $filename = $this->file_convert_id_to_filename($resource_type, $str_id);

                $filetime = null;
                if (method_exists($this, '_get_file_edit_date')) {
                    $filetime = $this->_get_file_edit_date($file, $parent_folder);
                }
                if ($filetime === null) {
                    if ($file_info['edit_time_field'] !== null) {
                        $filetime = $file[$file_info['edit_time_field']];
                    }
                    if ($filetime === null) {
                        if ($file_info['add_time_field'] !== null) {
                            $filetime = $file[$file_info['add_time_field']];
                        }
                    }
                }

                $listing[] = [
                    $filename,
                    COMMANDR_FS_FILE,
                    null/*don't calculate a filesize*/,
                    $filetime,
                ];
            }
        }

        if ($cat_id != '') { // File for editing the folder's own properties
            list($cat_resource_type, $cat_id) = $this->folder_convert_filename_to_id(implode('/', $meta_dir));
            require_code('content');
            $folder_info = $this->_get_cma_info($cat_resource_type);
            if ($folder_info !== null) {
                $folder = content_get_row($cat_id, $folder_info);

                $filetime = null;
                if (method_exists($this, '_get_file_edit_date')) {
                    $filetime = $this->_get_folder_edit_date($folder, end($meta_dir));
                }
                if ($filetime === null) {
                    if ($folder_info['edit_time_field'] !== null) {
                        $filetime = $folder[$folder_info['edit_time_field']];
                    }
                    if ($filetime === null) {
                        if ($folder_info['add_time_field'] !== null) {
                            $filetime = $folder[$folder_info['add_time_field']];
                        }
                    }
                }

                $listing[] = [
                    RESOURCE_FS_SPECIAL_DIRECTORY_FILE,
                    COMMANDR_FS_FILE,
                    null/*don't calculate a filesize*/,
                    $filetime,
                ];
            }
        }

        return $listing;
    }

    /**
     * Standard Commandr-fs directory creation function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  string $new_dir_name The new directory name
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return boolean Success?
     */
    public function make_directory(array $meta_dir, string $meta_root_node, string $new_dir_name, object &$commandr_fs) : bool
    {
        if ($this->folder_resource_type === null) {
            return false;
        }
        return $this->folder_add($new_dir_name, implode('/', $meta_dir), []);
    }

    /**
     * Standard Commandr-fs directory removal function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  string $dir_name The directory name
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return boolean Success?
     */
    public function remove_directory(array $meta_dir, string $meta_root_node, string $dir_name, object &$commandr_fs) : bool
    {
        if ($this->folder_resource_type === null) {
            return false;
        }
        return $this->folder_delete($dir_name, implode('/', $meta_dir));
    }

    /**
     * Standard Commandr-fs file reading function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  string $file_name The file name
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return ~string The file contents (false: failure)
     */
    public function read_file(array $meta_dir, string $meta_root_node, string $file_name, object &$commandr_fs)
    {
        if ($file_name == RESOURCE_FS_SPECIAL_DIRECTORY_FILE) {
            return $this->folder_load__flat(array_pop($meta_dir), implode('/', $meta_dir));
        }
        return $this->file_load__flat($file_name, implode('/', $meta_dir));
    }

    /**
     * Standard Commandr-fs file writing function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  string $file_name The file name
     * @param  string $contents The new file contents
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return boolean Success?
     */
    public function write_file(array $meta_dir, string $meta_root_node, string $file_name, string $contents, object &$commandr_fs) : bool
    {
        if ($file_name == RESOURCE_FS_SPECIAL_DIRECTORY_FILE) {
            return $this->folder_save__flat(array_pop($meta_dir), implode('/', $meta_dir), $contents) !== false;
        }
        return $this->file_save__flat($file_name, implode('/', $meta_dir), $contents) !== false;
    }

    /**
     * Standard Commandr-fs file removal function for Commandr-fs hooks.
     *
     * @param  array $meta_dir The current meta-directory path
     * @param  string $meta_root_node The root node of the current meta-directory
     * @param  string $file_name The file name
     * @param  object $commandr_fs A reference to the Commandr filesystem object
     * @return boolean Success?
     */
    public function remove_file(array $meta_dir, string $meta_root_node, string $file_name, object &$commandr_fs) : bool
    {
        if ($file_name == RESOURCE_FS_SPECIAL_DIRECTORY_FILE) {
            return true; // Fake success, as needs to do so when deleting folder contents
        }
        return $this->file_delete($file_name, implode('/', $meta_dir));
    }
}
