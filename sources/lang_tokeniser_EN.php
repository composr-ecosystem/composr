<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    search
 */

/**
 * Reference implementation of language tokeniser, coded for English.
 *
 * We only expose limited methods because not all languages have words or phrases - other languages will implement the decomposition and ngram functionality very differently.
 *
 * Particularly / for example...
 *
 * These common languages do not have words:
 *  - Chinese
 *  - Japanese
 *  - Thai
 *  - Khmer
 *  - Lao
 *  - Burmese
 *  - Korean
 *
 * Vietnamese has spaces but they dilineate syllables, not words.
 *
 * @package search
 */
class LangTokeniser_EN
{
    /* Querying */

    /**
     * Turn a search query into a set of tokens to search against.
     *
     * @param  string $query Search query
     * @param  boolean $support_boolean Whether to support boolean syntax
     * @param  integer $max_tokens The maximum number of tokens to parse
     * @return array A complex structure of search tokens
     */
    public function query_to_search_tokens(string $query, bool $support_boolean = true, int $max_tokens = 30) : array
    {
        /*
        Note the default for $max_tokens comes from being comfortably less than MySQL's:
         - maximum number of joins ("Too many tables; MySQL can only use 31 tables in a join" / "Too many tables; MySQL can only use 61 tables in a join" - depending on 32 vs 64 bit)
         - maximum nesting depth (61, "Too high level of nesting for select")

        If it's longer then the query is probably just spam anyway, intended as post spam by a bot. We therefore don't need anything bigger.
        */

        $fuzzy_and = [];
        $and = [];
        $not = [];

        $is_singular_ngram = true;
        $in_quotes = false;
        $operator = null;
        $current_search_token = '';
        $num_tokens_found = 0;

        $utf = (get_charset() == 'utf-8');
        $word_char_regexp = '#\w#' . ($utf ? 'u' : '');

        $c = null;
        $past_c = null;
        $len = cms_mb_strlen($query);
        for ($i = 0; $i < $len; $i++) {
            if ($c !== null) {
                $past_c = $c;
            }

            if ($utf) {
                $c = cms_mb_substr($query, $i, 1);
            } else {
                $c = $query[$i];
            }

            if (($operator === null) && (!$in_quotes) && ($current_search_token == '')) {
                if ($c == '"') {
                    if (($past_c === null) || (trim($past_c) == '')) {
                        $in_quotes = true;
                        continue;
                    }
                } elseif ($c == '+' || $c == '-') {
                    if ($support_boolean) {
                        $operator = $c;
                        continue;
                    }
                }

                if (preg_match($word_char_regexp, $c) != 0) {
                    $current_search_token = $c;
                }
            } else {
                if ($c == '"') {
                    if ($in_quotes) {
                        $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token, $is_singular_ngram, $num_tokens_found, $max_tokens);
                    } elseif ($current_search_token == '') {
                        $in_quotes = true; // E.g. +"foo"
                    }
                    continue;
                }

                if (($c == "'") && ($current_search_token != '') && ($i != $len - 1)) { // E.g. "Don't"
                    if ($utf) {
                        $next_c = cms_mb_substr($query, $i + 1, 1);
                    } else {
                        $next_c = $query[$i + 1];
                    }
                    if (preg_match($word_char_regexp, $next_c) != 0) {
                        $current_search_token .= $c . $next_c;
                        $i++;
                        continue;
                    }
                }

                if (preg_match($word_char_regexp, $c) != 0) {
                    $current_search_token .= $c;
                } elseif (!$in_quotes) {
                    $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token, $is_singular_ngram, $num_tokens_found, $max_tokens);
                } else {
                    $is_singular_ngram = false;
                    if (substr($current_search_token, -1) != ' ') {
                        $current_search_token .= ' ';
                    }
                }
            }
        }

        $this->finish_search_token($fuzzy_and, $and, $not, $in_quotes, $operator, $current_search_token, $is_singular_ngram, $num_tokens_found, $max_tokens);

        return [$fuzzy_and, $and, $not];
    }

    /**
     * Finish off parsing of a search token.
     *
     * @param  array $fuzzy_and Current fuzzy and tokens
     * @param  array $and Current and tokens
     * @param  array $not Current not tokens
     * @param  boolean $in_quotes Whether we are currently parsing a quoted portion of the query
     * @param  ?string $operator The special boolean operator for this token (null: none)
     * @param  string $current_search_token The current token
     * @param  boolean $is_singular_ngram If it is a singular ngram
     * @param  integer $num_tokens_found The number of tokens found so far
     * @param  integer $max_tokens The maximum number of tokens to parse
     */
    protected function finish_search_token(array &$fuzzy_and, array &$and, array &$not, bool &$in_quotes, ?string &$operator, string &$current_search_token, bool &$is_singular_ngram, int &$num_tokens_found, int $max_tokens)
    {
        if ($num_tokens_found == $max_tokens) {
            return;
        }

        if ($current_search_token != '') {
            $current_search_token = cms_mb_strtolower($current_search_token);

            // We map from search token to whether is is a $is_singular_ngram.
            //  In practice this means stemming and considering if it is a stop word
            //  For reference implementation this checks for spaces, which is consistent with how we delineate words in ngrams in this implementation
            //  Spaces will only be possible to be there if the term was surrounded in quotes
            if ((!$is_singular_ngram) && (substr($current_search_token, -1) == ' ')) {
                $current_search_token = substr($current_search_token, 0, strlen($current_search_token) - 1);
            }
            if ($operator === null) {
                $fuzzy_and[$current_search_token] = $is_singular_ngram;
            } elseif ($operator == '+') {
                $and[$current_search_token] = $is_singular_ngram;
            } elseif ($operator == '-') {
                $not[$current_search_token] = $is_singular_ngram;
            } else {
                fatal_exit('Unknown operator');
            }

            $num_tokens_found++;
        }

        $is_singular_ngram = true;
        $in_quotes = false;
        $operator = null;
        $current_search_token = '';
    }

    /* Indexing */

    /**
     * Convert some text into some ngrams (basically words or word sequences) to be indexed.
     *
     * @param  string $text Text to be indexed
     * @param  integer $max_ngram_size The maximum number of ngrams (typically words) to sequence together
     * @param  ?integer $total_singular_ngram_tokens Write into a count of singular ngrams (typically, words) in here (null: do not count)
     * @return array A list of ngrams (along with a boolean to indicate whether they are a boolean ngram)
     */
    public function text_to_ngrams(string $text, int $max_ngram_size = 1, ?int &$total_singular_ngram_tokens = null) : array
    {
        $word_ngrams = [];

        $phrases = $this->text_to_phrases($text);
        foreach ($phrases as $phrase) {
            $word_list = $this->phrase_to_word_list($phrase, $total_singular_ngram_tokens);
            $this->word_list_to_word_ngrams($word_ngrams, $word_list, $max_ngram_size);
        }

        return $word_ngrams;
    }

    /**
     * Convert text to phrases (a phrase is a sequence of words that go together, that can be used for ngram sequences).
     *
     * @param  string $text The text
     * @return array List of phrases
     */
    protected function text_to_phrases(string $text) : array
    {
        static $utf = null;
        if ($utf === null) {
            $utf = (get_charset() == 'utf-8');
        }

        static $phrase_separation_characters = null;
        if ($phrase_separation_characters === null) {
            $phrase_separation_characters = ['.', ';', ':', '"', '!', '?', '(', ')', '[', ']', '{', '}', '<', '>'];
            if ($utf) {
                // Smart quote characters
                $phrase_separation_characters[] = "\u{201C}";
                $phrase_separation_characters[] = "\u{201D}";
                $phrase_separation_characters[] = "\u{2018}";
                $phrase_separation_characters[] = "\u{2019}";
            }
            $phrase_separation_characters = array_flip($phrase_separation_characters);
        }

        $text = cms_mb_strtolower($text);

        $phrases = [];
        $len = cms_mb_strlen($text);
        $current_phrase = '';
        for ($i = 0; $i < $len; $i++) {
            if ($utf) {
                $c = cms_mb_substr($text, $i, 1);
            } else {
                $c = $text[$i];
            }
            if (isset($phrase_separation_characters[$c])) {
                $phrases[] = $current_phrase;
                $current_phrase = '';
            } else {
                $current_phrase .= $c;
            }
        }
        if ($current_phrase != '') {
            $phrases[] = $current_phrase;
        }
        return $phrases;
    }

    /**
     * Convert a phrase to a list of words.
     *
     * @param  string $phrase A phrase
     * @param  ?integer $total_word_tokens Maintain a count of singular ngrams (word tokens in our case) in here (null: do not count)
     * @return array List of words
     */
    protected function phrase_to_word_list(string $phrase, ?int &$total_word_tokens) : array
    {
        static $utf = null, $word_regexp = null;
        if ($utf === null) {
            $utf = (get_charset() == 'utf-8');
            $word_regexp = "#(\w'\w|\w)+#" . ($utf ? 'u' : '');
        }

        $matches = [];
        $_total_word_tokens = preg_match_all($word_regexp, $phrase, $matches);
        if ($total_word_tokens !== null) {
            $total_word_tokens += $_total_word_tokens;
        }
        $words = [];
        for ($i = 0; $i < $_total_word_tokens; $i++) {
            $words[] = $matches[0][$i];
        }
        return $words;
    }

    /**
     * Convert a simple word list into a list of ngrams, taking into account we want to do sequencing.
     *
     * @param  array $word_ngrams Write word ngrams into here (along with a boolean to indicate whether they are a boolean ngram)
     * @param  array $word_list List of words
     * @param  integer $max_ngram_size The maximum number of ngrams (typically words) to sequence together
     */
    protected function word_list_to_word_ngrams(array &$word_ngrams, array $word_list, int $max_ngram_size)
    {
        $count = count($word_list);

        for ($i = 0; $i < $count; $i++) {
            $current_ngram = '';

            for ($j = 0; $j < $max_ngram_size; $j++) {
                if (!isset($word_list[$i + $j])) {
                    break;
                }

                $word = $word_list[$i + $j];

                if ($j != 0) {
                    $current_ngram .= ' ';
                }
                $current_ngram .= $word;

                $is_singular_ngram = ($j == 0);
                $word_ngrams[$current_ngram] = $is_singular_ngram;
            }
        }
    }
}
