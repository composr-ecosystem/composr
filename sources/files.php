<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/*EXTRA FUNCTIONS: strtoupper|strtolower*/

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__files()
{
    if (!defined('IGNORE_DEFAULTS')) {
        define('IGNORE_DEFAULTS', 0);
        // -
        define('IGNORE_ACCESS_CONTROLLERS', 1);
        define('IGNORE_HIDDEN_FILES', 2);
        define('IGNORE_EDITFROM_FILES', 4);
        define('IGNORE_REVISION_FILES', 8);
        define('IGNORE_REBUILDABLE_OR_TEMP_FILES_FOR_BACKUP', 16); // Stuff that could be re-generated by the software on-demand
        define('IGNORE_CUSTOM_ZONES', 32);
        define('IGNORE_CUSTOM_THEMES', 64);
        define('IGNORE_CUSTOM_LANGS', 128);
        define('IGNORE_NONBUNDLED', 256); // Known non-bundled addon files
        define('IGNORE_FLOATING', 512); // Particular patterns of file which we know may appear but outside the scope of normal checks
        define('IGNORE_SHIPPED_VOLATILE', 1024); // Specific files liable to change that exist out-if-the-box
        define('IGNORE_UNSHIPPED_VOLATILE', 2048); // Specific files liable to change that don't exist out-of-the-box
        define('IGNORE_CUSTOM_DIRS', 4096); // Any *_custom directory, except for the default index.html/.htaccess files (access controller files) in them
        define('IGNORE_CUSTOM_DIR_FLOATING_CONTENTS', 8192); // Any *_custom directory which represents user-data we should ignore within a dev machine [very conservative compared to IGNORE_CUSTOM_DIRS, only Comcode pages and theme images], except for the default index.html/.htaccess files (access controller files) in them
        define('IGNORE_UPLOADS', 16384); // The uploads directory, except for the default index.html/.htaccess files (access controller files) in them
        define('IGNORE_ALIEN', 32768); // Similar to IGNORE_FLOATING except finds anything not defined in an addon (bundled or non-bundled). Used a lot in the automated tests. Note that this will make automated tests not work if you haven't yet put new files into an addon_registry hook.

        define('FILE_WRITE_FAILURE_SILENT', 1);
        define('FILE_WRITE_FAILURE_SOFT', 2);
        define('FILE_WRITE_FAILURE_CRITICAL', 32);
        define('FILE_WRITE_SYNC_FILE', 4);
        define('FILE_WRITE_FIX_PERMISSIONS', 8);
        define('FILE_WRITE_BOM', 16);

        define('NON_CNS_QUOTA', 5); // A hard-coded default for non-Conversr forums
    }
}

/**
 * Opens file or URL. {{creates-file}}
 * Supports character set detection using BOM (which will then by bypassed from further reading).
 *
 * @param  PATH $path File path
 * @param  ?string $charset Detected character set will be written into here (null: not set yet)
 * @param  boolean $locking File lock (if set, you must unlock with LOCK_UN before fclose)
 * @param  string $mode Mode (e.g. at).
 * @param  ?string $default_charset The default character set if none is specified (null: leave as null, ultimately meaning the default website character set will be used) (blank: smart detection)
 * @return ~resource The file handle (false: could not be opened)
 */
function cms_fopen_text_read(string $path, ?string &$charset, bool $locking = false, string $mode = 'rb', ?string $default_charset = null)
{
    $charset = null;

    $myfile = fopen($path, $mode);
    if ($myfile === false) {
        return false;
    }

    if ($locking) {
        flock($myfile, LOCK_SH);
    }

    $starts_at_end = (strpos($mode, 'a+') !== false);
    if ($starts_at_end) {
        fseek($myfile, 0, SEEK_SET);
    }

    $start_data = fread($myfile, 4);

    list($charset, $bom) = detect_string_bom($start_data);
    if ($charset === null) {
        if ($default_charset === '') {
            // We need to do a deeper probe -- if the first 10kb is utf-8 compatible it almost certainly is utf-8 or ASCII (which is fine to use as utf-8 too)
            $remaining = fread($myfile, 1024 * 10);
            if (fix_bad_unicode($remaining) == $remaining) {
                $default_charset = 'utf-8';
            } else {
                $default_charset = (get_charset() == 'utf-8') ? 'ISO-8859-1' : get_charset(); // Pick the most appropriate non-utf-8 character set we can
            }
        }

        $charset = $default_charset;
    }

    if ($starts_at_end) {
        fseek($myfile, 0, SEEK_END);
    } elseif ($bom !== null) {
        fseek($myfile, strlen($bom), SEEK_SET);
    } else {
        fseek($myfile, 0, SEEK_SET);
    }

    return $myfile;
}

/**
 * Gets line from file pointer. Supports character set conversion.
 *
 * @param  resource $myfile The file pointer
 * @param  ?string $charset The character set to read with (likely found from cms_fopen_text_read) (null: website character set)
 * @return ~string The string read (false: error)
 */
function cms_fgets($myfile, ?string $charset)
{
    $line = fgets($myfile);
    if ($line !== false) {
        $line = rtrim($line, "\r"); // In case it is in Windows format (effectively this is /s/\r\n/\n/). We don't consider Classic Mac format, as only Microsoft Excel Mac does this now, and we handle that in CMS_CSV_Reader

        if ($charset == 'utf-8') {
            // Fix any bad unicode
            $line = fix_bad_unicode($line);
        }

        require_code('character_sets');
        $line = convert_to_internal_encoding($line, $charset);
    }

    return $line;
}

/**
 * Open a file for writing, with a BOM.
 *
 * @param  PATH $path File path
 * @param  boolean $locking File lock (if set, you must unlock with LOCK_UN before fclose)
 * @param  ?string $mode File mode (null: detect based on $locking)
 * @param  ?string $charset Character set to write with (null: website character set)
 * @return ~resource The file handle (false: could not be opened)
 */
function cms_fopen_text_write(string $path, bool $locking = false, ?string $mode = null, ?string $charset = null)
{
    if ($mode === null) {
        $mode = ($locking ? 'cb' : 'wb');
    }

    $boms = _get_boms();
    if ($charset === null) {
        $charset = get_charset();
    }

    $file_already_existed = is_file($path);

    $myfile = fopen($path, $mode);

    if ($myfile !== false) {
        if ($locking) {
            flock($myfile, LOCK_EX);
            if ($mode == 'cb') {
                ftruncate($myfile, 0);
            }
        }

        if ((strpos($mode, 'a') === false) || (!$file_already_existed)) {
            if (array_key_exists($charset, $boms)) {
                fwrite($myfile, $boms[$charset]);
            }
        }
    }

    return $myfile;
}

/**
 * Write out to a file, with lots of error checking and locking.
 *
 * @param  PATH $path File path
 * @param  string $contents File contents
 * @param  integer $flags FILE_WRITE_* flags
 * @param  ?string $charset Character set to write with (null: website character set)
 * @param  integer $retry_depth How deep it is into retrying if somehow the data did not get written
 * @return boolean Success status
 */
function cms_file_put_contents_safe(string $path, string $contents, int $flags = 4, ?string $charset = null, int $retry_depth = 0) : bool
{
    // Add BOM (byte-order-mark) to identify character set within the file
    if ((($flags & FILE_WRITE_BOM) != 0) && ($contents != '')) {
        $boms = _get_boms();
        if ($charset === null) {
            $charset = get_charset();
        }
        if (array_key_exists($charset, $boms)) {
            $bom_found = false;
            foreach ($boms as $bom) {
                if ((strlen($contents) >= strlen($bom)) && (substr($contents, strlen($bom)) == $bom)) {
                    $bom_found = true;
                    break;
                }
            }
            if (!$bom_found) { // Only add if not already there
                $contents = $boms[$charset] . $contents;
            }
        }
    }

    $num_bytes_to_save = strlen($contents);

    $error_message = mixed();

    $exists_already = file_exists($path);

    if (!$exists_already) {
        // If the directory is missing
        if (!is_dir(dirname($path))) {
            require_code('files2');
            if (($flags & FILE_WRITE_FAILURE_SILENT) != 0) {
                $test = @make_missing_directory(dirname($path));
                if ($test === false) {
                    return false;
                }
            } else {
                make_missing_directory(dirname($path));
            }
        }
    }

    // Error condition: If there's a lack of disk space
    if (php_function_allowed('disk_free_space')) {
        $num_bytes_to_write = $num_bytes_to_save;
        if (is_file($path)) {
            $num_bytes_to_write -= @filesize($path); /* @ is for race condition */
        }
        static $disk_space = null;
        if ($disk_space === null) {
            $disk_space = @disk_free_space(dirname($path));
        }
        if ($disk_space !== false) {
            if ($disk_space < $num_bytes_to_write) {
                if (($flags & FILE_WRITE_FAILURE_SILENT) == 0) {
                    if (function_exists('do_lang_tempcode')) {
                        $error_message = do_lang_tempcode('COULD_NOT_SAVE_FILE', escape_html($path));
                    } else {
                        $error_message = 'Could not save file ' . htmlentities($path);
                    }
                } else {
                    $error_message = '';
                }
                return _cms_file_put_contents_safe_failed($error_message, $path, $flags);
            }
        }
    }

    // Save
    $num_bytes_written = @file_put_contents($path, $contents, (strpos($path, '://') !== false) ? 0 : LOCK_EX);
    if (php_function_allowed('disk_free_space')) {
        if (($disk_space !== false) && ($num_bytes_written !== false)) {
            $disk_space -= $num_bytes_written;
        }
    }

    // Error condition: If it failed to save
    if ($num_bytes_written === false) {
        if (($flags & FILE_WRITE_FAILURE_SILENT) == 0) {
            $error_message = intelligent_write_error_inline($path, ($flags & FILE_WRITE_FAILURE_CRITICAL) != 0);
        } else {
            $error_message = '';
        }
        return _cms_file_put_contents_safe_failed($error_message, $path, $flags);
    }

    // Error condition: If it did not save all bytes
    if ($num_bytes_written < $num_bytes_to_save) {
        if ($exists_already) {
            @unlink($path);
        }

        if (($flags & FILE_WRITE_FAILURE_SILENT) == 0) {
            if (function_exists('do_lang_tempcode')) {
                $error_message = do_lang_tempcode('COULD_NOT_SAVE_FILE', escape_html($path));
            } else {
                $error_message = 'Could not save file ' . htmlentities($path);
            }
        } else {
            $error_message = '';
        }
        return _cms_file_put_contents_safe_failed($error_message, $path, $flags);
    }

    // Extra requested operations
    if (($flags & FILE_WRITE_FIX_PERMISSIONS) != 0) {
        fix_permissions($path);
    }
    if (($flags & FILE_WRITE_SYNC_FILE) != 0) {
        sync_file($path);
    }

    return true;
}

/**
 * If cms_file_put_contents_safe has failed, process the error messaging.
 *
 * @param  mixed $error_message Error message (string or Tempcode)
 * @param  PATH $path File path
 * @param  integer $flags FILE_WRITE_* flags
 * @return boolean Success status (always false)
 */
function _cms_file_put_contents_safe_failed($error_message, string $path, int $flags = 4) : bool
{
    if (($flags & FILE_WRITE_FAILURE_SILENT) != 0) {
        return false;
    }

    static $looping = false;
    if ($looping || ($flags & FILE_WRITE_FAILURE_CRITICAL) != 0) {
        critical_error('PASSON', is_string($error_message) ? $error_message : ('Could not write to ' . htmlentities($path))); // Bail out hard if would cause a loop
    }
    $looping = true;

    if (($flags & FILE_WRITE_FAILURE_SOFT) != 0) {
        global $IN_MINIKERNEL_VERSION;
        if ((!$IN_MINIKERNEL_VERSION) && (function_exists('user_lang'))) {
            require_code('site');
            attach_message($error_message, 'warn', false, true);
        }
    } else { // default to hard error
        warn_exit($error_message, false, true);
    }

    $looping = false;

    return false;
}

/**
 * Get the number of bytes for a PHP config option. Code taken from the PHP manual.
 *
 * @param  string $val PHP config option value
 * @return integer Number of bytes
 */
function php_return_bytes(string $val) : int
{
    $val = trim($val);
    if ($val == '') {
        return 0;
    }
    $last = cms_strtolower_ascii($val[strlen($val) - 1]);
    $_val = intval(preg_replace('#[^\d]#', '', $val));
    switch ($last) {
        case 'g':
            $_val *= 1024;
            // no break
        case 'm':
            $_val *= 1024;
            // no break
        case 'k':
            $_val *= 1024;
            // no break
    }

    return $_val;
}

/**
 * Get a formatted-string filesize for the specified file. It is formatted as such: x MB/KB/Bytes (or unknown). It is assumed that the file exists.
 *
 * @param  URLPATH $url The URL that the file size of is being worked out for. Should be local.
 * @return string The formatted-string file size
 */
function get_file_size(string $url) : string
{
    if (substr($url, 0, strlen(get_base_url())) == get_base_url()) {
        $url = substr($url, strlen(get_base_url()));
    }

    if (!url_is_local($url)) {
        return do_lang('UNKNOWN');
    }

    $_full = rawurldecode($url);
    $_full = get_file_base() . '/' . $_full;
    $file_size_bytes = filesize($_full);

    return clean_file_size($file_size_bytes);
}

/**
 * Format the specified filesize.
 *
 * @param  mixed $bytes The number of bytes the file has (integer or float)
 * @return string The formatted-string file size
 */
function clean_file_size($bytes) : string
{
    if ($bytes < 0) {
        return '-' . clean_file_size(-$bytes);
    }

    if ($bytes === null) {
        return do_lang('UNKNOWN') . ' bytes';
    }
    if ($bytes == 2147483647) { // TODO: #3046 in tracker
        return do_lang('UNKNOWN') . ' bytes';
    }
    if (floatval($bytes) > 2.0 * 1024.0 * 1024.0 * 1024.0) {
        return strval(intval(round(floatval($bytes) / 1024.0 / 1024.0 / 1024.0))) . ' GB';
    }
    if (floatval($bytes) > 1024.0 * 1024.0 * 1024.0) {
        return float_format(floatval($bytes) / 1024.0 / 1024.0 / 1024.0, 2) . ' GB';
    }
    if (floatval($bytes) > 2.0 * 1024.0 * 1024.0) {
        return strval(intval(round(floatval($bytes) / 1024.0 / 1024.0))) . ' MB';
    }
    if (floatval($bytes) > 1024.0 * 1024.0) {
        return float_format(floatval($bytes) / 1024.0 / 1024.0, 2) . ' MB';
    }
    if (floatval($bytes) > 2.0 * 1024.0) {
        return strval(intval(round(floatval($bytes) / 1024.0))) . ' KB';
    }
    if (floatval($bytes) > 1024.0) {
        return float_format(floatval($bytes) / 1024.0, 2) . ' KB';
    }
    return strval($bytes) . ' Bytes';
}

/**
 * Parse a configuration file.
 * Supports locking and character set conversion (using BOMs).
 *
 * @param  PATH $path The file path
 * @param  boolean $process_sections Whether to process sections
 * @param  integer $scanner_mode Any INI_SCANNER_* constant
 * @return ~array Map of Ini file data (2d if processed sections) (false: error)
 */
function cms_parse_ini_file_safe(string $path, bool $process_sections = false, int $scanner_mode = INI_SCANNER_NORMAL)
{
    return parse_ini_string(cms_file_get_contents_safe($path), $process_sections, $scanner_mode);
}

/**
 * Parse the specified INI file, and get an array of what it found.
 * Designed to be higher performance than PHP's parse_ini_file, for simpler files.
 * Supports locking and character set conversion (using BOMs).
 *
 * @param  ?PATH $path The path to the ini file to open (null: given contents in $file instead)
 * @param  ?string $contents The contents of the file (null: the file needs opening)
 * @return array A map of the contents of the ini files
 */
function cms_parse_ini_file_fast(?string $path, ?string $contents = null) : array
{
    if ($contents === null) {
        global $FILE_ARRAY;
        if (@is_array($FILE_ARRAY)) {
            $contents = unixify_line_format(handle_string_bom(file_array_get($path)));
        } else {
            $contents = function_exists('cms_file_get_contents_safe') ? cms_file_get_contents_safe($path, FILE_READ_LOCK | FILE_READ_UNIXIFIED_TEXT | FILE_READ_BOM) : file_get_contents($path);
        }
    }

    $ini_array = [];
    $lines = explode("\n", $contents);
    foreach ($lines as $line) {
        $line = rtrim($line);

        if ($line == '') {
            continue;
        }
        if ($line[0] == '#') {
            continue;
        }

        $bits = explode('=', $line, 2);
        if (isset($bits[1])) {
            list($property, $value) = $bits;
            $value = trim($value, '"');
            $ini_array[$property] = str_replace('\n', "\n", $value);
        }
    }

    return $ini_array;
}

/**
 * Find whether a file/directory is known to be something that should/could be there but isn't a software distribution file, or for some other reason should be ignored.
 * NB: Don't forget to edit untouchable directories and files in global.php where necessary.
 *
 * @param  string $path Path (relative to the software base directory)
 * @param  integer $bitmask Bitmask of extra stuff to ignore (see IGNORE_* constants)
 * @return boolean Whether it should be ignored
 */
function should_ignore_file(string $path, int $bitmask = 0) : bool
{
    $is_dir = @is_dir(get_file_base() . '/' . $path);
    $is_file = @is_file(get_file_base() . '/' . $path);

    // Normalise
    if (strpos($path, '/') !== false) {
        $dir = dirname($path);
        $filename = basename($path);
    } else {
        $dir = '';
        $filename = $path;
    }
    $filename_lower = function_exists('cms_strtolower_ascii') ? cms_strtolower_ascii($filename) : strtolower($filename);

    $ignore_filenames_and_dir_names = [ // Case insensitive, define in lower case
        '.' => '.*',
        '..' => '.*',

        // Operating system files
        '__macosx' => '.*',
        '.bash_history' => '.*',
        'thumbs.db:encryptable' => '.*',
        'thumbs.db' => '.*',
        '.ds_store' => '.*',
        "icon\r" => '.*',
        'System Volume Information' => '', // If mounted in VirtualBox as a drive

        // Source code control systems
        '.git' => '.*',
        'git-hooks' => '',
        '.gitattributes' => '',
        '.gitignore' => '',
        '.gitconfig' => '',
        'ci_queue.bin' => 'data_custom',

        // Build files
        'phpdoc.dist.xml' => '',

        // Web server files
        'error_log' => '.*',
        'web-inf' => '.*',
        'www.pid' => '',
        '.ftaccess' => '',
        '.ftpquota' => '',
        'cgi-bin' => '',
        'stats' => '', // ISPConfig
        'php.ini' => '.*',
        '.htpasswd' => '.*',
        '400.shtml' => '',
        '500.shtml' => '',
        '404.shtml' => '',
        '403.shtml' => '',
        'cron.yaml' => '',
        'dos.yaml' => '',
        'queue.yaml' => '',
        '.htaccess' => '',

        // De facto standard
        'robots.txt' => '',
        'ads.txt' => '',
        'app-ads.txt' => '',
        'manifest.json' => '',
        'browserconfig.xml' => '',
        'favicon.ico' => '', // Not used for the software, but default path for other scripts on server

        // Authorisation files
        'bingsiteauth.xml' => '',

        // Dynamically created meta-tree, huge and must be ignored for anything
        '_meta_tree' => 'themes/[^/]*',

        // Specially-recognised naming conventions
        '_old' => '.*',
        '_old_backups' => '.*',

        // Syntax's used during software testing
        'gibb' => '.*',
        'gibberish' => '.*',

        // Installer files
        'install.php' => '', // Sometimes we do need to check this in our automated tests. Typically we just add it back into the file list or define a special case!
        'data.cms' => '',
        'install_ok' => '',
        'install_locked' => '',
        'cms.sql' => '', // Temporary backup
        'restore.php' => '',

        // IDE projects
        'nbproject' => '', // Netbeans
        '.project' => '', // Eclipse / Zend Studio
        '.settings' => '', // Eclipse / Zend Studio
        '.buildpath' => '', // Eclipse / Zend Studio
        '.idea' => '', // JetBrains / PhpStorm
        '.editorconfig' => '',

        // Linting
        '.eslintignore' => '', // ESLint ignore file
        '.eslintrc.json' => '', // ESLint config file
        '.phpcs.xml' => '', // PHP CodeSniffer config file
        'phpcs.phar' => '', // For latest version of PHP CodeSniffer
        'psalm.xml' => '', // Psalm

        // Composer
        'composer.phar' => '',
        'vendor' => '',
        'composer.lock' => '',

        // Software control files
        'closed.html' => '',
        'closed.html.old' => '',

        // Legacy temporary files
        'temp' => '',
        'safe_mode_temp' => '', // LEGACY

        // Testing platform
        'codechecker.ini' => '_tests/codechecker',
        'checker.ini' => '_tests/codechecker', // LEGACY

        // Telemetry (we do not ignore 'data/keys' as it contains the public software key)
        'telemetry.json' => 'data_custom/keys',
        'telemetry-site.json' => 'data_custom/keys',
    ];

    $ignore_extensions = [ // Case insensitive, define in lower case
        // Cache files
        'lcd' => 'caches/.*',
        'gcd' => 'caches/.*',
        'htm' => 'caches/static',
        'xml' => 'caches/static',
        'tcp' => 'themes/[^/]*/templates_cached/.*',
        'css' => 'themes/[^/]*/templates_cached/.*',
        'js' => 'themes/[^/]*/templates_cached/.*',
        'gz' => '(themes/[^/]*/templates_cached/.*|caches/static)',
        'br' => '(themes/[^/]*/templates_cached/.*|caches/static)',

        // Log files
        'log' => '.*',

        // Custom fonts
        'ttf' => 'data_custom/fonts',

        // Temporary files
        'tmp' => '.*',
        'bin' => 'caches/http',
        'bak' => '.*',
        'old' => '.*',
        'cms' => '.*', // Installers and upgraders
        'php' => '_compiled/.*',

        // Build files
        'class' => '.*',
        'lst' => '.*',

        // IDE projects
        'clpprj' => '.*', // Code Lobster
        'csprj' => '.*', // Code Lobster
        'geany' => '', // Geany
    ];

    $ignore_filename_and_dir_name_patterns = [ // Case insensitive
        // Operating system files
        ['\..*\.(png|gif|jpeg|jpg)', '.*'], // Image metadata file, e.g. ".example.png"
        ['\.\_.*', '.*'], // Mac OS extended attributes

        // Web server files
        ['\_vti\_.*', '.*'], // Frontpage

        // Authorisation files
        ['google.*\.html', ''],

        // LEGACY: Configuration backups
        ['_config\.php\.bak*', ''],
    ];

    $ignore_filename_patterns = [ // Case insensitive; we'll use this only when we *need* directories that would match to be valid
    ];

    if (($bitmask & IGNORE_ACCESS_CONTROLLERS) != 0) {
        $ignore_filenames_and_dir_names = array_merge($ignore_filenames_and_dir_names, [
            '.htaccess' => '.*',
            'web.config' => '.*',
            'index.html' => '.*',
        ]);
    }

    if (($bitmask & IGNORE_HIDDEN_FILES) != 0) {
        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['\..*', '.*'],
        ]);
    }

    if (($bitmask & IGNORE_EDITFROM_FILES) != 0) {
        $ignore_extensions = array_merge($ignore_extensions, [
            'editfrom' => '.*',
        ]);
    }

    if (($bitmask & IGNORE_REVISION_FILES) != 0) { // E.g. global.css.<timestamp>
        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['.*\.\d+.*', '.*'],
            ['.*\.latest_in_cms_edit', '.*'],
            ['.*\.\d+.*', 'exports/file_backups'],
        ]);
    }

    if (($bitmask & IGNORE_REBUILDABLE_OR_TEMP_FILES_FOR_BACKUP) != 0) {
        if (preg_match('#^exports/(builds|backups|addons)(/|$)#i', $path) != 0) {
            return true;
        }
        if (preg_match('#^uploads/(auto_thumbs)(/|$)#i', $path) != 0) {
            return true;
        }
    }

    if (($bitmask & IGNORE_CUSTOM_ZONES) != 0) {
        if ((is_dir(get_file_base() . '/' . $path)) && (is_file(get_file_base() . '/' . $path . '/index.php')) && (is_dir(get_file_base() . '/' . $path . '/pages')) && (!in_array($filename_lower, ['adminzone', 'cms', 'forum', 'site', 'docs']))) {
            return true;
        }
    }

    if (($bitmask & IGNORE_CUSTOM_THEMES) != 0) {
        if ((preg_match('#^themes($|/)#i', $dir) != 0) && (substr($path, 0, strlen('themes/default/')) != 'themes/default/') && (substr($path, 0, strlen('themes/admin/')) != 'themes/admin/') && (!in_array($path, ['themes/default', 'themes/admin', 'themes/index.html', 'themes/map.ini']))) {
            return true;
        }
    }

    if (($bitmask & IGNORE_CUSTOM_LANGS) != 0) {
        // Wrong lang packs
        if (
            (
                (strlen($filename) == 2) &&
                ((function_exists('cms_strtoupper_ascii') ? cms_strtoupper_ascii($filename) : strtoupper($filename)) == $filename) &&
                ($filename_lower != $filename) &&
                ($filename != 'EN')
            ) ||
            ($filename == 'EN_us') ||
            ($filename == 'ZH-TW') ||
            ($filename == 'ZH-CN')
        ) {
            return true;
        }
    }

    if ((($bitmask & IGNORE_NONBUNDLED) != 0) || (($bitmask & IGNORE_ALIEN) != 0)) {
        static $addon_files = null;
        static $addon_files_nonbundled = null;

        if ($addon_files === null) {
            $addon_files = [];
            $addon_files_nonbundled = [];
            $hooks = find_all_hooks('systems', 'addon_registry');
            if (!defined('DEFAULT_ZONE_PAGE_NAME')) {
                define('DEFAULT_ZONE_PAGE_NAME', 'home');
            }
            foreach ($hooks as $hook => $place) {
                if (function_exists('extract_module_functions')) {
                    require_code('addons');
                    $hook_path = get_file_base() . '/' . $place . '/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
                    $addon_info = read_addon_info($hook, false, null, null, $hook_path);
                    if ($place == 'sources_custom') {
                        $addon_files_nonbundled = array_merge($addon_files_nonbundled, array_map('cms_strtolower_ascii', $addon_info['files']));
                    } else {
                        $addon_files = array_merge($addon_files, array_map('cms_strtolower_ascii', $addon_info['files']));
                    }
                } else { // Running from outside the software
                    require_code('hooks/systems/addon_registry/' . filter_naughty_harsh($hook));
                    $hook_ob = object_factory('Hook_addon_registry_' . filter_naughty_harsh($hook));
                    if ($place == 'sources_custom') {
                        $addon_files_nonbundled = array_merge($addon_files_nonbundled, array_map(function_exists('cms_strtolower_ascii') ? 'cms_strtolower_ascii' : 'strtolower', $hook_ob->get_file_list()));
                    } else {
                        $addon_files = array_merge($addon_files, array_map(function_exists('cms_strtolower_ascii') ? 'cms_strtolower_ascii' : 'strtolower', $hook_ob->get_file_list()));
                    }
                }
            }
            $addon_files = array_flip($addon_files);
            $addon_files_nonbundled = array_flip($addon_files_nonbundled);
        }

        $is_addon_file = false;
        $is_nonbundled_addon_file = false;
        if ((isset($addon_files[$path])) || (isset($addon_files[function_exists('cms_strtolower_ascii') ? cms_strtolower_ascii($path) : strtolower($path)]))) {
            $is_addon_file = true;
        }
        if ((isset($addon_files_nonbundled[$path])) || (isset($addon_files_nonbundled[function_exists('cms_strtolower_ascii') ? cms_strtolower_ascii($path) : strtolower($path)]))) {
            $is_nonbundled_addon_file = true;
        }
        // Note that we have no support for identifying directories related to addons, only files inside. Code using this function should detect directories with no usable files in as relating to addons.

        if (!$is_dir) {
            if ((($bitmask & IGNORE_ALIEN) != 0) && (!$is_addon_file) && (!$is_nonbundled_addon_file)) {
                return true;
            }

            // Do not simply ignore if the file is in a non-bundled addon; it must also not be present in any bundled addon file lists.
            if ((($bitmask & IGNORE_NONBUNDLED) != 0) && (!$is_addon_file) && ($is_nonbundled_addon_file)) {
                return true;
            }
        }
    }

    if (($bitmask & IGNORE_FLOATING) != 0) {
        if (preg_match('#^tracker/uploads(/|$)#i', $path) != 0) {
            return true; // Mantis upload files
        }
        /* LEGACY: demonstratr
        if (preg_match('#^uploads/website_specific/([^/]*)/demonstratr/servers(/|$)#i', $path) != 0) {
            return true;
        }
        */
        if (preg_match('#^exports/(static|builds|backups)(/|$)#i', $path) != 0) {
            return true; // Huge exported stuff
        }
        if (preg_match('#^data_custom/images/addon_screenshots(/|$)#i', $path) != 0) {
            return true; // Relating to addon build, but not defined in addons
        }
        if (preg_match('#^_tests/(html_dump|screens_tested)(/|$)#i', $path) != 0) {
            return true; // Test set may have various temporary files buried within
        }
        if (preg_match('#^data_custom/ckeditor(/|$)#i', $path) != 0) {
            return true; // Development version of CKEditor
        }
        if ((function_exists('get_db_site')) && (preg_match('#^uploads/website_specific/' . preg_quote(get_db_site(), '#') . '(/|$)#i', $path) != 0)) {
            return true; // Development version of CKEditor
        }

        $ignore_extensions = array_merge($ignore_extensions, [
            'gz' => '(data_custom/sitemaps|themes/[^/]*/templates_cached/.*|caches/static|imports/.*|exports/.*)',

            // Import/Export files
            'tar' => '(imports|exports)/.*',
            'txt' => '(imports|exports)/.*',

            'xml' => 'data_custom/sitemaps',
        ]);

        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['(?!index\.html$)(?!\.htaccess$).*', 'data_custom/modules/chat'], // Various chat data files
        ]);

        $ignore_filenames_and_dir_names = array_merge($ignore_filenames_and_dir_names, [
            'latest_activity.bin' => 'data_custom',
            'latest_activity.txt' => 'data_custom', // LEGACY
            'keys.csv' => '_tests/assets',

            'critical_errors' => '',

            // Non-bundled addons inside the Git repository
            'upgrades' => '', // homesite

            // API docs
            'api' => 'docs',
            'jsdoc' => 'docs',
            'api-template' => 'docs',
        ]);
    }

    if (($bitmask & IGNORE_CUSTOM_DIRS) != 0) {
        $ignore_filename_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['(?!index\.html$)(?!\.htaccess$).*', '.*_custom(/.*)?'], // Stuff under custom folders
        ]);
    }

    if (($bitmask & IGNORE_CUSTOM_DIR_FLOATING_CONTENTS) != 0) {
        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['(?!index\.html$)(?!\.htaccess$).*', 'themes/default/images_custom'], // We don't want deep images_custom directories either
            ['(?!index\.html$)(?!\.htaccess$).*', '.*/(comcode|html)_custom/.*'], // Comcode pages
            ['(?!index\.html$)(?!\.htaccess$).*', 'text_custom/.*'], // Text files
        ]);
    }

    if (($bitmask & IGNORE_UPLOADS) != 0) {
        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['(?!index\.html$)(?!\.htaccess$).*', 'uploads/.*'], // Uploads
        ]);
    }

    if (($bitmask & IGNORE_SHIPPED_VOLATILE) != 0) {
        $ignore_extensions['bin'] .= '|data_custom/modules/chat';

        $ignore_filenames_and_dir_names = array_merge($ignore_filenames_and_dir_names, [
            'map.ini' => 'themes',
            'functions.bin' => 'data_custom',
            'errorlog.php' => 'data_custom',
            'execute_temp.php' => 'data_custom',
            '.user.ini' => '.*',
        ]);
    }

    if (($bitmask & IGNORE_UNSHIPPED_VOLATILE) != 0) {
        $ignore_filename_and_dir_name_patterns = array_merge($ignore_filename_and_dir_name_patterns, [
            ['(?!index\.html$)(?!\.htaccess$).*', 'data_custom/modules/chat'], // Various chat data files
        ]);

        $ignore_filenames_and_dir_names = array_merge($ignore_filenames_and_dir_names, [
            '_config.php' => '',
            'upgrader.cms.tmp' => 'data_custom',
            'unit_test_positive_ignore_sampler.xxx' => 'data_custom', // To help us test this function. This file won't ever exist.
            'latest.bin' => 'data_custom/modules/web_notifications',
            'failover_rewritemap.txt' => 'data_custom',
            'failover_rewritemap__mobile.txt' => 'data_custom',
            'aggregate_types.xml' => 'data_custom/xml_config',
            'hybridauth.xml' => 'data_custom/xml_config',
            'achievements.xml' => 'data_custom/xml_config',
            'breadcrumbs.xml' => 'data_custom/xml_config',
            'fields.xml' => 'data_custom/xml_config',
            'page_errors.xml' => 'data_custom/xml_config',
            'EN.pwl' => 'data_custom/spelling/personal_dicts',
            '_critical_error.html' => '',

            // Non-bundled addons inside the Git repository
            'out.csv' => 'data_custom/modules/user_export', // user_simple_spreadsheet_sync
            'request_helper.bin' => 'mobiquo/include', // tapatalk
            'server_certificates.pem' => 'data_custom/modules/composr_mobile_sdk/ios', // composr_mobile_sdk
            'if_hosted_service.txt' => 'text', // homesite (Demonstratr)
        ]);
    }

    // Special case checks...

    // Software dupe (e.g. an ad-hoc backup) install?
    if (($dir != '') && (is_dir(get_file_base() . '/' . $path)) && (is_dir(get_file_base() . '/' . $path . '/sources_custom'))) {
        return true;
    }

    // Run checks on our data...

    if (isset($ignore_filenames_and_dir_names[$filename_lower])) {
        if (preg_match('#^' . $ignore_filenames_and_dir_names[$filename_lower] . '$#i', $dir) != 0) {
            return true; // Check dir context
        }
    }

    $extension = get_file_extension($filename);
    $extension_lower = function_exists('cms_strtolower_ascii') ? cms_strtolower_ascii($extension) : strtolower($extension);
    if (isset($ignore_extensions[$extension_lower])) {
        if (preg_match('#^' . $ignore_extensions[$extension_lower] . '$#i', $dir) != 0) {
            return true; // Check dir context
        }
    }

    foreach (array_merge($is_file ? $ignore_filename_patterns : [], $ignore_filename_and_dir_name_patterns) as $pattern) {
        list($filename_pattern, $dir_pattern) = $pattern;
        if (preg_match('#^' . $filename_pattern . '$#i', $filename) != 0) {
            if (preg_match('#^' . $dir_pattern . '$#i', $dir) != 0) { // Check dir context
                return true;
            }
        }
    }

    return false;
}

/**
 * Delete all the contents of a directory, and any subdirectories of that specified directory (recursively).
 *
 * @param  PATH $dir The pathname to the directory to delete
 * @param  boolean $default_preserve Whether to preserve index.html and .htaccess files
 * @param  boolean $delete_dir_also Whether to delete the $dir at the end
 * @return boolean Success status
 */
function deldir_contents(string $dir, bool $default_preserve = false, bool $delete_dir_also = false) : bool
{
    require_code('files2');
    return _deldir_contents($dir, $default_preserve, $delete_dir_also);
}
