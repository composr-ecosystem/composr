<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__uploads()
{
    if (!defined('CMS_UPLOAD_ANYTHING')) {
        define('CMS_UPLOAD_IMAGE', 1);
        define('CMS_UPLOAD_VIDEO', 2);
        define('CMS_UPLOAD_AUDIO', 4);
        define('CMS_UPLOAD_ANYTHING', 15);

        define('OBFUSCATE_NEVER', 0);
        define('OBFUSCATE_LEAVE_SUFFIX', 1);
        define('OBFUSCATE_BIN_SUFFIX', 2);
    }

    require_code('urls2');
    require_code('images_cleanup_pipeline');
    require_code('urls_simplifier');

    reset_images_cleanup_pipeline_settings();
}

/**
 * Reset the images cleanup pipeline settings.
 */
function reset_images_cleanup_pipeline_settings()
{
    global $ICPS__RECOMPRESS_MODE, $ICPS__MAXIMUM_DIMENSION, $ICPS__WATERMARKS, $ICPS__STRIP_GPS;
    $ICPS__RECOMPRESS_MODE = IMG_RECOMPRESS_LOSSLESS;
    $ICPS__MAXIMUM_DIMENSION = null;
    $ICPS__WATERMARKS = null;
    $ICPS__STRIP_GPS = true;
}

/**
 * Set the images cleanup pipeline settings.
 *
 * @param  integer $recompress_mode How to recompress, an IMG_RECOMPRESS_* constant
 * @param  ?integer $maximum_dimension The size of the bounding box (null: none)
 * @param  ?array $watermarks Watermark corners (top-left, top-right, bottom-left, bottom-right) (null: none)
 * @param  boolean $strip_gps Whether to strip GPS metadata
 */
function set_images_cleanup_pipeline_settings(int $recompress_mode = 0, ?int $maximum_dimension = null, ?array $watermarks = null, bool $strip_gps = true)
{
    global $ICPS__RECOMPRESS_MODE, $ICPS__MAXIMUM_DIMENSION, $ICPS__WATERMARKS, $ICPS__STRIP_GPS;
    $ICPS__RECOMPRESS_MODE = $recompress_mode;
    $ICPS__MAXIMUM_DIMENSION = $maximum_dimension;
    $ICPS__WATERMARKS = $watermarks;
    $ICPS__STRIP_GPS = $strip_gps;
}

/**
 * An upload has been passed through by POST, either as a file (a new upload), a URL, or as a filedump reference.
 * For images use post_param_image instead.
 * Used with form_input_upload_multi_source.
 * Get the file URL from the POST data.
 *
 * @param  ID_TEXT $name Form field prefix (input type suffixes will be added automatically)
 * @param  ?PATH $upload_to Where to upload to (null: the correct place for $theme_image_type)
 * @param  boolean $required Whether an image is required
 * @param  boolean $is_edit Whether this is an edit operation
 * @param  ?string $filename Pass the filename back by reference (null: do not pass)
 * @param  ?string $thumb_url Pass the thumbnail back by reference (null: do not pass & do not collect a thumbnail)
 * @param  integer $upload_type A CMS_UPLOAD_* constant
 * @param  boolean $copy_to_server Whether to copy a URL (if a URL) to the server, and return a local reference
 * @param  integer $obfuscate Whether to obfuscate file names so the URLs can not be guessed/derived (a OBFUSCATE_* constant)
 * @return ?URLPATH The URL (either to an independent upload, or the theme image, or a filedump URL) (null: leave alone, when doing an edit operation)
 */
function post_param_multi_source_upload(string $name, ?string $upload_to, bool $required = true, bool $is_edit = false, ?string &$filename = null, ?string &$thumb_url = null, int $upload_type = 15, bool $copy_to_server = false, int $obfuscate = 0) : ?string
{
    $thumb_specify_name = $name . '__thumb__url';
    $test = post_param_string($thumb_specify_name, '');
    if ($test == '') {
        $thumb_specify_name = $name . '__thumb__filedump';
    }

    // Upload
    // ------

    require_code('uploads');
    $field_file = $name . '__upload';
    $thumb_attach_name = $name . '__thumb__upload';
    is_plupload(true);
    if (((array_key_exists($field_file, $_FILES)) && ((is_plupload()) || (is_uploaded_file($_FILES[$field_file]['tmp_name']))))) {
        $urls = get_url('', $field_file, $upload_to, $obfuscate, $upload_type, $thumb_url !== null, $thumb_specify_name, $thumb_attach_name);

        if (substr($urls[0], 0, 8) != 'uploads/') {
            $http_result = cms_http_request($urls[0], ['trigger_error' => false, 'byte_limit' => 0]);
            if (($http_result->data === null) && ($http_result->message_b !== null)) {
                attach_message($http_result->message_b, 'warn');
            }
        }

        if ($thumb_url !== null) {
            $thumb_url = $urls[1];
        }
        $filename = $urls[2];

        return cms_rawurlrecode($urls[0]);
    }

    // URL
    // ---

    $field_url = $name . '__url';
    $url = post_param_string($field_url, '');
    if ($url != '') {
        $filename = urldecode(preg_replace('#\?.*#', '', basename($url)));

        // Get thumbnail
        $urls = get_url($field_url, '', $upload_to, OBFUSCATE_NEVER, $upload_type, $thumb_url !== null, $thumb_specify_name, $thumb_attach_name, $copy_to_server);
        if ($thumb_url !== null) {
            $thumb_url = $urls[1];
        }

        return cms_rawurlrecode($url);
    }

    // Filedump
    // --------

    if (addon_installed('filedump')) {
        $field_filedump = $name . '__filedump';
        $url = post_param_string($field_filedump, '');
        if ($url != '') {
            $filename = urldecode(basename($url));

            // Get thumbnail
            $urls = get_url($field_filedump, '', $upload_to, OBFUSCATE_NEVER, $upload_type, $thumb_url !== null, $thumb_specify_name, $thumb_attach_name);
            if ($thumb_url !== null) {
                $thumb_url = $urls[1];
            }

            return cms_rawurlrecode($url);
        }
    }

    // ---

    if (!$required) {
        if (($is_edit) && (post_param_integer($field_file . '_unlink', 0) != 1)) {
            return null;
        }

        return '';
    }

    warn_exit(do_lang_tempcode('IMPROPERLY_FILLED_IN_UPLOAD'));
    return null;
}

/**
 * Find whether an plupload upload has just happened, and optionally simulate as if it were a normal upload (although 'is_uploaded_file'/'move_uploaded_file' would not work).
 *
 * @param  boolean $fake_prepopulation Simulate population of the $_FILES array
 * @return boolean Whether an plupload upload has just happened
 */
function is_plupload(bool $fake_prepopulation = false) : bool
{
    static $done_fake_prepopulation = false;

    $plupload = false;
    $rolling_offset = 0;
    foreach ($_POST as $key => $value) {
        if (!is_string($value)) {
            continue;
        }
        if (is_integer($key)) {
            $key = strval($key);
        }

        if ((preg_match('#^hid_file_id_#i', $key) != 0) && ($value != '-1')) {
            // Get the incoming uploads appropriate database table row
            if (substr($value, -4) == '.bin') { // By .bin name
                $filename = post_param_string(str_replace('hidFileID', 'hidFileName', $key), '');
                if ($filename == '') {
                    continue; // Was cancelled during plupload, but plupload can't cancel so was allowed to finish. So we have hidFileID but not hidFileName.
                }

                $path = 'uploads/incoming/' . filter_naughty($value);
                if (file_exists(get_custom_file_base() . '/' . $path)) {
                    $plupload = true;
                    if ($fake_prepopulation) {
                        $_FILES[substr($key, strlen('hid_file_id_'))] = [
                            'type' => 'plupload',
                            'name' => $filename,
                            'tmp_name' => get_custom_file_base() . '/' . $path,
                            'size' => filesize(get_custom_file_base() . '/' . $path),
                        ];
                    }
                }
            } else { // By incoming upload ID
                $rolling_offset = 0; // We do assume that if we have multiple multi-file fields in the same space that they are spaced with a large enough gap; so we don't maintain a rolling offset between fields
                foreach (array_map('intval', explode(':', $value)) as $i => $incoming_uploads_id) { // Some uploaders may delimite with ":" within a single POST field (plupload); others may give multiple POST fields (plupload, native)
                    $incoming_uploads_row = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . get_table_prefix() . 'incoming_uploads WHERE (i_submitter=' . strval(get_member()) . ' OR i_submitter=' . strval($GLOBALS['FORUM_DRIVER']->get_guest_id()) . ') AND id=' . strval($incoming_uploads_id), 1);
                    if (array_key_exists(0, $incoming_uploads_row)) {
                        if (file_exists(get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url'])) {
                            $plupload = true;
                            if ($fake_prepopulation) {
                                if (!$done_fake_prepopulation) {
                                    $new_key = $key;
                                    $matches = [];
                                    if (preg_match('#^hid_file_id_(.*)(\d+)$#', $key, $matches) != 0) {
                                        $new_key = $matches[1] . strval(intval($matches[2]) + $rolling_offset);
                                    } else {
                                        $new_key = substr($key, strlen('hid_file_id_'));
                                    }
                                    $_FILES[$new_key] = [
                                        'type' => 'plupload',
                                        'name' => $incoming_uploads_row[0]['i_orig_filename'],
                                        'tmp_name' => get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url'],
                                        'size' => filesize(get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url']),
                                    ];
                                    $_POST['hid_file_id_' . $new_key] = strval($incoming_uploads_id);

                                    $rolling_offset++;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if ($plupload) {
        // Filter out vestigial files (been reported as an issue)
        foreach (array_keys($_FILES) as $attach_name) {
            if ((array_key_exists($attach_name, $_FILES)) && (array_key_exists('error', $_FILES[$attach_name]))) {
                if ($_FILES[$attach_name]['error'] == 3) {
                    unset($_FILES[$attach_name]);
                }
            }
        }
    }

    if ($fake_prepopulation) {
        $done_fake_prepopulation = true;
    }

    return $plupload;
}

/**
 * Take an uploaded file and move it into Composr's temporary directory, for future processing outside this web request.
 *
 * @param  string $attach_name Field name
 * @param  boolean $prepend_session_id Prepend the current session ID to the beginning of the filename without returning it in the path (security), 'sessioning'
 * @param  ?string $unsessioned_filename The unsessioned filename (null: not set yet)
 * @return PATH Upload path
 */
function get_temporary_upload_path(string $attach_name, bool $prepend_session_id = false, ?string &$unsessioned_filename = null) : string
{
    require_code('files2');

    if (((is_plupload(true)) && (array_key_exists($attach_name, $_FILES))) || ((array_key_exists($attach_name, $_FILES)) && (is_uploaded_file($_FILES[$attach_name]['tmp_name'])))) {
        $ext = get_file_extension($_FILES[$attach_name]['name']);

        check_extension($_FILES[$attach_name]['name'], false, $_FILES[$attach_name]['tmp_name']);

        $temp_path = get_custom_file_base() . '/temp';
        if (!file_exists($temp_path)) {
            make_missing_directory($temp_path);
        }

        $unsessioned_filename = basename($_FILES[$attach_name]['name']);
        if ($prepend_session_id) {
            $sessioned_filename = get_session_id() . '_' . $unsessioned_filename;
            $target_path = $temp_path . '/' . basename($sessioned_filename, '.' . get_file_extension($sessioned_filename)) . '.' . $ext;
        } else {
            $target_path = $temp_path . '/' . basename($unsessioned_filename, '.' . get_file_extension($unsessioned_filename)) . '.' . $ext;
        }
        if ($_FILES[$attach_name]['type'] != 'plupload') {
            $test = @move_uploaded_file($_FILES[$attach_name]['tmp_name'], $target_path);
        } else {
            $test = @copy($_FILES[$attach_name]['tmp_name'], $target_path); // PHP/incoming_uploads.php will clean up for us, and using @copy makes debugging a lot easier
        }
        if ($test === false) {
            warn_exit(do_lang_tempcode('FILE_MOVE_ERROR', escape_html($_FILES[$attach_name]['name']), escape_html($target_path)));
        }
        fix_permissions($target_path);
        sync_file($target_path);
    } else {
        if (!array_key_exists($attach_name, $_FILES)) {
            warn_exit(do_lang_tempcode('IMPROPERLY_FILLED_IN_UPLOAD'));
        }

        $upload_error_message = get_upload_error_message($_FILES[$attach_name]);
        warn_exit($upload_error_message);
    }

    return $target_path;
}

/**
 * Get error message for an upload.
 *
 * @param  array $file_upload The $_FILES array entry
 * @param  boolean $should_get_something Whether to give a (deferred?) error if no file was given at all
 * @param  ?integer $max_size Maximum file size in bytes (null: default from get_max_file_size function)
 * @return ?Tempcode Error message (null: none;
 */
function get_upload_error_message(array $file_upload, bool $should_get_something = true, ?int $max_size = null) : ?object
{
    if (($file_upload['error'] != 4)/*no upload attempted*/ || ($should_get_something)) {
        if ($file_upload['error'] == 1) {
            if ($max_size === null) {
                require_code('files2');
                $max_size = get_max_file_size();
            }
            return do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format($max_size)));
        }

        if ($file_upload['error'] == 2) {
            return do_lang_tempcode('FILE_TOO_BIG_QUOTA', escape_html(integer_format($max_size)));
        }

        if (($file_upload['error'] == 3) || ($file_upload['error'] == 6) || ($file_upload['error'] == 7)) {
            return do_lang_tempcode('ERROR_UPLOADING_' . strval($file_upload['error']));
        }

        if ($file_upload['error'] == 4) {
            warn_exit(do_lang_tempcode('IMPROPERLY_FILLED_IN_UPLOAD'));
        }

        return do_lang_tempcode('ERROR_UPLOADING');
    }

    return null;
}

/**
 * Get URLs generated according to the specified information. It can also generate a thumbnail if required. It first tries attached upload, then URL, then fails.
 *
 * @param  ID_TEXT $specify_name The name of the POST parameter storing the URL (if '', then no POST parameter). Parameter value may be blank.
 * @param  ID_TEXT $attach_name The name of the HTTP file parameter storing the upload (if '', then no HTTP file parameter). No file necessarily is uploaded under this.
 * @param  ID_TEXT $upload_folder The folder name where we will put this upload
 * @param  integer $obfuscate Whether to obfuscate file names so the URLs can not be guessed/derived (a OBFUSCATE_* constant)
 * @param  integer $enforce_type The type of upload it is (bitmask, from CMS_UPLOAD_* constants)
 * @param  boolean $make_thumbnail Make a thumbnail (this only makes sense, if it is an image)
 * @param  ID_TEXT $thumb_specify_name The name of the POST parameter storing the thumb URL. As before
 * @param  ID_TEXT $thumb_attach_name The name of the HTTP file parameter storing the thumb upload. As before
 * @param  boolean $copy_to_server Whether to copy a URL (if a URL) to the server, and return a local reference
 * @param  boolean $accept_errors Whether to accept upload errors
 * @param  boolean $should_get_something Whether to give a (deferred?) error if no file was given at all
 * @param  boolean $only_make_smaller Whether to apply a 'never make the image bigger' rule for thumbnail creation (would affect very small images)
 * @param  ?MEMBER $member_id Member ID to run permissions with (null: current member)
 * @param  ?PATH $upload_folder_full Full path to upload folder, in case it is not relative to the base directory (null: work out)
 * @param  ?PATH $thumb_folder_full Full path to thumb folder, in case it is not relative to the base directory (null: work out)
 * @param  ?string $filename Filename to use (null: choose one)
 * @return array An array of 4 URL bits (URL, thumb URL, URL original filename, thumb original filename)
 */
function get_url(string $specify_name, string $attach_name, string $upload_folder, int $obfuscate = 0, int $enforce_type = 15, bool $make_thumbnail = false, string $thumb_specify_name = '', string $thumb_attach_name = '', bool $copy_to_server = false, bool $accept_errors = false, bool $should_get_something = false, bool $only_make_smaller = false, ?int $member_id = null, ?string $upload_folder_full = null, ?string $thumb_folder_full = null, ?string $filename = null) : array
{
    require_code('files2');

    if ($member_id === null) {
        $member_id = get_member();
    }

    $upload_folder = filter_naughty($upload_folder);
    if ($upload_folder_full === null) {
        $upload_folder_full = get_custom_file_base() . '/' . $upload_folder;
    }
    $thumb_folder = preg_replace('#^(uploads/[^/]+)#', '${1}_thumbs', $upload_folder);
    if ($thumb_folder_full === null) {
        $thumb_folder_full = get_custom_file_base() . '/' . $thumb_folder;
    }

    $out = [];
    $thumb = null;

    $filearrays = [];
    get_upload_file_array($attach_name, $filearrays);
    if ($thumb_specify_name != '') {
        get_upload_file_array($thumb_specify_name, $filearrays);
    }

    $plupload_uploaded = false;
    $plupload_uploaded_thumb = false;
    foreach ([$attach_name, $thumb_attach_name] as $i => $_attach_name) {
        if ($_attach_name == '') {
            continue;
        }

        // Check if it is an incoming upload
        $row_id_file = 'hid_file_id_' . $_attach_name;
        $row_id_file_value = post_param_string($row_id_file, null);
        if ($row_id_file_value == '-1') {
            $row_id_file_value = null;
        }

        // ID of the upload from the incoming uploads database table
        if ($row_id_file_value !== null) { // plupload was used
            // Get the incoming upload's appropiate DB table row
            if ((substr($row_id_file_value, -4) == '.bin') && (strpos($row_id_file_value, ':') === false)) {
                $path = 'uploads/incoming/' . filter_naughty($row_id_file_value);
                if (file_exists(get_custom_file_base() . '/' . $path)) {
                    $filearrays[$_attach_name] = ['type' => 'plupload', 'name' => post_param_string(str_replace('hidFileID', 'hidFileName', $row_id_file)), 'tmp_name' => get_custom_file_base() . '/' . $path, 'size' => filesize(get_custom_file_base() . '/' . $path)];
                    $_FILES[$_attach_name] = $filearrays[$_attach_name];
                    if ($i == 0) {
                        $plupload_uploaded = true;
                    } else {
                        $plupload_uploaded_thumb = true;
                    }
                }
            } else {
                $incoming_uploads_id = intval(preg_replace('#:.*$#', '', $row_id_file_value));
                $incoming_uploads_row = $GLOBALS['SITE_DB']->query('SELECT * FROM ' . get_table_prefix() . 'incoming_uploads WHERE (i_submitter=' . strval(get_member()) . ' OR i_submitter=' . strval($GLOBALS['FORUM_DRIVER']->get_guest_id()) . ') AND id=' . strval($incoming_uploads_id), 1);
                // If there is a DB record, proceed
                if (array_key_exists(0, $incoming_uploads_row)) {
                    if (file_exists(get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url'])) {
                        $filearrays[$_attach_name] = ['type' => 'plupload', 'name' => $incoming_uploads_row[0]['i_orig_filename'], 'tmp_name' => get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url'], 'size' => filesize(get_custom_file_base() . '/' . $incoming_uploads_row[0]['i_save_url'])];
                        $_FILES[$_attach_name] = $filearrays[$_attach_name];
                        if ($i == 0) {
                            $plupload_uploaded = true;
                        } else {
                            $plupload_uploaded_thumb = true;
                        }
                    }
                }
            }
        }
    }

    if (!empty($filearrays)) {
        cms_profile_start_for('get_url');
    }

    if (!file_exists($upload_folder_full)) {
        require_code('files2');
        make_missing_directory($upload_folder_full);
    }
    if ((!file_exists($thumb_folder_full)) && ($make_thumbnail)) {
        require_code('files2');
        make_missing_directory($thumb_folder_full);
    }

    // Find URL
    require_code('images');
    if ((($enforce_type & CMS_UPLOAD_VIDEO) != 0) || (($enforce_type & CMS_UPLOAD_AUDIO) != 0)) {
        require_code('files2');
        $max_size = get_max_file_size(($upload_folder == 'uploads/attachments') ? get_member() : null, null, false);
    } else {
        $max_size = get_max_image_size(false);
    }
    $is_uploaded = ($attach_name != '') && (array_key_exists($attach_name, $filearrays)) && ((is_uploaded_file($filearrays[$attach_name]['tmp_name'])) || ($plupload_uploaded));
    if ($is_uploaded) { // If we uploaded
        if (!has_privilege($member_id, 'exceed_filesize_limit')) {
            if ($filearrays[$attach_name]['size'] > $max_size) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format($max_size))), 'warn');
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format($max_size))));
                }
            }
        }

        $url = _get_upload_url($member_id, $attach_name, $upload_folder, $upload_folder_full, $enforce_type, $obfuscate, $accept_errors, $filename);
        if ($url == ['', '']) {
            return ['', '', '', ''];
        }

        $is_image = is_image($filearrays[$attach_name]['name'], IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous'), true);
    } elseif (post_param_string($specify_name, '') != '') { // If we specified
        $url = _get_specify_url($member_id, $specify_name, $upload_folder, $enforce_type, $accept_errors);
        $is_image = is_image($url[0], IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous'));
        if ($url[0] != '') {
            if ($enforce_type == CMS_UPLOAD_IMAGE) {
                $is_image = true; // Must be an image if it got to here. Maybe came from oEmbed and not having an image extension.
            }
        }
        if ($url == ['', '']) {
            return ['', '', '', ''];
        }
        if (($copy_to_server) && (!url_is_local($url[0]))) {
            $path2 = cms_tempnam();
            $tmpfile = fopen($path2, 'wb');

            $old_time_limit = cms_extend_time_limit(60);
            $http_result = cms_http_request($url[0], ['byte_limit' => $max_size, 'write_to_file' => $tmpfile, 'timeout' => 60.0]);
            @cms_set_time_limit($old_time_limit);

            $file = $http_result->data;
            fclose($tmpfile);
            if ($file === null) {
                @unlink($path2);
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('CANNOT_COPY_TO_SERVER'), 'warn', false, true);
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('CANNOT_COPY_TO_SERVER'), false, true);
                }
            }
            if ($http_result->filename === null) {
                $http_result->filename = $url[1];
            }

            if (!check_extension($http_result->filename, $obfuscate == OBFUSCATE_BIN_SUFFIX, $path2, $accept_errors)) {
                return ['', '', '', ''];
            }

            if (url_is_local($url[0])) {
                unlink($path2);
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('CANNOT_COPY_TO_SERVER'), 'warn');
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('CANNOT_COPY_TO_SERVER'), false, true);
                }
            }

            $ext = (($obfuscate == OBFUSCATE_BIN_SUFFIX) && (!is_image($http_result->filename, IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous')))) ? 'bin' : get_file_extension($http_result->filename, $http_result->download_mime_type);

            if ($filename === null) {
                if ($obfuscate != OBFUSCATE_NEVER) {
                    list($place, , $filename) = find_unique_path($upload_folder, $filename);
                } else {
                    $filename = shorten_urlencoded_filename($http_result->filename);
                    $place = $upload_folder_full . '/' . $filename;
                }
            } else {
                if (substr($filename, -4) == '.XXX') {
                    $filename = substr($filename, 0, strlen($filename) - 4) . '.' . $ext;
                }

                $place = $upload_folder_full . '/' . shorten_urlencoded_filename($filename);
            }
            if (!has_privilege($member_id, 'exceed_filesize_limit')) {
                $max_size = intval(get_option('max_download_size')) * 1024;
                if (strlen($file) > $max_size) {
                    if ($accept_errors) {
                        attach_message(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format($max_size))), 'warn');
                        return ['', '', '', ''];
                    } else {
                        warn_exit(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format($max_size))));
                    }
                }
            }
            $result = @rename($path2, $place);
            if (($http_result->download_mtime !== null) && ($http_result->download_mtime != 0)) {
                @touch($place, $http_result->download_mtime);
            }
            if (!$result) {
                unlink($path2);
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('WRITE_ERROR', escape_html($upload_folder)), 'warn', false, true);
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('WRITE_ERROR', escape_html($upload_folder)), false, true);
                }
            }
            fix_permissions($place);
            sync_file($place);

            $url[0] = $upload_folder . '/' . $filename;
            if (strpos($http_result->filename, '/') === false) {
                $url[1] = $http_result->filename;
            }
        }
    } else { // Uh oh
        if (array_key_exists($attach_name, $filearrays)) {
            $upload_error_message = get_upload_error_message($filearrays[$attach_name], $should_get_something, $max_size);
            if ($upload_error_message !== null) {
                if ($accept_errors) {
                    attach_message($upload_error_message, 'warn');
                    return ['', '', '', ''];
                } else {
                    warn_exit($upload_error_message);
                }
            }
        }

        $url[0] = '';
        $url[1] = '';
        $is_image = false;
    }

    $out[0] = $url[0];
    $out[1] = '';
    $out[2] = $url[1];
    $out[3] = '';

    // Generate thumbnail if needed
    if (($make_thumbnail) && ($url[0] != '') && ($is_image)) {
        if ((array_key_exists($thumb_attach_name, $filearrays)) && ((is_uploaded_file($filearrays[$thumb_attach_name]['tmp_name'])) || ($plupload_uploaded_thumb))) { // If we uploaded
            if ($filearrays[$thumb_attach_name]['size'] > get_max_image_size(false)) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format(get_max_image_size(false)))), 'warn');
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format(get_max_image_size(false)))));
                }
            }

            $_thumb = _get_upload_url($member_id, $thumb_attach_name, $thumb_folder, $thumb_folder_full, CMS_UPLOAD_IMAGE, OBFUSCATE_NEVER, $accept_errors);
            $thumb = $_thumb[0];
        } elseif (array_key_exists($thumb_specify_name, $_POST)) { // If we specified
            $_thumb = _get_specify_url($member_id, $thumb_specify_name, $thumb_folder, CMS_UPLOAD_IMAGE, $accept_errors);
            $thumb = $_thumb[0];
        } else {
            $thumb_filename = basename(preg_replace('#[^' . URL_CONTENT_REGEXP . '\.]#', 'x', basename($url[0])));
            list($place, , $thumb_filename) = find_unique_path($thumb_folder, $thumb_filename);
            $url_full = url_is_local($url[0]) ? (get_custom_base_url() . '/' . $url[0]) : $url[0];

            $thumb = convert_image($url_full, $place, null, null, intval(get_option('thumb_width')), true, null, false, $only_make_smaller);
        }

        $out[1] = $thumb;
    } elseif ($make_thumbnail) {
        if ((array_key_exists($thumb_attach_name, $filearrays)) && ((is_uploaded_file($filearrays[$thumb_attach_name]['tmp_name'])) || ($plupload_uploaded_thumb))) { // If we uploaded
            if ($filearrays[$thumb_attach_name]['size'] > get_max_image_size(false)) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format(get_max_image_size()))), 'warn');
                    return ['', '', '', ''];
                } else {
                    warn_exit(do_lang_tempcode('FILE_TOO_BIG', escape_html(integer_format(get_max_image_size()))));
                }
            }

            $_thumb = _get_upload_url($member_id, $thumb_attach_name, $thumb_folder, $thumb_folder_full, CMS_UPLOAD_IMAGE, OBFUSCATE_NEVER, $accept_errors);
            $thumb = $_thumb[0];
        } elseif (array_key_exists($thumb_specify_name, $_POST)) {
            $_thumb = _get_specify_url($member_id, $thumb_specify_name, $thumb_folder, CMS_UPLOAD_IMAGE, $accept_errors);
            $thumb = $_thumb[0];
        }
        if ($thumb !== null) {
            $out[1] = $thumb;
        }
    }

    // Images cleanup pipeline
    if ((($enforce_type & CMS_UPLOAD_IMAGE) != 0) && ($enforce_type != CMS_UPLOAD_ANYTHING)) {
        if (($is_uploaded) && ($out[0] != '') && (url_is_local($out[0]))) {
            global $ICPS__RECOMPRESS_MODE, $ICPS__MAXIMUM_DIMENSION, $ICPS__WATERMARKS, $ICPS__STRIP_GPS;
            handle_images_cleanup_pipeline(get_custom_file_base() . '/' . rawurldecode($out[0]), $out[2], $ICPS__RECOMPRESS_MODE, $ICPS__MAXIMUM_DIMENSION, $ICPS__WATERMARKS, $ICPS__STRIP_GPS);
        }
    }

    // For reentrance of previews
    if ($specify_name != '') {
        $_POST[$specify_name] = $out[0];
    }
    if ($thumb_specify_name != '') {
        $_POST[$thumb_specify_name] = $out[1];
    }

    $out[0] = cms_rawurlrecode($out[0]);
    if (array_key_exists(2, $out)) {
        $out[2] = cms_rawurlrecode($out[2]);
    }

    if (!empty($filearrays)) {
        cms_profile_end_for('get_url', $attach_name);
    }

    return $out;
}

/**
 * Filters specified URLs to make sure we're really allowed to access them.
 *
 * @param  MEMBER $member_id Member ID to check permissions with
 * @param  ID_TEXT $specify_name The name of the POST parameter storing the URL (if '', then no POST parameter). Parameter value may be blank.
 * @param  ID_TEXT $upload_folder The folder name where we will put this upload
 * @param  integer $enforce_type The type of upload it is (bitmask, from CMS_UPLOAD_* constants)
 * @param  boolean $accept_errors Whether to accept upload errors
 * @return array A pair: the URL and the filename
 *
 * @ignore
 */
function _get_specify_url(int $member_id, string $specify_name, string $upload_folder, int $enforce_type = 15, bool $accept_errors = false) : array
{
    // Security check against naughty URLs
    $url = [];
    $url[0] = /*filter_naughty*/(post_param_string($specify_name));
    $url[1] = rawurldecode(basename($url[0]));

    // If this is a relative URL then it may be downloaded through a PHP script.
    //  So lets check we are allowed to download it!
    if (($url[0] != '') && (url_is_local($url[0]))) {
        $missing_ok = false;

        // Check the file exists
        if ((!file_exists(get_custom_file_base() . '/' . rawurldecode($url[0]))) && (!$missing_ok)) {
            if ($accept_errors) {
                attach_message(do_lang_tempcode('MISSING_FILE'), 'warn', false, true);
                return ['', ''];
            } else {
                warn_exit(do_lang_tempcode('MISSING_FILE'), false, true);
            }
        }

        // Its not in the upload folder, so maybe we aren't allowed to download it
        if (
            (
                (substr($url[0], 0, strlen($upload_folder) + 1) != $upload_folder . '/') &&
                (substr($url[0], 0, strlen('data/images/') + 1) != 'data/images/') &&
                (preg_match('#^[^\?\.]*\.(m4v|mp4|f4v|mpeg|mpg|webm|ogv|png|gif|jpg|jpeg|jpe)$#', $url[0]) == 0)/*Streaming/compression plugins can mess up our script detection so safelist some formats*/
            ) ||
            (strpos($url[0], '..') !== false)
        ) {
            $myfile = @fopen(get_custom_file_base() . '/' . rawurldecode($url[0]), 'rb');
            if ($myfile !== false) {
                $shouldbe = fread($myfile, 8000);
                fclose($myfile);
            } else {
                $shouldbe = null;
            }
            $actuallyis = cms_http_request(get_custom_base_url() . '/' . $url[0], ['trigger_error' => false, 'byte_limit' => 8000]);

            if (($actuallyis->message == '200') && ($shouldbe === null)) {
                // No error downloading, but error using file system - therefore file exists and we'll use URL to download. Hence no security check.
                $missing_ok = true;
            } else {
                if (substr($shouldbe, 0, 8000) !== substr($actuallyis->data, 0, 8000)) {
                    log_hack_attack_and_exit('TRY_TO_DOWNLOAD_SCRIPT');
                }
            }
        }
    }

    if ($url[0] != '') {
        // oEmbed etc
        if (($enforce_type != CMS_UPLOAD_ANYTHING) && (($enforce_type & CMS_UPLOAD_IMAGE) != 0) && (!is_image($url[0], IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous')))) {
            require_code('media_renderer');
            require_code('http');
            $meta_details = get_webpage_meta_details($url[0]);
            require_code('hooks/systems/media_rendering/oembed');
            $oembed_ob = object_factory('Hook_media_rendering_oembed');
            if ((!empty($meta_details['t_mime_type'])) && ($oembed_ob->recognises_mime_type($meta_details['t_mime_type'], $meta_details)) || $oembed_ob->recognises_url($url[0])) {
                $oembed = $oembed_ob->get_oembed_data_result($url[0], ['width' => get_option('video_width_setting'), 'height' => get_option('video_height_setting')]);
                if (($oembed !== null) && ($oembed['type'] == 'photo')) {
                    $url[0] = preg_replace('#.*(https?://)#', '${1}', array_key_exists('url', $oembed) ? $oembed['url'] : $oembed['thumbnail_url']); // Get thumbnail, but strip noembed.com (for example) resizer-proxy prefix if there
                    $url[1] = basename(urldecode($url[0]));
                    return $url;
                }
            }
            if (($meta_details['t_mime_type'] !== null) && (substr($meta_details['t_mime_type'], 0, 6) == 'image/')) {
                return $url;
            }
            if ($meta_details['t_image_url'] != '') {
                $url[0] = $meta_details['t_image_url'];
                $url[1] = basename(urldecode($url[0]));
                return $url;
            }
        }

        if (!_check_enforcement_of_type($member_id, $url[0], $enforce_type, $accept_errors)) {
            return ['', ''];
        }
    }

    return $url;
}

/**
 * Ensures a given filename is of the right file extension for the desired file type.
 *
 * @param  MEMBER $member_id Member ID to check permissions with
 * @param  string $file The filename
 * @param  integer $enforce_type The type of upload it is (bitmask, from CMS_UPLOAD_* constants)
 * @param  boolean $accept_errors Whether to accept upload errors
 * @return boolean Success status
 *
 * @ignore
 */
function _check_enforcement_of_type(int $member_id, string $file, int $enforce_type, bool $accept_errors = false) : bool
{
    if (($enforce_type & CMS_UPLOAD_ANYTHING) != 0) {
        return true;
    }

    require_code('images');
    $ok = false;
    if (($enforce_type & CMS_UPLOAD_IMAGE) != 0) {
        if (!is_image($file, IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous'), true)) {
            if ($enforce_type == CMS_UPLOAD_IMAGE) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('NOT_IMAGE'), 'warn');
                } else {
                    warn_exit(do_lang_tempcode('NOT_IMAGE'));
                }
                return false;
            }
        } else {
            $ok = true;
        }
    }
    if (($enforce_type & CMS_UPLOAD_VIDEO) != 0) {
        if (!is_video($file, has_privilege($member_id, 'comcode_dangerous'), false)) {
            if ($enforce_type == CMS_UPLOAD_VIDEO) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('NOT_VIDEO'), 'warn');
                } else {
                    warn_exit(do_lang_tempcode('NOT_VIDEO'));
                }
                return false;
            }
        } else {
            $ok = true;
        }
    }
    if (($enforce_type & CMS_UPLOAD_AUDIO) != 0) {
        if (!is_audio($file, has_privilege($member_id, 'comcode_dangerous'))) {
            if ($enforce_type == CMS_UPLOAD_AUDIO) {
                if ($accept_errors) {
                    attach_message(do_lang_tempcode('NOT_AUDIO'), 'warn');
                } else {
                    warn_exit(do_lang_tempcode('NOT_AUDIO'));
                }
                return false;
            }
        } else {
            $ok = true;
        }
    }
    if (!$ok) {
        if ($accept_errors) {
            attach_message(do_lang_tempcode('_NOT_FILE_TYPE'), 'warn');
        } else {
            warn_exit(do_lang_tempcode('_NOT_FILE_TYPE'));
        }
        return false;
    }
    return true;
}

/**
 * Converts an uploaded file into a URL, by moving it to an appropriate place.
 *
 * @param  MEMBER $member_id Member ID to check permissions with
 * @param  ID_TEXT $attach_name The name of the HTTP file parameter storing the upload (if '', then no HTTP file parameter). No file necessarily is uploaded under this.
 * @param  ID_TEXT $upload_folder The folder name where we will put this upload
 * @param  PATH $upload_folder_full Full folder path
 * @param  integer $enforce_type The type of upload it is (bitmask, from CMS_UPLOAD_* constants)
 * @param  integer $obfuscate Whether to obfuscate file names so the URLs can not be guessed/derived (a OBFUSCATE_* constant)
 * @param  boolean $accept_errors Whether to accept upload errors
 * @param  ?string $filename Filename to use (null: choose one)
 * @return array A pair: the URL and the filename
 *
 * @ignore
 */
function _get_upload_url(int $member_id, string $attach_name, string $upload_folder, string $upload_folder_full, int $enforce_type = 15, int $obfuscate = 0, bool $accept_errors = false, ?string $filename = null) : array
{
    $filearrays = [];
    get_upload_file_array($attach_name, $filearrays);

    $file = shorten_urlencoded_filename($filearrays[$attach_name]['name']);

    if (!check_extension($file, $obfuscate == OBFUSCATE_BIN_SUFFIX, null, $accept_errors)) {
        return ['', '', '', ''];
    }

    if (!_check_enforcement_of_type($member_id, $file, $enforce_type, $accept_errors)) {
        return ['', ''];
    }

    $ext = get_file_extension($file);
    $ext = (($obfuscate == OBFUSCATE_BIN_SUFFIX) && (!is_image($file, IMAGE_CRITERIA_WEBSAFE, has_privilege(get_member(), 'comcode_dangerous')))) ? 'bin' : get_file_extension($file);

    if ($filename === null) {
        // If we are not obfuscating then we will need to search for an available filename
        if (($obfuscate == OBFUSCATE_NEVER) || (strlen($file) > 150)) {
            list($place, , $filename) = find_unique_path($upload_folder, $file);
        } else { // A result of some randomness
            require_code('crypt');
            $filename = get_secure_random_string() . '.' . $ext;
            list($place, , $filename) = find_unique_path($upload_folder, $filename);
        }
    } else {
        if (substr($filename, -4) == '.XXX') {
            $filename = substr($filename, 0, strlen($filename) - 4) . '.' . $ext;
        }

        $place = $upload_folder_full . '/' . $filename;
    }

    $test_cdn = handle_upload_post_processing($enforce_type, $filearrays[$attach_name]['tmp_name'], $upload_folder, basename($place), $obfuscate, $accept_errors);
    if ($test_cdn !== null) {
        $url = [];
        $url[0] = $test_cdn;
        $url[1] = $test_cdn;
        return $url;
    }

    // Copy there, and return our URL
    if ($filearrays[$attach_name]['type'] != 'plupload') {
        $test = @move_uploaded_file($filearrays[$attach_name]['tmp_name'], $place);
    } else {
        $test = @copy($filearrays[$attach_name]['tmp_name'], $place); // We could rename, but it would hurt integrity of refreshes
    }
    if ($test === false) {
        if ($accept_errors) {
            $df = do_lang_tempcode('FILE_MOVE_ERROR', escape_html($file), escape_html($place));
            attach_message($df, 'warn', false, true);
            return ['', ''];
        } else {
            warn_exit(do_lang_tempcode('FILE_MOVE_ERROR', escape_html($file), escape_html($place)));
        }
    }
    fix_permissions($place);
    sync_file($place);

    $url = [];
    $url[0] = $upload_folder . '/' . rawurlencode($filename);
    $url[1] = $file;
    return $url;
}

/**
 * Does post-processing of a new upload into the system.
 *
 * @param  integer $enforce_type The type of upload it is (bitmask, from CMS_UPLOAD_* constants)
 * @param  PATH $path The disk path of the upload. Should be a temporary path that is deleted by the calling code
 * @param  ID_TEXT $upload_folder The folder name in uploads/ where we would normally put this upload, if we weren't transferring it to the CDN
 * @param  string $filename Filename to upload with. May not be respected, depending on service implementation
 * @param  integer $obfuscate Whether to obfuscate file names so the URLs can not be guessed/derived (a OBFUSCATE_* constant)
 * @param  boolean $accept_errors Whether to accept upload errors
 * @return ?URLPATH URL on syndicated server (null: did not syndicate)
 */
function handle_upload_post_processing(int $enforce_type, string $path, string $upload_folder, string $filename, int $obfuscate = 0, bool $accept_errors = false) : ?string
{
    // Is a CDN transfer hook going to kick in?
    $hooks = find_all_hook_obs('systems', 'cdn_transfer', 'Hook_cdn_transfer_');
    foreach ($hooks as $object) {
        if ($object->is_enabled()) {
            $test = $object->transfer_upload($path, $upload_folder, $filename, $obfuscate, $accept_errors);
            if ($test !== null) {
                return $test;
            }
        }
    }

    // Check space
    require_code('files2');
    check_shared_space_usage(filesize($path));

    return null;
}

/**
 * In Tapatalk files may be passed as arrays, so abstract that complexity.
 *
 * @param  ID_TEXT $name The name of the HTTP file parameter storing the upload
 * @param  array $filearrays Where we are storing our file arrays
 */
function get_upload_file_array(string $name, array &$filearrays)
{
    if (!isset($_FILES[$name])) {
        $name = preg_replace('#\d+$#', '', $name);
    }

    if (!isset($_FILES[$name])) {
        return;
    }

    if (is_array($_FILES[$name]['name'])) {
        $matches = [];
        if (preg_match('#^([^\d]*)(\d+)([^\d]*)$#', $name, $matches) == 0) {
            $matches = [1 => $name, 2 => '1', 3 => ''];
        }
        $base_num = intval($matches[2]);

        $num_files = count($_FILES[$name]['name']);

        for ($i = 0; $i < $num_files; $i++) {
            $filearray = [];
            foreach ($_FILES[$name] as $key => $value) { // Goes through keys like 'name', 'tmp_name' etc
                $filearray[$key] = $value[$i];
            }
            $_name = $matches[1] . strval($i + $base_num) . $matches[3];
            $filearrays[$_name] = $filearray;
        }
        return;
    }

    $filearrays[$name] = $_FILES[$name];
}
