<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_addon_management
 */

/**
 * Standard code module initialisation function.
 *
 * @ignore
 */
function init__addons2()
{
    require_code('files');
    require_code('addons');

    global $SITE_MAINTENANCE_LOCK;
    $SITE_MAINTENANCE_LOCK = false;
}

/*
=====================
DEPENDENCY MANAGEMENT
=====================
*/

/**
 * Resolve addon dependencies to install missing dependencies / hold back uninstallation if a dependency exists.
 * Returns by reference.
 *
 * @param  array $installing Addons being installed (a map between addon filename and addon details)
 * @param  array $uninstalling Addons being uninstalled (a map between addon name and addon details)
 */
function resolve_addon_dependency_problems(array &$installing, array &$uninstalling)
{
    require_lang('addons');
    require_code('addons');

    preload_all_addons_info();

    $addons_not_installed = find_available_addons(false); // filename => addon details
    $addons_installed = find_installed_addons(false, true, true); // addon name => addon details

    $addon_names_to_filenames = [];
    foreach ($addons_not_installed as $addon_file => $addon_info) {
        $addon_names_to_filenames[$addon_info['name']] = $addon_file;
    }

    // Only uninstall if we're not working from a Git repository
    if (file_exists(get_file_base() . '/.git')) {
        $uninstalling = [];
    }

    // Resolve dependency problems
    //  Dependency chains can be complex, so loop until we're stopped finding anything changing.
    //  We (basically) bias for having more installed to resolve dependencies.
    do {
        $installing_pre = $installing;
        $uninstalling_pre = $uninstalling;

        // Select missing dependencies for what we are installing / remove if unsatisfiable dependencies
        foreach ($installing as $addon_file => $addon_info) {
            $addon_name = $addon_info['name'];

            $dependencies = isset($addon_info['dependencies']) ? explode(',', $addon_info['dependencies']) : [];
            foreach ($dependencies as $dep) {
                $dep_filename = isset($addon_names_to_filenames[$dep]) ? $addon_names_to_filenames[$dep] : null;

                if ((!addon_installed($dep, true)) && (($dep_filename === null) || (!in_array($dep_filename, $installing)))) {
                    if (($dep_filename !== null) && (in_array($dep_filename, $addons_not_installed))) {
                        $installing[$dep_filename] = $addons_not_installed[$dep];
                    } else {
                        unset($installing[$addon_file]); // unsatisfiable dependencies
                    }
                }
            }
        }

        // Deselect for uninstallation if something kept depends on it
        foreach ($uninstalling as $addon_name => $addon_info) {
            $dependencies_on_this = $addon_info['dependencies_on_this'];
            $has_active_dependencies = false;
            foreach ($dependencies_on_this as $dep) {
                if (!array_key_exists($dep, $uninstalling)) {
                    $has_active_dependencies = true;
                }
            }

            if ($has_active_dependencies) {
                unset($uninstalling[$addon_name]);
            }
        }
    } while (($installing != $installing_pre) || ($uninstalling != $uninstalling_pre));
}

/*
===============
CREATING ADDONS
===============
*/

/**
 * Create an addon to spec.
 *
 * @param  string $file Filename to create in exports/addons directory (should end in .tar)
 * @param  array $files List of files to include
 * @param  string $addon_name Addon name
 * @param  string $incompatibilities Addon incompatibilities (comma-separated)
 * @param  string $dependencies Addon dependencies (comma-separated)
 * @param  string $author Addon author
 * @param  string $organisation Addon organisation
 * @param  string $version Addon version
 * @param  string $category Addon category
 * @param  string $copyright_attribution Addon copyright attribution
 * @param  string $licence Addon licence
 * @param  string $description Addon description
 * @param  string $min_cms_version Minimum required major.minor version of the website software to install this addon (blank: effectively 11.0)
 * @param  string $max_cms_version Maximum allowed major.minor version of the website software to install this addon (blank: no maximum)
 * @param  PATH $dir Directory to save to
 * @param  array $mtimes A map of file mtimes to use
 * @param  ?PATH $file_base Alternate file base to get addon files from (null: main website file base)
 */
function create_addon(string $file, array $files, string $addon_name, string $incompatibilities, string $dependencies, string $author, string $organisation, string $version, string $category, string $copyright_attribution, string $licence, string $description, string $min_cms_version, string $max_cms_version, string $dir = 'exports/addons', array $mtimes = [], ?string $file_base = null)
{
    require_code('tar');

    $_full = get_custom_file_base() . '/' . $dir . '/' . $file;
    $tar = tar_open($_full, 'wb');

    if ($file_base === null) {
        $file_base = get_file_base();
    }

    $max_mtime = 0;

    foreach ($files as $val) {
        if ($val == 'addon.inf') {
            continue;
        }
        if ($val == 'mod.inf') { // LEGACY
            continue;
        }

        $full = $file_base . '/' . filter_naughty($val);

        $themed_suffix = get_param_string('theme', $GLOBALS['FORUM_DRIVER']->get_theme()) . '__';
        $themed_version = dirname($full) . '/' . $themed_suffix . basename($full);

        if ((get_param_integer('keep_theme_test', 0) == 1) && (file_exists($themed_version))) {
            if (!file_exists($themed_version)) {
                continue;
            }

            $mode = fileperms($themed_version);
            $mtime = isset($mtimes[$val]) ? $mtimes[$val] : filemtime($themed_version);
            if ($mtime > $max_mtime) {
                $max_mtime = $mtime;
            }
            tar_add_file($tar, $val, $themed_version, $mode, $mtime, true);
        } else {
            if (!file_exists($full)) {
                continue;
            }

            $mode = fileperms($full);
            $mtime = isset($mtimes[$val]) ? $mtimes[$val] : filemtime($full);
            if ($mtime > $max_mtime) {
                $max_mtime = $mtime;
            }
            tar_add_file($tar, $val, $full, $mode, $mtime, true);

            $full = $file_base . '/' . filter_naughty($val) . '.editfrom';
            if (file_exists($full)) {
                $mode = fileperms($full);
                $mtime = filemtime($full);
                tar_add_file($tar, $val . '.editfrom', $full, $mode, $mtime, true);
            }
        }

        // If it's a theme, make a addon_install_code.php for the theme to restore images_custom mappings
        if ((substr($val, 0, 7) == 'themes/') && (substr($val, 0, 15) == 'themes/default/') && (substr($val, 0, 12) != 'themes/admin/') && (substr($val, -10) == '/theme.ini')) {
            $theme = substr($val, 7, strpos($val, '/theme.ini') - 7);

            $images = $GLOBALS['SITE_DB']->query_select('theme_images', ['*'], ['theme' => $theme]);
            $data = '<' . '?php' . "\n";
            foreach ($images as $image) {
                if (($image['url'] != '') && ($image['url'] != find_theme_image($image['id'], true, true, 'default'))) {
                    $data .= '$GLOBALS[\'SITE_DB\']->query_insert(\'theme_images\', [\'id\' => \'' . db_escape_string($image['id']) . '\', \'theme\' => \'' . db_escape_string($image['theme']) . '\', \'url\' => \'' . db_escape_string($image['url']) . '\', \'lang\' => \'' . db_escape_string($image['lang']) . '\'], false, true);' . "\n";
                }
            }
            tar_add_file($tar, 'addon_install_code.php', $data, 0444, time());
        }
    }

    // Our special file; for auto-compiled addons these details will be copied from the addon_registry hook
    $addon_inf = '';
    $settings = [
        'name' => $addon_name,
        'author' => $author,
        'organisation' => $organisation,
        'version' => $version,
        'category' => $category,
        'copyright_attribution' => $copyright_attribution,
        'licence' => $licence,
        'description' => $description,
        'incompatibilities' => $incompatibilities,
        'dependencies' => $dependencies,
        'min_cms_version' => $min_cms_version,
        'max_cms_version' => $max_cms_version,
    ];
    foreach ($settings as $setting_name => $setting_value) {
        $addon_inf .= $setting_name . '="' . str_replace("\n", '\n', str_replace('"', '\'', $setting_value)) . '"' . "\n";
    }
    tar_add_file($tar, 'addon.inf', $addon_inf, 0644, time());

    tar_close($tar);

    $touch_result = @touch($_full, $max_mtime);
    if ($GLOBALS['DEV_MODE'] && !$touch_result && get_page_name() == 'build_addons') {
        warn_exit(comcode_to_tempcode('You need to fix file ownership of the existing TAR files. Run a command like [tt]sudo chown www-data exports/addons/*.tar[/tt]'));
    }

    fix_permissions($_full);
    sync_file($_full);
}

/*
===============
QUERYING ADDONS
===============
*/

/**
 * Find all the available addons (addons in imports/addons that are not necessarily installed).
 *
 * @param  boolean $installed_too Whether to include addons that are installed already
 * @param  boolean $hash_and_mtime Whether to generate a file hash and include it along with the file mtime in the info
 * @param  array $already_known Map of addons we already have details for, performance optimisation
 * @param  boolean $get_info Whether to get full details about each addon
 * @param  boolean $even_incompatible Whether to also return available addons that are not compatible with this version of the software
 * @return array Maps of maps describing the available addons (filename => details)
 */
function find_available_addons(bool $installed_too = true, bool $hash_and_mtime = true, array $already_known = [], bool $get_info = true, bool $even_incompatible = false) : array
{
    require_code('version');

    $addons_available_for_installation = [];
    $files = [];

    // Find addons available for installation
    $dh = @opendir(get_custom_file_base() . '/imports/addons/');
    if ($dh !== false) {
        while (($file = readdir($dh)) !== false) {
            if (substr($file, -4) == '.tar') {
                $files[] = [$file, null];
            }
        }
        closedir($dh);
    }

    // Find mtimes (in separate loop so as to not have to interleave fs-STAT calls between readdir calls (disk seeking)
    foreach ($files as $i => $file_parts) {
        $file = $file_parts[0];
        $files[$i][1] = $hash_and_mtime ? hash_file('crc32', get_custom_file_base() . '/imports/addons/' . $file) : '';
        $files[$i][2] = $hash_and_mtime ? filemtime(get_custom_file_base() . '/imports/addons/' . $file) : 0;
    }

    sort_maps_by($files, '2');

    foreach ($files as $_file) {
        $file = $_file[0];

        if (isset($already_known[$file])) {
            $addons_available_for_installation[$file] = $already_known[$file];
            continue;
        }

        if ((!$installed_too) && (addon_installed(preg_replace('#-\d+#', '', basename($file, '.tar')), false, true, true, true))) {
            continue;
        }

        $full = get_custom_file_base() . '/imports/addons/' . $file;
        require_code('tar');
        $tar = tar_open($full, 'rb', true);
        $info_file = tar_get_file($tar, 'addon.inf', true);
        if ($info_file === null) {
            $info_file = tar_get_file($tar, 'mod.inf', true); // LEGACY
        }
        tar_close($tar);

        if ($info_file !== null) {
            $info = cms_parse_ini_file_fast(null, $info_file['data']);

            // Skip incompatible addon TARs
            if ((!$even_incompatible) && (((empty($info['min_cms_version'])) || (floatval($info['min_cms_version']) > cms_version_number())) || ((!empty($info['max_cms_version'])) && (floatval($info['max_cms_version']) < cms_version_number())))) {
                continue;
            }

            if ($get_info) {
                if (!empty($info['copyright_attribution'])) {
                    $info['copyright_attribution'] = explode("\n", $info['copyright_attribution']);
                } else {
                    $info['copyright_attribution'] = [];
                }
                if (empty($info['licence'])) {
                    $info['category'] = '(Unstated)';
                }

                $files_rows = tar_get_directory($tar);
                $info['files'] = [];
                foreach ($files_rows as $file_row) {
                    $info['files'][] = $file_row['path'];
                }

                $info += get_default_addon_info();
            }

            // Special details for installable addons
            $info['hash'] = $_file[1];
            $info['mtime'] = $_file[2];
            $info['tar_path'] = $full;

            foreach ($addons_available_for_installation as $i => $a) { // Deduplicate, may be multiple versions in imports/addons
                if ((cms_strtolower_ascii($a['name']) == cms_strtolower_ascii($info['name'])) && (isset($a['version'], $info['version']))) {
                    if (version_compare($a['version'], $info['version']) > 0) {
                        continue 2;
                    } else {
                        unset($addons_available_for_installation[$i]);
                        break;
                    }
                }
            }

            $addons_available_for_installation[$file] = $info;
        }
    }

    return $addons_available_for_installation;
}

/**
 * Find the non-bundled addons available on the homesite.
 *
 * @return array Map of addon ID to addon title, could be empty if an error occurred
 */
function find_remote_addons() : array
{
    static $addons = [];
    if (!empty($addons)) {
        return $addons; // Caching
    }
    $stub = (get_param_integer('localhost', 0) == 1) ? get_base_url() : get_brand_base_url();
    $v = 'Version ' . float_to_raw_string(cms_version_number(), 2, true);
    $url = $stub . '/data/ajax_tree.php?hook=choose_download&id=' . urlencode($v) . '&file_type=tar&full_depth=1';
    $contents = http_get_contents($url, ['convert_to_internal_encoding' => true, 'trigger_error' => false]);
    if ($contents !== null) {
        $matches = [];
        $num_matches = preg_match_all('#<entry id="(\d+)".* title="([^"]+)"#Us', $contents, $matches);
        for ($i = 0; $i < $num_matches; $i++) {
            $id = intval($matches[1][$i]);
            $title = html_entity_decode($matches[2][$i], ENT_QUOTES);
            if ((!array_key_exists($title, $addons)) || ($addons[$title] > $id)) { // We want the one with the lowest ID, as that will be the official one (uploaded via automated process, then maintained since then)
                $addons[$title] = $id;
            }
        }
    } else { // Continue anyway but display error as attached and logged message
        attach_message(do_lang_tempcode('addons:FIND_REMOTE_ADDONS_ERROR', escape_html($stub)), 'warn', false, true);
    }
    return $addons;
}

/**
 * Find all the installed addons.
 *
 * @param  boolean $just_non_bundled Whether to only return details on on-bundled addons
 * @param  boolean $get_info Whether to get full details about each addon
 * @param  boolean $get_dependencies Whether to search for dependencies (only applies if $get_info is true)
 * @return array Map of maps describing the available addons (addon name => details)
 */
function find_installed_addons(bool $just_non_bundled = false, bool $get_info = true, bool $get_dependencies = false) : array
{
    $addons_installed = [];

    $hooks = find_all_hooks('systems', 'addon_registry');

    // Find installed addons- file system method (for coded addons). Coded addons don't need to be in the DB, although they will be if they are (re)installed after the original installation finished.
    foreach ($hooks as $addon_name => $hook_dir) {
        if (($just_non_bundled) && ($hook_dir == 'sources')) {
            continue;
        }

        if (substr($addon_name, 0, 4) != 'core') {
            $hook_path = get_file_base() . '/' . $hook_dir . '/hooks/systems/addon_registry/' . filter_naughty_harsh($addon_name) . '.php';
            $addons_installed[$addon_name] = $get_info ? read_addon_info($addon_name, $get_dependencies, null, null, $hook_path) : null;
        }
    }

    // Find installed addons- database registration method
    $_rows = $GLOBALS['SITE_DB']->query_select('addons', ['addon_name']);
    foreach ($_rows as $row) {
        $addon_name = $row['addon_name'];

        if (($just_non_bundled) && (isset($hooks[$addon_name])) && ($hooks[$addon_name] == 'sources')) {
            continue;
        }

        if (!isset($addons_installed[$addon_name])) {
            $addons_installed[$addon_name] = $get_info ? read_addon_info($addon_name, $get_dependencies) : null;
        }
    }

    return $addons_installed;
}

/**
 * Find addon dependencies.
 *
 * @param  string $addon_name The name of the addon
 * @return array List of dependencies
 */
function find_addon_dependencies_on(string $addon_name) : array
{
    // From DB
    $list_a = collapse_1d_complexity('addon_name', $GLOBALS['SITE_DB']->query_select('addons_dependencies', ['addon_name'], ['addon_name_dependant_upon' => $addon_name, 'addon_name_incompatibility' => 0], 'ORDER BY addon_name'));

    // From core addons
    static $software_addon_dep_cache = null;
    if ($software_addon_dep_cache === null) {
        $software_addon_dep_cache = [];
        $hooks = find_all_hooks('systems', 'addon_registry');
        foreach (array_keys($hooks) as $hook) {
            $_found_hook = false;
            $path = get_file_base() . '/sources_custom/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
            if (is_file($path)) {
                $_found_hook = true;
            } else {
                $path = get_file_base() . '/sources/hooks/systems/addon_registry/' . filter_naughty_harsh($hook) . '.php';
                if (is_file($path)) {
                    $_found_hook = true;
                }
            }
            if (!$_found_hook) {
                continue; // May have been uninstalled, find_all_hooks could have stale caching
            }
            $_hook_bits = extract_module_functions($path, ['get_dependencies']);
            if ($_hook_bits[0] === null) {
                $dep = [];
            } else {
                $dep = is_array($_hook_bits[0]) ? call_user_func_array($_hook_bits[0][0], $_hook_bits[0][1]) : cms_eval($_hook_bits[0], $path);
            }
            $software_addon_dep_cache[$hook] = $dep['requires'];
        }
    }
    $list_b = [];
    foreach ($software_addon_dep_cache as $hook => $hook_requires) {
        if (in_array($addon_name, $hook_requires)) {
            $list_b[] = $hook;
        }
    }

    return array_unique(array_merge($list_a, $list_b));
}

/*
=================
INSTALLING ADDONS
=================
*/

/**
 * Get information for the user relating to an addon that they are intending to install.
 *
 * @param  string $file Filename of the addon TAR file
 * @param  array $also_uninstalling List of addons that we're currently uninstalling (so dependencies from these are irrelevant)
 * @param  array $also_installing List of addons that we're currently installing (so dependencies to these are irrelevant)
 * @param  boolean $always_return Whether to make sure we always return, rather than possibly bombing out with a dependency management UI
 * @return array Triple: warnings, files, addon info array
 */
function inform_about_addon_install(string $file, array $also_uninstalling = [], array $also_installing = [], bool $always_return = false) : array
{
    site_maintenance_lock_engage();

    $full = get_custom_file_base() . '/imports/addons/' . $file;

    // Look in the TAR
    require_code('tar');
    if (!file_exists($full)) {
        warn_exit(do_lang_tempcode('MISSING_RESOURCE', do_lang_tempcode('ADDON')));
    }
    $tar = tar_open($full, 'rb');
    $directory = tar_get_directory($tar);
    $info_file = tar_get_file($tar, 'addon.inf');
    if ($info_file === null) {
        $info_file = tar_get_file($tar, 'mod.inf'); // LEGACY
    }
    if ($info_file === null) {
        warn_exit(do_lang_tempcode('NOT_ADDON'));
    }
    $info = cms_parse_ini_file_fast(null, $info_file['data']);
    if (!empty($info['copyright_attribution'])) {
        $info['copyright_attribution'] = explode("\n", $info['copyright_attribution']);
    } else {
        $info['copyright_attribution'] = [];
    }
    $info += get_default_addon_info();
    $addon_name = $info['name'];
    $php = false;
    $overwrite = new Tempcode();
    $dirs = [];
    $files = new Tempcode();
    $files_warnings = new Tempcode();

    sort_maps_by($directory, 'path');

    foreach ($directory as $i => $entry) {
        if ($entry['path'] == 'addon.inf') {
            continue;
        }
        if ($entry['path'] == 'mod.inf') { // LEGACY
            continue;
        }
        if ($entry['path'] == 'addon_install_code.php') {
            continue;
        }
        if (substr($entry['path'], -1) == '/') {
            continue;
        }

        $data = (cms_strtolower_ascii(substr($entry['path'], -4, 4)) == '.tpl') ? tar_get_file($tar, $entry['path'], true) : null;

        // check valid path
        $success = @file_exists(get_file_base() . '/' . $entry['path']); //@d due to possible bad file paths
        if ((!$success) && (strpos(cms_error_get_last(), 'be a valid path') !== false)) {
            warn_exit(do_lang_tempcode('CORRUPT_TAR', escape_html($entry['path'])), false, true);
        }

        // .php?
        if ((cms_strtolower_ascii(substr($entry['path'], -4, 4)) == '.php') || (($data !== null) && ((strpos($data['data'], '{+START,PHP') !== false) || (strpos($data['data'], '<' . '?php') !== false)))) {
            $php = true;
            $this_php = true;
        } else {
            $this_php = false;
        }

        // chmod?
        $pos = strrpos($entry['path'], '/');
        if ($pos !== false) {
            $dirs[substr($entry['path'], 0, $pos)] = 1;
        } else {
            $dirs[''] = 1;
        }

        // overwrite?
        if (file_exists(get_file_base() . '/' . $entry['path'])) {
            if (!$overwrite->is_empty()) {
                $overwrite->attach(do_lang_tempcode('LIST_SEP'));
            }
            $overwrite->attach(escape_html((($entry['path'][0] == '/') ? substr($entry['path'], 1) : $entry['path'])));
            $this_overwrite = true;
        } else {
            $this_overwrite = false;
        }

        // Comcode?
        if ((cms_strtolower_ascii(substr($entry['path'], -4, 4)) == '.txt') && (strpos($entry['path'], 'pages/comcode') !== false)) {
            $this_comcode_page = true;
        } else {
            $this_comcode_page = false;
        }

        // Template
        if ($this_comcode_page) {
            $files_warnings->attach(do_template('ADDON_INSTALL_FILES_WARNING', [
                '_GUID' => 'd0cf99f96262296df4afe2387f4cd3e8',
                'I' => strval($i),
                'PATH' => $entry['path'],
                'ABOUT' => do_lang_tempcode('ADDON_FILE_IS_COMCODE_PAGE'),
            ]));
        } elseif ($this_overwrite) {
            $backup = (substr($entry['path'], -4) == '.txt');
            $files_warnings->attach(do_template('ADDON_INSTALL_FILES_WARNING', [
                '_GUID' => 'c62168dee316d8f73d20a0d70d41b1a4',
                'I' => strval($i),
                'PATH' => $entry['path'],
                'ABOUT' => do_lang_tempcode($backup ? 'ADDON_FILE_WILL_OVERWRITE_BACKUP' : 'ADDON_FILE_WILL_OVERWRITE'),
            ]));
        } elseif ($this_php) {
            $files_warnings->attach(do_template('ADDON_INSTALL_FILES_WARNING', [
                '_GUID' => 'c0cf99f96262296df4afe2387f4cd3e8',
                'I' => strval($i),
                'PATH' => $entry['path'],
                'ABOUT' => do_lang_tempcode('ADDON_FILE_IS_PHP'),
            ]));
        } else {
            $files->attach(do_template('ADDON_INSTALL_FILES', [
                '_GUID' => '74edcf396387c842cab5cfd0ab74b8f6',
                'I' => strval($i),
                'PATH' => $entry['path'],
                'ABOUT' => do_lang_tempcode('ADDON_FILE_NORMAL'),
                'DISABLED' => false,
            ]));
        }
    }
    tar_close($tar);
    $chmod = new Tempcode();
    $root_chmod = false;
    foreach (array_keys($dirs) as $dir) {
        if ((cms_is_writable(get_file_base() . '/' . $dir)) && (file_exists(get_file_base() . '/' . $dir))) {
            if ($dir == '') {
                $root_chmod = true;
                continue;
            }

            if (!$chmod->is_empty()) {
                $chmod->attach(do_lang_tempcode('LIST_SEP'));
            }
            $chmod->attach(escape_html(do_lang('ROOT') . (($dir[0] != '/') ? '/' : '') . $dir));
        } elseif ((substr_count($dir, '/') == 1) && (!file_exists(get_file_base() . '/' . $dir))) {
            $root_chmod = true;
        }
    }
    if ($root_chmod) {
        if (!$chmod->is_empty()) {
            $chmod->attach(', ');
        }
        $chmod->attach(do_lang('ROOT'));
    }

    // Check incompatibilities, and show general warning
    // NB: It's theoretically possible that there may be incompatibilities between two addons installing together, and we can't detect this (only incompatibilities for what is already installed). However it's very unlikely as multi-install is only really going to happen with official addons which have no such problems.
    $warnings = new Tempcode();
    require_code('version');

    // Website software version incompatibilities
    if (($info['min_cms_version'] == '') || (floatval($info['min_cms_version']) > cms_version_number()) || ((!empty($info['max_cms_version']) && (floatval($info['max_cms_version']) < cms_version_number())))) {
        if (!$always_return) {
            warn_exit(do_lang_tempcode('ADDON_WARNING_INCOMPATIBILITIES_VERSION', escape_html(float_to_raw_string(cms_version_number())), escape_html($addon_name)));
        }
        $warnings->attach(do_lang_tempcode('ADDON_WARNING_INCOMPATIBILITIES_VERSION', escape_html(float_to_raw_string(cms_version_number())), escape_html($addon_name)));
    }

    // Non-core addon
    if ($info['author'] != 'Core Team') {
        static $done_non_core_warn = false;
        if (!$done_non_core_warn) {
            $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => 'dd66b2c540908de60753a1ced73b8ac0', 'WARNING' => do_lang_tempcode('ADDON_WARNING_GENERAL')]));
        }
        $done_non_core_warn = true;
    }

    // Addon incompatibilities
    $incompatibilities = collapse_1d_complexity('addon_name', $GLOBALS['SITE_DB']->query_select('addons_dependencies', ['addon_name'], ['addon_name_dependant_upon' => $addon_name, 'addon_name_incompatibility' => 1], 'ORDER BY addon_name'));
    $_incompatibilities = new Tempcode();
    foreach ($incompatibilities as $in) {
        if (!$_incompatibilities->is_empty()) {
            $_incompatibilities->attach(do_lang_tempcode('LIST_SEP'));
        }
        $_incompatibilities->attach(escape_html($in));
    }
    if (!empty($incompatibilities)) {
        $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => '7ee5935df99b7b863477ec96989df0eb', 'WARNING' => do_lang_tempcode('ADDON_WARNING_INCOMPATIBILITIES', $_incompatibilities, escape_html($file))]));
    }

    // Check dependencies
    $_dependencies = explode(',', array_key_exists('dependencies', $info) ? $info['dependencies'] : '');
    $dependencies = [];
    foreach ($_dependencies as $dependency) {
        if ($dependency == '') {
            continue;
        }
        if (in_array($dependency . '.tar', $also_installing)) {
            continue;
        }
        if (in_array($dependency . '.tar', $also_uninstalling)) {
            $dependencies[] = $dependency;
            continue;
        }
        if (!has_feature($dependency)) {
            $dependencies[] = $dependency;
        }
    }
    $_dependencies_str = new Tempcode();
    foreach ($dependencies as $in) {
        if (!$_dependencies_str->is_empty()) {
            $_dependencies_str->attach(do_lang_tempcode('LIST_SEP'));
        }
        if (file_exists(get_custom_file_base() . '/imports/addons/' . $in . '.tar')) {
            $in_tpl = hyperlink(build_url(['page' => 'admin_addons', 'type' => 'addon_install', 'file' => $in . '.tar'], get_module_zone('admin_addons')), $in, true, true);
        } else {
            $in_tpl = make_string_tempcode(escape_html($in));
        }
        $_dependencies_str->attach($in_tpl);
    }
    if (!empty($dependencies)) {
        if (($info['author'] == 'Core Team') && (!$always_return)) {
            $post_fields = build_keep_post_fields();
            foreach ($dependencies as $in) {
                $post_fields->attach(form_input_hidden('install_' . $in . '.tar', $in . '.tar'));
            }
            $post_fields->attach(symbol_tempcode('INSERT_FORM_POST_SECURITY'));

            if (get_param_string('type', 'browse') == 'addon_install') {
                $post_fields->attach(form_input_hidden('install_' . $file, $file));
                $url = static_evaluate_tempcode(build_url(['page' => 'admin_addons', 'type' => 'multi_action'], get_module_zone('admin_addons')));
            } else {
                $url = get_self_url(true);
            }
            warn_exit(do_lang_tempcode('_ADDON_WARNING_MISSING_DEPENDENCIES', $_dependencies_str->evaluate(), escape_html($addon_name), [escape_html($url), $post_fields]));
        } else {
            $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => 'ba2146fb91a940e0b2793d985563fb9e', 'WARNING' => do_lang_tempcode('ADDON_WARNING_MISSING_DEPENDENCIES', $_dependencies_str, escape_html($file))]));
        }
    }

    //if (!$overwrite->is_empty()) $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => 'fe40ed8192a452a835be4c0fde64406b', 'WARNING' => do_lang_tempcode('ADDON_WARNING_OVERWRITE', escape_html($overwrite], escape_html($file)))));
    if ($info['author'] != 'Core Team') {
        if ($php) {
            $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => '8cf249a119d10b2e97fc94cb9981dcea', 'WARNING' => do_lang_tempcode('ADDON_WARNING_PHP', escape_html($file))]));
        }
    }
    //if ($chmod != '') $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => '78121e40b9a26c2f33d09f7eee7b74be', 'WARNING' => do_lan g_tempcode('ADDON_WARNING_CHMOD', escape_html($chmod])))); // Now uses AFM

    $files_combined = new Tempcode();
    $files_combined->attach($files_warnings);
    $files_combined->attach($files);

    return [$warnings, $files_combined, $info];
}

/**
 * Find whether a particular feature is available to the software (e.g. it's an addon).
 *
 * @param  ID_TEXT $dependency Feature name
 * @return boolean Whether it is
 */
function has_feature(string $dependency) : bool
{
    // Normalise
    $dependency = str_replace(' ', '', cms_strtolower_ascii(preg_replace('# (enabled|needed|required)$#', '', $dependency)));

    $remapping = [ // LEGACY: Useful for carrying legacy remappings
        'unvalidated' => 'validation'
    ];
    if (array_key_exists($dependency, $remapping)) {
        $dependency = $remapping[$dependency];
    }

    // Non-bundled addon
    $test = $GLOBALS['SITE_DB']->query_select_value_if_there('addons', 'addon_name', ['addon_name' => $dependency]);
    if ($test !== null) {
        return true;
    }

    // Bundled addon
    if (file_exists(get_file_base() . '/sources/hooks/systems/addon_registry/' . $dependency . '.php')) {
        return true;
    }

    // Some other features (referenced in automated test, addon_dependency_naming.php; note these are lower-case and you must use the casing specified in the tests)
    if (($dependency == 'mysql') && (strpos(get_db_type(), 'mysql') !== false)) {
        return true;
    }
    if (($dependency == 'system scheduler') && (cron_installed())) {
        return true;
    }
    if ((($dependency == 'cns') || ($dependency == 'conversr')) && (get_forum_type() == 'cns')) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'utf-8') && (get_charset() == 'utf-8')) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php curl extension') && (function_exists('curl_init'))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php simplexml extension') && (function_exists('simplexml_load_string'))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php openssl extension') && (function_exists('openssl_encrypt'))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php sessions extension') && (function_exists('session_start'))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php xml extension') && (function_exists('xml_parser_create'))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php zip extension') && (class_exists('ZipArchive', false))) {
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'php pdo_mysql extension') && (defined('PDO::ATTR_DRIVER_NAME'))) {
        return true;
    }
    if (substr($dependency, 0, 4) == 'php ') {
        $phpv = PHP_VERSION;
        if (version_compare(substr($phpv, 0, strlen(substr($dependency, 4))), substr($dependency, 4), '>=')) {
            return true;
        }
    }
    if (preg_match('#^(IE|safari) [\d\.]+\+$#i', $dependency) != 0) { // LEGACY
        // Client side requirements
        return true;
    }
    if ((cms_strtolower_ascii($dependency) == 'ssl') && (substr(get_base_url(), 0, 8) == 'https://')) {
        return true;
    }

    // ---

    // Try plural form
    if (substr($dependency, -1) != 's') {
        return has_feature($dependency . 's');
    }

    return false;
}

/**
 * Find what paths need to be writable for an addon to install.
 *
 * @param  string $file Name of the addon TAR file
 * @return array List of paths that need to be writable
 */
function get_addon_install_writable_paths(string $file) : array
{
    $writable_paths = [];

    require_code('tar');
    $full = get_custom_file_base() . '/imports/addons/' . $file;
    $tar = tar_open($full, 'rb');
    $directory = tar_get_directory($tar);
    foreach ($directory as $entry) {
        $writable_paths[] = $entry['path'];
    }
    tar_close($tar);

    return $writable_paths;
}

/**
 * Install an addon.
 *
 * @param  string $file Name of the addon TAR file
 * @param  ?array $files The files to install (null: all)
 * @param  boolean $do_files Do file part
 * @param  boolean $do_db Do DB part
 * @param  boolean $clear_caches Whether to clear caches
 */
function install_addon(string $file, ?array $files = null, bool $do_files = true, bool $do_db = true, bool $clear_caches = true)
{
    site_maintenance_lock_engage();

    require_code('zones2');
    require_code('zones3');

    require_code('tar');
    $full = get_custom_file_base() . '/imports/addons/' . $file;
    $tar = tar_open($full, 'rb');
    $info_file = tar_get_file($tar, 'addon.inf');
    if ($info_file === null) {
        $info_file = tar_get_file($tar, 'mod.inf'); // LEGACY
    }
    if ($info_file === null) {
        warn_exit(do_lang_tempcode('NOT_ADDON'));
    }
    $info = cms_parse_ini_file_fast(null, $info_file['data']);

    $addon_name = $info['name'];

    $was_already_installed = addon_installed($addon_name);

    // Stop! Don't install an addon if it is not compatible with this version of the website software
    require_code('version');
    if (($info['min_cms_version'] == '') || (floatval($info['min_cms_version']) > cms_version_number()) || ((!empty($info['max_cms_version']) && (floatval($info['max_cms_version']) < cms_version_number())))) {
        warn_exit(do_lang_tempcode('ADDON_WARNING_INCOMPATIBILITIES_VERSION', escape_html(float_to_raw_string(cms_version_number())), escape_html($addon_name)));
    }

    require_code('developer_tools');
    destrictify();
    set_mass_import_mode();

    // Extract files
    $directory = tar_get_directory($tar);
    if ($do_files) {
        tar_extract_to_folder($tar, '', true, $files, true);
    }

    // Install new zones
    if ($do_db) {
        $zones = [''];
        foreach ($directory as $dir) {
            $addon_file = $dir['path'];

            if (($files === null) || (in_array($addon_file, $files))) {
                $matches = [];
                if (preg_match('#(\w*)/index\.php$#', $addon_file, $matches) != 0) {
                    $zone = $matches[1];

                    $test = $GLOBALS['SITE_DB']->query_select_value_if_there('zones', 'zone_name', ['zone_name' => $zone]);
                    if ($test === null) {
                        $map = [
                            'zone_name' => $zone,
                            'zone_default_page' => ($zone == 'forum') ? 'forumview' : DEFAULT_ZONE_PAGE_NAME,
                            'zone_theme' => '-1',
                            'zone_require_session' => 0,
                        ];
                        $map += insert_lang('zone_title', titleify($zone), 1);
                        $map += insert_lang('zone_header_text', '', 1);
                        $GLOBALS['SITE_DB']->query_insert('zones', $map);

                        $groups = $GLOBALS['FORUM_DRIVER']->get_usergroup_list(false, true);
                        foreach (array_keys($groups) as $group_id) {
                            $GLOBALS['SITE_DB']->query_insert('group_zone_access', ['zone_name' => $zone, 'group_id' => $group_id], false, true); // errors suppressed in case already there
                        }
                    }

                    $zones[] = $zone;
                }
            }
        }
    }

    // Install new modules
    if ($do_db) {
        $zones = array_unique(array_merge(find_all_zones(), $zones));
        if (get_option('single_public_zone') == '1') {
            $zones[] = 'site';
        }
        foreach ($zones as $zone) {
            $prefix = ($zone == '') ? '' : ($zone . '/');

            foreach ($directory as $dir) {
                $addon_file = $dir['path'];
                if (substr(basename($addon_file), 0, 1) == '.') {
                    continue;
                }

                if (($files === null) || (in_array($addon_file, $files))) {
                    if (preg_match('#^' . $prefix . 'pages/(modules|modules_custom)/([^/]*)\.php$#', $addon_file, $matches) != 0) {
                        if (!module_installed($matches[2])) {
                            reinstall_module($zone, $matches[2]);
                        } else {
                            upgrade_module($zone, $matches[2]);
                        }
                    }
                }
            }
        }
    }

    // Install new blocks
    if ($do_db) {
        foreach ($directory as $dir) {
            $addon_file = $dir['path'];
            if (substr(basename($addon_file), 0, 1) == '.') {
                continue;
            }

            if (($files === null) || (in_array($addon_file, $files))) {
                if (preg_match('#^(sources|sources_custom)/blocks/([^/]*)\.php$#', $addon_file, $matches) != 0) {
                    if (!block_installed($matches[2])) {
                        reinstall_block($matches[2]);
                    } else {
                        upgrade_block($matches[2]);
                    }
                }
            }
        }
    }

    // Install addon itself
    if ($do_db) {
        $_files = [];
        foreach ($directory as $dir) {
            $addon_file = $dir['path'];
            if ($addon_file == 'addon.inf') {
                continue;
            }
            if ($addon_file == 'mod.inf') { // LEGACY
                continue;
            }
            if ($addon_file == 'addon.php') {
                continue;
            }
            if (substr($addon_file, -1) == '/') {
                continue;
            }
            if (($files === null) || (in_array($addon_file, $files))) {
                $_files[] = $addon_file;
            }
        }
        if (!$was_already_installed) {
            reinstall_addon_soft($addon_name, $info + ['files' => $_files]);
        } else {
            upgrade_addon_soft($addon_name);
        }
    }

    // Clear some caching
    if ($clear_caches) {
        require_code('caches3');
        erase_comcode_page_cache();
        erase_block_cache(true);
        erase_persistent_cache();
        erase_cached_templates(false, null, TEMPLATE_DECACHE_WITH_ADDON);
        $template_files_to_erase = [];
        foreach ($directory as $dir) {
            $addon_file = $dir['path'];
            if (substr($addon_file, 0, 7) == 'themes/') {
                $template_files_to_erase[] = preg_replace('#\..*$#', '', basename($addon_file));
            }
        }
        erase_cached_templates(false, $template_files_to_erase);
        erase_cached_language();
    }

    // Load addon_install_code.php if it exists
    if ($do_db) {
        $_modphp_file = tar_get_file($tar, 'addon_install_code.php');
        if ($_modphp_file !== null) {
            $modphp_file = clean_php_file_for_eval($_modphp_file['data']);

            cms_eval($modphp_file, $full . ': addon_install_code.php');
        }
    }

    tar_close($tar);

    site_maintenance_lock_disengage();

    if ($do_db) {
        require_lang('addons');
        log_it('INSTALL_ADDON', $addon_name);
    }
}

/**
 * Reinstall the specified addon.
 *
 * @param  ID_TEXT $addon_name The addon name
 * @param  ?array $ini_info .ini-format info (needs processing) (null: unknown / N/A)
 */
function reinstall_addon_soft(string $addon_name, ?array $ini_info = null)
{
    push_query_limiting(false);

    require_code('files2');
    require_all_core_cms_code();

    $addon_info = read_addon_info($addon_name, false, null, $ini_info);

    // Stop! Don't reinstall an addon if it is not compatible with this version of the website software
    require_code('version');
    if (($addon_info['min_cms_version'] == '') || (floatval($addon_info['min_cms_version']) > cms_version_number()) || ((!empty($addon_info['max_cms_version']) && (floatval($addon_info['max_cms_version']) < cms_version_number())))) {
        warn_exit(do_lang_tempcode('ADDON_WARNING_INCOMPATIBILITIES_VERSION', escape_html(float_to_raw_string(cms_version_number())), escape_html($addon_name)));
    }

    $hook_path = 'hooks/systems/addon_registry/' . filter_naughty($addon_name);
    if (is_file(get_file_base() . '/sources/' . $hook_path . '.php') || is_file(get_file_base() . '/sources_custom/' . $hook_path . '.php')) {
        require_code($hook_path);
        $ob = object_factory('Hook_addon_registry_' . filter_naughty_harsh($addon_name));

        if (method_exists($ob, 'uninstall')) {
            $old = cms_extend_time_limit(15);
            $ob->uninstall();
            cms_set_time_limit($old);
        }
        if (method_exists($ob, 'install')) {
            $old = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLUGGISH);
            $ob->install();
            cms_set_time_limit($old);
        }
    }

    $GLOBALS['SITE_DB']->query_delete('addons_files', ['addon_name' => $addon_name]);
    $GLOBALS['SITE_DB']->query_delete('addons_dependencies', ['addon_name' => $addon_name]);
    $GLOBALS['SITE_DB']->query_delete('addons', ['addon_name' => $addon_name], '', 1);

    $GLOBALS['SITE_DB']->query_insert('addons', [
        'addon_name' => $addon_name,
        'addon_author' => $addon_info['author'],
        'addon_organisation' => $addon_info['organisation'],
        'addon_version' => $addon_info['version'],
        'addon_category' => $addon_info['category'],
        'addon_copyright_attribution' => implode("\n", $addon_info['copyright_attribution']),
        'addon_licence' => $addon_info['licence'],
        'addon_description' => $addon_info['description'],
        'addon_min_cms_version' => $addon_info['min_cms_version'],
        'addon_max_cms_version' => $addon_info['max_cms_version'],
        'addon_install_time' => time(),
    ]);

    $GLOBALS['SITE_DB']->query_insert('addons_dependencies', [
        'addon_name' => array_fill(0, count($addon_info['dependencies']), $addon_name),
        'addon_name_dependant_upon' => array_map('trim', $addon_info['dependencies']),
        'addon_name_incompatibility' => array_fill(0, count($addon_info['dependencies']), 0),
    ]);

    $GLOBALS['SITE_DB']->query_insert('addons_dependencies', [
        'addon_name' => array_fill(0, count($addon_info['incompatibilities']), $addon_name),
        'addon_name_dependant_upon' => array_map('trim', $addon_info['incompatibilities']),
        'addon_name_incompatibility' => array_fill(0, count($addon_info['incompatibilities']), 1),
    ]);

    $GLOBALS['SITE_DB']->query_insert('addons_files', [
        'addon_name' => array_fill(0, count($addon_info['files']), $addon_name),
        'filepath' => $addon_info['files'],
    ]);
}

/*
================
UPGRADING ADDONS
================
*/

/**
 * Find updated addons via checking the homesite web service.
 *
 * @return array List of addons updated
 */
function find_updated_addons() : array
{
    static $updated_addons = null; // Cache
    if ($updated_addons === null) {
        $updated_addons = null;
    }
    if ($updated_addons !== null) {
        return $updated_addons;
    }

    $addons = find_installed_addons(true, true);
    if (empty($addons)) {
        return [];
    }

    // Repair: To properly check for non-bundled addons needing upgrading, they must have a TAR. Sometimes they get removed for whatever reason.
    require_code('tar');
    $old = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLOW);
    foreach ($addons as $addon_name => $info) {
        if (!is_file(get_custom_file_base() . '/imports/addons/' . $addon_name . '.tar')) {
            create_addon(
                $addon_name . '.tar',
                $info['files'],
                $info['name'],
                implode(',', $info['incompatibilities']),
                implode(',', $info['dependencies']),
                $info['author'],
                $info['organisation'],
                $info['version'],
                $info['category'],
                implode("\n", $info['copyright_attribution']),
                $info['licence'],
                $info['description'],
                $info['min_cms_version'],
                $info['max_cms_version'],
                'imports/addons'
            );
        }
    }
    cms_set_time_limit($old);

    $url = get_brand_base_url() . '/data/endpoint.php/cms_homesite/addon_manifest/' . urlencode(float_to_raw_string(cms_version_number(), 2, true));
    $post = [];
    foreach (array_keys($addons) as $i => $addon_name) {
        $post['addon_' . strval($i)] = urlencode($addon_name);
    }

    require_code('http');
    list($_addon_data) = cache_and_carry('cms_http_request', [$url, ['convert_to_internal_encoding' => true, 'trigger_error' => false, 'post_params' => $post]], 5/*5 minute cache*/);
    $addon_data = @json_decode($_addon_data, true);
    if (($addon_data === null) || (!$addon_data['success'])) {
        return [];
        //warn_exit(do_lang('INTERNAL_ERROR', comcode_escape('a1a699cb5dd65a23b8d2a331e0c4ae2e')));
    }

    $available_addons = find_available_addons(true, true, $addons, false, true);

    $updated_addons = [];
    foreach ($addon_data['response_data'] as $i => $addon_bits) {
        $found = false;

        foreach ($available_addons as $available_addon) {
            if ($available_addon['name'] == $addon_bits[3]) {
                $found = true;
                if (($addon_bits[0] !== null) && (($addon_bits[4] === null) || ($available_addon['hash'] != $addon_bits[4])) && ($available_addon['mtime'] < $addon_bits[0])) { // If known to server, and updated
                    $updated_addons[$addon_bits[3]] = [$addon_bits[1]]; // Is known to server though
                }
                break;
            }
        }
        if ((!$found) && (addon_installed($addon_bits[3], false, false))) { // Don't have our original .tar, so lets say we need to reinstall
            if ($addon_bits[0] !== null) { // If server has it
                $mtime = find_addon_effective_mtime($addon_bits[3], $addon_bits[0]);
                if (($mtime !== null) && ($mtime < $addon_bits[0])) { // If it is newer
                    $updated_addons[$addon_bits[3]] = [$addon_bits[1]];
                }
            }
        }
    }
    return $updated_addons;
}

/**
 * Find effective modification date of an addon.
 *
 * @param  string $addon_name The name of the addon
 * @param  ?TIME $newer_than_ok Optimisation: If the date is newer than this then that's good enough for a comparison and we can not look harder (null: no optimisation)
 * @return ?TIME Modification time (null: could not find any files)
 */
function find_addon_effective_mtime(string $addon_name, ?int $newer_than_ok = null) : ?int
{
    $addon_info = read_addon_info($addon_name);

    // Note we could look at install time, but we do not trust that

    $mtime = null;
    foreach ($addon_info['files'] as $filepath) {
        if (@file_exists(get_file_base() . '/' . $filepath)) { //@d due to possible bad file paths
            $_mtime = filemtime(get_file_base() . '/' . $filepath);
            $mtime = ($mtime === null) ? $_mtime : max($mtime, $_mtime);
            if (($newer_than_ok !== null) && ($mtime > $newer_than_ok)) {
                return $mtime;
            }
        }
    }
    return $mtime;
}

/**
 * Upgrade the specified addon.
 *
 * @param  ID_TEXT $addon_name The addon name
 * @return integer 1=Upgrade, 0=No upgrade needed, -1=Not compatible with this software version, -2=Not installed
 */
function upgrade_addon_soft(string $addon_name) : int
{
    require_code('files2');
    require_all_core_cms_code();

    $rows = $GLOBALS['SITE_DB']->query_select('addons', ['*'], ['addon_name' => $addon_name], '', 1);
    if (!array_key_exists(0, $rows)) {
        return (-2); // Not installed, so can't upgrade
    }

    $upgrade_from = $rows[0]['addon_version'];

    if (!hook_exists('systems', 'addon_registry', $addon_name)) {
        return 0;
    }
    $code_file = 'hooks/systems/addon_registry/' . filter_naughty($addon_name);
    require_code($code_file);
    $ob = object_factory('Hook_addon_registry_' . filter_naughty_harsh($addon_name));

    require_code('version');

    $min_cms_version = method_exists($ob, 'get_min_cms_version') ? $ob->get_min_cms_version() : null;
    $max_cms_version = method_exists($ob, 'get_max_cms_version') ? $ob->get_max_cms_version() : null;

    if (($min_cms_version === null) || ($min_cms_version > cms_version_number())) {
        return (-1);
    }
    if (($max_cms_version !== null) && ($max_cms_version < cms_version_number())) {
        return (-1);
    }

    $disk_version = float_to_raw_string($ob->get_version(), 2, true);

    $ret = 0;
    if (floatval($upgrade_from) < floatval($disk_version)) {
        if (method_exists($ob, 'install')) {
            $old = cms_extend_time_limit(TIME_LIMIT_EXTEND__SLUGGISH);
            $ob->install($upgrade_from);
            $ret = 1;
            cms_set_time_limit($old);
        }
    }

    // Update the database
    $GLOBALS['SITE_DB']->query_update('addons', [
        'addon_version' => $disk_version,
        'addon_min_cms_version' => strval($min_cms_version),
        'addon_max_cms_version' => ($max_cms_version !== null) ? strval($max_cms_version) : '',
    ], ['addon_name' => $addon_name], '', 1);

    $GLOBALS['SITE_DB']->query_delete('addons_dependencies', ['addon_name' => $addon_name]);
    $dependencies = $ob->get_dependencies();

    $requires = array_key_exists('requires', $dependencies) ? $dependencies['requires'] : [];
    $GLOBALS['SITE_DB']->query_insert('addons_dependencies', [
        'addon_name' => array_fill(0, count($requires), $addon_name),
        'addon_name_dependant_upon' => array_map('trim', $requires),
        'addon_name_incompatibility' => array_fill(0, count($requires), 0),
    ]);

    $incompatibilities = array_key_exists('conflicts_with', $dependencies) ? $dependencies['conflicts_with'] : [];
    $GLOBALS['SITE_DB']->query_insert('addons_dependencies', [
        'addon_name' => array_fill(0, count($incompatibilities), $addon_name),
        'addon_name_dependant_upon' => array_map('trim', $incompatibilities),
        'addon_name_incompatibility' => array_fill(0, count($incompatibilities), 1),
    ]);

    $GLOBALS['SITE_DB']->query_delete('addons_files', ['addon_name' => $addon_name]);
    $file_list = $ob->get_file_list();

    $GLOBALS['SITE_DB']->query_insert('addons_files', [
        'addon_name' => array_fill(0, count($file_list), $addon_name),
        'filepath' => $file_list,
    ]);

    return $ret;
}

/*
===================
UNINSTALLING ADDONS
===================
*/

/**
 * Get information for the user relating to an addon that they are intending to uninstall.
 *
 * @param  string $addon_name Name of the addon
 * @param  array $also_uninstalling List of addons that we're currently uninstalling (so dependencies from these are irrelevant)
 * @param  ?array $addon_info Addon details. (null: load in function)
 * @param  boolean $always_return Whether to make sure we always return, rather than possibly bombing out with a dependency management UI
 * @return array Pair: warnings, files
 */
function inform_about_addon_uninstall(string $addon_name, array $also_uninstalling = [], ?array $addon_info = null, bool $always_return = false) : array
{
    // Read/show info
    if ($addon_info === null) {
        $addon_info = read_addon_info($addon_name, true);
    }
    $files = new Tempcode();
    // The files can come in as either a newline-separated string or an array.
    // If its an array then we use it as-is, if it's a string then we explode it first.
    if (is_array($addon_info['files'])) {
        $loopable = $addon_info['files'];
    } else {
        $loopable = explode("\n", $addon_info['files']);
    }
    foreach ($loopable as $i => $filepath) {
        $files->attach(do_template('ADDON_INSTALL_FILES', ['_GUID' => '235d09a3cc041cea03f5421f639e8edf', 'I' => strval($i), 'DISABLED' => true, 'PATH' => $filepath]));
    }

    // Check dependencies
    $dependencies = $addon_info['dependencies_on_this'];
    foreach ($also_uninstalling as $d) {
        if (in_array($d, $dependencies)) {
            unset($dependencies[array_search($d, $dependencies)]);
        }
    }
    $warnings = new Tempcode();
    $_dependencies_str = new Tempcode();
    foreach ($dependencies as $in) {
        if (!$_dependencies_str->is_empty()) {
            $_dependencies_str->attach(do_lang_tempcode('LIST_SEP'));
        }
        $_dependencies_str->attach(escape_html($in));
    }
    if (!empty($dependencies)) {
        if (($addon_info['author'] == 'Core Team') && (!$always_return)) {
            $post_fields = build_keep_post_fields();
            foreach ($dependencies as $in) {
                $post_fields->attach(form_input_hidden('uninstall_' . $in, $in));
            }
            $post_fields->attach(symbol_tempcode('INSERT_FORM_POST_SECURITY'));
            if (get_param_string('type', 'browse') == 'addon_uninstall') {
                $post_fields->attach(form_input_hidden('uninstall_' . $addon_name, $addon_name));
                $url = static_evaluate_tempcode(build_url(['page' => 'admin_addons', 'type' => 'multi_action'], get_module_zone('admin_addons')));
            } else {
                $url = get_self_url(true);
            }
            warn_exit(do_lang_tempcode('_ADDON_WARNING_PRESENT_DEPENDENCIES', $_dependencies_str->evaluate(), escape_html($addon_name), [escape_html($url), $post_fields]));
        } else {
            $warnings->attach(do_template('ADDON_INSTALL_WARNING', ['_GUID' => '95b9f58ac4f19afe974082a4185642a4', 'WARNING' => do_lang_tempcode('ADDON_WARNING_PRESENT_DEPENDENCIES', $_dependencies_str, escape_html($addon_name))]));
        }
    }

    return [$warnings, $files];
}

/**
 * Find what addons a set of files are in.
 *
 * @param  array $paths List of files
 * @return array A map between file path and addon
 */
function find_addons_for_files(array $paths) : array
{
    if (empty($paths)) {
        return [];
    }

    $addons = [];
    foreach ($paths as $path) {
        $addons[$path] = [];
    }

    $or_list = '';
    foreach ($paths as $path) {
        if ($or_list != '') {
            $or_list .= ' OR ';
        }
        $or_list .= db_string_equal_to('filepath', $path);
    }
    $addon_files = $GLOBALS['SITE_DB']->query_select('addons_files', ['addon_name', 'filepath'], [], 'WHERE ' . $or_list);
    foreach ($addon_files as $_path) {
        if (in_array($_path['filepath'], $paths)) {
            $addons[$_path['filepath']][] = $_path['addon_name'];
        }
    }

    $hooks = find_all_hook_obs('systems', 'addon_registry', 'Hook_addon_registry_');
    foreach ($hooks as $hook => $ob) {
        $files = $ob->get_file_list();
        foreach ($files as $path) {
            if (in_array($path, $paths)) {
                $addons[$path][] = $hook;
            }
        }
    }

    foreach ($addons as &$files) {
        $files = array_unique($files);
    }

    return $addons;
}

/**
 * Find what paths need to be writable for an addon to uninstall.
 *
 * @param  string $addon_name Name of the addon
 * @return array List of paths that need to be writable
 */
function get_addon_uninstall_writable_paths(string $addon_name) : array
{
    $addon_info = read_addon_info($addon_name);

    $writable_paths = array_keys(find_addons_for_files($addon_info['files']));

    // Try and cleanup some empty/unneeded dirs
    do {
        $dirs = [];
        $changes = false;
        foreach ($writable_paths as $writable_path) {
            if (strpos($writable_path, '/') !== false) {
                $dir = dirname($writable_path);
                if (!isset($dirs[$dir])) {
                    $dirs[$dir] = [];
                }
                $dirs[$dir][] = basename($writable_path);

                $matches = [];
                if (preg_match('#^([^/]*)/index\.php#', $writable_path, $matches) != 0) {
                    $zone = $matches[1];
                    if (!in_array($zone, $writable_paths)) {
                        $writable_paths[] = $zone;
                        $changes = true;
                    }
                }
            }
        }
        foreach ($dirs as $dir => $dir_contents_being_deleted) {
            $dir_scan = [];
            if (file_exists(get_file_base() . '/' . $dir)) {
                $dir_scan = scandir(get_file_base() . '/' . $dir);
            }
            $dir_contents = array_diff($dir_scan, ['..', '.'], $dir_contents_being_deleted);
            if (empty($dir_contents)) {
                if (!in_array($dir, $writable_paths)) {
                    $writable_paths[] = $dir; // Directory is going to be empty (or it does not exist)
                    $changes = true;
                }
            }
        }
    } while ($changes);

    return $writable_paths;
}

/**
 * Completely uninstall the specified addon from the system.
 *
 * @param  string $addon_name Name of the addon
 * @param  boolean $clear_caches Whether to clear caches
 */
function uninstall_addon(string $addon_name, bool $clear_caches = true)
{
    $addon_info = read_addon_info($addon_name);

    site_maintenance_lock_engage();

    require_code('zones2');
    require_code('zones3');
    require_code('abstract_file_manager');

    require_code('developer_tools');
    destrictify();
    set_mass_import_mode();

    // Remove addon info from database, modules, blocks, and files
    uninstall_addon_soft($addon_name);
    $last = [];
    $zones_gone = [];
    $addons_for_files = find_addons_for_files($addon_info['files']);
    foreach ($addon_info['files'] as $filepath) {
        if (file_exists(get_file_base() . '/' . $filepath)) {
            if (count($addons_for_files[$filepath]) <= 1) { // Make sure it's not shared with other addons
                if (substr($filepath, 0, 37) == 'sources/hooks/systems/addon_registry/') {
                    $last[] = $filepath;
                    continue;
                }

                $matches = [];
                if (preg_match('#([^/]*)/?pages/modules(_custom)?/(.*)\.php#', $filepath, $matches) != 0) {
                    if ($matches[2] != '_custom' || ($matches[2] == '_custom' && !is_file(get_file_base() . '/' . str_replace('_custom/', '/', $filepath)))) {
                        $zone = $matches[1];
                        $module = $matches[3];
                        uninstall_module($zone, $module);

                        // Remove from menu too
                        $menu_sql = 'SELECT id FROM ' . get_table_prefix() . 'menu_items WHERE ';
                        $menu_sql .= db_string_equal_to('i_link', $zone . ':' . $module);
                        $menu_sql .= ' OR ';
                        $menu_sql .= 'i_link LIKE \'' . db_encode_like($zone . ':' . $module . ':%') . '\'';
                        if (($zone == 'site') && (get_option('single_public_zone') == '1')) {
                            $zone = '';
                            $menu_sql .= ' OR ';
                            $menu_sql .= db_string_equal_to('i_link', $zone . ':' . $module);
                            $menu_sql .= ' OR ';
                            $menu_sql .= 'i_link LIKE \'' . db_encode_like($zone . ':' . $module . ':%') . '\'';
                        }
                        $menu_items = $GLOBALS['SITE_DB']->query($menu_sql);
                        foreach ($menu_items as $menu_item) {
                            require_code('menus2');
                            delete_menu_item($menu_item['id']);
                        }
                    }
                }
                if (preg_match('#sources(_custom)?/blocks/(.*)\.php#', $filepath, $matches) != 0) {
                    if ($matches[1] != '_custom' || ($matches[1] == '_custom' && !is_file(get_file_base() . '/' . str_replace('_custom/', '/', $filepath)))) {
                        uninstall_block($matches[2]);
                    }
                }
                if (preg_match('#^([^/]*)/index\.php#', $filepath, $matches) != 0) {
                    $zone = $matches[1];
                    actual_delete_zone_lite($zone);
                    $zones_gone[] = $zone;
                }
                if (preg_match('#^sources(_custom)?/hooks/systems/config/([^/]*)\.php#', $filepath, $matches) != 0) {
                    delete_config_option($matches[2]);
                }
                if (($filepath != 'addon.inf') && ($filepath != 'addon_install_code.php') && ($filepath != '') && (substr($filepath, -1) != '/')) {
                    $last[] = $filepath;
                }
            }
        }
    }
    $dirs = [];
    foreach ($last as $filepath) {
        afm_delete_file($filepath);
        $dirs[dirname($filepath)] = true;
    }

    // Try and cleanup some empty/unneeded dirs
    krsort($dirs);
    foreach ($dirs as $dir => $true) {
        if (empty(array_diff(scandir(get_file_base() . '/' . $dir), ['..', '.']))) {
            afm_delete_directory($dir);
            if (strpos($dir, '/') !== false) {
                $dirs[dirname($dir)] = true;
            }
        }
    }
    foreach ($zones_gone as $zone) {
        if (file_exists(get_custom_file_base() . '/' . filter_naughty($zone))) {
            afm_delete_directory(filter_naughty($zone), true);
        }
    }

    global $ADDON_INSTALLED_CACHE;
    unset($ADDON_INSTALLED_CACHE[$addon_info['name']]);

    if ($clear_caches) {
        // Clear some caching
        require_code('caches3');
        erase_comcode_page_cache();
        erase_block_cache(true);
        erase_persistent_cache();
        erase_cached_templates(false, null, TEMPLATE_DECACHE_WITH_ADDON);
        $template_files_to_erase = [];
        foreach ($addon_info['files'] as $addon_file) {
            if (substr($addon_file, 0, 7) == 'themes/') {
                $template_files_to_erase[] = preg_replace('#\..*$#', '', basename($addon_file));
            }
        }
        erase_cached_templates(false, $template_files_to_erase);
        erase_cached_language();
        erase_theme_images_cache();
        global $HOOKS_CACHE;
        $HOOKS_CACHE = [];

        if (function_exists('persistent_cache_set')) {
            persistent_cache_set('ADDONS_INSTALLED', $ADDON_INSTALLED_CACHE);
        }
    }

    site_maintenance_lock_disengage();

    require_lang('addons');
    log_it('UNINSTALL_ADDON', $addon_info['name']);
}

/**
 * Uninstall the specified addon.
 *
 * @param  ID_TEXT $addon_name The addon name
 */
function uninstall_addon_soft(string $addon_name)
{
    $was_installed = addon_installed($addon_name);

    $GLOBALS['SITE_DB']->query_delete('addons', ['addon_name' => $addon_name], '', 1);

    $GLOBALS['SITE_DB']->query_delete('addons_files', ['addon_name' => $addon_name]);
    $GLOBALS['SITE_DB']->query_delete('addons_dependencies', ['addon_name' => $addon_name]);
    $GLOBALS['SITE_DB']->query_delete('addons', ['addon_name' => $addon_name], '', 1);

    require_code('files2');
    require_all_core_cms_code();

    if ($was_installed) {
        if (!hook_exists('systems', 'addon_registry', $addon_name)) {
            return;
        }
        $code_file = 'hooks/systems/addon_registry/' . filter_naughty($addon_name);
        require_code($code_file);
        $ob = object_factory('Hook_addon_registry_' . filter_naughty_harsh($addon_name));

        if (method_exists($ob, 'uninstall')) {
            $ob->uninstall();
        }
    }

    set_value('kill_cron_looping', '1', true);
}

/**
 * Engage a lock to stop site traffic, with automatic timeout and removal upon crash.
 */
function site_maintenance_lock_engage()
{
    global $SITE_MAINTENANCE_LOCK;
    $SITE_MAINTENANCE_LOCK = true;

    set_value('site_maintenance_lock', strval(time()));

    cms_register_shutdown_function_if_available('site_maintenance_lock_disengage'); // Auto-unlocks on some kind of crash
}

/**
 * Disengage lock from site_maintenance_lock_engage().
 */
function site_maintenance_lock_disengage()
{
    global $SITE_MAINTENANCE_LOCK;

    if ($SITE_MAINTENANCE_LOCK) {
        $SITE_MAINTENANCE_LOCK = false;

        set_value('site_maintenance_lock', '');
    }
}
