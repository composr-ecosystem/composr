<?php /*

 Composr
 Copyright (c) ocProducts, 2004-2019

 See text/EN/licence.txt for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core
 */

/*
This file is designed to be able to work as standalone, should you want to hook rewrite rules directly into it.
This allows static cache to run even when Composr is itself not booting at all.
*/

if (!isset($GLOBALS['FILE_BASE'])) {
    // Fixup SCRIPT_FILENAME potentially being missing
    $_SERVER['SCRIPT_FILENAME'] = __FILE__;

    // Find Composr base directory, and chdir into it
    global $FILE_BASE;
    $FILE_BASE = (strpos(__FILE__, './') === false) ? __FILE__ : realpath(__FILE__);
    $FILE_BASE = dirname(dirname($FILE_BASE));

    chdir($FILE_BASE);

    require($FILE_BASE . '/_config.php');

    if (!defined('STATIC_CACHE__FAST_SPIDER')) {
        define('STATIC_CACHE__FAST_SPIDER', 1);
        define('STATIC_CACHE__GUEST', 2);
        define('STATIC_CACHE__FAILOVER_MODE', 4);
    }

    static_cache(STATIC_CACHE__FAILOVER_MODE);
}

/**
 * Get a well formed URL equivalent to the current URL. Reads direct from the environment and does no clever mapping at all. This function should rarely be used.
 *
 * @return URLPATH The URL
 */
function static_cache__get_self_url_easy()
{
    // May not be called from Composr, so can't rely on Composr's normal fixup_bad_php_env_vars function having being called
    $self_url = '';
    if ((!empty($_SERVER['HTTP_HOST'])) && (!@cms_empty_safe($_SERVER['REQUEST_URI']))) {
        $self_url .= $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
    } elseif (!@cms_empty_safe($_SERVER['PHP_SELF'])) {
        $self_url .= $_SERVER['PHP_SELF'];
        if (!empty($_GET)) {
            $self_url .= '?' . http_build_query($_GET);
        }
    }
    return $self_url;
}

/**
 * Find if we are debugging the static cache.
 * Manually alter this function to enable debugging.
 *
 * @return boolean Whether we are
 */
function debugging_static_cache()
{
    return !empty($_GET['debug_static_cache']);
}

/**
 * Find if we can use the static cache for the web request.
 * For the save side, some additional checks are done in save_static_caching.
 *
 * @param  boolean $consider_failover_mode Whether to consider potential of cache being needed for failover mode
 * @return boolean Whether we can
 */
function can_static_cache_request($consider_failover_mode = false)
{
    global $SITE_INFO, $RELATIVE_PATH, $NON_CANONICAL_PARAMS;

    $debugging = debugging_static_cache();

    $url = static_cache__get_self_url_easy();

    if ($debugging) {
        require_code('urls');
    }

    $mode = null;
    $reason = null;
    if (!web_client_may_use_static_cache(!function_exists('is_guest'), $mode, $reason, $consider_failover_mode)) {
        if ($debugging) {
            if (php_function_allowed('error_log')) {
                @error_log('SC: No, ' . $reason . ' on ' . $url);
            }
        }

        return false;
    }

    if (!empty($SITE_INFO['static_caching_blacklist'])) {
        if (preg_match('#' . $SITE_INFO['static_caching_blacklist'] . '#', $url) != 0) {
            if ($debugging) {
                if (php_function_allowed('error_log')) {
                    @error_log('SC: No, pattern-matched URL to blacklist on ' . $url);
                }
            }

            return false;
        }
    }

    if (!empty($SITE_INFO['static_caching_whitelist'])) {
        if (preg_match('#' . $SITE_INFO['static_caching_whitelist'] . '#', $url) == 0) {
            if ($debugging) {
                if (php_function_allowed('error_log')) {
                    @error_log('SC: No, non-pattern-matched URL to whitelist on ' . $url);
                }
            }

            return false;
        }
    } else {
        if ((isset($RELATIVE_PATH)) && ($RELATIVE_PATH == '') && ((!isset($_GET['page'])) || ($_GET['page'] == 'home')) && (!empty(array_diff(array_keys($_GET), ['page', 'keep_session', 'keep_devtest', 'keep_failover'])))) {
            if ($debugging) {
                if (php_function_allowed('error_log')) {
                    @error_log('SC: No, home page has spurious parameters, likely a bot probing');
                }
            }

            return false;
        }

        if (isset($NON_CANONICAL_PARAMS)) {
            foreach ($NON_CANONICAL_PARAMS as $param => $block_page_from_static_cache_if_present) {
                if (isset($_GET[$param])) {
                    if ($block_page_from_static_cache_if_present) {
                        if ($debugging) {
                            if (php_function_allowed('error_log')) {
                                @error_log('SC: No, has ' . $param . ' on ' . $url);
                            }
                        }

                        return false; // Too parameterised
                    }
                }
            }
        }
    }

    if ($debugging) {
        if (php_function_allowed('error_log')) {
            @error_log('SC: Yes, on ' . $url);
        }
    }

    return true;
}

/**
 * Get the URL we are considering static caching against.
 *
 * @return URLPATH The URL
 */
function static_cache_current_url()
{
    $url = static_cache__get_self_url_easy();
    $url = preg_replace('#(keep_session|for_session|keep_devtest|keep_failover)=\d+#', '', $url);
    $url = str_replace('keep_su=Guest', '', $url);
    $url = preg_replace('#\?&+#', '?', $url);
    $url = preg_replace('#&+#', '&', $url);
    $url = preg_replace('#[&?]$#', '', $url);
    return $url;
}

/**
 * If possible dump the user to 100% static caching.
 *
 * @param  integer $mode The mode
 */
function static_cache($mode)
{
    global $SITE_INFO;

    $in_failover_mode = (($mode & STATIC_CACHE__FAILOVER_MODE) != 0);

    if ($in_failover_mode) {
        // Correct HTTP status
        if ((!function_exists('browser_matches')) || ((!browser_matches('ie')) && (strpos($_SERVER['SERVER_SOFTWARE'], 'IIS') === false))) {
            http_response_code(503);
        }
    } else {
        if (!can_static_cache_request($in_failover_mode)) {
            return;
        }
    }

    $script_name = isset($_SERVER['SCRIPT_NAME']) ? $_SERVER['SCRIPT_NAME'] : '';
    if (basename($script_name) == 'backend.php') { // FUDGE hardcoding recognition of backend.php caching
        $file_extension = '.xml';
    } else {
        $file_extension = '.htm';
    }
    // ^ Note that static caching will not run for anything other, but it's implicit - as nothing other will be saving into the cache!

    $client_support_brotli = (isset($_SERVER['HTTP_ACCEPT_ENCODING'])) && (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'br') !== false);
    $client_support_gzip = (isset($_SERVER['HTTP_ACCEPT_ENCODING'])) && (strpos($_SERVER['HTTP_ACCEPT_ENCODING'], 'gzip') !== false);
    $client_support_compressed = ($client_support_brotli || $client_support_gzip) && (function_exists('php_function_allowed')) && (php_function_allowed('ini_set')/*If can disable default PHP compression*/);
    $server_support_brotli = false; // May be set later
    $server_support_gzip = false; // May be set later

    if (function_exists('is_mobile')) {
        $is_mobile = is_mobile();
    } else {
        // The set of browsers
        $browsers = [
            // Implication by technology claims
            'WML',
            'WAP',
            'Wap',
            'MIDP', // Mobile Information Device Profile

            // Generics
            'Mobile',
            'Smartphone',
            'WebTV',

            // Well known/important browsers/brands
            'Mobile Safari', // Usually Android
            'iPhone',
            'iPod',
            'Opera Mobi',
            'Opera Mini',
            'BlackBerry',
            'Windows Phone',
            'nook browser', // Barnes and Noble
        ];
        $is_mobile = (preg_match('#' . implode('|', $browsers) . '#', $_SERVER['HTTP_USER_AGENT']) != 0);
    }

    // Work out cache path (potentially will search a few places, based on priority)
    $url = static_cache_current_url();
    $_fast_cache_path = (function_exists('get_custom_file_base') ? get_custom_file_base() : $GLOBALS['FILE_BASE']) . '/caches/static/' . md5($url);
    $param_sets = [
        [
            'non_bot' => ($mode & STATIC_CACHE__FAST_SPIDER) == 0,
            'no_js' => !array_key_exists('js_on', $_COOKIE),
            'mobile' => $is_mobile,
            'failover_mode' => $in_failover_mode,
        ],
    ];
    if ($in_failover_mode) {
        foreach ($param_sets[0]['mobile'] ? [true, false] : [false, true] as $mobile) {
            foreach ($param_sets[0]['no_js'] ? [true, false] : [false, true] as $no_js) {
                foreach ($param_sets[0]['non_bot'] ? [true, false] : [false, true] as $non_bot) {
                    $param_sets[] = [
                        'non_bot' => $non_bot,
                        'no_js' => $no_js,
                        'mobile' => $mobile,
                        'failover_mode' => true, // This is always saved as a variant anyway
                    ];
                }
            }
        }
    }
    foreach ($param_sets as $param) {
        $fast_cache_path = $_fast_cache_path;
        if (!$param['failover_mode']) {
            if ($param['non_bot']) {
                $fast_cache_path .= '__non-bot';
            }
            if ($param['no_js']) {
                $fast_cache_path .= '__no-js';
            }
        }
        if ($param['mobile']) {
            $fast_cache_path .= '__mobile';
        }
        if ($param['failover_mode']) {
            $fast_cache_path .= '__failover_mode';
        }
        $fast_cache_path .= $file_extension;

        if ($client_support_compressed) {
            if (($client_support_brotli) && (is_file($fast_cache_path . '.br'))) {
                $fast_cache_path .= '.br';
                $server_support_brotli = true;
                break;
            }

            if (($client_support_gzip) && (is_file($fast_cache_path . '.gz'))) {
                $fast_cache_path .= '.gz';
                $server_support_gzip = true;
                break;
            }
        }

        if (is_file($fast_cache_path)) {
            break;
        }
    }

    // Is cached
    if (is_file($fast_cache_path)) {
        $expires = intval(60.0 * 60.0 * floatval($SITE_INFO['static_caching_hours']));
        $mtime = filemtime($fast_cache_path);
        if (($mtime > time() - $expires) || ($in_failover_mode)) {
            if ($file_extension == '.htm') {
                header('Content-Type: text/html; charset=utf-8');
            } else {
                header('Content-Type: text/xml; charset=utf-8');
            }

            // Only bots can do HTTP caching, as they won't try to login and end up reaching a previously cached page
            if ((($mode & STATIC_CACHE__FAST_SPIDER) != 0) && ($in_failover_mode)) {
                header('Last-Modified: ' . gmdate('D, d M Y H:i:s', $mtime) . ' GMT');
                header('Cache-Control: public, max-age=' . strval($expires));
                header_remove('Pragma');
                header_remove('Expires');

                $since = $_SERVER['HTTP_IF_MODIFIED_SINCE'];
                if ($since != '') {
                    if (strtotime($since) < $mtime) {
                        http_response_code(304);

                        $aaf = ini_get('auto_append_file');
                        if (!empty($aaf)) {
                            @include($aaf); // Because exit() avoids running this
                        }

                        exit();
                    }
                }
            } else {
                @header('Cache-Control: no-cache');
            }

            // Output
            if (($server_support_brotli) || ($server_support_gzip)) {
                if (function_exists('ini_set')/*guard for CQC; always will be true for this branch as also checked earlier*/) {
                    ini_set('zlib.output_compression', 'Off');
                    ini_set('brotli.output_compression', 'Off');
                }
                if ($server_support_brotli) {
                    header('Content-Encoding: br');
                }
                if ($server_support_gzip) {
                    header('Content-Encoding: gzip');
                }
                header('Vary: Accept-Encoding');
            }
            $contents = file_get_contents($fast_cache_path);
            if (function_exists('ocp_mark_as_escaped')) {
                ocp_mark_as_escaped($contents);
            }
            if (($in_failover_mode) && ($file_extension == '.htm')) {
                $contents .= "\n\n" . '<!-- Served ' . htmlentities($fast_cache_path) . ' -->';
                $contents .= '<failover />';
            }

            echo $contents;

            // Add to stats
            if (addon_installed('stats')) {
                require_code('caches');
                require_code('database');
                require_code('config');
                $browser = cms_mb_substr(get_browser_string(), 0, 255);
                if ((get_option('bot_stats') == '0') || ((stripos($browser, 'http:') === false) && (stripos($browser, 'bot') === false) && (get_bot_type() === null))) {
                    load_user_stuff();
                    $GLOBALS['SITE_DB']->query_insert('stats', [
                        'access_denied_counter' => 0,
                        'browser' => $browser,
                        'operating_system' => cms_mb_substr(get_os_string(), 0, 255),
                        'the_page' => cms_mb_substr('/static_caching:' . serialize($_GET), 0, 255),
                        'ip' => get_ip_address(),
                        'session_id' => '',
                        'member_id' => $GLOBALS['FORUM_DRIVER']->get_guest_id(),
                        'date_and_time' => time(),
                        'referer' => cms_mb_substr($_SERVER['HTTP_REFERER'], 0, 255),
                        's_get' => '',
                        'post' => '',
                        'milliseconds' => 0,
                    ], false, true);
                }
            }

            exit();
        } else {
            @unlink($fast_cache_path);
            if (function_exists('sync_file')) {
                sync_file($fast_cache_path);
            }
        }
    }

    if ($in_failover_mode) {
        // Error message saying nothing cached
        header('Content-Type: text/plain; charset=utf-8');
        if (!isset($SITE_INFO['failover_cache_miss_message'])) {
            $SITE_INFO['failover_cache_miss_message'] = 'Cannot find cache file.';
        }
        exit($SITE_INFO['failover_cache_miss_message']);
    }
}

/**
 * Mark that this request will not be cached into the static cache.
 * Also causes real session IDs to be returned, consistent with previous requests that were also not subject to the static cache.
 *
 * @return URLPATH The URL
 */
function disable_static_caching()
{
    global $STATIC_CACHE_ENABLED;
    $STATIC_CACHE_ENABLED = false;
}
