<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  ocProducts Ltd
 * @package    core_cns
 */

/**
 * Test password strength.
 *
 * @param  string $password The password to check
 * @param  string $username The username that will go with the password (blank: unknown)
 * @param  EMAIL $email_address The e-mail address that will go with the password (blank: unknown)
 * @param  ?TIME $dob The date of birth that will go with the password (null: unknown)
 * @return integer Password strength (1-10)
 */
function test_password(string $password, string $username = '', string $email_address = '', ?int $dob = null) : int
{
    // Take out completely insecure elements from the password so that they won't contribute to the scoring...

    // Tainted strings based on something a hacker may know
    $tainted_strings_source = [];
    if ($username != '') {
        $tainted_strings_source[cms_mb_strtoupper($username)] = 3;
    }
    if ($email_address != '') {
        $tainted_strings_source[cms_mb_strtoupper($email_address)] = 3;
    }
    if ($dob !== null) {
        $tainted_strings_source[cms_mb_strtoupper(date('Y', $dob))] = 4;
        $tainted_strings_source[cms_mb_strtoupper(date('y', $dob))] = 2;
    }
    $tainted_substrings_pool = [];
    foreach ($tainted_strings_source as $tainted_string => $minimum_substring_length_to_consider) {
        if (!is_string($tainted_string)) {
            $tainted_string = strval($tainted_string);
        }

        $len = cms_mb_strlen($tainted_string);
        for ($start = 0; $start <= $len; $start++) {
            for ($end = $start + $minimum_substring_length_to_consider; $end <= $len; $end++) {
                if ($end - $start >= $minimum_substring_length_to_consider) {
                    $tainted_substring = cms_mb_substr($tainted_string, $start, $end - $start);
                    $tainted_substrings_pool[$tainted_substring] = cms_mb_strlen($tainted_substring);
                }
            }
        }
    }
    arsort($tainted_substrings_pool);
    $password_upper = cms_mb_strtoupper($password);
    foreach (array_keys($tainted_substrings_pool) as $tainted_substring) {
        if (!is_string($tainted_substring)) {
            $tainted_substring = strval($tainted_substring);
        }

        do {
            $pos = strpos($password_upper, $tainted_substring);
            if ($pos !== false) {
                $password = substr($password, 0, $pos) . substr($password, $pos + strlen($tainted_substring));
                $password_upper = cms_mb_strtoupper($password);
            }
        } while ($pos !== false);
    }

    // Simple dictionary pass
    require_code('spelling');
    $spell_checker = _find_spell_checker();
    if ($spell_checker !== null) {
        $test = run_spellcheck__words([cms_mb_strtolower($password)], null, /*$skip_known_words_in_db = */true, /*$provide_corrections = */false);
        if (($test !== null) && (count($test) == 0)) { // Fully matches dictionary
            $password = '';
        }
    }

    // Return 1 for the strength immediately if there is no password.
    if ($password == '') {
        return 1;
    }

    $strength = 0.5;

    // Consider numbers
    if (preg_match('#[0-9]#', $password) == 1) {
        $strength += 1.0;
    }

    // Consider lower case letters
    if (preg_match('#[a-z]#', $password) == 1) {
        $strength += 2.6;
    }

    // Consider upper case letters
    if (preg_match('#[A-Z]#', $password) == 1) {
        $strength += 2.6;
    }

    // Consider special characters
    if (preg_match('#[^a-zA-Z0-9]#', $password) == 1) {
        $strength += 3.3;
    }

    // The strengths above all add up to 10. Calculations below will modulate the strength according to additional factors.

    // Factor password length
    $length = cms_mb_strlen($password);
    $chars = preg_split('#(.)#', $password, -1, PREG_SPLIT_DELIM_CAPTURE);
    $num_unique_chars = count(array_unique($chars));

    // Reduce strength on a percentage when characters are not unique.
    $strength *= (floatval($num_unique_chars) / floatval($length));


    // Multiply strength score depending on password length
    $strength *= ($length / 16);

    // Clamp the strength to be a number 1-10...
    $strength_final = intval($strength);

    if ($strength_final < 1) {
        $strength_final = 1;
    }
    if ($strength_final > 10) {
        $strength_final = 10;
    }
    return $strength_final;
}

/**
 * API function for if password resets have just been turned on but you want some more time before it kicks in.
 */
function bump_password_times_forward()
{
    $start = 0;
    do {
        $members = $GLOBALS['FORUM_DB']->query_select('f_members', ['id', 'm_pass_hash_salted', 'm_pass_salt'], [], '', 500, $start);
        foreach ($members as $member) {
            $GLOBALS['FORUM_DB']->query_delete('f_password_history', [
                'p_member_id' => $member['id'],
                'p_hash_salted' => $member['m_pass_hash_salted'],
                'p_salt' => $member['m_pass_salt'],
            ], '', 1);
            $GLOBALS['FORUM_DB']->query_insert('f_password_history', [
                'p_member_id' => $member['id'],
                'p_hash_salted' => $member['m_pass_hash_salted'],
                'p_salt' => $member['m_pass_salt'],
                'p_time' => time(),
            ]);
        }

        $start += 500;
    } while (!empty($members));
}

/**
 * Find if a member's account has expired, due to inactivity.
 *
 * @param  MEMBER $member_id The member this is for
 * @return boolean Whether it is
 */
function member_password_expired(int $member_id) : bool
{
    // Expired in the database
    if ($GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_password_compat_scheme') == 'expired') {
        return true;
    }

    $expiry_days = intval(get_option('password_expiry_days'));

    if ($expiry_days > 0) {
        $last_time = $GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_last_visit_time');
        if ($last_time < time() - 60 * 60 * 24 * $expiry_days) {
            // Make sure the expiration sticks because m_last_visit_time is going to get updated
            $GLOBALS['FORUM_DB']->query_update('f_members', ['m_password_compat_scheme' => 'expired'], ['id' => $member_id]);

            return true;
        }
    }

    return false;
}

/**
 * Find if a member's password is too old.
 *
 * @param  MEMBER $member_id The member this is for
 * @return boolean Whether it is
 */
function member_password_too_old(int $member_id) : bool
{
    $change_days = intval(get_option('password_change_days'));

    if ($change_days > 0) {
        $last_time = $GLOBALS['FORUM_DB']->query_select_value('f_password_history', 'MAX(p_time)', [
            'p_member_id' => $member_id,
        ]);
        if ($last_time === null) {
            $last_time = $GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_join_time');
        }
        if ($last_time < time() - 60 * 60 * 24 * $change_days) {
            return true;
        }
    }

    return false;
}

/**
 * Check the complexity of a password.
 *
 * @param  string $password The password to check
 * @param  string $username The username that will go with the password (blank: unknown)
 * @param  EMAIL $email_address The e-mail address that will go with the password (blank: unknown)
 * @param  ?TIME $dob The date of birth that will go with the password (null: unknown)
 * @param  boolean $return_errors Whether to return errors instead of dying on them
 * @return ?Tempcode Error (null: none)
 */
function check_password_complexity(string $password, string $username, string $email_address, ?int $dob, bool $return_errors = false) : ?object
{
    $_maximum_password_length = get_option('maximum_password_length');
    $maximum_password_length = min(255, intval($_maximum_password_length));
    if (cms_mb_strlen($password) > $maximum_password_length) {
        if ($return_errors) {
            return do_lang_tempcode('PASSWORD_TOO_LONG', escape_html(integer_format($maximum_password_length)));
        }
        warn_exit(do_lang_tempcode('PASSWORD_TOO_LONG', escape_html(integer_format($maximum_password_length))));
    }

    $_minimum_password_length = get_option('minimum_password_length');
    $minimum_password_length = intval($_minimum_password_length);
    if (cms_mb_strlen($password) < $minimum_password_length) {
        if ($return_errors) {
            return do_lang_tempcode('PASSWORD_TOO_SHORT', escape_html(integer_format($minimum_password_length)));
        }
        warn_exit(do_lang_tempcode('PASSWORD_TOO_SHORT', escape_html(integer_format($minimum_password_length))));
    }

    $_minimum_password_strength = get_option('minimum_password_strength');
    if ($_minimum_password_strength != '1') {
        $minimum_strength = intval($_minimum_password_strength);
        require_code('password_rules');
        $strength = test_password($password, $username, $email_address, $dob);
        if ($strength < $minimum_strength) {
            require_lang('password_rules');
            if ($return_errors) {
                return do_lang_tempcode('PASSWORD_NOT_COMPLEX_ENOUGH', strval($_minimum_password_strength), strval($strength));
            }
            warn_exit(do_lang_tempcode('PASSWORD_NOT_COMPLEX_ENOUGH', strval($_minimum_password_strength), strval($strength)));
        }
    }

    return null;
}

/**
 * Store (a hash of) and validate a new password.
 *
 * @param  MEMBER $member_id The member this is for
 * @param  string $password New password
 * @param  string $password_salted Hashed password
 * @param  string $salt Password salt
 * @param  boolean $check_correctness Whether to check details for correctness
 * @param  ?TIME $time The time this is logged to be happening at (null: now)
 */
function bump_password_change_date(int $member_id, string $password, string $password_salted, string $salt, bool $check_correctness = true, ?int $time = null)
{
    if ($time === null) {
        $time = time();
    }

    // Ensure does not re-use previous password
    if ($check_correctness) {
        require_code('crypt');

        $past_passwords = $GLOBALS['FORUM_DB']->query_select('f_password_history', ['*'], ['p_member_id' => $member_id], 'ORDER BY p_time DESC', 1000/*reasonable limit*/);
        foreach ($past_passwords as $past_password) {
            if (ratchet_hash_verify($password, $past_password['p_salt'], $past_password['p_hash_salted'])) {
                require_lang('password_rules');
                warn_exit(do_lang_tempcode('CANNOT_REUSE_PASSWORD'));
            }
        }
    }

    // Insert into log
    $GLOBALS['FORUM_DB']->query_insert('f_password_history', [
        'p_member_id' => $member_id,
        'p_hash_salted' => $password_salted,
        'p_salt' => $salt,
        'p_time' => $time,
    ]);
}
