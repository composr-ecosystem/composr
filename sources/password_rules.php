<?php /*

 Composr
 Copyright (c) Christopher Graham, 2004-2024

 See docs/LICENSE.md for full licensing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license    http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright  Christopher Graham
 * @package    core_cns
 */

/**
 * Test password strength.
 *
 * @param  string $password The password to check
 * @param  string $username The username that will go with the password (blank: unknown)
 * @param  EMAIL $email_address The e-mail address that will go with the password (blank: unknown)
 * @param  ?TIME $dob The date of birth that will go with the password (null: unknown)
 * @return integer Password strength (1-10)
 */
function test_password(string $password, string $username = '', string $email_address = '', ?int $dob = null) : int
{
    // Remove tainted strings based on something a hacker may know
    $tainted_strings_source = [];
    if ($username != '') {
        $tainted_strings_source[cms_mb_strtoupper($username)] = 3;
    }
    if ($email_address != '') {
        $tainted_strings_source[cms_mb_strtoupper($email_address)] = 3;
    }
    if ($dob !== null) {
        $tainted_strings_source[cms_mb_strtoupper(date('Y', $dob))] = 4;
        $tainted_strings_source[cms_mb_strtoupper(date('y', $dob))] = 2;
    }
    $tainted_substrings_pool = [];
    foreach ($tainted_strings_source as $tainted_string => $minimum_substring_length_to_consider) {
        if (!is_string($tainted_string)) {
            $tainted_string = strval($tainted_string);
        }

        $len = cms_mb_strlen($tainted_string);
        for ($start = 0; $start <= $len; $start++) {
            for ($end = $start + $minimum_substring_length_to_consider; $end <= $len; $end++) {
                if ($end - $start >= $minimum_substring_length_to_consider) {
                    $tainted_substring = cms_mb_substr($tainted_string, $start, $end - $start);
                    $tainted_substrings_pool[$tainted_substring] = cms_mb_strlen($tainted_substring);
                }
            }
        }
    }
    arsort($tainted_substrings_pool);
    $password_upper = cms_mb_strtoupper($password);
    foreach (array_keys($tainted_substrings_pool) as $tainted_substring) {
        if (!is_string($tainted_substring)) {
            $tainted_substring = strval($tainted_substring);
        }

        do {
            $pos = strpos($password_upper, $tainted_substring);
            if ($pos !== false) {
                $password = substr($password, 0, $pos) . substr($password, $pos + strlen($tainted_substring));
                $password_upper = cms_mb_strtoupper($password);
            }
        } while ($pos !== false);
    }

    // Simple dictionary pass
    require_code('spelling');
    $spell_checker = _find_spell_checker();
    if ($spell_checker !== null) {
        $test = run_spellcheck__words([cms_mb_strtolower($password)], null, /*$skip_known_words_in_db = */true, /*$provide_corrections = */false);
        if (($test !== null) && (count($test) == 0)) { // Fully matches dictionary
            $password = '';
        }
    }

    $len = cms_mb_strlen($password);

    // If filtering made the remaining password empty, it's very weak.
    if ($len == 0) {
        return 1;
    }

    // Calculate character pool size for entropy calculation
    $pool_size = 0.0;
    $has_lower = (preg_match('/[a-z]/', $password) != 0);
    $has_upper = (preg_match('/[A-Z]/', $password) != 0);
    $has_digit = (preg_match('/[0-9]/', $password) != 0);
    $has_symbol = (preg_match('/[^a-zA-Z0-9]/', $password) != 0);
    if ($has_lower) {
        $pool_size += 26.0;
    }
    if ($has_upper) {
        $pool_size += 26.0;
    }
    if ($has_digit) {
        $pool_size += 10.0;
    }
    if ($has_symbol) {
        $pool_size += 32.0; // Approximation for common symbols
    }

    // Initial strength based on entropy
    $entropy = 0.0;
    if ($pool_size == 0.0) {
        // This case implies the password consists of characters not in the common sets, or the regex missed something.
        $entropy = floatval($len);
    } else {
        $entropy = floatval($len * log($pool_size, 2.0));
    }
    $strength = intval($entropy / 10.0);

    // Strength penalty for repeating characters
    $lower_password_for_consecutive = cms_mb_strtolower($password);
    if ($len > 1) {
        for ($i = 1; $i < $len; $i++) {
            if ($lower_password_for_consecutive[$i] == $lower_password_for_consecutive[$i - 1]) {
                $strength--;
            }
        }
    }

    // Strength penalty for simple sequential letters (3+ chars, e.g., "abc", "cba")
    $lower_password_for_sequence = cms_mb_strtolower($password);
    $alpha_sequences = ['abc', 'bcd', 'cde', 'def', 'efg', 'fgh', 'ghi', 'hij', 'ijk', 'jkl', 'klm', 'lmn', 'mno', 'nop', 'opq', 'pqr', 'qrs', 'rst', 'stu', 'tuv', 'uvw', 'vwx', 'wxy', 'xyz'];
    foreach ($alpha_sequences as $seq) {
        if ((strpos($lower_password_for_sequence, $seq) !== false) || (strpos($lower_password_for_sequence, strrev($seq)) !== false)) {
            $strength--;
        }
    }

    // Strength penalty for simple sequential numbers (3+ chars, e.g., "123", "321")
    $num_sequences = ['012', '123', '234', '345', '456', '567', '678', '789'];
    foreach ($num_sequences as $seq) {
        if ((strpos($password, $seq) !== false) || (strpos($password, strrev($seq)) !== false)) {
            $strength -= 2; // Strength cannot exceed 3
        }
    }

    // Ensure strength is within 1-10 range
    return intval(max(1.0, min(10.0, $strength)));
}

/**
 * API function for if password resets have just been turned on but you want some more time before it kicks in.
 */
function bump_password_times_forward()
{
    $start = 0;
    do {
        $members = $GLOBALS['FORUM_DB']->query_select('f_members', ['id', 'm_pass_hash_salted', 'm_pass_salt'], [], '', 500, $start);
        foreach ($members as $member) {
            $GLOBALS['FORUM_DB']->query_delete('f_password_history', [
                'p_member_id' => $member['id'],
                'p_hash_salted' => $member['m_pass_hash_salted'],
                'p_salt' => $member['m_pass_salt'],
            ], '', 1);
            $GLOBALS['FORUM_DB']->query_insert('f_password_history', [
                'p_member_id' => $member['id'],
                'p_hash_salted' => $member['m_pass_hash_salted'],
                'p_salt' => $member['m_pass_salt'],
                'p_time' => time(),
            ]);
        }

        $start += 500;
    } while (!empty($members));
}

/**
 * Find if a member's account has expired, due to inactivity.
 *
 * @param  MEMBER $member_id The member this is for
 * @return boolean Whether it is
 */
function member_password_expired(int $member_id) : bool
{
    $password_compat_scheme = $GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_password_compat_scheme');

    // Expired in the database
    if ($password_compat_scheme == 'expired') { // LEGACY
        return true;
    }
    if ($password_compat_scheme == 'bcrypt_expired') {
        return true;
    }

    $expiry_days = intval(get_option('password_expiry_days'));

    if ($expiry_days > 0) {
        $last_time = $GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_last_visit_time');
        if ($last_time < time() - 60 * 60 * 24 * $expiry_days) {
            // Make sure the expiration sticks because m_last_visit_time is going to get updated
            $updated_scheme = 'bcrypt_expired';
            if ($password_compat_scheme == '') { // LEGACY
                $updated_scheme = 'expired';
            }
            $GLOBALS['FORUM_DB']->query_update('f_members', ['m_password_compat_scheme' => $updated_scheme], ['id' => $member_id]);

            return true;
        }
    }

    return false;
}

/**
 * Find if a member's password is too old.
 *
 * @param  MEMBER $member_id The member this is for
 * @return boolean Whether it is
 */
function member_password_too_old(int $member_id) : bool
{
    $change_days = intval(get_option('password_change_days'));

    if ($change_days > 0) {
        $last_time = $GLOBALS['FORUM_DB']->query_select_value('f_password_history', 'MAX(p_time)', [
            'p_member_id' => $member_id,
        ]);
        if ($last_time === null) {
            $last_time = $GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id, 'm_join_time');
        }
        if ($last_time < time() - 60 * 60 * 24 * $change_days) {
            return true;
        }
    }

    return false;
}

/**
 * Check the complexity of a password.
 *
 * @param  string $password The password to check
 * @param  string $username The username that will go with the password (blank: unknown)
 * @param  EMAIL $email_address The e-mail address that will go with the password (blank: unknown)
 * @param  ?TIME $dob The date of birth that will go with the password (null: unknown)
 * @param  boolean $return_errors Whether to return errors instead of dying on them
 * @return ?Tempcode Error (null: none)
 */
function check_password_complexity(string $password, string $username, string $email_address, ?int $dob, bool $return_errors = false) : ?object
{
    $_maximum_password_length = get_option('maximum_password_length');
    $maximum_password_length = min(255, intval($_maximum_password_length));
    if (cms_mb_strlen($password) > $maximum_password_length) {
        if ($return_errors) {
            return do_lang_tempcode('PASSWORD_TOO_LONG', escape_html(integer_format($maximum_password_length)));
        }
        warn_exit(do_lang_tempcode('PASSWORD_TOO_LONG', escape_html(integer_format($maximum_password_length))));
    }

    $_minimum_password_length = get_option('minimum_password_length');
    $minimum_password_length = intval($_minimum_password_length);
    if (cms_mb_strlen($password) < $minimum_password_length) {
        if ($return_errors) {
            return do_lang_tempcode('PASSWORD_TOO_SHORT', escape_html(integer_format($minimum_password_length)));
        }
        warn_exit(do_lang_tempcode('PASSWORD_TOO_SHORT', escape_html(integer_format($minimum_password_length))));
    }

    $_minimum_password_strength = get_option('minimum_password_strength');
    if ($_minimum_password_strength != '1') {
        $minimum_strength = intval($_minimum_password_strength);
        require_code('password_rules');
        $strength = test_password($password, $username, $email_address, $dob);
        if ($strength < $minimum_strength) {
            require_lang('password_rules');
            if ($return_errors) {
                return do_lang_tempcode('PASSWORD_NOT_COMPLEX_ENOUGH', strval($_minimum_password_strength), strval($strength));
            }
            warn_exit(do_lang_tempcode('PASSWORD_NOT_COMPLEX_ENOUGH', strval($_minimum_password_strength), strval($strength)));
        }
    }

    return null;
}

/**
 * Store (a hash of) and validate a new password.
 *
 * @param  MEMBER $member_id The member this is for
 * @param  string $password New password
 * @param  boolean $check_correctness Whether to check details for correctness
 * @param  ?TIME $time The time this is logged to be happening at (null: now)
 */
function bump_password_change_date(int $member_id, string $password, bool $check_correctness = true, ?int $time = null)
{
    if ($time === null) {
        $time = time();
    }

    require_code('crypt');

    // Ensure does not re-use recently previous password
    if ($check_correctness) {
        $past_passwords = $GLOBALS['FORUM_DB']->query_select('f_password_history', ['*'], ['p_member_id' => $member_id], 'ORDER BY p_time DESC', 10/*Only compare against the last 10 passwords used*/);
        foreach ($past_passwords as $past_password) {
            if (ratchet_hash_verify($password . '_history', $past_password['p_salt'], $past_password['p_hash_salted'])) {
                require_lang('password_rules');

                // NB: This lang string should not directly disclose the re-use of a password as hackers could use that to figure out someone's password in a rainbow attack.
                warn_exit(do_lang_tempcode('CANNOT_REUSE_PASSWORD'));
            }
        }
    }

    // Generate our own salt and hash for the history log so hackers cannot easily compare it with existing records
    $log_salt = get_secure_random_string(32, CRYPT_BASE64);
    $log_hash = ratchet_hash($password . '_history', $log_salt);

    // Insert into log
    $GLOBALS['FORUM_DB']->query_insert('f_password_history', [
        'p_member_id' => $member_id,
        'p_hash_salted' => $log_hash,
        'p_salt' => $log_salt,
        'p_time' => $time,
    ]);
}
